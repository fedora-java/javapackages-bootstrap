From 4b42ac9e0d77c8a65af3ac9f046d47de8f91f5bf Mon Sep 17 00:00:00 2001
From: Mikolaj Izdebski <mizdebsk@redhat.com>
Date: Wed, 8 Mar 2023 20:25:03 +0100
Subject: [PATCH 3/3] Remove annotations

Forwarded: not-needed

Generated using Jurand version 1.2.0.
Invoke as:
$ jurand -i -a guava \
         -p ^org.checkerframework. \
         -p ^com.google.common.annotations. \
         -p ^com.google.errorprone.annotations. \
         -p ^com.google.j2objc.annotations.
---
 guava/src/com/google/common/base/Absent.java  |   2 -
 .../google/common/base/AbstractIterator.java  |   7 +-
 guava/src/com/google/common/base/Ascii.java   |   2 -
 .../com/google/common/base/CaseFormat.java    |   2 -
 .../com/google/common/base/CharMatcher.java   |  33 +-
 .../src/com/google/common/base/Charsets.java  |  11 +-
 .../com/google/common/base/CommonMatcher.java |   2 -
 .../com/google/common/base/CommonPattern.java |   2 -
 .../src/com/google/common/base/Converter.java |  14 +-
 .../src/com/google/common/base/Defaults.java  |   2 -
 .../base/ElementTypesAreNonnullByDefault.java |   2 -
 guava/src/com/google/common/base/Enums.java   |  11 +-
 .../com/google/common/base/Equivalence.java   |  21 +-
 .../base/ExtraObjectsMethodsForWeb.java       |   2 -
 .../base/FinalizablePhantomReference.java     |   2 -
 .../common/base/FinalizableReference.java     |   4 -
 .../base/FinalizableReferenceQueue.java       |   5 +-
 .../common/base/FinalizableSoftReference.java |   2 -
 .../common/base/FinalizableWeakReference.java |   2 -
 .../src/com/google/common/base/Function.java  |   8 +-
 .../common/base/FunctionalEquivalence.java    |   4 -
 .../src/com/google/common/base/Functions.java |  33 +-
 .../common/base/Java8Compatibility.java       |   2 -
 .../com/google/common/base/JdkPattern.java    |   2 -
 guava/src/com/google/common/base/Joiner.java  |  57 +---
 .../com/google/common/base/MoreObjects.java   |  18 --
 .../com/google/common/base/NullnessCasts.java |   5 +-
 guava/src/com/google/common/base/Objects.java |   5 +-
 .../src/com/google/common/base/Optional.java  |   7 -
 .../common/base/PairwiseEquivalence.java      |   5 +-
 .../common/base/ParametricNullness.java       |   2 -
 .../google/common/base/PatternCompiler.java   |   2 -
 .../src/com/google/common/base/Platform.java  |   2 -
 .../com/google/common/base/Preconditions.java |  39 +--
 .../src/com/google/common/base/Predicate.java |   7 +-
 .../com/google/common/base/Predicates.java    |  77 ++---
 guava/src/com/google/common/base/Present.java |   2 -
 .../google/common/base/SmallCharMatcher.java  |   5 +-
 .../src/com/google/common/base/Splitter.java  |  13 +-
 .../common/base/StandardSystemProperty.java   |   3 +-
 .../src/com/google/common/base/Stopwatch.java |  10 -
 guava/src/com/google/common/base/Strings.java |  11 +-
 .../src/com/google/common/base/Supplier.java  |   7 +-
 .../src/com/google/common/base/Suppliers.java |  37 +--
 .../com/google/common/base/Throwables.java    |  53 ++--
 guava/src/com/google/common/base/Ticker.java  |   2 -
 guava/src/com/google/common/base/Utf8.java    |   4 -
 guava/src/com/google/common/base/Verify.java  |  10 +-
 .../google/common/base/VerifyException.java   |   2 -
 .../common/base/internal/Finalizer.java       |  11 +-
 .../com/google/common/base/package-info.java  |   2 -
 .../google/common/cache/AbstractCache.java    |   2 -
 .../common/cache/AbstractLoadingCache.java    |   2 -
 guava/src/com/google/common/cache/Cache.java  |  13 +-
 .../com/google/common/cache/CacheBuilder.java |  59 ++--
 .../google/common/cache/CacheBuilderSpec.java |  34 +-
 .../com/google/common/cache/CacheLoader.java  |  11 +-
 .../com/google/common/cache/CacheStats.java   |   2 -
 .../ElementTypesAreNonnullByDefault.java      |   2 -
 .../google/common/cache/ForwardingCache.java  |   2 -
 .../common/cache/ForwardingLoadingCache.java  |   2 -
 .../com/google/common/cache/LoadingCache.java |   2 -
 .../com/google/common/cache/LocalCache.java   | 208 +++++-------
 .../com/google/common/cache/LongAddable.java  |   2 -
 .../com/google/common/cache/LongAddables.java |   2 -
 .../com/google/common/cache/LongAdder.java    |   2 -
 .../common/cache/ParametricNullness.java      |   2 -
 .../google/common/cache/ReferenceEntry.java   |   2 -
 .../com/google/common/cache/RemovalCause.java |   2 -
 .../google/common/cache/RemovalListener.java  |   2 -
 .../google/common/cache/RemovalListeners.java |   2 -
 .../common/cache/RemovalNotification.java     |   5 +-
 .../com/google/common/cache/Striped64.java    |   5 +-
 .../src/com/google/common/cache/Weigher.java  |   2 -
 .../google/common/collect/AbstractBiMap.java  |  38 +--
 .../collect/AbstractIndexedListIterator.java  |   5 +-
 .../common/collect/AbstractIterator.java      |  11 +-
 .../common/collect/AbstractListMultimap.java  |  11 +-
 .../collect/AbstractMapBasedMultimap.java     |  23 +-
 .../collect/AbstractMapBasedMultiset.java     |  14 +-
 .../common/collect/AbstractMapEntry.java      |   5 +-
 .../common/collect/AbstractMultimap.java      |  26 +-
 .../common/collect/AbstractMultiset.java      |  23 +-
 .../common/collect/AbstractNavigableMap.java  |   5 +-
 .../common/collect/AbstractRangeSet.java      |   2 -
 .../collect/AbstractSequentialIterator.java   |   2 -
 .../common/collect/AbstractSetMultimap.java   |  11 +-
 .../AbstractSortedKeySortedSetMultimap.java   |   5 +-
 .../collect/AbstractSortedMultiset.java       |   7 +-
 .../collect/AbstractSortedSetMultimap.java    |  10 +-
 .../google/common/collect/AbstractTable.java  |  16 +-
 .../common/collect/AllEqualOrdering.java      |  11 +-
 .../common/collect/ArrayListMultimap.java     |  21 +-
 ...tMultimapGwtSerializationDependencies.java |   2 -
 .../com/google/common/collect/ArrayTable.java | 100 +++---
 .../common/collect/BaseImmutableMultimap.java |   2 -
 .../src/com/google/common/collect/BiMap.java  |   8 +-
 .../com/google/common/collect/BoundType.java  |   2 -
 .../common/collect/ByFunctionOrdering.java    |   5 +-
 .../google/common/collect/CartesianList.java  |   2 -
 .../common/collect/ClassToInstanceMap.java    |   6 -
 .../common/collect/CollectCollectors.java     |  47 ++-
 .../common/collect/CollectPreconditions.java  |   5 -
 .../common/collect/CollectSpliterators.java   |  40 ++-
 .../google/common/collect/Collections2.java   |  19 +-
 .../google/common/collect/CompactHashMap.java |  60 ++--
 .../google/common/collect/CompactHashSet.java |  40 +--
 .../google/common/collect/CompactHashing.java |   7 +-
 .../common/collect/CompactLinkedHashMap.java  |  27 +-
 .../common/collect/CompactLinkedHashSet.java  |  20 +-
 .../common/collect/ComparatorOrdering.java    |   5 +-
 .../google/common/collect/Comparators.java    |  31 +-
 .../common/collect/ComparisonChain.java       |   9 +-
 .../common/collect/CompoundOrdering.java      |   5 +-
 .../common/collect/ComputationException.java  |   2 -
 .../collect/ConcurrentHashMultiset.java       |  19 +-
 .../collect/ConsumingQueueIterator.java       |   5 +-
 .../google/common/collect/ContiguousSet.java  |  18 +-
 .../src/com/google/common/collect/Count.java  |   2 -
 guava/src/com/google/common/collect/Cut.java  |   2 -
 .../common/collect/DenseImmutableTable.java   |  13 +-
 .../DescendingImmutableSortedMultiset.java    |   2 -
 .../collect/DescendingImmutableSortedSet.java |   5 -
 .../common/collect/DescendingMultiset.java    |  11 +-
 .../google/common/collect/DiscreteDomain.java |   5 -
 .../ElementTypesAreNonnullByDefault.java      |   2 -
 .../common/collect/EmptyContiguousSet.java    |  15 +-
 .../collect/EmptyImmutableListMultimap.java   |   2 -
 .../collect/EmptyImmutableSetMultimap.java    |   2 -
 .../com/google/common/collect/EnumBiMap.java  |   9 +-
 .../google/common/collect/EnumHashBiMap.java  |  19 +-
 .../google/common/collect/EnumMultiset.java   |  13 +-
 .../google/common/collect/EvictingQueue.java  |  11 +-
 .../common/collect/ExplicitOrdering.java      |   2 -
 .../common/collect/FilteredEntryMultimap.java |  13 +-
 .../collect/FilteredEntrySetMultimap.java     |   5 +-
 .../collect/FilteredKeyListMultimap.java      |   5 +-
 .../common/collect/FilteredKeyMultimap.java   |  13 +-
 .../collect/FilteredKeySetMultimap.java       |   5 +-
 .../common/collect/FilteredMultimap.java      |   5 +-
 .../collect/FilteredMultimapValues.java       |   8 +-
 .../common/collect/FilteredSetMultimap.java   |   5 +-
 .../google/common/collect/FluentIterable.java |  58 ++--
 .../collect/ForwardingBlockingDeque.java      |   2 -
 .../common/collect/ForwardingCollection.java  |  22 +-
 .../collect/ForwardingConcurrentMap.java      |   7 -
 .../common/collect/ForwardingDeque.java       |  19 +-
 .../ForwardingImmutableCollection.java        |   2 -
 .../collect/ForwardingImmutableList.java      |   2 -
 .../collect/ForwardingImmutableMap.java       |   2 -
 .../collect/ForwardingImmutableSet.java       |   2 -
 .../common/collect/ForwardingIterator.java    |   7 +-
 .../google/common/collect/ForwardingList.java |  14 +-
 .../collect/ForwardingListIterator.java       |   7 +-
 .../collect/ForwardingListMultimap.java       |   8 +-
 .../google/common/collect/ForwardingMap.java  |  14 +-
 .../common/collect/ForwardingMapEntry.java    |   7 +-
 .../common/collect/ForwardingMultimap.java    |  12 +-
 .../common/collect/ForwardingMultiset.java    |  14 +-
 .../collect/ForwardingNavigableMap.java       |   9 +-
 .../collect/ForwardingNavigableSet.java       |   8 +-
 .../common/collect/ForwardingObject.java      |   2 -
 .../common/collect/ForwardingQueue.java       |  11 +-
 .../google/common/collect/ForwardingSet.java  |   5 +-
 .../common/collect/ForwardingSetMultimap.java |   8 +-
 .../common/collect/ForwardingSortedMap.java   |  15 +-
 .../collect/ForwardingSortedMultiset.java     |   7 +-
 .../common/collect/ForwardingSortedSet.java   |  13 +-
 .../collect/ForwardingSortedSetMultimap.java  |   5 +-
 .../common/collect/ForwardingTable.java       |   8 +-
 .../google/common/collect/GeneralRange.java   |  13 +-
 .../google/common/collect/GwtTransient.java   |   2 -
 .../google/common/collect/HashBasedTable.java |   2 -
 .../com/google/common/collect/HashBiMap.java  |  54 ++--
 .../google/common/collect/HashMultimap.java   |  21 +-
 ...hMultimapGwtSerializationDependencies.java |   2 -
 .../google/common/collect/HashMultiset.java   |  18 +-
 .../com/google/common/collect/Hashing.java    |   2 -
 .../common/collect/ImmutableAsList.java       |   9 +-
 .../google/common/collect/ImmutableBiMap.java |  22 +-
 .../collect/ImmutableBiMapFauxverideShim.java |  10 +-
 .../collect/ImmutableClassToInstanceMap.java  |  10 -
 .../common/collect/ImmutableCollection.java   |  30 +-
 .../google/common/collect/ImmutableEntry.java |   5 +-
 .../common/collect/ImmutableEnumMap.java      |   2 -
 .../common/collect/ImmutableEnumSet.java      |   5 +-
 .../google/common/collect/ImmutableList.java  |  34 +-
 .../common/collect/ImmutableListMultimap.java |  38 +--
 .../google/common/collect/ImmutableMap.java   |  59 +---
 .../common/collect/ImmutableMapEntry.java     |   3 +-
 .../common/collect/ImmutableMapEntrySet.java  |  13 +-
 .../common/collect/ImmutableMapKeySet.java    |   5 +-
 .../common/collect/ImmutableMapValues.java    |   7 +-
 .../common/collect/ImmutableMultimap.java     |  48 +--
 .../common/collect/ImmutableMultiset.java     |  36 +--
 ...eMultisetGwtSerializationDependencies.java |   2 -
 .../common/collect/ImmutableRangeMap.java     |  23 +-
 .../common/collect/ImmutableRangeSet.java     |  20 +-
 .../google/common/collect/ImmutableSet.java   |  27 +-
 .../common/collect/ImmutableSetMultimap.java  |  43 +--
 .../common/collect/ImmutableSortedAsList.java |   9 +-
 .../common/collect/ImmutableSortedMap.java    |  28 +-
 .../ImmutableSortedMapFauxverideShim.java     |  23 +-
 .../collect/ImmutableSortedMultiset.java      |  21 +-
 ...ImmutableSortedMultisetFauxverideShim.java |  16 +-
 .../common/collect/ImmutableSortedSet.java    |  37 +--
 .../ImmutableSortedSetFauxverideShim.java     |  13 -
 .../google/common/collect/ImmutableTable.java |  23 +-
 .../common/collect/IndexedImmutableSet.java   |   7 +-
 .../com/google/common/collect/Interner.java   |   7 +-
 .../com/google/common/collect/Interners.java  |   8 +-
 .../com/google/common/collect/Iterables.java  |  97 +++---
 .../com/google/common/collect/Iterators.java  | 129 ++++----
 .../collect/JdkBackedImmutableBiMap.java      |  13 +-
 .../common/collect/JdkBackedImmutableMap.java |   5 +-
 .../collect/JdkBackedImmutableMultiset.java   |   2 -
 .../common/collect/JdkBackedImmutableSet.java |   2 -
 .../collect/LexicographicalOrdering.java      |   5 +-
 .../common/collect/LinkedHashMultimap.java    |  49 ++-
 ...hMultimapGwtSerializationDependencies.java |   2 -
 .../common/collect/LinkedHashMultiset.java    |  18 +-
 .../common/collect/LinkedListMultimap.java    |  37 +--
 .../google/common/collect/ListMultimap.java   |   8 +-
 .../src/com/google/common/collect/Lists.java  |  78 ++---
 .../google/common/collect/MapDifference.java  |  10 +-
 .../com/google/common/collect/MapMaker.java   |  15 +-
 .../common/collect/MapMakerInternalMap.java   | 136 +++-----
 guava/src/com/google/common/collect/Maps.java | 300 ++++++++----------
 .../common/collect/MinMaxPriorityQueue.java   |  34 +-
 .../google/common/collect/MoreCollectors.java |  11 +-
 .../com/google/common/collect/Multimap.java   |  29 +-
 .../common/collect/MultimapBuilder.java       |  79 +++--
 .../com/google/common/collect/Multimaps.java  | 164 +++++-----
 .../com/google/common/collect/Multiset.java   |  23 +-
 .../com/google/common/collect/Multisets.java  |  69 ++--
 .../collect/MutableClassToInstanceMap.java    |   9 +-
 .../common/collect/NaturalOrdering.java       |  19 +-
 .../google/common/collect/NullnessCasts.java  |   7 +-
 .../common/collect/NullsFirstOrdering.java    |  13 +-
 .../common/collect/NullsLastOrdering.java     |  13 +-
 .../google/common/collect/ObjectArrays.java   |  37 +--
 .../com/google/common/collect/Ordering.java   |  45 +--
 .../common/collect/ParametricNullness.java    |   2 -
 .../common/collect/PeekingIterator.java       |   9 +-
 .../com/google/common/collect/Platform.java   |  19 +-
 .../src/com/google/common/collect/Queues.java |  50 ++-
 .../src/com/google/common/collect/Range.java  |   2 -
 .../RangeGwtSerializationDependencies.java    |   2 -
 .../com/google/common/collect/RangeMap.java   |   9 +-
 .../com/google/common/collect/RangeSet.java   |   6 -
 .../common/collect/RegularContiguousSet.java  |  11 +-
 .../collect/RegularImmutableAsList.java       |  10 +-
 .../common/collect/RegularImmutableBiMap.java |  26 +-
 .../common/collect/RegularImmutableList.java  |   8 +-
 .../common/collect/RegularImmutableMap.java   |  31 +-
 .../collect/RegularImmutableMultiset.java     |  24 +-
 .../common/collect/RegularImmutableSet.java   |  12 +-
 .../RegularImmutableSortedMultiset.java       |   5 +-
 .../collect/RegularImmutableSortedSet.java    |   5 +-
 .../common/collect/RegularImmutableTable.java |   5 -
 .../collect/ReverseNaturalOrdering.java       |   2 -
 .../common/collect/ReverseOrdering.java       |   5 +-
 .../google/common/collect/RowSortedTable.java |   5 +-
 .../google/common/collect/Serialization.java  |  21 +-
 .../google/common/collect/SetMultimap.java    |   8 +-
 guava/src/com/google/common/collect/Sets.java | 104 +++---
 .../collect/SingletonImmutableBiMap.java      |   6 +-
 .../collect/SingletonImmutableList.java       |   2 -
 .../common/collect/SingletonImmutableSet.java |   5 +-
 .../collect/SingletonImmutableTable.java      |   2 -
 .../google/common/collect/SortedIterable.java |   5 +-
 .../common/collect/SortedIterables.java       |   5 +-
 .../google/common/collect/SortedLists.java    |  23 +-
 .../common/collect/SortedMapDifference.java   |   5 +-
 .../google/common/collect/SortedMultiset.java |   5 +-
 .../common/collect/SortedMultisetBridge.java  |   5 +-
 .../common/collect/SortedMultisets.java       |  17 +-
 .../common/collect/SortedSetMultimap.java     |   8 +-
 .../common/collect/SparseImmutableTable.java  |   4 -
 .../collect/StandardRowSortedTable.java       |   4 -
 .../google/common/collect/StandardTable.java  |  19 --
 .../com/google/common/collect/Streams.java    |  68 +---
 .../google/common/collect/Synchronized.java   | 128 ++++----
 .../src/com/google/common/collect/Table.java  |  31 +-
 .../common/collect/TableCollectors.java       |  25 +-
 .../src/com/google/common/collect/Tables.java |  62 ++--
 .../google/common/collect/TopKSelector.java   |  11 +-
 .../common/collect/TransformedIterator.java   |   5 +-
 .../collect/TransformedListIterator.java      |   5 +-
 .../google/common/collect/TreeBasedTable.java |   2 -
 .../google/common/collect/TreeMultimap.java   |  16 +-
 .../google/common/collect/TreeMultiset.java   |  25 +-
 .../google/common/collect/TreeRangeMap.java   |  10 +-
 .../google/common/collect/TreeRangeSet.java   |   9 +-
 .../google/common/collect/TreeTraverser.java  |   4 -
 .../common/collect/UnmodifiableIterator.java  |   7 +-
 .../collect/UnmodifiableListIterator.java     |   8 +-
 .../collect/UnmodifiableSortedMultiset.java   |   5 +-
 .../common/collect/UsingToStringOrdering.java |   2 -
 .../google/common/collect/package-info.java   |   2 -
 .../common/escape/ArrayBasedCharEscaper.java  |   4 -
 .../common/escape/ArrayBasedEscaperMap.java   |   6 -
 .../escape/ArrayBasedUnicodeEscaper.java      |   9 +-
 .../com/google/common/escape/CharEscaper.java |   4 -
 .../common/escape/CharEscaperBuilder.java     |  14 +-
 .../ElementTypesAreNonnullByDefault.java      |   2 -
 .../src/com/google/common/escape/Escaper.java |   4 -
 .../com/google/common/escape/Escapers.java    |  12 +-
 .../common/escape/ParametricNullness.java     |   2 -
 .../com/google/common/escape/Platform.java    |   2 -
 .../google/common/escape/UnicodeEscaper.java  |   4 -
 .../google/common/escape/package-info.java    |   2 -
 .../ElementTypesAreNonnullByDefault.java      |   2 -
 .../common/eventbus/ParametricNullness.java   |   2 -
 .../google/common/eventbus/Subscriber.java    |   8 +-
 .../common/eventbus/SubscriberRegistry.java   |   6 +-
 .../google/common/eventbus/package-info.java  |   2 -
 .../google/common/graph/AbstractGraph.java    |   2 -
 .../google/common/graph/AbstractNetwork.java  |   2 -
 .../common/graph/AbstractValueGraph.java      |   2 -
 .../DirectedMultiNetworkConnections.java      |   5 +-
 .../com/google/common/graph/ElementOrder.java |   4 -
 .../ElementTypesAreNonnullByDefault.java      |   2 -
 .../com/google/common/graph/EndpointPair.java |   4 -
 .../common/graph/EndpointPairIterator.java    |   3 +-
 guava/src/com/google/common/graph/Graph.java  |   4 -
 .../com/google/common/graph/GraphBuilder.java |   4 -
 .../google/common/graph/GraphConnections.java |   3 -
 guava/src/com/google/common/graph/Graphs.java |   7 -
 .../google/common/graph/ImmutableGraph.java   |   8 -
 .../google/common/graph/ImmutableNetwork.java |   8 -
 .../common/graph/ImmutableValueGraph.java     |   8 -
 .../google/common/graph/MapIteratorCache.java |   3 -
 .../com/google/common/graph/MutableGraph.java |   9 -
 .../google/common/graph/MutableNetwork.java   |   8 -
 .../common/graph/MutableValueGraph.java       |   9 -
 .../src/com/google/common/graph/Network.java  |   4 -
 .../google/common/graph/NetworkBuilder.java   |   2 -
 .../common/graph/NetworkConnections.java      |   3 -
 .../common/graph/ParametricNullness.java      |   2 -
 .../common/graph/PredecessorsFunction.java    |   4 -
 .../common/graph/StandardMutableNetwork.java  |   7 -
 .../graph/StandardMutableValueGraph.java      |   8 -
 .../common/graph/SuccessorsFunction.java      |   4 -
 .../com/google/common/graph/Traverser.java    |   6 -
 .../UndirectedMultiNetworkConnections.java    |   3 +-
 .../com/google/common/graph/ValueGraph.java   |   2 -
 .../common/graph/ValueGraphBuilder.java       |   2 -
 .../com/google/common/graph/package-info.java |   2 -
 .../common/hash/AbstractByteHasher.java       |   2 -
 .../hash/AbstractCompositeHashFunction.java   |   5 +-
 .../common/hash/AbstractHashFunction.java     |   5 +-
 .../google/common/hash/AbstractHasher.java    |   5 +-
 .../AbstractNonStreamingHashFunction.java     |   2 -
 .../common/hash/AbstractStreamingHasher.java  |   2 -
 .../com/google/common/hash/BloomFilter.java   |  34 +-
 .../common/hash/BloomFilterStrategies.java    |   9 +-
 .../common/hash/ChecksumHashFunction.java     |   2 -
 .../common/hash/Crc32cHashFunction.java       |   2 -
 .../hash/ElementTypesAreNonnullByDefault.java |   2 -
 .../common/hash/FarmHashFingerprint64.java    |   2 -
 guava/src/com/google/common/hash/Funnel.java  |   7 +-
 guava/src/com/google/common/hash/Funnels.java |   7 +-
 .../src/com/google/common/hash/HashCode.java  |   2 -
 .../com/google/common/hash/HashFunction.java  |   5 +-
 guava/src/com/google/common/hash/Hasher.java  |   7 +-
 guava/src/com/google/common/hash/Hashing.java |   4 -
 .../common/hash/HashingInputStream.java       |   5 -
 .../common/hash/HashingOutputStream.java      |   2 -
 .../google/common/hash/ImmutableSupplier.java |   2 -
 .../common/hash/Java8Compatibility.java       |   2 -
 .../google/common/hash/MacHashFunction.java   |   2 -
 .../hash/MessageDigestHashFunction.java       |   2 -
 .../common/hash/Murmur3_128HashFunction.java  |   2 -
 .../common/hash/Murmur3_32HashFunction.java   |   4 -
 .../common/hash/ParametricNullness.java       |   2 -
 .../com/google/common/hash/PrimitiveSink.java |   4 -
 .../google/common/hash/SipHashFunction.java   |   2 -
 .../src/com/google/common/hash/Striped64.java |   5 +-
 .../com/google/common/hash/package-info.java  |   2 -
 .../html/ElementTypesAreNonnullByDefault.java |   2 -
 .../com/google/common/html/HtmlEscapers.java  |   2 -
 .../common/html/ParametricNullness.java       |   2 -
 .../com/google/common/html/package-info.java  |   2 -
 .../google/common/io/AppendableWriter.java    |   2 -
 .../com/google/common/io/BaseEncoding.java    |  27 +-
 .../google/common/io/ByteArrayDataInput.java  |  27 +-
 .../google/common/io/ByteArrayDataOutput.java |   2 -
 .../com/google/common/io/ByteProcessor.java   |  12 +-
 guava/src/com/google/common/io/ByteSink.java  |   4 -
 .../src/com/google/common/io/ByteSource.java  |  15 +-
 .../src/com/google/common/io/ByteStreams.java |  27 +-
 .../google/common/io/CharSequenceReader.java  |   2 -
 guava/src/com/google/common/io/CharSink.java  |   7 -
 .../src/com/google/common/io/CharSource.java  |  21 +-
 .../src/com/google/common/io/CharStreams.java |  19 +-
 .../src/com/google/common/io/Closeables.java  |   7 +-
 guava/src/com/google/common/io/Closer.java    |  16 +-
 .../google/common/io/CountingInputStream.java |   4 -
 .../common/io/CountingOutputStream.java       |   2 -
 .../io/ElementTypesAreNonnullByDefault.java   |   2 -
 .../common/io/FileBackedOutputStream.java     |  11 -
 .../com/google/common/io/FileWriteMode.java   |   2 -
 guava/src/com/google/common/io/Files.java     |  42 +--
 .../src/com/google/common/io/Flushables.java  |   4 -
 .../io/InsecureRecursiveDeleteException.java  |   7 +-
 .../google/common/io/Java8Compatibility.java  |   2 -
 .../src/com/google/common/io/LineBuffer.java  |   4 -
 .../com/google/common/io/LineProcessor.java   |  10 +-
 .../src/com/google/common/io/LineReader.java  |   7 +-
 .../io/LittleEndianDataInputStream.java       |  31 +-
 .../io/LittleEndianDataOutputStream.java      |   4 -
 guava/src/com/google/common/io/MoreFiles.java |   7 +-
 .../google/common/io/MultiInputStream.java    |   2 -
 .../src/com/google/common/io/MultiReader.java |   2 -
 .../google/common/io/ParametricNullness.java  |   2 -
 .../common/io/PatternFilenameFilter.java      |   4 -
 .../google/common/io/ReaderInputStream.java   |   2 -
 .../common/io/RecursiveDeleteOption.java      |   7 +-
 guava/src/com/google/common/io/Resources.java |  14 +-
 .../com/google/common/io/package-info.java    |   2 -
 .../google/common/math/BigDecimalMath.java    |   2 -
 .../google/common/math/BigIntegerMath.java    |  24 +-
 .../com/google/common/math/DoubleMath.java    |  27 +-
 .../com/google/common/math/DoubleUtils.java   |   5 +-
 .../math/ElementTypesAreNonnullByDefault.java |   2 -
 guava/src/com/google/common/math/IntMath.java |  31 +-
 .../common/math/LinearTransformation.java     |   9 +-
 .../src/com/google/common/math/LongMath.java  |  52 +--
 .../google/common/math/MathPreconditions.java |   4 -
 .../com/google/common/math/PairedStats.java   |   4 -
 .../common/math/PairedStatsAccumulator.java   |   4 -
 .../common/math/ParametricNullness.java       |   2 -
 .../src/com/google/common/math/Quantiles.java |   4 -
 guava/src/com/google/common/math/Stats.java   |   4 -
 .../google/common/math/StatsAccumulator.java  |   4 -
 .../google/common/math/ToDoubleRounder.java   |   2 -
 .../com/google/common/math/package-info.java  |   2 -
 .../net/ElementTypesAreNonnullByDefault.java  |   2 -
 .../com/google/common/net/HostAndPort.java    |   6 -
 .../com/google/common/net/HostSpecifier.java  |   4 -
 .../com/google/common/net/HttpHeaders.java    |  12 +-
 .../com/google/common/net/InetAddresses.java  |   5 -
 .../google/common/net/InternetDomainName.java |   6 -
 .../src/com/google/common/net/MediaType.java  |  13 +-
 .../google/common/net/ParametricNullness.java |   2 -
 .../com/google/common/net/PercentEscaper.java |   4 -
 .../com/google/common/net/UrlEscapers.java    |   2 -
 .../google/common/primitives/Booleans.java    |   7 -
 .../com/google/common/primitives/Bytes.java   |   3 -
 .../com/google/common/primitives/Chars.java   |  12 +-
 .../com/google/common/primitives/Doubles.java |  18 +-
 .../primitives/DoublesMethodsForWeb.java      |   2 -
 .../ElementTypesAreNonnullByDefault.java      |   2 -
 .../com/google/common/primitives/Floats.java  |  14 +-
 .../primitives/FloatsMethodsForWeb.java       |   2 -
 .../primitives/ImmutableDoubleArray.java      |  10 -
 .../common/primitives/ImmutableIntArray.java  |  10 -
 .../common/primitives/ImmutableLongArray.java |  10 -
 .../com/google/common/primitives/Ints.java    |  13 -
 .../common/primitives/IntsMethodsForWeb.java  |   2 -
 .../com/google/common/primitives/Longs.java   |   8 -
 .../common/primitives/ParametricNullness.java |   2 -
 .../common/primitives/ParseRequest.java       |   2 -
 .../google/common/primitives/Platform.java    |   2 -
 .../google/common/primitives/Primitives.java  |   2 -
 .../com/google/common/primitives/Shorts.java  |  17 +-
 .../primitives/ShortsMethodsForWeb.java       |   2 -
 .../google/common/primitives/SignedBytes.java |   2 -
 .../common/primitives/UnsignedBytes.java      |  14 -
 .../common/primitives/UnsignedInteger.java    |   5 +-
 .../common/primitives/UnsignedInts.java       |   8 -
 .../common/primitives/UnsignedLong.java       |   7 -
 .../common/primitives/UnsignedLongs.java      |   8 -
 .../common/primitives/package-info.java       |   2 -
 .../reflect/AbstractInvocationHandler.java    |   7 +-
 .../com/google/common/reflect/ClassPath.java  |  12 +-
 .../ElementTypesAreNonnullByDefault.java      |   2 -
 .../reflect/ImmutableTypeToInstanceMap.java   |  14 -
 .../com/google/common/reflect/Invokable.java  |  13 +-
 .../reflect/MutableTypeToInstanceMap.java     |  22 +-
 .../com/google/common/reflect/Parameter.java  |   4 -
 .../common/reflect/ParametricNullness.java    |   2 -
 .../com/google/common/reflect/Reflection.java |   2 -
 .../google/common/reflect/TypeParameter.java  |   2 -
 .../google/common/reflect/TypeResolver.java   |   2 -
 .../common/reflect/TypeToInstanceMap.java     |  16 +-
 .../com/google/common/reflect/TypeToken.java  |   7 -
 .../google/common/reflect/TypeVisitor.java    |   3 +-
 .../src/com/google/common/reflect/Types.java  |   8 +-
 .../google/common/reflect/package-info.java   |   2 -
 .../concurrent/AbstractCatchingFuture.java    |  16 +-
 .../AbstractExecutionThreadService.java       |   7 -
 .../util/concurrent/AbstractFuture.java       |  29 +-
 .../util/concurrent/AbstractIdleService.java  |   8 -
 .../AbstractListeningExecutorService.java     |  15 +-
 .../concurrent/AbstractScheduledService.java  |  23 +-
 .../util/concurrent/AbstractService.java      |  18 --
 .../concurrent/AbstractTransformFuture.java   |  16 +-
 .../util/concurrent/AggregateFuture.java      |   9 +-
 .../util/concurrent/AggregateFutureState.java |   7 +-
 .../common/util/concurrent/AsyncCallable.java |   7 +-
 .../common/util/concurrent/AsyncFunction.java |   5 +-
 .../common/util/concurrent/AtomicDouble.java  |   7 -
 .../util/concurrent/AtomicDoubleArray.java    |   5 -
 .../common/util/concurrent/AtomicLongMap.java |  18 --
 .../common/util/concurrent/Atomics.java       |  11 +-
 .../common/util/concurrent/Callables.java     |  19 +-
 .../common/util/concurrent/ClosingFuture.java | 196 ++++++------
 .../util/concurrent/CollectionFuture.java     |  29 +-
 .../util/concurrent/CombinedFuture.java       |  13 +-
 .../concurrent/CycleDetectingLockFactory.java |  19 +-
 .../util/concurrent/DirectExecutor.java       |   2 -
 .../ElementTypesAreNonnullByDefault.java      |   2 -
 .../util/concurrent/ExecutionError.java       |   2 -
 .../common/util/concurrent/ExecutionList.java |   5 -
 .../util/concurrent/ExecutionSequencer.java   |  13 +-
 .../util/concurrent/FakeTimeLimiter.java      |  11 +-
 .../common/util/concurrent/FluentFuture.java  |  28 +-
 .../concurrent/ForwardingBlockingDeque.java   |   2 -
 .../concurrent/ForwardingBlockingQueue.java   |   5 +-
 .../concurrent/ForwardingExecutorService.java |  18 +-
 .../concurrent/ForwardingFluentFuture.java    |   5 +-
 .../util/concurrent/ForwardingFuture.java     |  10 +-
 .../ForwardingListenableFuture.java           |  10 +-
 .../ForwardingListeningExecutorService.java   |  10 +-
 .../util/concurrent/FutureCallback.java       |   5 +-
 .../common/util/concurrent/Futures.java       | 150 ++++-----
 .../util/concurrent/FuturesGetChecked.java    |  26 +-
 ...GwtFluentFutureCatchingSpecialization.java |   5 +-
 .../GwtFuturesCatchingSpecialization.java     |   2 -
 .../util/concurrent/ImmediateFuture.java      |  11 +-
 .../common/util/concurrent/Internal.java      |   3 +-
 .../util/concurrent/InterruptibleTask.java    |  11 +-
 .../util/concurrent/JdkFutureAdapters.java    |  11 +-
 .../util/concurrent/ListenableFuture.java     |   5 +-
 .../util/concurrent/ListenableFutureTask.java |  11 +-
 .../concurrent/ListenableScheduledFuture.java |   7 +-
 .../util/concurrent/ListenerCallQueue.java    |   6 -
 .../concurrent/ListeningExecutorService.java  |  15 +-
 .../ListeningScheduledExecutorService.java    |   7 +-
 .../common/util/concurrent/Monitor.java       |  20 +-
 .../common/util/concurrent/MoreExecutors.java | 105 +++---
 .../common/util/concurrent/NullnessCasts.java |   7 +-
 .../util/concurrent/ParametricNullness.java   |   2 -
 .../common/util/concurrent/Partially.java     |   2 -
 .../common/util/concurrent/Platform.java      |   2 -
 .../common/util/concurrent/RateLimiter.java   |  10 -
 .../common/util/concurrent/Runnables.java     |   4 -
 .../util/concurrent/SequentialExecutor.java   |   9 +-
 .../common/util/concurrent/Service.java       |   7 -
 .../util/concurrent/ServiceManager.java       |  19 --
 .../util/concurrent/ServiceManagerBridge.java |   2 -
 .../util/concurrent/SettableFuture.java       |  11 +-
 .../util/concurrent/SimpleTimeLimiter.java    |  20 +-
 .../util/concurrent/SmoothRateLimiter.java    |   2 -
 .../common/util/concurrent/Striped.java       |  10 +-
 .../util/concurrent/ThreadFactoryBuilder.java |   6 -
 .../common/util/concurrent/TimeLimiter.java   |  20 +-
 .../common/util/concurrent/TimeoutFuture.java |   9 +-
 .../TrustedListenableFutureTask.java          |  14 +-
 .../concurrent/UncaughtExceptionHandlers.java |   4 -
 .../UncheckedExecutionException.java          |   2 -
 .../concurrent/UncheckedTimeoutException.java |   2 -
 .../util/concurrent/Uninterruptibles.java     |  76 ++---
 .../concurrent/WrappingExecutorService.java   |  22 +-
 .../WrappingScheduledExecutorService.java     |   8 +-
 .../common/util/concurrent/package-info.java  |   2 -
 .../xml/ElementTypesAreNonnullByDefault.java  |   2 -
 .../google/common/xml/ParametricNullness.java |   2 -
 .../com/google/common/xml/XmlEscapers.java    |   4 -
 .../com/google/common/xml/package-info.java   |   2 -
 .../publicsuffix/PublicSuffixPatterns.java    |   4 -
 .../publicsuffix/PublicSuffixType.java        |   4 -
 .../thirdparty/publicsuffix/TrieParser.java   |   2 -
 575 files changed, 2133 insertions(+), 5714 deletions(-)

diff --git a/guava/src/com/google/common/base/Absent.java b/guava/src/com/google/common/base/Absent.java
index f96136b5ef..6331d23163 100644
--- a/guava/src/com/google/common/base/Absent.java
+++ b/guava/src/com/google/common/base/Absent.java
@@ -16,13 +16,11 @@ package com.google.common.base;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.Collections;
 import java.util.Set;
 import javax.annotation.CheckForNull;
 
 /** Implementation of an {@link Optional} not containing a reference. */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 final class Absent<T> extends Optional<T> {
   static final Absent<Object> INSTANCE = new Absent<>();
diff --git a/guava/src/com/google/common/base/AbstractIterator.java b/guava/src/com/google/common/base/AbstractIterator.java
index bb0a1d3249..d3bc20ec7e 100644
--- a/guava/src/com/google/common/base/AbstractIterator.java
+++ b/guava/src/com/google/common/base/AbstractIterator.java
@@ -17,20 +17,16 @@ package com.google.common.base;
 import static com.google.common.base.NullnessCasts.uncheckedCastNullableTToT;
 import static com.google.common.base.Preconditions.checkState;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Iterator;
 import java.util.NoSuchElementException;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Note this class is a copy of {@link com.google.common.collect.AbstractIterator} (for dependency
  * reasons).
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-abstract class AbstractIterator<T extends @Nullable Object> implements Iterator<T> {
+abstract class AbstractIterator<T extends Object> implements Iterator<T> {
   private State state = State.NOT_READY;
 
   protected AbstractIterator() {}
@@ -47,7 +43,6 @@ abstract class AbstractIterator<T extends @Nullable Object> implements Iterator<
   @CheckForNull
   protected abstract T computeNext();
 
-  @CanIgnoreReturnValue
   @CheckForNull
   protected final T endOfData() {
     state = State.DONE;
diff --git a/guava/src/com/google/common/base/Ascii.java b/guava/src/com/google/common/base/Ascii.java
index 0c651bb27b..81f5156be8 100644
--- a/guava/src/com/google/common/base/Ascii.java
+++ b/guava/src/com/google/common/base/Ascii.java
@@ -17,7 +17,6 @@ package com.google.common.base;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
 
 /**
  * Static methods pertaining to ASCII characters (those in the range of values {@code 0x00} through
@@ -36,7 +35,6 @@ import com.google.common.annotations.GwtCompatible;
  * @author Gregory Kick
  * @since 7.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class Ascii {
 
diff --git a/guava/src/com/google/common/base/CaseFormat.java b/guava/src/com/google/common/base/CaseFormat.java
index 7b393ebd7e..6eb78fb998 100644
--- a/guava/src/com/google/common/base/CaseFormat.java
+++ b/guava/src/com/google/common/base/CaseFormat.java
@@ -17,7 +17,6 @@ package com.google.common.base;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 import javax.annotation.CheckForNull;
 
@@ -28,7 +27,6 @@ import javax.annotation.CheckForNull;
  * @author Mike Bostock
  * @since 1.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public enum CaseFormat {
   /** Hyphenated variable naming convention, e.g., "lower-hyphen". */
diff --git a/guava/src/com/google/common/base/CharMatcher.java b/guava/src/com/google/common/base/CharMatcher.java
index e052f800a6..5a323994f3 100644
--- a/guava/src/com/google/common/base/CharMatcher.java
+++ b/guava/src/com/google/common/base/CharMatcher.java
@@ -18,9 +18,6 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndex;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import java.util.Arrays;
 import java.util.BitSet;
 
@@ -60,7 +57,6 @@ import java.util.BitSet;
  * @author Kevin Bourrillion
  * @since 1.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public abstract class CharMatcher implements Predicate<Character> {
   /*
@@ -412,7 +408,7 @@ public abstract class CharMatcher implements Predicate<Character> {
    * constructs an eight-kilobyte bit array and queries that. In many situations this produces a
    * matcher which is faster to query than the original.
    */
-  @GwtIncompatible // SmallCharMatcher
+  // SmallCharMatcher
   CharMatcher precomputedInternal() {
     final BitSet table = new BitSet();
     setBits(table);
@@ -442,7 +438,7 @@ public abstract class CharMatcher implements Predicate<Character> {
   /**
    * Helper method for {@link #precomputedInternal} that doesn't test if the negation is cheaper.
    */
-  @GwtIncompatible // SmallCharMatcher
+  // SmallCharMatcher
   private static CharMatcher precomputedPositive(
       int totalCharacters, BitSet table, String description) {
     switch (totalCharacters) {
@@ -461,7 +457,7 @@ public abstract class CharMatcher implements Predicate<Character> {
     }
   }
 
-  @GwtIncompatible // SmallCharMatcher
+  // SmallCharMatcher
   private static boolean isSmall(int totalCharacters, int tableLength) {
     return totalCharacters <= SmallCharMatcher.MAX_SIZE
         && tableLength > (totalCharacters * 4 * Character.SIZE);
@@ -469,7 +465,7 @@ public abstract class CharMatcher implements Predicate<Character> {
   }
 
   /** Sets bits in {@code table} matched by this matcher. */
-  @GwtIncompatible // used only from other GwtIncompatible code
+  // used only from other GwtIncompatible code
   void setBits(BitSet table) {
     for (int c = Character.MAX_VALUE; c >= Character.MIN_VALUE; c--) {
       if (matches((char) c)) {
@@ -979,7 +975,7 @@ public abstract class CharMatcher implements Predicate<Character> {
   }
 
   /** Fast matcher using a {@link BitSet} table of matching characters. */
-  @GwtIncompatible // used only from other GwtIncompatible code
+  // used only from other GwtIncompatible code
   private static final class BitSetMatcher extends NamedFastMatcher {
 
     private final BitSet table;
@@ -1207,7 +1203,6 @@ public abstract class CharMatcher implements Predicate<Character> {
   }
 
   /** Implementation of {@link #whitespace()}. */
-  @VisibleForTesting
   static final class Whitespace extends NamedFastMatcher {
 
     // TABLE is a precomputed hashset of whitespace characters. MULTIPLIER serves as a hash function
@@ -1233,7 +1228,7 @@ public abstract class CharMatcher implements Predicate<Character> {
       return TABLE.charAt((MULTIPLIER * c) >>> SHIFT) == c;
     }
 
-    @GwtIncompatible // used only from other GwtIncompatible code
+    // used only from other GwtIncompatible code
     @Override
     void setBits(BitSet table) {
       for (int i = 0; i < TABLE.length(); i++) {
@@ -1519,7 +1514,7 @@ public abstract class CharMatcher implements Predicate<Character> {
       return sequence.length() - original.countIn(sequence);
     }
 
-    @GwtIncompatible // used only from other GwtIncompatible code
+    // used only from other GwtIncompatible code
     @Override
     void setBits(BitSet table) {
       BitSet tmp = new BitSet();
@@ -1555,7 +1550,7 @@ public abstract class CharMatcher implements Predicate<Character> {
       return first.matches(c) && second.matches(c);
     }
 
-    @GwtIncompatible // used only from other GwtIncompatible code
+    // used only from other GwtIncompatible code
     @Override
     void setBits(BitSet table) {
       BitSet tmp1 = new BitSet();
@@ -1583,7 +1578,7 @@ public abstract class CharMatcher implements Predicate<Character> {
       second = checkNotNull(b);
     }
 
-    @GwtIncompatible // used only from other GwtIncompatible code
+    // used only from other GwtIncompatible code
     @Override
     void setBits(BitSet table) {
       first.setBits(table);
@@ -1637,7 +1632,7 @@ public abstract class CharMatcher implements Predicate<Character> {
       return isNot(match);
     }
 
-    @GwtIncompatible // used only from other GwtIncompatible code
+    // used only from other GwtIncompatible code
     @Override
     void setBits(BitSet table) {
       table.set(match);
@@ -1673,7 +1668,7 @@ public abstract class CharMatcher implements Predicate<Character> {
       return other.matches(match) ? any() : this;
     }
 
-    @GwtIncompatible // used only from other GwtIncompatible code
+    // used only from other GwtIncompatible code
     @Override
     void setBits(BitSet table) {
       table.set(0, match);
@@ -1711,7 +1706,7 @@ public abstract class CharMatcher implements Predicate<Character> {
       return c == match1 || c == match2;
     }
 
-    @GwtIncompatible // used only from other GwtIncompatible code
+    // used only from other GwtIncompatible code
     @Override
     void setBits(BitSet table) {
       table.set(match1);
@@ -1740,7 +1735,7 @@ public abstract class CharMatcher implements Predicate<Character> {
     }
 
     @Override
-    @GwtIncompatible // used only from other GwtIncompatible code
+    // used only from other GwtIncompatible code
     void setBits(BitSet table) {
       for (char c : chars) {
         table.set(c);
@@ -1775,7 +1770,7 @@ public abstract class CharMatcher implements Predicate<Character> {
       return startInclusive <= c && c <= endInclusive;
     }
 
-    @GwtIncompatible // used only from other GwtIncompatible code
+    // used only from other GwtIncompatible code
     @Override
     void setBits(BitSet table) {
       table.set(startInclusive, endInclusive + 1);
diff --git a/guava/src/com/google/common/base/Charsets.java b/guava/src/com/google/common/base/Charsets.java
index 7aebea826c..33a431a7e8 100644
--- a/guava/src/com/google/common/base/Charsets.java
+++ b/guava/src/com/google/common/base/Charsets.java
@@ -14,8 +14,6 @@
 
 package com.google.common.base;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import java.nio.charset.Charset;
 
 /**
@@ -30,7 +28,6 @@ import java.nio.charset.Charset;
  * @author Mike Bostock
  * @since 1.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class Charsets {
   private Charsets() {}
@@ -42,7 +39,7 @@ public final class Charsets {
    * java.nio.charset.StandardCharsets#US_ASCII} instead.
    *
    */
-  @GwtIncompatible // Charset not supported by GWT
+  // Charset not supported by GWT
   public static final Charset US_ASCII = Charset.forName("US-ASCII");
 
   /**
@@ -70,7 +67,7 @@ public final class Charsets {
    * java.nio.charset.StandardCharsets#UTF_16BE} instead.
    *
    */
-  @GwtIncompatible // Charset not supported by GWT
+  // Charset not supported by GWT
   public static final Charset UTF_16BE = Charset.forName("UTF-16BE");
 
   /**
@@ -80,7 +77,7 @@ public final class Charsets {
    * java.nio.charset.StandardCharsets#UTF_16LE} instead.
    *
    */
-  @GwtIncompatible // Charset not supported by GWT
+  // Charset not supported by GWT
   public static final Charset UTF_16LE = Charset.forName("UTF-16LE");
 
   /**
@@ -91,7 +88,7 @@ public final class Charsets {
    * java.nio.charset.StandardCharsets#UTF_16} instead.
    *
    */
-  @GwtIncompatible // Charset not supported by GWT
+  // Charset not supported by GWT
   public static final Charset UTF_16 = Charset.forName("UTF-16");
 
   /*
diff --git a/guava/src/com/google/common/base/CommonMatcher.java b/guava/src/com/google/common/base/CommonMatcher.java
index d63b46b5d4..270293415a 100644
--- a/guava/src/com/google/common/base/CommonMatcher.java
+++ b/guava/src/com/google/common/base/CommonMatcher.java
@@ -14,14 +14,12 @@
 
 package com.google.common.base;
 
-import com.google.common.annotations.GwtCompatible;
 
 /**
  * The subset of the {@link java.util.regex.Matcher} API which is used by this package, and also
  * shared with the {@code re2j} library. For internal use only. Please refer to the {@code Matcher}
  * javadoc for details.
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 abstract class CommonMatcher {
   public abstract boolean matches();
diff --git a/guava/src/com/google/common/base/CommonPattern.java b/guava/src/com/google/common/base/CommonPattern.java
index c425d52609..cdadb590d5 100644
--- a/guava/src/com/google/common/base/CommonPattern.java
+++ b/guava/src/com/google/common/base/CommonPattern.java
@@ -14,14 +14,12 @@
 
 package com.google.common.base;
 
-import com.google.common.annotations.GwtCompatible;
 
 /**
  * The subset of the {@link java.util.regex.Pattern} API which is used by this package, and also
  * shared with the {@code re2j} library. For internal use only. Please refer to the {@code Pattern}
  * javadoc for details.
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 abstract class CommonPattern {
   public abstract CommonMatcher matcher(CharSequence t);
diff --git a/guava/src/com/google/common/base/Converter.java b/guava/src/com/google/common/base/Converter.java
index 208a0324ed..1d0dcae721 100644
--- a/guava/src/com/google/common/base/Converter.java
+++ b/guava/src/com/google/common/base/Converter.java
@@ -17,11 +17,6 @@ package com.google.common.base;
 import static com.google.common.base.NullnessCasts.uncheckedCastNullableTToT;
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.ForOverride;
-import com.google.errorprone.annotations.concurrent.LazyInit;
-import com.google.j2objc.annotations.RetainedWith;
 import java.io.Serializable;
 import java.util.Iterator;
 import javax.annotation.CheckForNull;
@@ -113,7 +108,6 @@ import javax.annotation.CheckForNull;
  * @author Gregory Kick
  * @since 16.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 /*
  * 1. The type parameter is <T> rather than <T extends @Nullable> so that we can use T in the
@@ -143,7 +137,7 @@ public abstract class Converter<A, B> implements Function<A, B> {
   private final boolean handleNullAutomatically;
 
   // We lazily cache the reverse view to avoid allocating on every call to reverse().
-  @LazyInit @RetainedWith @CheckForNull private transient Converter<B, A> reverse;
+  @CheckForNull private transient Converter<B, A> reverse;
 
   /** Constructor for use by subclasses. */
   protected Converter() {
@@ -164,7 +158,6 @@ public abstract class Converter<A, B> implements Function<A, B> {
    * @param a the instance to convert; will never be null
    * @return the converted instance; <b>must not</b> be null
    */
-  @ForOverride
   protected abstract B doForward(A a);
 
   /**
@@ -179,7 +172,6 @@ public abstract class Converter<A, B> implements Function<A, B> {
    *     then this is not logically a {@code Converter} at all, and should just implement {@link
    *     Function}.
    */
-  @ForOverride
   protected abstract A doBackward(B b);
 
   // API (consumer-side) methods
@@ -189,7 +181,6 @@ public abstract class Converter<A, B> implements Function<A, B> {
    *
    * @return the converted value; is null <i>if and only if</i> {@code a} is null
    */
-  @CanIgnoreReturnValue
   @CheckForNull
   public final B convert(@CheckForNull A a) {
     return correctedDoForward(a);
@@ -259,7 +250,6 @@ public abstract class Converter<A, B> implements Function<A, B> {
    * a successful {@code remove()} call, {@code fromIterable} no longer contains the corresponding
    * element.
    */
-  @CanIgnoreReturnValue
   /*
    * Just as Converter could implement `Function<@Nullable A, @Nullable B>` instead of `Function<A,
    * B>`, convertAll could accept and return iterables with nullable element types. In both cases,
@@ -307,7 +297,6 @@ public abstract class Converter<A, B> implements Function<A, B> {
    *
    * <p><b>Note:</b> you should not override this method. It is non-final for legacy reasons.
    */
-  @CanIgnoreReturnValue
   public Converter<B, A> reverse() {
     Converter<B, A> result = reverse;
     return (result == null) ? reverse = new ReverseConverter<>(this) : result;
@@ -459,7 +448,6 @@ public abstract class Converter<A, B> implements Function<A, B> {
    */
   @Deprecated
   @Override
-  @CanIgnoreReturnValue
   /*
    * Even though we implement `Function<A, B>` instead of `Function<@Nullable A, @Nullable B>` (as
    * discussed in a code comment at the top of the class), we declare our override of Function.apply
diff --git a/guava/src/com/google/common/base/Defaults.java b/guava/src/com/google/common/base/Defaults.java
index 5d12343ed2..c5a9f9705f 100644
--- a/guava/src/com/google/common/base/Defaults.java
+++ b/guava/src/com/google/common/base/Defaults.java
@@ -16,7 +16,6 @@ package com.google.common.base;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtIncompatible;
 import javax.annotation.CheckForNull;
 
 /**
@@ -25,7 +24,6 @@ import javax.annotation.CheckForNull;
  * @author Ben Yu
  * @since 1.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class Defaults {
   private Defaults() {}
diff --git a/guava/src/com/google/common/base/ElementTypesAreNonnullByDefault.java b/guava/src/com/google/common/base/ElementTypesAreNonnullByDefault.java
index 890e3a3606..f5595b7bcc 100644
--- a/guava/src/com/google/common/base/ElementTypesAreNonnullByDefault.java
+++ b/guava/src/com/google/common/base/ElementTypesAreNonnullByDefault.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.ElementType.TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -33,7 +32,6 @@ import javax.annotation.meta.TypeQualifierDefault;
  * unfortunately includes type-variable usages, so we also provide {@link ParametricNullness} to
  * "undo" it as best we can.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target(TYPE)
 @TypeQualifierDefault({FIELD, METHOD, PARAMETER})
diff --git a/guava/src/com/google/common/base/Enums.java b/guava/src/com/google/common/base/Enums.java
index 449b7e3a95..1ebfbb7a25 100644
--- a/guava/src/com/google/common/base/Enums.java
+++ b/guava/src/com/google/common/base/Enums.java
@@ -16,8 +16,6 @@ package com.google.common.base;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import java.io.Serializable;
 import java.lang.ref.WeakReference;
 import java.lang.reflect.Field;
@@ -33,7 +31,6 @@ import javax.annotation.CheckForNull;
  * @author Steve McKay
  * @since 9.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class Enums {
 
@@ -46,7 +43,7 @@ public final class Enums {
    *
    * @since 12.0
    */
-  @GwtIncompatible // reflection
+  // reflection
   public static Field getField(Enum<?> enumValue) {
     Class<?> clazz = enumValue.getDeclaringClass();
     try {
@@ -70,11 +67,11 @@ public final class Enums {
     return Platform.getEnumIfPresent(enumClass, value);
   }
 
-  @GwtIncompatible // java.lang.ref.WeakReference
+  // java.lang.ref.WeakReference
   private static final Map<Class<? extends Enum<?>>, Map<String, WeakReference<? extends Enum<?>>>>
       enumConstantCache = new WeakHashMap<>();
 
-  @GwtIncompatible // java.lang.ref.WeakReference
+  // java.lang.ref.WeakReference
   private static <T extends Enum<T>> Map<String, WeakReference<? extends Enum<?>>> populateCache(
       Class<T> enumClass) {
     Map<String, WeakReference<? extends Enum<?>>> result = new HashMap<>();
@@ -85,7 +82,7 @@ public final class Enums {
     return result;
   }
 
-  @GwtIncompatible // java.lang.ref.WeakReference
+  // java.lang.ref.WeakReference
   static <T extends Enum<T>> Map<String, WeakReference<? extends Enum<?>>> getEnumConstants(
       Class<T> enumClass) {
     synchronized (enumConstantCache) {
diff --git a/guava/src/com/google/common/base/Equivalence.java b/guava/src/com/google/common/base/Equivalence.java
index fbcd21237e..549dda6e18 100644
--- a/guava/src/com/google/common/base/Equivalence.java
+++ b/guava/src/com/google/common/base/Equivalence.java
@@ -16,12 +16,9 @@ package com.google.common.base;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.ForOverride;
 import java.io.Serializable;
 import java.util.function.BiPredicate;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A strategy for determining whether two instances are considered equivalent, and for computing
@@ -34,13 +31,12 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @since 10.0 (<a href="https://github.com/google/guava/wiki/Compatibility">mostly
  *     source-compatible</a> since 4.0)
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 /*
  * The type parameter is <T> rather than <T extends @Nullable> so that we can use T in the
  * doEquivalent and doHash methods to indicate that the parameter cannot be null.
  */
-public abstract class Equivalence<T> implements BiPredicate<@Nullable T, @Nullable T> {
+public abstract class Equivalence<T> implements BiPredicate<T, T> {
   /** Constructor for use by subclasses. */
   protected Equivalence() {}
 
@@ -91,7 +87,6 @@ public abstract class Equivalence<T> implements BiPredicate<@Nullable T, @Nullab
    *
    * @since 10.0 (previously, subclasses would override equivalent())
    */
-  @ForOverride
   protected abstract boolean doEquivalent(T a, T b);
 
   /**
@@ -127,7 +122,6 @@ public abstract class Equivalence<T> implements BiPredicate<@Nullable T, @Nullab
    *
    * @since 10.0 (previously, subclasses would override hash())
    */
-  @ForOverride
   protected abstract int doHash(T t);
 
   /**
@@ -153,7 +147,7 @@ public abstract class Equivalence<T> implements BiPredicate<@Nullable T, @Nullab
    *
    * @since 10.0
    */
-  public final <F> Equivalence<F> onResultOf(Function<? super F, ? extends @Nullable T> function) {
+  public final <F> Equivalence<F> onResultOf(Function<? super F, ? extends T> function) {
     return new FunctionalEquivalence<>(function, this);
   }
 
@@ -164,7 +158,7 @@ public abstract class Equivalence<T> implements BiPredicate<@Nullable T, @Nullab
    *
    * @since 10.0
    */
-  public final <S extends @Nullable T> Wrapper<S> wrap(@ParametricNullness S reference) {
+  public final <S extends T> Wrapper<S> wrap(@ParametricNullness S reference) {
     return new Wrapper<S>(this, reference);
   }
 
@@ -188,7 +182,7 @@ public abstract class Equivalence<T> implements BiPredicate<@Nullable T, @Nullab
    *
    * @since 10.0
    */
-  public static final class Wrapper<T extends @Nullable Object> implements Serializable {
+  public static final class Wrapper<T extends Object> implements Serializable {
     private final Equivalence<? super T> equivalence;
     @ParametricNullness private final T reference;
 
@@ -258,8 +252,7 @@ public abstract class Equivalence<T> implements BiPredicate<@Nullable T, @Nullab
    *
    * @since 10.0
    */
-  @GwtCompatible(serializable = true)
-  public final <S extends @Nullable T> Equivalence<Iterable<S>> pairwise() {
+  public final <S extends T> Equivalence<Iterable<S>> pairwise() {
     // Ideally, the returned equivalence would support Iterable<? extends T>. However,
     // the need for this is so rare that it's not worth making callers deal with the ugly wildcard.
     return new PairwiseEquivalence<>(this);
@@ -271,12 +264,12 @@ public abstract class Equivalence<T> implements BiPredicate<@Nullable T, @Nullab
    *
    * @since 10.0
    */
-  public final Predicate<@Nullable T> equivalentTo(@CheckForNull T target) {
+  public final Predicate<T> equivalentTo(@CheckForNull T target) {
     return new EquivalentToPredicate<T>(this, target);
   }
 
   private static final class EquivalentToPredicate<T>
-      implements Predicate<@Nullable T>, Serializable {
+      implements Predicate<T>, Serializable {
 
     private final Equivalence<T> equivalence;
     @CheckForNull private final T target;
diff --git a/guava/src/com/google/common/base/ExtraObjectsMethodsForWeb.java b/guava/src/com/google/common/base/ExtraObjectsMethodsForWeb.java
index 6770755220..a5aa8a2aeb 100644
--- a/guava/src/com/google/common/base/ExtraObjectsMethodsForWeb.java
+++ b/guava/src/com/google/common/base/ExtraObjectsMethodsForWeb.java
@@ -14,12 +14,10 @@
 
 package com.google.common.base;
 
-import com.google.common.annotations.GwtCompatible;
 
 /**
  * Holder for extra methods of {@code Objects} only in web. Intended to be empty for regular
  * version.
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 abstract class ExtraObjectsMethodsForWeb {}
diff --git a/guava/src/com/google/common/base/FinalizablePhantomReference.java b/guava/src/com/google/common/base/FinalizablePhantomReference.java
index 4f93996695..fa4790752b 100644
--- a/guava/src/com/google/common/base/FinalizablePhantomReference.java
+++ b/guava/src/com/google/common/base/FinalizablePhantomReference.java
@@ -14,7 +14,6 @@
 
 package com.google.common.base;
 
-import com.google.common.annotations.GwtIncompatible;
 import java.lang.ref.PhantomReference;
 import java.lang.ref.ReferenceQueue;
 import javax.annotation.CheckForNull;
@@ -29,7 +28,6 @@ import javax.annotation.CheckForNull;
  * @author Bob Lee
  * @since 2.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public abstract class FinalizablePhantomReference<T> extends PhantomReference<T>
     implements FinalizableReference {
diff --git a/guava/src/com/google/common/base/FinalizableReference.java b/guava/src/com/google/common/base/FinalizableReference.java
index 73753c9b35..ac0f6e7150 100644
--- a/guava/src/com/google/common/base/FinalizableReference.java
+++ b/guava/src/com/google/common/base/FinalizableReference.java
@@ -14,8 +14,6 @@
 
 package com.google.common.base;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.DoNotMock;
 
 /**
  * Implemented by references that have code to run after garbage collection of their referents.
@@ -24,8 +22,6 @@ import com.google.errorprone.annotations.DoNotMock;
  * @author Bob Lee
  * @since 2.0
  */
-@DoNotMock("Use an instance of one of the Finalizable*Reference classes")
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public interface FinalizableReference {
   /**
diff --git a/guava/src/com/google/common/base/FinalizableReferenceQueue.java b/guava/src/com/google/common/base/FinalizableReferenceQueue.java
index 5ce1d31038..02d4de07ed 100644
--- a/guava/src/com/google/common/base/FinalizableReferenceQueue.java
+++ b/guava/src/com/google/common/base/FinalizableReferenceQueue.java
@@ -14,8 +14,6 @@
 
 package com.google.common.base;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import java.io.Closeable;
 import java.io.FileNotFoundException;
 import java.io.IOException;
@@ -88,7 +86,6 @@ import javax.annotation.CheckForNull;
  * @author Bob Lee
  * @since 2.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public class FinalizableReferenceQueue implements Closeable {
   /*
@@ -240,7 +237,7 @@ public class FinalizableReferenceQueue implements Closeable {
   static class SystemLoader implements FinalizerLoader {
     // This is used by the ClassLoader-leak test in FinalizableReferenceQueueTest to disable
     // finding Finalizer on the system class path even if it is there.
-    @VisibleForTesting static boolean disabled;
+    static boolean disabled;
 
     @Override
     @CheckForNull
diff --git a/guava/src/com/google/common/base/FinalizableSoftReference.java b/guava/src/com/google/common/base/FinalizableSoftReference.java
index c0e9b6bae0..53c83a3700 100644
--- a/guava/src/com/google/common/base/FinalizableSoftReference.java
+++ b/guava/src/com/google/common/base/FinalizableSoftReference.java
@@ -14,7 +14,6 @@
 
 package com.google.common.base;
 
-import com.google.common.annotations.GwtIncompatible;
 import java.lang.ref.ReferenceQueue;
 import java.lang.ref.SoftReference;
 import javax.annotation.CheckForNull;
@@ -27,7 +26,6 @@ import javax.annotation.CheckForNull;
  * @author Bob Lee
  * @since 2.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public abstract class FinalizableSoftReference<T> extends SoftReference<T>
     implements FinalizableReference {
diff --git a/guava/src/com/google/common/base/FinalizableWeakReference.java b/guava/src/com/google/common/base/FinalizableWeakReference.java
index 9cca92ed53..304167dbf5 100644
--- a/guava/src/com/google/common/base/FinalizableWeakReference.java
+++ b/guava/src/com/google/common/base/FinalizableWeakReference.java
@@ -14,7 +14,6 @@
 
 package com.google.common.base;
 
-import com.google.common.annotations.GwtIncompatible;
 import java.lang.ref.ReferenceQueue;
 import java.lang.ref.WeakReference;
 import javax.annotation.CheckForNull;
@@ -27,7 +26,6 @@ import javax.annotation.CheckForNull;
  * @author Bob Lee
  * @since 2.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public abstract class FinalizableWeakReference<T> extends WeakReference<T>
     implements FinalizableReference {
diff --git a/guava/src/com/google/common/base/Function.java b/guava/src/com/google/common/base/Function.java
index 45287b744a..d0362af0a0 100644
--- a/guava/src/com/google/common/base/Function.java
+++ b/guava/src/com/google/common/base/Function.java
@@ -14,10 +14,7 @@
 
 package com.google.common.base;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Legacy version of {@link java.util.function.Function java.util.function.Function}.
@@ -40,13 +37,12 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kevin Bourrillion
  * @since 2.0
  */
-@GwtCompatible
 @FunctionalInterface
 @ElementTypesAreNonnullByDefault
-public interface Function<F extends @Nullable Object, T extends @Nullable Object>
+public interface Function<F extends Object, T extends Object>
     extends java.util.function.Function<F, T> {
   @Override
-  @CanIgnoreReturnValue // TODO(kevinb): remove this
+  // TODO(kevinb): remove this
   @ParametricNullness
   T apply(@ParametricNullness F input);
 
diff --git a/guava/src/com/google/common/base/FunctionalEquivalence.java b/guava/src/com/google/common/base/FunctionalEquivalence.java
index 8bb67be288..bd18c1d803 100644
--- a/guava/src/com/google/common/base/FunctionalEquivalence.java
+++ b/guava/src/com/google/common/base/FunctionalEquivalence.java
@@ -16,8 +16,6 @@ package com.google.common.base;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 import javax.annotation.CheckForNull;
 
@@ -27,8 +25,6 @@ import javax.annotation.CheckForNull;
  * @author Bob Lee
  * @since 10.0
  */
-@Beta
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 final class FunctionalEquivalence<F, T> extends Equivalence<F> implements Serializable {
 
diff --git a/guava/src/com/google/common/base/Functions.java b/guava/src/com/google/common/base/Functions.java
index 5337d0e36f..5ad49d6e20 100644
--- a/guava/src/com/google/common/base/Functions.java
+++ b/guava/src/com/google/common/base/Functions.java
@@ -18,11 +18,9 @@ import static com.google.common.base.NullnessCasts.uncheckedCastNullableTToT;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 import java.util.Map;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to {@code com.google.common.base.Function} instances; see that
@@ -37,7 +35,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Jared Levy
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class Functions {
   private Functions() {}
@@ -82,12 +79,12 @@ public final class Functions {
   /** Returns the identity function. */
   // implementation is "fully variant"; E has become a "pass-through" type
   @SuppressWarnings("unchecked")
-  public static <E extends @Nullable Object> Function<E, E> identity() {
+  public static <E extends Object> Function<E, E> identity() {
     return (Function<E, E>) IdentityFunction.INSTANCE;
   }
 
   // enum singleton pattern
-  private enum IdentityFunction implements Function<@Nullable Object, @Nullable Object> {
+  private enum IdentityFunction implements Function<Object, Object> {
     INSTANCE;
 
     @Override
@@ -115,7 +112,7 @@ public final class Functions {
    * key (instead of an exception being thrown), you can use the method reference {@code map::get}
    * instead.
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object> Function<K, V> forMap(
+  public static <K extends Object, V extends Object> Function<K, V> forMap(
       Map<K, V> map) {
     return new FunctionForMapNoDefault<>(map);
   }
@@ -133,13 +130,13 @@ public final class Functions {
    * @return function that returns {@code map.get(a)} when {@code a} is a key, or {@code
    *     defaultValue} otherwise
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object> Function<K, V> forMap(
+  public static <K extends Object, V extends Object> Function<K, V> forMap(
       Map<K, ? extends V> map, @ParametricNullness V defaultValue) {
     return new ForMapWithDefault<>(map, defaultValue);
   }
 
   private static class FunctionForMapNoDefault<
-          K extends @Nullable Object, V extends @Nullable Object>
+          K extends Object, V extends Object>
       implements Function<K, V>, Serializable {
     final Map<K, V> map;
 
@@ -178,7 +175,7 @@ public final class Functions {
     private static final long serialVersionUID = 0;
   }
 
-  private static class ForMapWithDefault<K extends @Nullable Object, V extends @Nullable Object>
+  private static class ForMapWithDefault<K extends Object, V extends Object>
       implements Function<K, V>, Serializable {
     final Map<K, ? extends V> map;
     @ParametricNullness final V defaultValue;
@@ -233,13 +230,13 @@ public final class Functions {
    * @return the composition of {@code f} and {@code g}
    * @see <a href="//en.wikipedia.org/wiki/Function_composition">function composition</a>
    */
-  public static <A extends @Nullable Object, B extends @Nullable Object, C extends @Nullable Object>
+  public static <A extends Object, B extends Object, C extends Object>
       Function<A, C> compose(Function<B, C> g, Function<A, ? extends B> f) {
     return new FunctionComposition<>(g, f);
   }
 
   private static class FunctionComposition<
-          A extends @Nullable Object, B extends @Nullable Object, C extends @Nullable Object>
+          A extends Object, B extends Object, C extends Object>
       implements Function<A, C>, Serializable {
     private final Function<B, C> g;
     private final Function<A, ? extends B> f;
@@ -286,13 +283,13 @@ public final class Functions {
    *
    * <p><b>Java 8 users:</b> use the method reference {@code predicate::test} instead.
    */
-  public static <T extends @Nullable Object> Function<T, Boolean> forPredicate(
+  public static <T extends Object> Function<T, Boolean> forPredicate(
       Predicate<T> predicate) {
     return new PredicateFunction<T>(predicate);
   }
 
   /** @see Functions#forPredicate */
-  private static class PredicateFunction<T extends @Nullable Object>
+  private static class PredicateFunction<T extends Object>
       implements Function<T, Boolean>, Serializable {
     private final Predicate<T> predicate;
 
@@ -335,13 +332,13 @@ public final class Functions {
    * @param value the constant value for the function to return
    * @return a function that always returns {@code value}
    */
-  public static <E extends @Nullable Object> Function<@Nullable Object, E> constant(
+  public static <E extends Object> Function<Object, E> constant(
       @ParametricNullness E value) {
     return new ConstantFunction<>(value);
   }
 
-  private static class ConstantFunction<E extends @Nullable Object>
-      implements Function<@Nullable Object, E>, Serializable {
+  private static class ConstantFunction<E extends Object>
+      implements Function<Object, E>, Serializable {
     @ParametricNullness private final E value;
 
     public ConstantFunction(@ParametricNullness E value) {
@@ -383,13 +380,13 @@ public final class Functions {
    *
    * @since 10.0
    */
-  public static <F extends @Nullable Object, T extends @Nullable Object> Function<F, T> forSupplier(
+  public static <F extends Object, T extends Object> Function<F, T> forSupplier(
       Supplier<T> supplier) {
     return new SupplierFunction<>(supplier);
   }
 
   /** @see Functions#forSupplier */
-  private static class SupplierFunction<F extends @Nullable Object, T extends @Nullable Object>
+  private static class SupplierFunction<F extends Object, T extends Object>
       implements Function<F, T>, Serializable {
 
     private final Supplier<T> supplier;
diff --git a/guava/src/com/google/common/base/Java8Compatibility.java b/guava/src/com/google/common/base/Java8Compatibility.java
index edc8b73bdd..2d2b5f3e92 100644
--- a/guava/src/com/google/common/base/Java8Compatibility.java
+++ b/guava/src/com/google/common/base/Java8Compatibility.java
@@ -14,14 +14,12 @@
 
 package com.google.common.base;
 
-import com.google.common.annotations.GwtIncompatible;
 import java.nio.Buffer;
 
 /**
  * Wrappers around {@link Buffer} methods that are covariantly overridden in Java 9+. See
  * https://github.com/google/guava/issues/3990
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 final class Java8Compatibility {
   static void clear(Buffer b) {
diff --git a/guava/src/com/google/common/base/JdkPattern.java b/guava/src/com/google/common/base/JdkPattern.java
index 4788398b7c..1d5a3101c8 100644
--- a/guava/src/com/google/common/base/JdkPattern.java
+++ b/guava/src/com/google/common/base/JdkPattern.java
@@ -14,14 +14,12 @@
 
 package com.google.common.base;
 
-import com.google.common.annotations.GwtIncompatible;
 import java.io.Serializable;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 /** A regex pattern implementation which is backed by the {@link Pattern}. */
 @ElementTypesAreNonnullByDefault
-@GwtIncompatible
 final class JdkPattern extends CommonPattern implements Serializable {
   private final Pattern pattern;
 
diff --git a/guava/src/com/google/common/base/Joiner.java b/guava/src/com/google/common/base/Joiner.java
index 0f3d6e4b61..b6f0b11db5 100644
--- a/guava/src/com/google/common/base/Joiner.java
+++ b/guava/src/com/google/common/base/Joiner.java
@@ -17,9 +17,6 @@ package com.google.common.base;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.IOException;
 import java.util.AbstractList;
 import java.util.Arrays;
@@ -27,7 +24,6 @@ import java.util.Iterator;
 import java.util.Map;
 import java.util.Map.Entry;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An object which joins pieces of text (specified as an array, {@link Iterable}, varargs or even a
@@ -64,7 +60,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kevin Bourrillion
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public class Joiner {
   /** Returns a joiner which automatically places {@code separator} between consecutive elements. */
@@ -97,8 +92,7 @@ public class Joiner {
    * Appends the string representation of each of {@code parts}, using the previously configured
    * separator between each, to {@code appendable}.
    */
-  @CanIgnoreReturnValue
-  public <A extends Appendable> A appendTo(A appendable, Iterable<? extends @Nullable Object> parts)
+  public <A extends Appendable> A appendTo(A appendable, Iterable<? extends Object> parts)
       throws IOException {
     return appendTo(appendable, parts.iterator());
   }
@@ -109,8 +103,7 @@ public class Joiner {
    *
    * @since 11.0
    */
-  @CanIgnoreReturnValue
-  public <A extends Appendable> A appendTo(A appendable, Iterator<? extends @Nullable Object> parts)
+  public <A extends Appendable> A appendTo(A appendable, Iterator<? extends Object> parts)
       throws IOException {
     checkNotNull(appendable);
     if (parts.hasNext()) {
@@ -127,19 +120,17 @@ public class Joiner {
    * Appends the string representation of each of {@code parts}, using the previously configured
    * separator between each, to {@code appendable}.
    */
-  @CanIgnoreReturnValue
-  public final <A extends Appendable> A appendTo(A appendable, @Nullable Object[] parts)
+  public final <A extends Appendable> A appendTo(A appendable, Object[] parts)
       throws IOException {
     return appendTo(appendable, Arrays.asList(parts));
   }
 
   /** Appends to {@code appendable} the string representation of each of the remaining arguments. */
-  @CanIgnoreReturnValue
   public final <A extends Appendable> A appendTo(
       A appendable,
       @CheckForNull Object first,
       @CheckForNull Object second,
-      @Nullable Object... rest)
+      Object... rest)
       throws IOException {
     return appendTo(appendable, iterable(first, second, rest));
   }
@@ -149,9 +140,8 @@ public class Joiner {
    * separator between each, to {@code builder}. Identical to {@link #appendTo(Appendable,
    * Iterable)}, except that it does not throw {@link IOException}.
    */
-  @CanIgnoreReturnValue
   public final StringBuilder appendTo(
-      StringBuilder builder, Iterable<? extends @Nullable Object> parts) {
+      StringBuilder builder, Iterable<? extends Object> parts) {
     return appendTo(builder, parts.iterator());
   }
 
@@ -162,9 +152,8 @@ public class Joiner {
    *
    * @since 11.0
    */
-  @CanIgnoreReturnValue
   public final StringBuilder appendTo(
-      StringBuilder builder, Iterator<? extends @Nullable Object> parts) {
+      StringBuilder builder, Iterator<? extends Object> parts) {
     try {
       appendTo((Appendable) builder, parts);
     } catch (IOException impossible) {
@@ -178,8 +167,7 @@ public class Joiner {
    * separator between each, to {@code builder}. Identical to {@link #appendTo(Appendable,
    * Iterable)}, except that it does not throw {@link IOException}.
    */
-  @CanIgnoreReturnValue
-  public final StringBuilder appendTo(StringBuilder builder, @Nullable Object[] parts) {
+  public final StringBuilder appendTo(StringBuilder builder, Object[] parts) {
     return appendTo(builder, Arrays.asList(parts));
   }
 
@@ -188,12 +176,11 @@ public class Joiner {
    * Identical to {@link #appendTo(Appendable, Object, Object, Object...)}, except that it does not
    * throw {@link IOException}.
    */
-  @CanIgnoreReturnValue
   public final StringBuilder appendTo(
       StringBuilder builder,
       @CheckForNull Object first,
       @CheckForNull Object second,
-      @Nullable Object... rest) {
+      Object... rest) {
     return appendTo(builder, iterable(first, second, rest));
   }
 
@@ -201,7 +188,7 @@ public class Joiner {
    * Returns a string containing the string representation of each of {@code parts}, using the
    * previously configured separator between each.
    */
-  public final String join(Iterable<? extends @Nullable Object> parts) {
+  public final String join(Iterable<? extends Object> parts) {
     return join(parts.iterator());
   }
 
@@ -211,7 +198,7 @@ public class Joiner {
    *
    * @since 11.0
    */
-  public final String join(Iterator<? extends @Nullable Object> parts) {
+  public final String join(Iterator<? extends Object> parts) {
     return appendTo(new StringBuilder(), parts).toString();
   }
 
@@ -219,7 +206,7 @@ public class Joiner {
    * Returns a string containing the string representation of each of {@code parts}, using the
    * previously configured separator between each.
    */
-  public final String join(@Nullable Object[] parts) {
+  public final String join(Object[] parts) {
     return join(Arrays.asList(parts));
   }
 
@@ -228,7 +215,7 @@ public class Joiner {
    * configured separator between each.
    */
   public final String join(
-      @CheckForNull Object first, @CheckForNull Object second, @Nullable Object... rest) {
+      @CheckForNull Object first, @CheckForNull Object second, Object... rest) {
     return join(iterable(first, second, rest));
   }
 
@@ -264,7 +251,7 @@ public class Joiner {
     return new Joiner(this) {
       @Override
       public <A extends Appendable> A appendTo(
-          A appendable, Iterator<? extends @Nullable Object> parts) throws IOException {
+          A appendable, Iterator<? extends Object> parts) throws IOException {
         checkNotNull(appendable, "appendable");
         checkNotNull(parts, "parts");
         while (parts.hasNext()) {
@@ -345,7 +332,6 @@ public class Joiner {
      * Appends the string representation of each entry of {@code map}, using the previously
      * configured separator and key-value separator, to {@code appendable}.
      */
-    @CanIgnoreReturnValue
     public <A extends Appendable> A appendTo(A appendable, Map<?, ?> map) throws IOException {
       return appendTo(appendable, map.entrySet());
     }
@@ -355,7 +341,6 @@ public class Joiner {
      * configured separator and key-value separator, to {@code builder}. Identical to {@link
      * #appendTo(Appendable, Map)}, except that it does not throw {@link IOException}.
      */
-    @CanIgnoreReturnValue
     public StringBuilder appendTo(StringBuilder builder, Map<?, ?> map) {
       return appendTo(builder, map.entrySet());
     }
@@ -366,8 +351,6 @@ public class Joiner {
      *
      * @since 10.0
      */
-    @Beta
-    @CanIgnoreReturnValue
     public <A extends Appendable> A appendTo(A appendable, Iterable<? extends Entry<?, ?>> entries)
         throws IOException {
       return appendTo(appendable, entries.iterator());
@@ -379,8 +362,6 @@ public class Joiner {
      *
      * @since 11.0
      */
-    @Beta
-    @CanIgnoreReturnValue
     public <A extends Appendable> A appendTo(A appendable, Iterator<? extends Entry<?, ?>> parts)
         throws IOException {
       checkNotNull(appendable);
@@ -407,8 +388,6 @@ public class Joiner {
      *
      * @since 10.0
      */
-    @Beta
-    @CanIgnoreReturnValue
     public StringBuilder appendTo(StringBuilder builder, Iterable<? extends Entry<?, ?>> entries) {
       return appendTo(builder, entries.iterator());
     }
@@ -420,8 +399,6 @@ public class Joiner {
      *
      * @since 11.0
      */
-    @Beta
-    @CanIgnoreReturnValue
     public StringBuilder appendTo(StringBuilder builder, Iterator<? extends Entry<?, ?>> entries) {
       try {
         appendTo((Appendable) builder, entries);
@@ -445,7 +422,6 @@ public class Joiner {
      *
      * @since 10.0
      */
-    @Beta
     public String join(Iterable<? extends Entry<?, ?>> entries) {
       return join(entries.iterator());
     }
@@ -456,7 +432,6 @@ public class Joiner {
      *
      * @since 11.0
      */
-    @Beta
     public String join(Iterator<? extends Entry<?, ?>> entries) {
       return appendTo(new StringBuilder(), entries).toString();
     }
@@ -492,12 +467,12 @@ public class Joiner {
     return (part instanceof CharSequence) ? (CharSequence) part : part.toString();
   }
 
-  private static Iterable<@Nullable Object> iterable(
+  private static Iterable<Object> iterable(
       @CheckForNull final Object first,
       @CheckForNull final Object second,
-      final @Nullable Object[] rest) {
+      final Object[] rest) {
     checkNotNull(rest);
-    return new AbstractList<@Nullable Object>() {
+    return new AbstractList<Object>() {
       @Override
       public int size() {
         return rest.length + 2;
diff --git a/guava/src/com/google/common/base/MoreObjects.java b/guava/src/com/google/common/base/MoreObjects.java
index 16e12bb507..a1199ee73c 100644
--- a/guava/src/com/google/common/base/MoreObjects.java
+++ b/guava/src/com/google/common/base/MoreObjects.java
@@ -16,8 +16,6 @@ package com.google.common.base;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.lang.reflect.Array;
 import java.util.Arrays;
 import java.util.Collection;
@@ -38,7 +36,6 @@ import javax.annotation.CheckForNull;
  * @author Laurence Gonsalves
  * @since 18.0 (since 2.0 as {@code Objects})
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class MoreObjects {
   /**
@@ -183,7 +180,6 @@ public final class MoreObjects {
      *
      * @since 18.0 (since 12.0 as {@code Objects.ToStringHelper.omitNullValues()}).
      */
-    @CanIgnoreReturnValue
     public ToStringHelper omitNullValues() {
       omitNullValues = true;
       return this;
@@ -194,7 +190,6 @@ public final class MoreObjects {
      * is {@code null}, the string {@code "null"} is used, unless {@link #omitNullValues()} is
      * called, in which case this name/value pair will not be added.
      */
-    @CanIgnoreReturnValue
     public ToStringHelper add(String name, @CheckForNull Object value) {
       return addHolder(name, value);
     }
@@ -204,7 +199,6 @@ public final class MoreObjects {
      *
      * @since 18.0 (since 11.0 as {@code Objects.ToStringHelper.add()}).
      */
-    @CanIgnoreReturnValue
     public ToStringHelper add(String name, boolean value) {
       return addUnconditionalHolder(name, String.valueOf(value));
     }
@@ -214,7 +208,6 @@ public final class MoreObjects {
      *
      * @since 18.0 (since 11.0 as {@code Objects.ToStringHelper.add()}).
      */
-    @CanIgnoreReturnValue
     public ToStringHelper add(String name, char value) {
       return addUnconditionalHolder(name, String.valueOf(value));
     }
@@ -224,7 +217,6 @@ public final class MoreObjects {
      *
      * @since 18.0 (since 11.0 as {@code Objects.ToStringHelper.add()}).
      */
-    @CanIgnoreReturnValue
     public ToStringHelper add(String name, double value) {
       return addUnconditionalHolder(name, String.valueOf(value));
     }
@@ -234,7 +226,6 @@ public final class MoreObjects {
      *
      * @since 18.0 (since 11.0 as {@code Objects.ToStringHelper.add()}).
      */
-    @CanIgnoreReturnValue
     public ToStringHelper add(String name, float value) {
       return addUnconditionalHolder(name, String.valueOf(value));
     }
@@ -244,7 +235,6 @@ public final class MoreObjects {
      *
      * @since 18.0 (since 11.0 as {@code Objects.ToStringHelper.add()}).
      */
-    @CanIgnoreReturnValue
     public ToStringHelper add(String name, int value) {
       return addUnconditionalHolder(name, String.valueOf(value));
     }
@@ -254,7 +244,6 @@ public final class MoreObjects {
      *
      * @since 18.0 (since 11.0 as {@code Objects.ToStringHelper.add()}).
      */
-    @CanIgnoreReturnValue
     public ToStringHelper add(String name, long value) {
       return addUnconditionalHolder(name, String.valueOf(value));
     }
@@ -265,7 +254,6 @@ public final class MoreObjects {
      * <p>It is strongly encouraged to use {@link #add(String, Object)} instead and give value a
      * readable name.
      */
-    @CanIgnoreReturnValue
     public ToStringHelper addValue(@CheckForNull Object value) {
       return addHolder(value);
     }
@@ -278,7 +266,6 @@ public final class MoreObjects {
      *
      * @since 18.0 (since 11.0 as {@code Objects.ToStringHelper.addValue()}).
      */
-    @CanIgnoreReturnValue
     public ToStringHelper addValue(boolean value) {
       return addUnconditionalHolder(String.valueOf(value));
     }
@@ -291,7 +278,6 @@ public final class MoreObjects {
      *
      * @since 18.0 (since 11.0 as {@code Objects.ToStringHelper.addValue()}).
      */
-    @CanIgnoreReturnValue
     public ToStringHelper addValue(char value) {
       return addUnconditionalHolder(String.valueOf(value));
     }
@@ -304,7 +290,6 @@ public final class MoreObjects {
      *
      * @since 18.0 (since 11.0 as {@code Objects.ToStringHelper.addValue()}).
      */
-    @CanIgnoreReturnValue
     public ToStringHelper addValue(double value) {
       return addUnconditionalHolder(String.valueOf(value));
     }
@@ -317,7 +302,6 @@ public final class MoreObjects {
      *
      * @since 18.0 (since 11.0 as {@code Objects.ToStringHelper.addValue()}).
      */
-    @CanIgnoreReturnValue
     public ToStringHelper addValue(float value) {
       return addUnconditionalHolder(String.valueOf(value));
     }
@@ -330,7 +314,6 @@ public final class MoreObjects {
      *
      * @since 18.0 (since 11.0 as {@code Objects.ToStringHelper.addValue()}).
      */
-    @CanIgnoreReturnValue
     public ToStringHelper addValue(int value) {
       return addUnconditionalHolder(String.valueOf(value));
     }
@@ -343,7 +326,6 @@ public final class MoreObjects {
      *
      * @since 18.0 (since 11.0 as {@code Objects.ToStringHelper.addValue()}).
      */
-    @CanIgnoreReturnValue
     public ToStringHelper addValue(long value) {
       return addUnconditionalHolder(String.valueOf(value));
     }
diff --git a/guava/src/com/google/common/base/NullnessCasts.java b/guava/src/com/google/common/base/NullnessCasts.java
index 1ada6bf261..3132e98be2 100644
--- a/guava/src/com/google/common/base/NullnessCasts.java
+++ b/guava/src/com/google/common/base/NullnessCasts.java
@@ -14,12 +14,9 @@
 
 package com.google.common.base;
 
-import com.google.common.annotations.GwtCompatible;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** A utility method to perform unchecked casts to suppress errors produced by nullness analyses. */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 final class NullnessCasts {
   /**
@@ -52,7 +49,7 @@ final class NullnessCasts {
    */
   @ParametricNullness
   @SuppressWarnings("nullness")
-  static <T extends @Nullable Object> T uncheckedCastNullableTToT(@CheckForNull T t) {
+  static <T extends Object> T uncheckedCastNullableTToT(@CheckForNull T t) {
     return t;
   }
 
diff --git a/guava/src/com/google/common/base/Objects.java b/guava/src/com/google/common/base/Objects.java
index bd6b0d94c5..8bda9c617a 100644
--- a/guava/src/com/google/common/base/Objects.java
+++ b/guava/src/com/google/common/base/Objects.java
@@ -14,10 +14,8 @@
 
 package com.google.common.base;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.Arrays;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Helper functions that can operate on any {@code Object}.
@@ -29,7 +27,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Laurence Gonsalves
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class Objects extends ExtraObjectsMethodsForWeb {
   private Objects() {}
@@ -75,7 +72,7 @@ public final class Objects extends ExtraObjectsMethodsForWeb {
    * <p><b>Note for Java 7 and later:</b> This method should be treated as deprecated; use {@link
    * java.util.Objects#hash} instead.
    */
-  public static int hashCode(@CheckForNull @Nullable Object... objects) {
+  public static int hashCode(@CheckForNull Object... objects) {
     return Arrays.hashCode(objects);
   }
 }
diff --git a/guava/src/com/google/common/base/Optional.java b/guava/src/com/google/common/base/Optional.java
index b47705e82f..3384d1ce33 100644
--- a/guava/src/com/google/common/base/Optional.java
+++ b/guava/src/com/google/common/base/Optional.java
@@ -16,9 +16,6 @@ package com.google.common.base;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.DoNotMock;
 import java.io.Serializable;
 import java.util.Iterator;
 import java.util.Set;
@@ -80,8 +77,6 @@ import javax.annotation.CheckForNull;
  * @author Kevin Bourrillion
  * @since 10.0
  */
-@DoNotMock("Use Optional.of(value) or Optional.absent()")
-@GwtCompatible(serializable = true)
 @ElementTypesAreNonnullByDefault
 public abstract class Optional<T> implements Serializable {
   /**
@@ -239,7 +234,6 @@ public abstract class Optional<T> implements Serializable {
    * @throws NullPointerException if this optional's value is absent and the supplier returns {@code
    *     null}
    */
-  @Beta
   public abstract T or(Supplier<? extends T> supplier);
 
   /**
@@ -331,7 +325,6 @@ public abstract class Optional<T> implements Serializable {
    *
    * @since 11.0 (generics widened in 13.0)
    */
-  @Beta
   public static <T> Iterable<T> presentInstances(
       final Iterable<? extends Optional<? extends T>> optionals) {
     checkNotNull(optionals);
diff --git a/guava/src/com/google/common/base/PairwiseEquivalence.java b/guava/src/com/google/common/base/PairwiseEquivalence.java
index 74be27fd7c..bf6b3d83af 100644
--- a/guava/src/com/google/common/base/PairwiseEquivalence.java
+++ b/guava/src/com/google/common/base/PairwiseEquivalence.java
@@ -14,15 +14,12 @@
 
 package com.google.common.base;
 
-import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 import java.util.Iterator;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
-@GwtCompatible(serializable = true)
 @ElementTypesAreNonnullByDefault
-final class PairwiseEquivalence<E, T extends @Nullable E> extends Equivalence<Iterable<T>>
+final class PairwiseEquivalence<E, T extends E> extends Equivalence<Iterable<T>>
     implements Serializable {
   final Equivalence<E> elementEquivalence;
 
diff --git a/guava/src/com/google/common/base/ParametricNullness.java b/guava/src/com/google/common/base/ParametricNullness.java
index c73605548f..e14753124a 100644
--- a/guava/src/com/google/common/base/ParametricNullness.java
+++ b/guava/src/com/google/common/base/ParametricNullness.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import static javax.annotation.meta.When.UNKNOWN;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -35,7 +34,6 @@ import javax.annotation.meta.TypeQualifierNickname;
  * href="https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/NullFromTypeParam.java">{@code
  * NullFromTypeParam}</a>). We use this to "undo" {@link ElementTypesAreNonnullByDefault}.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target({FIELD, METHOD, PARAMETER})
 @TypeQualifierNickname
diff --git a/guava/src/com/google/common/base/PatternCompiler.java b/guava/src/com/google/common/base/PatternCompiler.java
index 72a45faae9..11e6e8637d 100644
--- a/guava/src/com/google/common/base/PatternCompiler.java
+++ b/guava/src/com/google/common/base/PatternCompiler.java
@@ -14,14 +14,12 @@
 
 package com.google.common.base;
 
-import com.google.common.annotations.GwtIncompatible;
 
 /**
  * Pluggable interface for compiling a regex pattern. By default this package uses the {@code
  * java.util.regex} library, but an alternate implementation can be supplied using the {@link
  * java.util.ServiceLoader} mechanism.
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 interface PatternCompiler {
   /**
diff --git a/guava/src/com/google/common/base/Platform.java b/guava/src/com/google/common/base/Platform.java
index 644e89cbfa..f72acf80f5 100644
--- a/guava/src/com/google/common/base/Platform.java
+++ b/guava/src/com/google/common/base/Platform.java
@@ -14,7 +14,6 @@
 
 package com.google.common.base;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.ref.WeakReference;
 import java.util.Locale;
 import java.util.ServiceConfigurationError;
@@ -28,7 +27,6 @@ import javax.annotation.CheckForNull;
  *
  * @author Jesse Wilson
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 final class Platform {
   private static final Logger logger = Logger.getLogger(Platform.class.getName());
diff --git a/guava/src/com/google/common/base/Preconditions.java b/guava/src/com/google/common/base/Preconditions.java
index 13ff77b7f7..9bf263d7ae 100644
--- a/guava/src/com/google/common/base/Preconditions.java
+++ b/guava/src/com/google/common/base/Preconditions.java
@@ -16,10 +16,7 @@ package com.google.common.base;
 
 import static com.google.common.base.Strings.lenientFormat;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static convenience methods that help a method or constructor check whether it was invoked
@@ -113,7 +110,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kevin Bourrillion
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class Preconditions {
   private Preconditions() {}
@@ -162,7 +158,7 @@ public final class Preconditions {
   public static void checkArgument(
       boolean expression,
       String errorMessageTemplate,
-      @CheckForNull @Nullable Object... errorMessageArgs) {
+      @CheckForNull Object... errorMessageArgs) {
     if (!expression) {
       throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, errorMessageArgs));
     }
@@ -529,7 +525,7 @@ public final class Preconditions {
        * that user first.
        */
       @CheckForNull String errorMessageTemplate,
-      @CheckForNull @Nullable Object... errorMessageArgs) {
+      @CheckForNull Object... errorMessageArgs) {
     if (!expression) {
       throw new IllegalStateException(lenientFormat(errorMessageTemplate, errorMessageArgs));
     }
@@ -883,7 +879,6 @@ public final class Preconditions {
    * @throws NullPointerException if {@code reference} is null
    * @see Verify#verifyNotNull Verify.verifyNotNull()
    */
-  @CanIgnoreReturnValue
   public static <T> T checkNotNull(@CheckForNull T reference) {
     if (reference == null) {
       throw new NullPointerException();
@@ -901,7 +896,6 @@ public final class Preconditions {
    * @throws NullPointerException if {@code reference} is null
    * @see Verify#verifyNotNull Verify.verifyNotNull()
    */
-  @CanIgnoreReturnValue
   public static <T> T checkNotNull(@CheckForNull T reference, @CheckForNull Object errorMessage) {
     if (reference == null) {
       throw new NullPointerException(String.valueOf(errorMessage));
@@ -924,11 +918,10 @@ public final class Preconditions {
    * @throws NullPointerException if {@code reference} is null
    * @see Verify#verifyNotNull Verify.verifyNotNull()
    */
-  @CanIgnoreReturnValue
   public static <T> T checkNotNull(
       @CheckForNull T reference,
       String errorMessageTemplate,
-      @CheckForNull @Nullable Object... errorMessageArgs) {
+      @CheckForNull Object... errorMessageArgs) {
     if (reference == null) {
       throw new NullPointerException(lenientFormat(errorMessageTemplate, errorMessageArgs));
     }
@@ -942,7 +935,6 @@ public final class Preconditions {
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  @CanIgnoreReturnValue
   public static <T> T checkNotNull(@CheckForNull T obj, String errorMessageTemplate, char p1) {
     if (obj == null) {
       throw new NullPointerException(lenientFormat(errorMessageTemplate, p1));
@@ -957,7 +949,6 @@ public final class Preconditions {
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  @CanIgnoreReturnValue
   public static <T> T checkNotNull(@CheckForNull T obj, String errorMessageTemplate, int p1) {
     if (obj == null) {
       throw new NullPointerException(lenientFormat(errorMessageTemplate, p1));
@@ -972,7 +963,6 @@ public final class Preconditions {
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  @CanIgnoreReturnValue
   public static <T> T checkNotNull(@CheckForNull T obj, String errorMessageTemplate, long p1) {
     if (obj == null) {
       throw new NullPointerException(lenientFormat(errorMessageTemplate, p1));
@@ -987,7 +977,6 @@ public final class Preconditions {
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  @CanIgnoreReturnValue
   public static <T> T checkNotNull(
       @CheckForNull T obj, String errorMessageTemplate, @CheckForNull Object p1) {
     if (obj == null) {
@@ -1003,7 +992,6 @@ public final class Preconditions {
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  @CanIgnoreReturnValue
   public static <T> T checkNotNull(
       @CheckForNull T obj, String errorMessageTemplate, char p1, char p2) {
     if (obj == null) {
@@ -1019,7 +1007,6 @@ public final class Preconditions {
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  @CanIgnoreReturnValue
   public static <T> T checkNotNull(
       @CheckForNull T obj, String errorMessageTemplate, char p1, int p2) {
     if (obj == null) {
@@ -1035,7 +1022,6 @@ public final class Preconditions {
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  @CanIgnoreReturnValue
   public static <T> T checkNotNull(
       @CheckForNull T obj, String errorMessageTemplate, char p1, long p2) {
     if (obj == null) {
@@ -1051,7 +1037,6 @@ public final class Preconditions {
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  @CanIgnoreReturnValue
   public static <T> T checkNotNull(
       @CheckForNull T obj, String errorMessageTemplate, char p1, @CheckForNull Object p2) {
     if (obj == null) {
@@ -1067,7 +1052,6 @@ public final class Preconditions {
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  @CanIgnoreReturnValue
   public static <T> T checkNotNull(
       @CheckForNull T obj, String errorMessageTemplate, int p1, char p2) {
     if (obj == null) {
@@ -1083,7 +1067,6 @@ public final class Preconditions {
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  @CanIgnoreReturnValue
   public static <T> T checkNotNull(
       @CheckForNull T obj, String errorMessageTemplate, int p1, int p2) {
     if (obj == null) {
@@ -1099,7 +1082,6 @@ public final class Preconditions {
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  @CanIgnoreReturnValue
   public static <T> T checkNotNull(
       @CheckForNull T obj, String errorMessageTemplate, int p1, long p2) {
     if (obj == null) {
@@ -1115,7 +1097,6 @@ public final class Preconditions {
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  @CanIgnoreReturnValue
   public static <T> T checkNotNull(
       @CheckForNull T obj, String errorMessageTemplate, int p1, @CheckForNull Object p2) {
     if (obj == null) {
@@ -1131,7 +1112,6 @@ public final class Preconditions {
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  @CanIgnoreReturnValue
   public static <T> T checkNotNull(
       @CheckForNull T obj, String errorMessageTemplate, long p1, char p2) {
     if (obj == null) {
@@ -1147,7 +1127,6 @@ public final class Preconditions {
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  @CanIgnoreReturnValue
   public static <T> T checkNotNull(
       @CheckForNull T obj, String errorMessageTemplate, long p1, int p2) {
     if (obj == null) {
@@ -1163,7 +1142,6 @@ public final class Preconditions {
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  @CanIgnoreReturnValue
   public static <T> T checkNotNull(
       @CheckForNull T obj, String errorMessageTemplate, long p1, long p2) {
     if (obj == null) {
@@ -1179,7 +1157,6 @@ public final class Preconditions {
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  @CanIgnoreReturnValue
   public static <T> T checkNotNull(
       @CheckForNull T obj, String errorMessageTemplate, long p1, @CheckForNull Object p2) {
     if (obj == null) {
@@ -1195,7 +1172,6 @@ public final class Preconditions {
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  @CanIgnoreReturnValue
   public static <T> T checkNotNull(
       @CheckForNull T obj, String errorMessageTemplate, @CheckForNull Object p1, char p2) {
     if (obj == null) {
@@ -1211,7 +1187,6 @@ public final class Preconditions {
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  @CanIgnoreReturnValue
   public static <T> T checkNotNull(
       @CheckForNull T obj, String errorMessageTemplate, @CheckForNull Object p1, int p2) {
     if (obj == null) {
@@ -1227,7 +1202,6 @@ public final class Preconditions {
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  @CanIgnoreReturnValue
   public static <T> T checkNotNull(
       @CheckForNull T obj, String errorMessageTemplate, @CheckForNull Object p1, long p2) {
     if (obj == null) {
@@ -1243,7 +1217,6 @@ public final class Preconditions {
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  @CanIgnoreReturnValue
   public static <T> T checkNotNull(
       @CheckForNull T obj,
       String errorMessageTemplate,
@@ -1262,7 +1235,6 @@ public final class Preconditions {
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  @CanIgnoreReturnValue
   public static <T> T checkNotNull(
       @CheckForNull T obj,
       String errorMessageTemplate,
@@ -1282,7 +1254,6 @@ public final class Preconditions {
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  @CanIgnoreReturnValue
   public static <T> T checkNotNull(
       @CheckForNull T obj,
       String errorMessageTemplate,
@@ -1332,7 +1303,6 @@ public final class Preconditions {
    * @throws IndexOutOfBoundsException if {@code index} is negative or is not less than {@code size}
    * @throws IllegalArgumentException if {@code size} is negative
    */
-  @CanIgnoreReturnValue
   public static int checkElementIndex(int index, int size) {
     return checkElementIndex(index, size, "index");
   }
@@ -1348,7 +1318,6 @@ public final class Preconditions {
    * @throws IndexOutOfBoundsException if {@code index} is negative or is not less than {@code size}
    * @throws IllegalArgumentException if {@code size} is negative
    */
-  @CanIgnoreReturnValue
   public static int checkElementIndex(int index, int size, String desc) {
     // Carefully optimized for execution by hotspot (explanatory comment above)
     if (index < 0 || index >= size) {
@@ -1377,7 +1346,6 @@ public final class Preconditions {
    * @throws IndexOutOfBoundsException if {@code index} is negative or is greater than {@code size}
    * @throws IllegalArgumentException if {@code size} is negative
    */
-  @CanIgnoreReturnValue
   public static int checkPositionIndex(int index, int size) {
     return checkPositionIndex(index, size, "index");
   }
@@ -1393,7 +1361,6 @@ public final class Preconditions {
    * @throws IndexOutOfBoundsException if {@code index} is negative or is greater than {@code size}
    * @throws IllegalArgumentException if {@code size} is negative
    */
-  @CanIgnoreReturnValue
   public static int checkPositionIndex(int index, int size, String desc) {
     // Carefully optimized for execution by hotspot (explanatory comment above)
     if (index < 0 || index > size) {
diff --git a/guava/src/com/google/common/base/Predicate.java b/guava/src/com/google/common/base/Predicate.java
index 4384ed0e59..e2d3d181a8 100644
--- a/guava/src/com/google/common/base/Predicate.java
+++ b/guava/src/com/google/common/base/Predicate.java
@@ -14,10 +14,7 @@
 
 package com.google.common.base;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Legacy version of {@link java.util.function.Predicate java.util.function.Predicate}. Determines a
@@ -42,9 +39,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @since 2.0
  */
 @FunctionalInterface
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public interface Predicate<T extends @Nullable Object> extends java.util.function.Predicate<T> {
+public interface Predicate<T extends Object> extends java.util.function.Predicate<T> {
   /**
    * Returns the result of applying this predicate to {@code input} (Java 8 users, see notes in the
    * class documentation above). This method is <i>generally expected</i>, but not absolutely
@@ -60,7 +56,6 @@ public interface Predicate<T extends @Nullable Object> extends java.util.functio
    * @throws NullPointerException if {@code input} is null and this predicate does not accept null
    *     arguments
    */
-  @CanIgnoreReturnValue
   boolean apply(@ParametricNullness T input);
 
   /**
diff --git a/guava/src/com/google/common/base/Predicates.java b/guava/src/com/google/common/base/Predicates.java
index c3b5562658..c8a5b1f0cc 100644
--- a/guava/src/com/google/common/base/Predicates.java
+++ b/guava/src/com/google/common/base/Predicates.java
@@ -16,9 +16,6 @@ package com.google.common.base;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -26,7 +23,6 @@ import java.util.Collection;
 import java.util.List;
 import java.util.regex.Pattern;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to {@code Predicate} instances.
@@ -39,7 +35,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kevin Bourrillion
  * @since 2.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class Predicates {
   private Predicates() {}
@@ -48,14 +43,12 @@ public final class Predicates {
   // interface which specifies an accept(PredicateVisitor) method.
 
   /** Returns a predicate that always evaluates to {@code true}. */
-  @GwtCompatible(serializable = true)
-  public static <T extends @Nullable Object> Predicate<T> alwaysTrue() {
+  public static <T extends Object> Predicate<T> alwaysTrue() {
     return ObjectPredicate.ALWAYS_TRUE.withNarrowedType();
   }
 
   /** Returns a predicate that always evaluates to {@code false}. */
-  @GwtCompatible(serializable = true)
-  public static <T extends @Nullable Object> Predicate<T> alwaysFalse() {
+  public static <T extends Object> Predicate<T> alwaysFalse() {
     return ObjectPredicate.ALWAYS_FALSE.withNarrowedType();
   }
 
@@ -63,8 +56,7 @@ public final class Predicates {
    * Returns a predicate that evaluates to {@code true} if the object reference being tested is
    * null.
    */
-  @GwtCompatible(serializable = true)
-  public static <T extends @Nullable Object> Predicate<T> isNull() {
+  public static <T extends Object> Predicate<T> isNull() {
     return ObjectPredicate.IS_NULL.withNarrowedType();
   }
 
@@ -72,8 +64,7 @@ public final class Predicates {
    * Returns a predicate that evaluates to {@code true} if the object reference being tested is not
    * null.
    */
-  @GwtCompatible(serializable = true)
-  public static <T extends @Nullable Object> Predicate<T> notNull() {
+  public static <T extends Object> Predicate<T> notNull() {
     return ObjectPredicate.NOT_NULL.withNarrowedType();
   }
 
@@ -81,7 +72,7 @@ public final class Predicates {
    * Returns a predicate that evaluates to {@code true} if the given predicate evaluates to {@code
    * false}.
    */
-  public static <T extends @Nullable Object> Predicate<T> not(Predicate<T> predicate) {
+  public static <T extends Object> Predicate<T> not(Predicate<T> predicate) {
     return new NotPredicate<T>(predicate);
   }
 
@@ -92,7 +83,7 @@ public final class Predicates {
    * changes to it won't alter the behavior of this predicate. If {@code components} is empty, the
    * returned predicate will always evaluate to {@code true}.
    */
-  public static <T extends @Nullable Object> Predicate<T> and(
+  public static <T extends Object> Predicate<T> and(
       Iterable<? extends Predicate<? super T>> components) {
     return new AndPredicate<T>(defensiveCopy(components));
   }
@@ -105,7 +96,7 @@ public final class Predicates {
    * returned predicate will always evaluate to {@code true}.
    */
   @SafeVarargs
-  public static <T extends @Nullable Object> Predicate<T> and(Predicate<? super T>... components) {
+  public static <T extends Object> Predicate<T> and(Predicate<? super T>... components) {
     return new AndPredicate<T>(defensiveCopy(components));
   }
 
@@ -114,7 +105,7 @@ public final class Predicates {
    * true}. The components are evaluated in order, and evaluation will be "short-circuited" as soon
    * as a false predicate is found.
    */
-  public static <T extends @Nullable Object> Predicate<T> and(
+  public static <T extends Object> Predicate<T> and(
       Predicate<? super T> first, Predicate<? super T> second) {
     return new AndPredicate<T>(Predicates.<T>asList(checkNotNull(first), checkNotNull(second)));
   }
@@ -126,7 +117,7 @@ public final class Predicates {
    * changes to it won't alter the behavior of this predicate. If {@code components} is empty, the
    * returned predicate will always evaluate to {@code false}.
    */
-  public static <T extends @Nullable Object> Predicate<T> or(
+  public static <T extends Object> Predicate<T> or(
       Iterable<? extends Predicate<? super T>> components) {
     return new OrPredicate<T>(defensiveCopy(components));
   }
@@ -139,7 +130,7 @@ public final class Predicates {
    * returned predicate will always evaluate to {@code false}.
    */
   @SafeVarargs
-  public static <T extends @Nullable Object> Predicate<T> or(Predicate<? super T>... components) {
+  public static <T extends Object> Predicate<T> or(Predicate<? super T>... components) {
     return new OrPredicate<T>(defensiveCopy(components));
   }
 
@@ -148,7 +139,7 @@ public final class Predicates {
    * {@code true}. The components are evaluated in order, and evaluation will be "short-circuited"
    * as soon as a true predicate is found.
    */
-  public static <T extends @Nullable Object> Predicate<T> or(
+  public static <T extends Object> Predicate<T> or(
       Predicate<? super T> first, Predicate<? super T> second) {
     return new OrPredicate<T>(Predicates.<T>asList(checkNotNull(first), checkNotNull(second)));
   }
@@ -157,7 +148,7 @@ public final class Predicates {
    * Returns a predicate that evaluates to {@code true} if the object being tested {@code equals()}
    * the given target or both are null.
    */
-  public static <T extends @Nullable Object> Predicate<T> equalTo(@ParametricNullness T target) {
+  public static <T extends Object> Predicate<T> equalTo(@ParametricNullness T target) {
     return (target == null)
         ? Predicates.<T>isNull()
         : new IsEqualToPredicate(target).withNarrowedType();
@@ -176,8 +167,8 @@ public final class Predicates {
    * example, {@code instanceOf(ArrayList.class)} will yield different results for the two equal
    * instances {@code Lists.newArrayList(1)} and {@code Arrays.asList(1)}.
    */
-  @GwtIncompatible // Class.isInstance
-  public static <T extends @Nullable Object> Predicate<T> instanceOf(Class<?> clazz) {
+  // Class.isInstance
+  public static <T extends Object> Predicate<T> instanceOf(Class<?> clazz) {
     return new InstanceOfPredicate<>(clazz);
   }
 
@@ -195,8 +186,7 @@ public final class Predicates {
    *
    * @since 20.0 (since 10.0 under the incorrect name {@code assignableFrom})
    */
-  @GwtIncompatible // Class.isAssignableFrom
-  @Beta
+  // Class.isAssignableFrom
   public static Predicate<Class<?>> subtypeOf(Class<?> clazz) {
     return new SubtypeOfPredicate(clazz);
   }
@@ -212,7 +202,7 @@ public final class Predicates {
    *
    * @param target the collection that may contain the function input
    */
-  public static <T extends @Nullable Object> Predicate<T> in(Collection<? extends T> target) {
+  public static <T extends Object> Predicate<T> in(Collection<? extends T> target) {
     return new InPredicate<T>(target);
   }
 
@@ -222,7 +212,7 @@ public final class Predicates {
    *
    * @return the composition of the provided function and predicate
    */
-  public static <A extends @Nullable Object, B extends @Nullable Object> Predicate<A> compose(
+  public static <A extends Object, B extends Object> Predicate<A> compose(
       Predicate<B> predicate, Function<A, ? extends B> function) {
     return new CompositionPredicate<>(predicate, function);
   }
@@ -235,7 +225,7 @@ public final class Predicates {
    * @throws IllegalArgumentException if the pattern is invalid
    * @since 3.0
    */
-  @GwtIncompatible // Only used by other GWT-incompatible code.
+  // Only used by other GWT-incompatible code.
   public static Predicate<CharSequence> containsPattern(String pattern) {
     return new ContainsPatternFromStringPredicate(pattern);
   }
@@ -247,7 +237,6 @@ public final class Predicates {
    *
    * @since 3.0
    */
-  @GwtIncompatible(value = "java.util.regex.Pattern")
   public static Predicate<CharSequence> contains(Pattern pattern) {
     return new ContainsPatternPredicate(new JdkPattern(pattern));
   }
@@ -255,7 +244,7 @@ public final class Predicates {
   // End public API, begin private implementation classes.
 
   // Package private for GWT serialization.
-  enum ObjectPredicate implements Predicate<@Nullable Object> {
+  enum ObjectPredicate implements Predicate<Object> {
     /** @see Predicates#alwaysTrue() */
     ALWAYS_TRUE {
       @Override
@@ -306,13 +295,13 @@ public final class Predicates {
     };
 
     @SuppressWarnings("unchecked") // safe contravariant cast
-    <T extends @Nullable Object> Predicate<T> withNarrowedType() {
+    <T extends Object> Predicate<T> withNarrowedType() {
       return (Predicate<T>) this;
     }
   }
 
   /** @see Predicates#not(Predicate) */
-  private static class NotPredicate<T extends @Nullable Object>
+  private static class NotPredicate<T extends Object>
       implements Predicate<T>, Serializable {
     final Predicate<T> predicate;
 
@@ -348,7 +337,7 @@ public final class Predicates {
   }
 
   /** @see Predicates#and(Iterable) */
-  private static class AndPredicate<T extends @Nullable Object>
+  private static class AndPredicate<T extends Object>
       implements Predicate<T>, Serializable {
     private final List<? extends Predicate<? super T>> components;
 
@@ -391,7 +380,7 @@ public final class Predicates {
   }
 
   /** @see Predicates#or(Iterable) */
-  private static class OrPredicate<T extends @Nullable Object>
+  private static class OrPredicate<T extends Object>
       implements Predicate<T>, Serializable {
     private final List<? extends Predicate<? super T>> components;
 
@@ -447,7 +436,7 @@ public final class Predicates {
   }
 
   /** @see Predicates#equalTo(Object) */
-  private static class IsEqualToPredicate implements Predicate<@Nullable Object>, Serializable {
+  private static class IsEqualToPredicate implements Predicate<Object>, Serializable {
     private final Object target;
 
     private IsEqualToPredicate(Object target) {
@@ -481,14 +470,14 @@ public final class Predicates {
     private static final long serialVersionUID = 0;
 
     @SuppressWarnings("unchecked") // safe contravariant cast
-    <T extends @Nullable Object> Predicate<T> withNarrowedType() {
+    <T extends Object> Predicate<T> withNarrowedType() {
       return (Predicate<T>) this;
     }
   }
 
   /** @see Predicates#instanceOf(Class) */
-  @GwtIncompatible // Class.isInstance
-  private static class InstanceOfPredicate<T extends @Nullable Object>
+  // Class.isInstance
+  private static class InstanceOfPredicate<T extends Object>
       implements Predicate<T>, Serializable {
     private final Class<?> clazz;
 
@@ -524,7 +513,7 @@ public final class Predicates {
   }
 
   /** @see Predicates#subtypeOf(Class) */
-  @GwtIncompatible // Class.isAssignableFrom
+  // Class.isAssignableFrom
   private static class SubtypeOfPredicate implements Predicate<Class<?>>, Serializable {
     private final Class<?> clazz;
 
@@ -560,7 +549,7 @@ public final class Predicates {
   }
 
   /** @see Predicates#in(Collection) */
-  private static class InPredicate<T extends @Nullable Object>
+  private static class InPredicate<T extends Object>
       implements Predicate<T>, Serializable {
     private final Collection<?> target;
 
@@ -600,7 +589,7 @@ public final class Predicates {
   }
 
   /** @see Predicates#compose(Predicate, Function) */
-  private static class CompositionPredicate<A extends @Nullable Object, B extends @Nullable Object>
+  private static class CompositionPredicate<A extends Object, B extends Object>
       implements Predicate<A>, Serializable {
     final Predicate<B> p;
     final Function<A, ? extends B> f;
@@ -639,7 +628,7 @@ public final class Predicates {
   }
 
   /** @see Predicates#contains(Pattern) */
-  @GwtIncompatible // Only used by other GWT-incompatible code.
+  // Only used by other GWT-incompatible code.
   private static class ContainsPatternPredicate implements Predicate<CharSequence>, Serializable {
     final CommonPattern pattern;
 
@@ -687,7 +676,7 @@ public final class Predicates {
   }
 
   /** @see Predicates#containsPattern(String) */
-  @GwtIncompatible // Only used by other GWT-incompatible code.
+  // Only used by other GWT-incompatible code.
   private static class ContainsPatternFromStringPredicate extends ContainsPatternPredicate {
 
     ContainsPatternFromStringPredicate(String string) {
@@ -702,7 +691,7 @@ public final class Predicates {
     private static final long serialVersionUID = 0;
   }
 
-  private static <T extends @Nullable Object> List<Predicate<? super T>> asList(
+  private static <T extends Object> List<Predicate<? super T>> asList(
       Predicate<? super T> first, Predicate<? super T> second) {
     // TODO(kevinb): understand why we still get a warning despite @SafeVarargs!
     return Arrays.<Predicate<? super T>>asList(first, second);
diff --git a/guava/src/com/google/common/base/Present.java b/guava/src/com/google/common/base/Present.java
index 59efebc102..35d951ec4d 100644
--- a/guava/src/com/google/common/base/Present.java
+++ b/guava/src/com/google/common/base/Present.java
@@ -16,13 +16,11 @@ package com.google.common.base;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.Collections;
 import java.util.Set;
 import javax.annotation.CheckForNull;
 
 /** Implementation of an {@link Optional} containing a reference. */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 final class Present<T> extends Optional<T> {
   private final T reference;
diff --git a/guava/src/com/google/common/base/SmallCharMatcher.java b/guava/src/com/google/common/base/SmallCharMatcher.java
index f0e801b671..7bc52b0455 100644
--- a/guava/src/com/google/common/base/SmallCharMatcher.java
+++ b/guava/src/com/google/common/base/SmallCharMatcher.java
@@ -14,8 +14,6 @@
 
 package com.google.common.base;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.CharMatcher.NamedFastMatcher;
 import java.util.BitSet;
 
@@ -25,7 +23,7 @@ import java.util.BitSet;
  *
  * @author Christopher Swenson
  */
-@GwtIncompatible // no precomputation is done in GWT
+// no precomputation is done in GWT
 @ElementTypesAreNonnullByDefault
 final class SmallCharMatcher extends NamedFastMatcher {
   static final int MAX_SIZE = 1023;
@@ -70,7 +68,6 @@ final class SmallCharMatcher extends NamedFastMatcher {
    * with linear probing in its implementation. The returned size is the smallest power of two that
    * can hold setSize elements with the desired load factor.
    */
-  @VisibleForTesting
   static int chooseTableSize(int setSize) {
     if (setSize == 1) {
       return 2;
diff --git a/guava/src/com/google/common/base/Splitter.java b/guava/src/com/google/common/base/Splitter.java
index e60e9887df..43ec5089c9 100644
--- a/guava/src/com/google/common/base/Splitter.java
+++ b/guava/src/com/google/common/base/Splitter.java
@@ -17,9 +17,6 @@ package com.google.common.base;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Iterator;
@@ -99,7 +96,6 @@ import javax.annotation.CheckForNull;
  * @author Louis Wasserman
  * @since 1.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class Splitter {
   private final CharMatcher trimmer;
@@ -214,7 +210,7 @@ public final class Splitter {
    * @return a splitter, with default settings, that uses this pattern
    * @throws IllegalArgumentException if {@code separatorPattern} matches the empty string
    */
-  @GwtIncompatible // java.util.regex
+  // java.util.regex
   public static Splitter on(Pattern separatorPattern) {
     return on(new JdkPattern(separatorPattern));
   }
@@ -257,7 +253,7 @@ public final class Splitter {
    * @throws IllegalArgumentException if {@code separatorPattern} matches the empty string or is a
    *     malformed expression
    */
-  @GwtIncompatible // java.util.regex
+  // java.util.regex
   public static Splitter onPattern(String separatorPattern) {
     return on(Platform.compilePattern(separatorPattern));
   }
@@ -434,7 +430,6 @@ public final class Splitter {
    * @return a stream over the segments split from the parameter
    * @since 28.2
    */
-  @Beta
   public Stream<String> splitToStream(CharSequence sequence) {
     // Can't use Streams.stream() from base
     return StreamSupport.stream(split(sequence).spliterator(), false);
@@ -446,7 +441,6 @@ public final class Splitter {
    *
    * @since 10.0
    */
-  @Beta
   public MapSplitter withKeyValueSeparator(String separator) {
     return withKeyValueSeparator(on(separator));
   }
@@ -457,7 +451,6 @@ public final class Splitter {
    *
    * @since 14.0
    */
-  @Beta
   public MapSplitter withKeyValueSeparator(char separator) {
     return withKeyValueSeparator(on(separator));
   }
@@ -481,7 +474,6 @@ public final class Splitter {
    *
    * @since 10.0
    */
-  @Beta
   public MapSplitter withKeyValueSeparator(Splitter keyValueSplitter) {
     return new MapSplitter(this, keyValueSplitter);
   }
@@ -494,7 +486,6 @@ public final class Splitter {
    *
    * @since 10.0
    */
-  @Beta
   public static final class MapSplitter {
     private static final String INVALID_ENTRY_MESSAGE = "Chunk [%s] is not a valid entry";
     private final Splitter outerSplitter;
diff --git a/guava/src/com/google/common/base/StandardSystemProperty.java b/guava/src/com/google/common/base/StandardSystemProperty.java
index dc29792de7..e4805004b8 100644
--- a/guava/src/com/google/common/base/StandardSystemProperty.java
+++ b/guava/src/com/google/common/base/StandardSystemProperty.java
@@ -14,7 +14,6 @@
 
 package com.google.common.base;
 
-import com.google.common.annotations.GwtIncompatible;
 import javax.annotation.CheckForNull;
 
 /**
@@ -23,7 +22,7 @@ import javax.annotation.CheckForNull;
  * @author Kurt Alfred Kluever
  * @since 15.0
  */
-@GwtIncompatible // java.lang.System#getProperty
+// java.lang.System#getProperty
 @ElementTypesAreNonnullByDefault
 public enum StandardSystemProperty {
 
diff --git a/guava/src/com/google/common/base/Stopwatch.java b/guava/src/com/google/common/base/Stopwatch.java
index 9d5282d24a..f590d13ed6 100644
--- a/guava/src/com/google/common/base/Stopwatch.java
+++ b/guava/src/com/google/common/base/Stopwatch.java
@@ -24,10 +24,6 @@ import static java.util.concurrent.TimeUnit.MINUTES;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.j2objc.annotations.J2ObjCIncompatible;
 import java.time.Duration;
 import java.util.concurrent.TimeUnit;
 
@@ -87,7 +83,6 @@ import java.util.concurrent.TimeUnit;
  * @author Kevin Bourrillion
  * @since 10.0
  */
-@GwtCompatible(emulated = true)
 @SuppressWarnings("GoodTime") // lots of violations
 @ElementTypesAreNonnullByDefault
 public final class Stopwatch {
@@ -154,7 +149,6 @@ public final class Stopwatch {
    * @return this {@code Stopwatch} instance
    * @throws IllegalStateException if the stopwatch is already running.
    */
-  @CanIgnoreReturnValue
   public Stopwatch start() {
     checkState(!isRunning, "This stopwatch is already running.");
     isRunning = true;
@@ -169,7 +163,6 @@ public final class Stopwatch {
    * @return this {@code Stopwatch} instance
    * @throws IllegalStateException if the stopwatch is already stopped.
    */
-  @CanIgnoreReturnValue
   public Stopwatch stop() {
     long tick = ticker.read();
     checkState(isRunning, "This stopwatch is already stopped.");
@@ -183,7 +176,6 @@ public final class Stopwatch {
    *
    * @return this {@code Stopwatch} instance
    */
-  @CanIgnoreReturnValue
   public Stopwatch reset() {
     elapsedNanos = 0;
     isRunning = false;
@@ -217,8 +209,6 @@ public final class Stopwatch {
    *
    * @since 22.0
    */
-  @GwtIncompatible
-  @J2ObjCIncompatible
   public Duration elapsed() {
     return Duration.ofNanos(elapsedNanos());
   }
diff --git a/guava/src/com/google/common/base/Strings.java b/guava/src/com/google/common/base/Strings.java
index e56bf1c481..35098b72d1 100644
--- a/guava/src/com/google/common/base/Strings.java
+++ b/guava/src/com/google/common/base/Strings.java
@@ -18,13 +18,8 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static java.util.logging.Level.WARNING;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.VisibleForTesting;
-import com.google.errorprone.annotations.InlineMe;
-import com.google.errorprone.annotations.InlineMeValidationDisabled;
 import java.util.logging.Logger;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to {@code String} or {@code CharSequence} instances.
@@ -32,7 +27,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kevin Bourrillion
  * @since 3.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class Strings {
   private Strings() {}
@@ -147,8 +141,6 @@ public final class Strings {
    *     {@code count} is zero)
    * @throws IllegalArgumentException if {@code count} is negative
    */
-  @InlineMe(replacement = "string.repeat(count)")
-  @InlineMeValidationDisabled("Java 11+ API only")
   public static String repeat(String string, int count) {
     checkNotNull(string); // eager for GWT.
 
@@ -224,7 +216,6 @@ public final class Strings {
    * True when a valid surrogate pair starts at the given {@code index} in the given {@code string}.
    * Out-of-range indexes return false.
    */
-  @VisibleForTesting
   static boolean validSurrogatePairAt(CharSequence string, int index) {
     return index >= 0
         && index <= (string.length() - 2)
@@ -266,7 +257,7 @@ public final class Strings {
    */
   // TODO(diamondm) consider using Arrays.toString() for array parameters
   public static String lenientFormat(
-      @CheckForNull String template, @CheckForNull @Nullable Object... args) {
+      @CheckForNull String template, @CheckForNull Object... args) {
     template = String.valueOf(template); // null -> "null"
 
     if (args == null) {
diff --git a/guava/src/com/google/common/base/Supplier.java b/guava/src/com/google/common/base/Supplier.java
index 08f96beccd..2e737b1020 100644
--- a/guava/src/com/google/common/base/Supplier.java
+++ b/guava/src/com/google/common/base/Supplier.java
@@ -14,9 +14,6 @@
 
 package com.google.common.base;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Legacy version of {@link java.util.function.Supplier java.util.function.Supplier}. Semantically,
@@ -36,17 +33,15 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Harry Heymann
  * @since 2.0
  */
-@GwtCompatible
 @FunctionalInterface
 @ElementTypesAreNonnullByDefault
-public interface Supplier<T extends @Nullable Object> extends java.util.function.Supplier<T> {
+public interface Supplier<T extends Object> extends java.util.function.Supplier<T> {
   /**
    * Retrieves an instance of the appropriate type. The returned object may or may not be a new
    * instance, depending on the implementation.
    *
    * @return an instance of the appropriate type
    */
-  @CanIgnoreReturnValue
   @Override
   @ParametricNullness
   T get();
diff --git a/guava/src/com/google/common/base/Suppliers.java b/guava/src/com/google/common/base/Suppliers.java
index 57d3486b27..05a80d3838 100644
--- a/guava/src/com/google/common/base/Suppliers.java
+++ b/guava/src/com/google/common/base/Suppliers.java
@@ -19,12 +19,9 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.VisibleForTesting;
 import java.io.Serializable;
 import java.util.concurrent.TimeUnit;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Useful suppliers.
@@ -35,7 +32,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Harry Heymann
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class Suppliers {
   private Suppliers() {}
@@ -46,12 +42,12 @@ public final class Suppliers {
    * and then applying {@code function} to that value. Note that the resulting supplier will not
    * call {@code supplier} or invoke {@code function} until it is called.
    */
-  public static <F extends @Nullable Object, T extends @Nullable Object> Supplier<T> compose(
+  public static <F extends Object, T extends Object> Supplier<T> compose(
       Function<? super F, T> function, Supplier<F> supplier) {
     return new SupplierComposition<>(function, supplier);
   }
 
-  private static class SupplierComposition<F extends @Nullable Object, T extends @Nullable Object>
+  private static class SupplierComposition<F extends Object, T extends Object>
       implements Supplier<T>, Serializable {
     final Function<? super F, T> function;
     final Supplier<F> supplier;
@@ -105,7 +101,7 @@ public final class Suppliers {
    * <p>If {@code delegate} is an instance created by an earlier call to {@code memoize}, it is
    * returned directly.
    */
-  public static <T extends @Nullable Object> Supplier<T> memoize(Supplier<T> delegate) {
+  public static <T extends Object> Supplier<T> memoize(Supplier<T> delegate) {
     if (delegate instanceof NonSerializableMemoizingSupplier
         || delegate instanceof MemoizingSupplier) {
       return delegate;
@@ -115,8 +111,7 @@ public final class Suppliers {
         : new NonSerializableMemoizingSupplier<T>(delegate);
   }
 
-  @VisibleForTesting
-  static class MemoizingSupplier<T extends @Nullable Object> implements Supplier<T>, Serializable {
+  static class MemoizingSupplier<T extends Object> implements Supplier<T>, Serializable {
     final Supplier<T> delegate;
     transient volatile boolean initialized;
     // "value" does not need to be volatile; visibility piggy-backs
@@ -155,8 +150,7 @@ public final class Suppliers {
     private static final long serialVersionUID = 0;
   }
 
-  @VisibleForTesting
-  static class NonSerializableMemoizingSupplier<T extends @Nullable Object> implements Supplier<T> {
+  static class NonSerializableMemoizingSupplier<T extends Object> implements Supplier<T> {
     @CheckForNull volatile Supplier<T> delegate;
     volatile boolean initialized;
     // "value" does not need to be volatile; visibility piggy-backs
@@ -224,14 +218,13 @@ public final class Suppliers {
    * @since 2.0
    */
   @SuppressWarnings("GoodTime") // should accept a java.time.Duration
-  public static <T extends @Nullable Object> Supplier<T> memoizeWithExpiration(
+  public static <T extends Object> Supplier<T> memoizeWithExpiration(
       Supplier<T> delegate, long duration, TimeUnit unit) {
     return new ExpiringMemoizingSupplier<T>(delegate, duration, unit);
   }
 
-  @VisibleForTesting
   @SuppressWarnings("GoodTime") // lots of violations
-  static class ExpiringMemoizingSupplier<T extends @Nullable Object>
+  static class ExpiringMemoizingSupplier<T extends Object>
       implements Supplier<T>, Serializable {
     final Supplier<T> delegate;
     final long durationNanos;
@@ -284,12 +277,12 @@ public final class Suppliers {
   }
 
   /** Returns a supplier that always supplies {@code instance}. */
-  public static <T extends @Nullable Object> Supplier<T> ofInstance(
+  public static <T extends Object> Supplier<T> ofInstance(
       @ParametricNullness T instance) {
     return new SupplierOfInstance<T>(instance);
   }
 
-  private static class SupplierOfInstance<T extends @Nullable Object>
+  private static class SupplierOfInstance<T extends Object>
       implements Supplier<T>, Serializable {
     @ParametricNullness final T instance;
 
@@ -329,12 +322,12 @@ public final class Suppliers {
    * Returns a supplier whose {@code get()} method synchronizes on {@code delegate} before calling
    * it, making it thread-safe.
    */
-  public static <T extends @Nullable Object> Supplier<T> synchronizedSupplier(
+  public static <T extends Object> Supplier<T> synchronizedSupplier(
       Supplier<T> delegate) {
     return new ThreadSafeSupplier<T>(delegate);
   }
 
-  private static class ThreadSafeSupplier<T extends @Nullable Object>
+  private static class ThreadSafeSupplier<T extends Object>
       implements Supplier<T>, Serializable {
     final Supplier<T> delegate;
 
@@ -366,21 +359,21 @@ public final class Suppliers {
    *
    * @since 8.0
    */
-  public static <T extends @Nullable Object> Function<Supplier<T>, T> supplierFunction() {
+  public static <T extends Object> Function<Supplier<T>, T> supplierFunction() {
     @SuppressWarnings("unchecked") // implementation is "fully variant"
     SupplierFunction<T> sf = (SupplierFunction<T>) SupplierFunctionImpl.INSTANCE;
     return sf;
   }
 
-  private interface SupplierFunction<T extends @Nullable Object> extends Function<Supplier<T>, T> {}
+  private interface SupplierFunction<T extends Object> extends Function<Supplier<T>, T> {}
 
-  private enum SupplierFunctionImpl implements SupplierFunction<@Nullable Object> {
+  private enum SupplierFunctionImpl implements SupplierFunction<Object> {
     INSTANCE;
 
     // Note: This makes T a "pass-through type"
     @Override
     @CheckForNull
-    public Object apply(Supplier<@Nullable Object> input) {
+    public Object apply(Supplier<Object> input) {
       return input.get();
     }
 
diff --git a/guava/src/com/google/common/base/Throwables.java b/guava/src/com/google/common/base/Throwables.java
index 7832d186ad..b168e938f9 100644
--- a/guava/src/com/google/common/base/Throwables.java
+++ b/guava/src/com/google/common/base/Throwables.java
@@ -19,11 +19,6 @@ import static java.util.Arrays.asList;
 import static java.util.Collections.unmodifiableList;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StringWriter;
@@ -45,7 +40,6 @@ import javax.annotation.CheckForNull;
  * @author Ben Yu
  * @since 1.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class Throwables {
   private Throwables() {}
@@ -70,7 +64,7 @@ public final class Throwables {
    *
    * @since 20.0
    */
-  @GwtIncompatible // Class.cast, Class.isInstance
+  // Class.cast, Class.isInstance
   public static <X extends Throwable> void throwIfInstanceOf(
       Throwable throwable, Class<X> declaredType) throws X {
     checkNotNull(throwable);
@@ -99,7 +93,7 @@ public final class Throwables {
    *     null}.
    */
   @Deprecated
-  @GwtIncompatible // throwIfInstanceOf
+  // throwIfInstanceOf
   public static <X extends Throwable> void propagateIfInstanceOf(
       @CheckForNull Throwable throwable, Class<X> declaredType) throws X {
     if (throwable != null) {
@@ -155,7 +149,6 @@ public final class Throwables {
    *     null}.
    */
   @Deprecated
-  @GwtIncompatible
   public static void propagateIfPossible(@CheckForNull Throwable throwable) {
     if (throwable != null) {
       throwIfUnchecked(throwable);
@@ -180,7 +173,7 @@ public final class Throwables {
    * @param throwable the Throwable to possibly propagate
    * @param declaredType the single checked exception type declared by the calling method
    */
-  @GwtIncompatible // propagateIfInstanceOf
+  // propagateIfInstanceOf
   public static <X extends Throwable> void propagateIfPossible(
       @CheckForNull Throwable throwable, Class<X> declaredType) throws X {
     propagateIfInstanceOf(throwable, declaredType);
@@ -198,7 +191,7 @@ public final class Throwables {
    * @param declaredType1 any checked exception type declared by the calling method
    * @param declaredType2 any other checked exception type declared by the calling method
    */
-  @GwtIncompatible // propagateIfInstanceOf
+  // propagateIfInstanceOf
   public static <X1 extends Throwable, X2 extends Throwable> void propagateIfPossible(
       @CheckForNull Throwable throwable, Class<X1> declaredType1, Class<X2> declaredType2)
       throws X1, X2 {
@@ -235,8 +228,6 @@ public final class Throwables {
    *     background on the deprecation, read <a href="https://goo.gl/Ivn2kc">Why we deprecated
    *     {@code Throwables.propagate}</a>.
    */
-  @CanIgnoreReturnValue
-  @GwtIncompatible
   @Deprecated
   public static RuntimeException propagate(Throwable throwable) {
     throwIfUnchecked(throwable);
@@ -290,7 +281,7 @@ public final class Throwables {
    * @return an unmodifiable list containing the cause chain starting with {@code throwable}
    * @throws IllegalArgumentException if there is a loop in the causal chain
    */
-  @Beta // TODO(kevinb): decide best return type
+  // TODO(kevinb): decide best return type
   public static List<Throwable> getCausalChain(Throwable throwable) {
     checkNotNull(throwable);
     List<Throwable> causes = new ArrayList<>(4);
@@ -330,8 +321,7 @@ public final class Throwables {
    *     ClassCastException}'s cause is {@code throwable}.
    * @since 22.0
    */
-  @Beta
-  @GwtIncompatible // Class.cast(Object)
+  // Class.cast(Object)
   @CheckForNull
   public static <X extends Throwable> X getCauseAs(
       Throwable throwable, Class<X> expectedCauseType) {
@@ -349,7 +339,7 @@ public final class Throwables {
    * parsing the resulting string; if you need programmatic access to the stack frames, you can call
    * {@link Throwable#getStackTrace()}.
    */
-  @GwtIncompatible // java.io.PrintWriter, java.io.StringWriter
+  // java.io.PrintWriter, java.io.StringWriter
   public static String getStackTraceAsString(Throwable throwable) {
     StringWriter stringWriter = new StringWriter();
     throwable.printStackTrace(new PrintWriter(stringWriter));
@@ -384,8 +374,7 @@ public final class Throwables {
    * @since 19.0
    */
   // TODO(cpovirk): Say something about the possibility that List access could fail at runtime?
-  @Beta
-  @GwtIncompatible // lazyStackTraceIsLazy, jlaStackTrace
+  // lazyStackTraceIsLazy, jlaStackTrace
   // TODO(cpovirk): Consider making this available under GWT (slow implementation only).
   public static List<StackTraceElement> lazyStackTrace(Throwable throwable) {
     return lazyStackTraceIsLazy()
@@ -399,13 +388,12 @@ public final class Throwables {
    *
    * @since 19.0
    */
-  @Beta
-  @GwtIncompatible // getStackTraceElementMethod
+  // getStackTraceElementMethod
   public static boolean lazyStackTraceIsLazy() {
     return getStackTraceElementMethod != null && getStackTraceDepthMethod != null;
   }
 
-  @GwtIncompatible // invokeAccessibleNonThrowingMethod
+  // invokeAccessibleNonThrowingMethod
   private static List<StackTraceElement> jlaStackTrace(final Throwable t) {
     checkNotNull(t);
     /*
@@ -435,7 +423,7 @@ public final class Throwables {
     };
   }
 
-  @GwtIncompatible // java.lang.reflect
+  // java.lang.reflect
   private static Object invokeAccessibleNonThrowingMethod(
       Method method, Object receiver, Object... params) {
     try {
@@ -448,16 +436,15 @@ public final class Throwables {
   }
 
   /** JavaLangAccess class name to load using reflection */
-  @GwtIncompatible // not used by GWT emulation
+  // not used by GWT emulation
   private static final String JAVA_LANG_ACCESS_CLASSNAME = "sun.misc.JavaLangAccess";
 
   /** SharedSecrets class name to load using reflection */
-  @GwtIncompatible // not used by GWT emulation
-  @VisibleForTesting
+  // not used by GWT emulation
   static final String SHARED_SECRETS_CLASSNAME = "sun.misc.SharedSecrets";
 
   /** Access to some fancy internal JVM internals. */
-  @GwtIncompatible // java.lang.reflect
+  // java.lang.reflect
   @CheckForNull
   private static final Object jla = getJLA();
 
@@ -465,7 +452,7 @@ public final class Throwables {
    * The "getStackTraceElementMethod" method, only available on some JDKs so we use reflection to
    * find it when available. When this is null, use the slow way.
    */
-  @GwtIncompatible // java.lang.reflect
+  // java.lang.reflect
   @CheckForNull
   private static final Method getStackTraceElementMethod = (jla == null) ? null : getGetMethod();
 
@@ -473,7 +460,7 @@ public final class Throwables {
    * The "getStackTraceDepth" method, only available on some JDKs so we use reflection to find it
    * when available. When this is null, use the slow way.
    */
-  @GwtIncompatible // java.lang.reflect
+  // java.lang.reflect
   @CheckForNull
   private static final Method getStackTraceDepthMethod = (jla == null) ? null : getSizeMethod(jla);
 
@@ -481,7 +468,7 @@ public final class Throwables {
    * Returns the JavaLangAccess class that is present in all Sun JDKs. It is not allowed in
    * AppEngine, and not present in non-Sun JDKs.
    */
-  @GwtIncompatible // java.lang.reflect
+  // java.lang.reflect
   @CheckForNull
   private static Object getJLA() {
     try {
@@ -507,7 +494,7 @@ public final class Throwables {
    * Returns the Method that can be used to resolve an individual StackTraceElement, or null if that
    * method cannot be found (it is only to be found in fairly recent JDKs).
    */
-  @GwtIncompatible // java.lang.reflect
+  // java.lang.reflect
   @CheckForNull
   private static Method getGetMethod() {
     return getJlaMethod("getStackTraceElement", Throwable.class, int.class);
@@ -522,7 +509,7 @@ public final class Throwables {
    * <p>See <a href="https://github.com/google/guava/issues/2887">Throwables#lazyStackTrace throws
    * UnsupportedOperationException</a>.
    */
-  @GwtIncompatible // java.lang.reflect
+  // java.lang.reflect
   @CheckForNull
   private static Method getSizeMethod(Object jla) {
     try {
@@ -537,7 +524,7 @@ public final class Throwables {
     }
   }
 
-  @GwtIncompatible // java.lang.reflect
+  // java.lang.reflect
   @CheckForNull
   private static Method getJlaMethod(String name, Class<?>... parameterTypes) throws ThreadDeath {
     try {
diff --git a/guava/src/com/google/common/base/Ticker.java b/guava/src/com/google/common/base/Ticker.java
index d898735c02..4a7d6f8049 100644
--- a/guava/src/com/google/common/base/Ticker.java
+++ b/guava/src/com/google/common/base/Ticker.java
@@ -14,7 +14,6 @@
 
 package com.google.common.base;
 
-import com.google.common.annotations.GwtCompatible;
 
 /**
  * A time source; returns a time value representing the number of nanoseconds elapsed since some
@@ -27,7 +26,6 @@ import com.google.common.annotations.GwtCompatible;
  * @since 10.0 (<a href="https://github.com/google/guava/wiki/Compatibility">mostly
  *     source-compatible</a> since 9.0)
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public abstract class Ticker {
   /** Constructor for use by subclasses. */
diff --git a/guava/src/com/google/common/base/Utf8.java b/guava/src/com/google/common/base/Utf8.java
index bb945a35f0..8851b0ea29 100644
--- a/guava/src/com/google/common/base/Utf8.java
+++ b/guava/src/com/google/common/base/Utf8.java
@@ -18,8 +18,6 @@ import static com.google.common.base.Preconditions.checkPositionIndexes;
 import static java.lang.Character.MAX_SURROGATE;
 import static java.lang.Character.MIN_SURROGATE;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 
 /**
  * Low-level, high-performance utility methods related to the {@linkplain Charsets#UTF_8 UTF-8}
@@ -36,8 +34,6 @@ import com.google.common.annotations.GwtCompatible;
  * @author Clément Roux
  * @since 16.0
  */
-@Beta
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class Utf8 {
   /**
diff --git a/guava/src/com/google/common/base/Verify.java b/guava/src/com/google/common/base/Verify.java
index b2e9f5f04f..08a90462cb 100644
--- a/guava/src/com/google/common/base/Verify.java
+++ b/guava/src/com/google/common/base/Verify.java
@@ -16,10 +16,7 @@ package com.google.common.base;
 
 import static com.google.common.base.Strings.lenientFormat;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static convenience methods that serve the same purpose as Java language <a
@@ -87,7 +84,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @since 17.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class Verify {
   /**
@@ -121,7 +117,7 @@ public final class Verify {
   public static void verify(
       boolean expression,
       String errorMessageTemplate,
-      @CheckForNull @Nullable Object... errorMessageArgs) {
+      @CheckForNull Object... errorMessageArgs) {
     if (!expression) {
       throw new VerifyException(lenientFormat(errorMessageTemplate, errorMessageArgs));
     }
@@ -474,7 +470,6 @@ public final class Verify {
    * @throws VerifyException if {@code reference} is {@code null}
    * @see Preconditions#checkNotNull Preconditions.checkNotNull()
    */
-  @CanIgnoreReturnValue
   public static <T> T verifyNotNull(@CheckForNull T reference) {
     return verifyNotNull(reference, "expected a non-null reference");
   }
@@ -494,11 +489,10 @@ public final class Verify {
    * @throws VerifyException if {@code reference} is {@code null}
    * @see Preconditions#checkNotNull Preconditions.checkNotNull()
    */
-  @CanIgnoreReturnValue
   public static <T> T verifyNotNull(
       @CheckForNull T reference,
       String errorMessageTemplate,
-      @CheckForNull @Nullable Object... errorMessageArgs) {
+      @CheckForNull Object... errorMessageArgs) {
     if (reference == null) {
       throw new VerifyException(lenientFormat(errorMessageTemplate, errorMessageArgs));
     }
diff --git a/guava/src/com/google/common/base/VerifyException.java b/guava/src/com/google/common/base/VerifyException.java
index 10b99dee72..f1cb7ca8ca 100644
--- a/guava/src/com/google/common/base/VerifyException.java
+++ b/guava/src/com/google/common/base/VerifyException.java
@@ -14,7 +14,6 @@
 
 package com.google.common.base;
 
-import com.google.common.annotations.GwtCompatible;
 import javax.annotation.CheckForNull;
 
 /**
@@ -24,7 +23,6 @@ import javax.annotation.CheckForNull;
  *
  * @since 17.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public class VerifyException extends RuntimeException {
   /** Constructs a {@code VerifyException} with no message. */
diff --git a/guava/src/com/google/common/base/internal/Finalizer.java b/guava/src/com/google/common/base/internal/Finalizer.java
index 75d0d72f6e..d1e706a3b0 100644
--- a/guava/src/com/google/common/base/internal/Finalizer.java
+++ b/guava/src/com/google/common/base/internal/Finalizer.java
@@ -23,7 +23,6 @@ import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Thread that finalizes referents. All references should implement {@code
@@ -116,10 +115,10 @@ public class Finalizer implements Runnable {
   // By preference, we will use the Thread constructor that has an `inheritThreadLocals` parameter.
   // But before Java 9, our only way not to inherit ThreadLocals is to zap them after the thread
   // is created, by accessing a private field.
-  private static final @Nullable Constructor<Thread> bigThreadConstructor =
+  private static final Constructor<Thread> bigThreadConstructor =
       getBigThreadConstructor();
 
-  private static final @Nullable Field inheritableThreadLocals =
+  private static final Field inheritableThreadLocals =
       (bigThreadConstructor == null) ? getInheritableThreadLocalsField() : null;
 
   /** Constructs a new finalizer thread. */
@@ -191,7 +190,7 @@ public class Finalizer implements Runnable {
   }
 
   /** Looks up FinalizableReference.finalizeReferent() method. */
-  private @Nullable Method getFinalizeReferentMethod() {
+  private Method getFinalizeReferentMethod() {
     Class<?> finalizableReferenceClass = finalizableReferenceClassReference.get();
     if (finalizableReferenceClass == null) {
       /*
@@ -209,7 +208,7 @@ public class Finalizer implements Runnable {
     }
   }
 
-  private static @Nullable Field getInheritableThreadLocalsField() {
+  private static Field getInheritableThreadLocalsField() {
     try {
       Field inheritableThreadLocals = Thread.class.getDeclaredField("inheritableThreadLocals");
       inheritableThreadLocals.setAccessible(true);
@@ -223,7 +222,7 @@ public class Finalizer implements Runnable {
     }
   }
 
-  private static @Nullable Constructor<Thread> getBigThreadConstructor() {
+  private static Constructor<Thread> getBigThreadConstructor() {
     try {
       return Thread.class.getConstructor(
           ThreadGroup.class, Runnable.class, String.class, long.class, boolean.class);
diff --git a/guava/src/com/google/common/base/package-info.java b/guava/src/com/google/common/base/package-info.java
index f2218562e8..f4e7d6a4ad 100644
--- a/guava/src/com/google/common/base/package-info.java
+++ b/guava/src/com/google/common/base/package-info.java
@@ -55,9 +55,7 @@
  * </ul>
  *
  */
-@CheckReturnValue
 @ParametersAreNonnullByDefault
 package com.google.common.base;
 
-import com.google.errorprone.annotations.CheckReturnValue;
 import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/guava/src/com/google/common/cache/AbstractCache.java b/guava/src/com/google/common/cache/AbstractCache.java
index eec5fdc34f..55c3a20150 100644
--- a/guava/src/com/google/common/cache/AbstractCache.java
+++ b/guava/src/com/google/common/cache/AbstractCache.java
@@ -14,7 +14,6 @@
 
 package com.google.common.cache;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Maps;
 import java.util.Map;
@@ -37,7 +36,6 @@ import java.util.concurrent.ExecutionException;
  * @author Charles Fry
  * @since 10.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public abstract class AbstractCache<K, V> implements Cache<K, V> {
 
diff --git a/guava/src/com/google/common/cache/AbstractLoadingCache.java b/guava/src/com/google/common/cache/AbstractLoadingCache.java
index 489597c518..45dda91ec0 100644
--- a/guava/src/com/google/common/cache/AbstractLoadingCache.java
+++ b/guava/src/com/google/common/cache/AbstractLoadingCache.java
@@ -14,7 +14,6 @@
 
 package com.google.common.cache;
 
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Maps;
 import com.google.common.util.concurrent.UncheckedExecutionException;
@@ -37,7 +36,6 @@ import java.util.concurrent.ExecutionException;
  * @author Charles Fry
  * @since 11.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public abstract class AbstractLoadingCache<K, V> extends AbstractCache<K, V>
     implements LoadingCache<K, V> {
diff --git a/guava/src/com/google/common/cache/Cache.java b/guava/src/com/google/common/cache/Cache.java
index 8755595a07..7a227ab522 100644
--- a/guava/src/com/google/common/cache/Cache.java
+++ b/guava/src/com/google/common/cache/Cache.java
@@ -14,13 +14,9 @@
 
 package com.google.common.cache;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.util.concurrent.ExecutionError;
 import com.google.common.util.concurrent.UncheckedExecutionException;
-import com.google.errorprone.annotations.CheckReturnValue;
-import com.google.errorprone.annotations.CompatibleWith;
-import com.google.errorprone.annotations.DoNotMock;
 import java.util.Map;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ConcurrentMap;
@@ -40,8 +36,6 @@ import javax.annotation.CheckForNull;
  * @author Charles Fry
  * @since 10.0
  */
-@DoNotMock("Use CacheBuilder.newBuilder().build()")
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public interface Cache<K, V> {
 
@@ -52,7 +46,7 @@ public interface Cache<K, V> {
    * @since 11.0
    */
   @CheckForNull
-  V getIfPresent(@CompatibleWith("K") Object key);
+  V getIfPresent(Object key);
 
   /**
    * Returns the value associated with {@code key} in this cache, obtaining that value from {@code
@@ -136,7 +130,7 @@ public interface Cache<K, V> {
   void putAll(Map<? extends K, ? extends V> m);
 
   /** Discards any cached value for key {@code key}. */
-  void invalidate(@CompatibleWith("K") Object key);
+  void invalidate(Object key);
 
   /**
    * Discards any cached values for keys {@code keys}.
@@ -150,7 +144,6 @@ public interface Cache<K, V> {
   void invalidateAll();
 
   /** Returns the approximate number of entries in this cache. */
-  @CheckReturnValue
   long size();
 
   /**
@@ -164,7 +157,6 @@ public interface Cache<K, V> {
    * all values is returned.
    *
    */
-  @CheckReturnValue
   CacheStats stats();
 
   /**
@@ -175,7 +167,6 @@ public interface Cache<K, V> {
    * concurrent use, but if the cache is modified (including by eviction) after the iterator is
    * created, it is undefined which of the changes (if any) will be reflected in that iterator.
    */
-  @CheckReturnValue
   ConcurrentMap<K, V> asMap();
 
   /**
diff --git a/guava/src/com/google/common/cache/CacheBuilder.java b/guava/src/com/google/common/cache/CacheBuilder.java
index 3537bab531..d37493422d 100644
--- a/guava/src/com/google/common/cache/CacheBuilder.java
+++ b/guava/src/com/google/common/cache/CacheBuilder.java
@@ -18,8 +18,6 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Ascii;
 import com.google.common.base.Equivalence;
 import com.google.common.base.MoreObjects;
@@ -29,8 +27,6 @@ import com.google.common.base.Ticker;
 import com.google.common.cache.AbstractCache.SimpleStatsCounter;
 import com.google.common.cache.AbstractCache.StatsCounter;
 import com.google.common.cache.LocalCache.Strength;
-import com.google.errorprone.annotations.CheckReturnValue;
-import com.google.j2objc.annotations.J2ObjCIncompatible;
 import java.util.ConcurrentModificationException;
 import java.util.IdentityHashMap;
 import java.util.Map;
@@ -38,7 +34,6 @@ import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.TimeUnit;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A builder of {@link LoadingCache} and {@link Cache} instances.
@@ -189,7 +184,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kevin Bourrillion
  * @since 10.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class CacheBuilder<K, V> {
   private static final int DEFAULT_INITIAL_CAPACITY = 16;
@@ -270,10 +264,10 @@ public final class CacheBuilder<K, V> {
   int concurrencyLevel = UNSET_INT;
   long maximumSize = UNSET_INT;
   long maximumWeight = UNSET_INT;
-  @Nullable Weigher<? super K, ? super V> weigher;
+  Weigher<? super K, ? super V> weigher;
 
-  @Nullable Strength keyStrength;
-  @Nullable Strength valueStrength;
+  Strength keyStrength;
+  Strength valueStrength;
 
   @SuppressWarnings("GoodTime") // should be a java.time.Duration
   long expireAfterWriteNanos = UNSET_INT;
@@ -284,11 +278,11 @@ public final class CacheBuilder<K, V> {
   @SuppressWarnings("GoodTime") // should be a java.time.Duration
   long refreshNanos = UNSET_INT;
 
-  @Nullable Equivalence<Object> keyEquivalence;
-  @Nullable Equivalence<Object> valueEquivalence;
+  Equivalence<Object> keyEquivalence;
+  Equivalence<Object> valueEquivalence;
 
-  @Nullable RemovalListener<? super K, ? super V> removalListener;
-  @Nullable Ticker ticker;
+  RemovalListener<? super K, ? super V> removalListener;
+  Ticker ticker;
 
   Supplier<? extends StatsCounter> statsCounterSupplier = NULL_STATS_COUNTER;
 
@@ -301,7 +295,6 @@ public final class CacheBuilder<K, V> {
    * <p>Note that while this return type is {@code CacheBuilder<Object, Object>}, type parameters on
    * the {@link #build} methods allow you to create a cache of any key and value type desired.
    */
-  @CheckReturnValue
   public static CacheBuilder<Object, Object> newBuilder() {
     return new CacheBuilder<>();
   }
@@ -311,8 +304,7 @@ public final class CacheBuilder<K, V> {
    *
    * @since 12.0
    */
-  @GwtIncompatible // To be supported
-  @CheckReturnValue
+  // To be supported
   public static CacheBuilder<Object, Object> from(CacheBuilderSpec spec) {
     return spec.toCacheBuilder().lenientParsing();
   }
@@ -324,8 +316,7 @@ public final class CacheBuilder<K, V> {
    * @param spec a String in the format specified by {@link CacheBuilderSpec}
    * @since 12.0
    */
-  @GwtIncompatible // To be supported
-  @CheckReturnValue
+  // To be supported
   public static CacheBuilder<Object, Object> from(String spec) {
     return from(CacheBuilderSpec.parse(spec));
   }
@@ -335,7 +326,7 @@ public final class CacheBuilder<K, V> {
    *
    * @return this {@code CacheBuilder} instance (for chaining)
    */
-  @GwtIncompatible // To be supported
+  // To be supported
   CacheBuilder<K, V> lenientParsing() {
     strictParsing = false;
     return this;
@@ -349,7 +340,7 @@ public final class CacheBuilder<K, V> {
    *
    * @return this {@code CacheBuilder} instance (for chaining)
    */
-  @GwtIncompatible // To be supported
+  // To be supported
   CacheBuilder<K, V> keyEquivalence(Equivalence<Object> equivalence) {
     checkState(keyEquivalence == null, "key equivalence was already set to %s", keyEquivalence);
     keyEquivalence = checkNotNull(equivalence);
@@ -369,7 +360,7 @@ public final class CacheBuilder<K, V> {
    *
    * @return this {@code CacheBuilder} instance (for chaining)
    */
-  @GwtIncompatible // To be supported
+  // To be supported
   CacheBuilder<K, V> valueEquivalence(Equivalence<Object> equivalence) {
     checkState(
         valueEquivalence == null, "value equivalence was already set to %s", valueEquivalence);
@@ -512,7 +503,7 @@ public final class CacheBuilder<K, V> {
    * @throws IllegalStateException if a maximum weight or size was already set
    * @since 11.0
    */
-  @GwtIncompatible // To be supported
+  // To be supported
   public CacheBuilder<K, V> maximumWeight(long maximumWeight) {
     checkState(
         this.maximumWeight == UNSET_INT,
@@ -554,7 +545,7 @@ public final class CacheBuilder<K, V> {
    * @throws IllegalStateException if a maximum size was already set
    * @since 11.0
    */
-  @GwtIncompatible // To be supported
+  // To be supported
   public <K1 extends K, V1 extends V> CacheBuilder<K1, V1> weigher(
       Weigher<? super K1, ? super V1> weigher) {
     checkState(this.weigher == null);
@@ -601,7 +592,7 @@ public final class CacheBuilder<K, V> {
    * @return this {@code CacheBuilder} instance (for chaining)
    * @throws IllegalStateException if the key strength was already set
    */
-  @GwtIncompatible // java.lang.ref.WeakReference
+  // java.lang.ref.WeakReference
   public CacheBuilder<K, V> weakKeys() {
     return setKeyStrength(Strength.WEAK);
   }
@@ -633,7 +624,7 @@ public final class CacheBuilder<K, V> {
    * @return this {@code CacheBuilder} instance (for chaining)
    * @throws IllegalStateException if the value strength was already set
    */
-  @GwtIncompatible // java.lang.ref.WeakReference
+  // java.lang.ref.WeakReference
   public CacheBuilder<K, V> weakValues() {
     return setValueStrength(Strength.WEAK);
   }
@@ -658,7 +649,7 @@ public final class CacheBuilder<K, V> {
    * @return this {@code CacheBuilder} instance (for chaining)
    * @throws IllegalStateException if the value strength was already set
    */
-  @GwtIncompatible // java.lang.ref.SoftReference
+  // java.lang.ref.SoftReference
   public CacheBuilder<K, V> softValues() {
     return setValueStrength(Strength.SOFT);
   }
@@ -693,8 +684,7 @@ public final class CacheBuilder<K, V> {
    * @throws ArithmeticException for durations greater than +/- approximately 292 years
    * @since 25.0
    */
-  @J2ObjCIncompatible
-  @GwtIncompatible // java.time.Duration
+  // java.time.Duration
   @SuppressWarnings("GoodTime") // java.time.Duration decomposition
   public CacheBuilder<K, V> expireAfterWrite(java.time.Duration duration) {
     return expireAfterWrite(toNanosSaturated(duration), TimeUnit.NANOSECONDS);
@@ -763,8 +753,7 @@ public final class CacheBuilder<K, V> {
    * @throws ArithmeticException for durations greater than +/- approximately 292 years
    * @since 25.0
    */
-  @J2ObjCIncompatible
-  @GwtIncompatible // java.time.Duration
+  // java.time.Duration
   @SuppressWarnings("GoodTime") // java.time.Duration decomposition
   public CacheBuilder<K, V> expireAfterAccess(java.time.Duration duration) {
     return expireAfterAccess(toNanosSaturated(duration), TimeUnit.NANOSECONDS);
@@ -842,8 +831,7 @@ public final class CacheBuilder<K, V> {
    * @throws ArithmeticException for durations greater than +/- approximately 292 years
    * @since 25.0
    */
-  @J2ObjCIncompatible
-  @GwtIncompatible // java.time.Duration
+  // java.time.Duration
   @SuppressWarnings("GoodTime") // java.time.Duration decomposition
   public CacheBuilder<K, V> refreshAfterWrite(java.time.Duration duration) {
     return refreshAfterWrite(toNanosSaturated(duration), TimeUnit.NANOSECONDS);
@@ -879,7 +867,7 @@ public final class CacheBuilder<K, V> {
    * @throws IllegalStateException if {@link #refreshAfterWrite} was already set
    * @since 11.0
    */
-  @GwtIncompatible // To be supported (synchronously).
+  // To be supported (synchronously).
   @SuppressWarnings("GoodTime") // should accept a java.time.Duration
   public CacheBuilder<K, V> refreshAfterWrite(long duration, TimeUnit unit) {
     checkNotNull(unit);
@@ -938,7 +926,6 @@ public final class CacheBuilder<K, V> {
    * @return this {@code CacheBuilder} instance (for chaining)
    * @throws IllegalStateException if a removal listener was already set
    */
-  @CheckReturnValue
   public <K1 extends K, V1 extends V> CacheBuilder<K1, V1> removalListener(
       RemovalListener<? super K1, ? super V1> listener) {
     checkState(this.removalListener == null);
@@ -991,7 +978,6 @@ public final class CacheBuilder<K, V> {
    * @param loader the cache loader used to obtain new values
    * @return a cache having the requested features
    */
-  @CheckReturnValue
   public <K1 extends K, V1 extends V> LoadingCache<K1, V1> build(
       CacheLoader<? super K1, V1> loader) {
     checkWeightWithWeigher();
@@ -1010,7 +996,6 @@ public final class CacheBuilder<K, V> {
    * @return a cache having the requested features
    * @since 11.0
    */
-  @CheckReturnValue
   public <K1 extends K, V1 extends V> Cache<K1, V1> build() {
     checkWeightWithWeigher();
     checkNonLoadingCache();
@@ -1085,7 +1070,7 @@ public final class CacheBuilder<K, V> {
    * {@link Long#MAX_VALUE} or {@link Long#MIN_VALUE}. This behavior can be useful when decomposing
    * a duration in order to call a legacy API which requires a {@code long, TimeUnit} pair.
    */
-  @GwtIncompatible // java.time.Duration
+  // java.time.Duration
   @SuppressWarnings("GoodTime") // duration decomposition
   private static long toNanosSaturated(java.time.Duration duration) {
     // Using a try/catch seems lazy, but the catch block will rarely get invoked (except for
diff --git a/guava/src/com/google/common/cache/CacheBuilderSpec.java b/guava/src/com/google/common/cache/CacheBuilderSpec.java
index 64b5ad2619..f9914a072c 100644
--- a/guava/src/com/google/common/cache/CacheBuilderSpec.java
+++ b/guava/src/com/google/common/cache/CacheBuilderSpec.java
@@ -17,8 +17,6 @@ package com.google.common.cache;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Strings.isNullOrEmpty;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Objects;
 import com.google.common.base.Splitter;
@@ -29,7 +27,6 @@ import java.util.List;
 import java.util.Locale;
 import java.util.concurrent.TimeUnit;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A specification of a {@link CacheBuilder} configuration.
@@ -79,7 +76,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @since 12.0
  */
 @SuppressWarnings("GoodTime") // lots of violations (nanosecond math)
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class CacheBuilderSpec {
   /** Parses a single value. */
@@ -110,19 +106,19 @@ public final class CacheBuilderSpec {
           .put("refreshInterval", new RefreshDurationParser())
           .build();
 
-  @VisibleForTesting @CheckForNull Integer initialCapacity;
-  @VisibleForTesting @CheckForNull Long maximumSize;
-  @VisibleForTesting @CheckForNull Long maximumWeight;
-  @VisibleForTesting @CheckForNull Integer concurrencyLevel;
-  @VisibleForTesting @CheckForNull Strength keyStrength;
-  @VisibleForTesting @CheckForNull Strength valueStrength;
-  @VisibleForTesting @CheckForNull Boolean recordStats;
-  @VisibleForTesting long writeExpirationDuration;
-  @VisibleForTesting @CheckForNull TimeUnit writeExpirationTimeUnit;
-  @VisibleForTesting long accessExpirationDuration;
-  @VisibleForTesting @CheckForNull TimeUnit accessExpirationTimeUnit;
-  @VisibleForTesting long refreshDuration;
-  @VisibleForTesting @CheckForNull TimeUnit refreshTimeUnit;
+  @CheckForNull Integer initialCapacity;
+  @CheckForNull Long maximumSize;
+  @CheckForNull Long maximumWeight;
+  @CheckForNull Integer concurrencyLevel;
+  @CheckForNull Strength keyStrength;
+  @CheckForNull Strength valueStrength;
+  @CheckForNull Boolean recordStats;
+  long writeExpirationDuration;
+  @CheckForNull TimeUnit writeExpirationTimeUnit;
+  long accessExpirationDuration;
+  @CheckForNull TimeUnit accessExpirationTimeUnit;
+  long refreshDuration;
+  @CheckForNull TimeUnit refreshTimeUnit;
   /** Specification; used for toParseableString(). */
   private final String specification;
 
@@ -291,7 +287,7 @@ public final class CacheBuilderSpec {
     protected abstract void parseInteger(CacheBuilderSpec spec, int value);
 
     @Override
-    public void parse(CacheBuilderSpec spec, String key, @Nullable String value) {
+    public void parse(CacheBuilderSpec spec, String key, String value) {
       if (isNullOrEmpty(value)) {
         throw new IllegalArgumentException("value of key " + key + " omitted");
       }
@@ -309,7 +305,7 @@ public final class CacheBuilderSpec {
     protected abstract void parseLong(CacheBuilderSpec spec, long value);
 
     @Override
-    public void parse(CacheBuilderSpec spec, String key, @Nullable String value) {
+    public void parse(CacheBuilderSpec spec, String key, String value) {
       if (isNullOrEmpty(value)) {
         throw new IllegalArgumentException("value of key " + key + " omitted");
       }
diff --git a/guava/src/com/google/common/cache/CacheLoader.java b/guava/src/com/google/common/cache/CacheLoader.java
index 7a5e017d03..56c7b9ac44 100644
--- a/guava/src/com/google/common/cache/CacheLoader.java
+++ b/guava/src/com/google/common/cache/CacheLoader.java
@@ -16,14 +16,11 @@ package com.google.common.cache;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Function;
 import com.google.common.base.Supplier;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.ListenableFutureTask;
-import com.google.errorprone.annotations.CheckReturnValue;
 import java.io.Serializable;
 import java.util.Map;
 import java.util.concurrent.Callable;
@@ -56,7 +53,6 @@ import java.util.concurrent.Executor;
  * @author Charles Fry
  * @since 10.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public abstract class CacheLoader<K, V> {
   /** Constructor for use by subclasses. */
@@ -95,7 +91,7 @@ public abstract class CacheLoader<K, V> {
    *     the thread's interrupt status is set
    * @since 11.0
    */
-  @GwtIncompatible // Futures
+  // Futures
   public ListenableFuture<V> reload(K key, V oldValue) throws Exception {
     checkNotNull(key);
     checkNotNull(oldValue);
@@ -137,7 +133,6 @@ public abstract class CacheLoader<K, V> {
    * @param function the function to be used for loading values; must never return {@code null}
    * @return a cache loader that loads values by passing each key to {@code function}
    */
-  @CheckReturnValue
   public static <K, V> CacheLoader<K, V> from(Function<K, V> function) {
     return new FunctionToCacheLoader<>(function);
   }
@@ -151,7 +146,6 @@ public abstract class CacheLoader<K, V> {
    * @return a cache loader that loads values by calling {@link Supplier#get}, irrespective of the
    *     key
    */
-  @CheckReturnValue
   public static <V> CacheLoader<Object, V> from(Supplier<V> supplier) {
     return new SupplierToCacheLoader<V>(supplier);
   }
@@ -181,8 +175,7 @@ public abstract class CacheLoader<K, V> {
    *
    * @since 17.0
    */
-  @CheckReturnValue
-  @GwtIncompatible // Executor + Futures
+  // Executor + Futures
   public static <K, V> CacheLoader<K, V> asyncReloading(
       final CacheLoader<K, V> loader, final Executor executor) {
     checkNotNull(loader);
diff --git a/guava/src/com/google/common/cache/CacheStats.java b/guava/src/com/google/common/cache/CacheStats.java
index 8307e942a8..b41ad6c4e7 100644
--- a/guava/src/com/google/common/cache/CacheStats.java
+++ b/guava/src/com/google/common/cache/CacheStats.java
@@ -18,7 +18,6 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.math.LongMath.saturatedAdd;
 import static com.google.common.math.LongMath.saturatedSubtract;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Objects;
 import java.util.concurrent.Callable;
@@ -56,7 +55,6 @@ import javax.annotation.CheckForNull;
  * @author Charles Fry
  * @since 10.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class CacheStats {
   private final long hitCount;
diff --git a/guava/src/com/google/common/cache/ElementTypesAreNonnullByDefault.java b/guava/src/com/google/common/cache/ElementTypesAreNonnullByDefault.java
index bcf0fcef1c..2cc8bd26d7 100644
--- a/guava/src/com/google/common/cache/ElementTypesAreNonnullByDefault.java
+++ b/guava/src/com/google/common/cache/ElementTypesAreNonnullByDefault.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.ElementType.TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -33,7 +32,6 @@ import javax.annotation.meta.TypeQualifierDefault;
  * unfortunately includes type-variable usages, so we also provide {@link ParametricNullness} to
  * "undo" it as best we can.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target(TYPE)
 @TypeQualifierDefault({FIELD, METHOD, PARAMETER})
diff --git a/guava/src/com/google/common/cache/ForwardingCache.java b/guava/src/com/google/common/cache/ForwardingCache.java
index f118977b09..2ca1e399ae 100644
--- a/guava/src/com/google/common/cache/ForwardingCache.java
+++ b/guava/src/com/google/common/cache/ForwardingCache.java
@@ -14,7 +14,6 @@
 
 package com.google.common.cache;
 
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ForwardingObject;
 import com.google.common.collect.ImmutableMap;
@@ -32,7 +31,6 @@ import javax.annotation.CheckForNull;
  * @author Charles Fry
  * @since 10.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public abstract class ForwardingCache<K, V> extends ForwardingObject implements Cache<K, V> {
 
diff --git a/guava/src/com/google/common/cache/ForwardingLoadingCache.java b/guava/src/com/google/common/cache/ForwardingLoadingCache.java
index ecd44ca8d8..3e310da16f 100644
--- a/guava/src/com/google/common/cache/ForwardingLoadingCache.java
+++ b/guava/src/com/google/common/cache/ForwardingLoadingCache.java
@@ -14,7 +14,6 @@
 
 package com.google.common.cache;
 
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableMap;
 import java.util.concurrent.ExecutionException;
@@ -30,7 +29,6 @@ import java.util.concurrent.ExecutionException;
  * @author Charles Fry
  * @since 11.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public abstract class ForwardingLoadingCache<K, V> extends ForwardingCache<K, V>
     implements LoadingCache<K, V> {
diff --git a/guava/src/com/google/common/cache/LoadingCache.java b/guava/src/com/google/common/cache/LoadingCache.java
index e338ac4c37..c1ca776866 100644
--- a/guava/src/com/google/common/cache/LoadingCache.java
+++ b/guava/src/com/google/common/cache/LoadingCache.java
@@ -14,7 +14,6 @@
 
 package com.google.common.cache;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.util.concurrent.ExecutionError;
@@ -38,7 +37,6 @@ import java.util.concurrent.ExecutionException;
  * @author Charles Fry
  * @since 11.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public interface LoadingCache<K, V> extends Cache<K, V>, Function<K, V> {
 
diff --git a/guava/src/com/google/common/cache/LocalCache.java b/guava/src/com/google/common/cache/LocalCache.java
index f421781d8f..9d4e276d3d 100644
--- a/guava/src/com/google/common/cache/LocalCache.java
+++ b/guava/src/com/google/common/cache/LocalCache.java
@@ -23,9 +23,6 @@ import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 import static com.google.common.util.concurrent.Uninterruptibles.getUninterruptibly;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Stopwatch;
 import com.google.common.base.Ticker;
@@ -49,9 +46,6 @@ import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.SettableFuture;
 import com.google.common.util.concurrent.UncheckedExecutionException;
 import com.google.common.util.concurrent.Uninterruptibles;
-import com.google.errorprone.annotations.concurrent.GuardedBy;
-import com.google.j2objc.annotations.RetainedWith;
-import com.google.j2objc.annotations.Weak;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.Serializable;
@@ -85,7 +79,6 @@ import java.util.function.Function;
 import java.util.function.Predicate;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * The concurrent hash map implementation built by {@link CacheBuilder}.
@@ -101,7 +94,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
   "GoodTime", // lots of violations (nanosecond math)
   "nullness", // too much trouble for the payoff
 })
-@GwtCompatible(emulated = true)
 // TODO(cpovirk): Annotate for nullness.
 class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V> {
 
@@ -234,13 +226,13 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
   final StatsCounter globalStatsCounter;
 
   /** The default cache loader to use on loading operations. */
-  final @Nullable CacheLoader<? super K, V> defaultLoader;
+  final CacheLoader<? super K, V> defaultLoader;
 
   /**
    * Creates a new, empty map with the specified strategy, initial capacity and concurrency level.
    */
   LocalCache(
-      CacheBuilder<? super K, ? super V> builder, @Nullable CacheLoader<? super K, V> loader) {
+      CacheBuilder<? super K, ? super V> builder, CacheLoader<? super K, V> loader) {
     concurrencyLevel = Math.min(builder.getConcurrencyLevel(), MAX_SEGMENTS);
 
     keyStrength = builder.getKeyStrength();
@@ -444,14 +436,14 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     STRONG {
       @Override
       <K, V> ReferenceEntry<K, V> newEntry(
-          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {
+          Segment<K, V> segment, K key, int hash, ReferenceEntry<K, V> next) {
         return new StrongEntry<>(key, hash, next);
       }
     },
     STRONG_ACCESS {
       @Override
       <K, V> ReferenceEntry<K, V> newEntry(
-          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {
+          Segment<K, V> segment, K key, int hash, ReferenceEntry<K, V> next) {
         return new StrongAccessEntry<>(key, hash, next);
       }
 
@@ -466,7 +458,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     STRONG_WRITE {
       @Override
       <K, V> ReferenceEntry<K, V> newEntry(
-          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {
+          Segment<K, V> segment, K key, int hash, ReferenceEntry<K, V> next) {
         return new StrongWriteEntry<>(key, hash, next);
       }
 
@@ -481,7 +473,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     STRONG_ACCESS_WRITE {
       @Override
       <K, V> ReferenceEntry<K, V> newEntry(
-          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {
+          Segment<K, V> segment, K key, int hash, ReferenceEntry<K, V> next) {
         return new StrongAccessWriteEntry<>(key, hash, next);
       }
 
@@ -497,14 +489,14 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     WEAK {
       @Override
       <K, V> ReferenceEntry<K, V> newEntry(
-          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {
+          Segment<K, V> segment, K key, int hash, ReferenceEntry<K, V> next) {
         return new WeakEntry<>(segment.keyReferenceQueue, key, hash, next);
       }
     },
     WEAK_ACCESS {
       @Override
       <K, V> ReferenceEntry<K, V> newEntry(
-          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {
+          Segment<K, V> segment, K key, int hash, ReferenceEntry<K, V> next) {
         return new WeakAccessEntry<>(segment.keyReferenceQueue, key, hash, next);
       }
 
@@ -519,7 +511,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     WEAK_WRITE {
       @Override
       <K, V> ReferenceEntry<K, V> newEntry(
-          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {
+          Segment<K, V> segment, K key, int hash, ReferenceEntry<K, V> next) {
         return new WeakWriteEntry<>(segment.keyReferenceQueue, key, hash, next);
       }
 
@@ -534,7 +526,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     WEAK_ACCESS_WRITE {
       @Override
       <K, V> ReferenceEntry<K, V> newEntry(
-          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {
+          Segment<K, V> segment, K key, int hash, ReferenceEntry<K, V> next) {
         return new WeakAccessWriteEntry<>(segment.keyReferenceQueue, key, hash, next);
       }
 
@@ -584,7 +576,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
      * @param next entry in the same bucket
      */
     abstract <K, V> ReferenceEntry<K, V> newEntry(
-        Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next);
+        Segment<K, V> segment, K key, int hash, ReferenceEntry<K, V> next);
 
     /**
      * Copies an entry, assigning it a new {@code next} entry.
@@ -626,7 +618,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
   /** A reference to a value. */
   interface ValueReference<K, V> {
     /** Returns the value. Does not block or throw exceptions. */
-    @Nullable
     V get();
 
     /**
@@ -645,7 +636,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
      * Returns the entry associated with this value reference, or {@code null} if this value
      * reference is independent of any entry.
      */
-    @Nullable
     ReferenceEntry<K, V> getEntry();
 
     /**
@@ -654,13 +644,13 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
      * <p>{@code value} may be null only for a loading reference.
      */
     ValueReference<K, V> copyFor(
-        ReferenceQueue<V> queue, @Nullable V value, ReferenceEntry<K, V> entry);
+        ReferenceQueue<V> queue, V value, ReferenceEntry<K, V> entry);
 
     /**
      * Notify pending loads that a new value was set. This is only relevant to loading value
      * references.
      */
-    void notifyNewValue(@Nullable V newValue);
+    void notifyNewValue(V newValue);
 
     /**
      * Returns true if a new value is currently loading, regardless of whether or not there is an
@@ -700,7 +690,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
         @Override
         public ValueReference<Object, Object> copyFor(
             ReferenceQueue<Object> queue,
-            @Nullable Object value,
+            Object value,
             ReferenceEntry<Object, Object> entry) {
           return this;
         }
@@ -943,7 +933,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
   static class StrongEntry<K, V> extends AbstractReferenceEntry<K, V> {
     final K key;
 
-    StrongEntry(K key, int hash, @Nullable ReferenceEntry<K, V> next) {
+    StrongEntry(K key, int hash, ReferenceEntry<K, V> next) {
       this.key = key;
       this.hash = hash;
       this.next = next;
@@ -957,7 +947,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     // The code below is exactly the same for each entry type.
 
     final int hash;
-    final @Nullable ReferenceEntry<K, V> next;
+    final ReferenceEntry<K, V> next;
     volatile ValueReference<K, V> valueReference = unset();
 
     @Override
@@ -982,7 +972,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
   }
 
   static final class StrongAccessEntry<K, V> extends StrongEntry<K, V> {
-    StrongAccessEntry(K key, int hash, @Nullable ReferenceEntry<K, V> next) {
+    StrongAccessEntry(K key, int hash, ReferenceEntry<K, V> next) {
       super(key, hash, next);
     }
 
@@ -1001,7 +991,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     }
 
     // Guarded By Segment.this
-    @Weak ReferenceEntry<K, V> nextAccess = nullEntry();
+    ReferenceEntry<K, V> nextAccess = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getNextInAccessQueue() {
@@ -1014,7 +1004,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     }
 
     // Guarded By Segment.this
-    @Weak ReferenceEntry<K, V> previousAccess = nullEntry();
+    ReferenceEntry<K, V> previousAccess = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getPreviousInAccessQueue() {
@@ -1028,7 +1018,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
   }
 
   static final class StrongWriteEntry<K, V> extends StrongEntry<K, V> {
-    StrongWriteEntry(K key, int hash, @Nullable ReferenceEntry<K, V> next) {
+    StrongWriteEntry(K key, int hash, ReferenceEntry<K, V> next) {
       super(key, hash, next);
     }
 
@@ -1047,7 +1037,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     }
 
     // Guarded By Segment.this
-    @Weak ReferenceEntry<K, V> nextWrite = nullEntry();
+    ReferenceEntry<K, V> nextWrite = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getNextInWriteQueue() {
@@ -1060,7 +1050,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     }
 
     // Guarded By Segment.this
-    @Weak ReferenceEntry<K, V> previousWrite = nullEntry();
+    ReferenceEntry<K, V> previousWrite = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getPreviousInWriteQueue() {
@@ -1074,7 +1064,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
   }
 
   static final class StrongAccessWriteEntry<K, V> extends StrongEntry<K, V> {
-    StrongAccessWriteEntry(K key, int hash, @Nullable ReferenceEntry<K, V> next) {
+    StrongAccessWriteEntry(K key, int hash, ReferenceEntry<K, V> next) {
       super(key, hash, next);
     }
 
@@ -1093,7 +1083,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     }
 
     // Guarded By Segment.this
-    @Weak ReferenceEntry<K, V> nextAccess = nullEntry();
+    ReferenceEntry<K, V> nextAccess = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getNextInAccessQueue() {
@@ -1106,7 +1096,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     }
 
     // Guarded By Segment.this
-    @Weak ReferenceEntry<K, V> previousAccess = nullEntry();
+    ReferenceEntry<K, V> previousAccess = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getPreviousInAccessQueue() {
@@ -1133,7 +1123,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     }
 
     // Guarded By Segment.this
-    @Weak ReferenceEntry<K, V> nextWrite = nullEntry();
+    ReferenceEntry<K, V> nextWrite = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getNextInWriteQueue() {
@@ -1146,7 +1136,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     }
 
     // Guarded By Segment.this
-    @Weak ReferenceEntry<K, V> previousWrite = nullEntry();
+    ReferenceEntry<K, V> previousWrite = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getPreviousInWriteQueue() {
@@ -1161,7 +1151,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
 
   /** Used for weakly-referenced keys. */
   static class WeakEntry<K, V> extends WeakReference<K> implements ReferenceEntry<K, V> {
-    WeakEntry(ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {
+    WeakEntry(ReferenceQueue<K> queue, K key, int hash, ReferenceEntry<K, V> next) {
       super(key, queue);
       this.hash = hash;
       this.next = next;
@@ -1244,7 +1234,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     // The code below is exactly the same for each entry type.
 
     final int hash;
-    final @Nullable ReferenceEntry<K, V> next;
+    final ReferenceEntry<K, V> next;
     volatile ValueReference<K, V> valueReference = unset();
 
     @Override
@@ -1269,7 +1259,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
   }
 
   static final class WeakAccessEntry<K, V> extends WeakEntry<K, V> {
-    WeakAccessEntry(ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {
+    WeakAccessEntry(ReferenceQueue<K> queue, K key, int hash, ReferenceEntry<K, V> next) {
       super(queue, key, hash, next);
     }
 
@@ -1288,7 +1278,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     }
 
     // Guarded By Segment.this
-    @Weak ReferenceEntry<K, V> nextAccess = nullEntry();
+    ReferenceEntry<K, V> nextAccess = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getNextInAccessQueue() {
@@ -1301,7 +1291,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     }
 
     // Guarded By Segment.this
-    @Weak ReferenceEntry<K, V> previousAccess = nullEntry();
+    ReferenceEntry<K, V> previousAccess = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getPreviousInAccessQueue() {
@@ -1315,7 +1305,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
   }
 
   static final class WeakWriteEntry<K, V> extends WeakEntry<K, V> {
-    WeakWriteEntry(ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {
+    WeakWriteEntry(ReferenceQueue<K> queue, K key, int hash, ReferenceEntry<K, V> next) {
       super(queue, key, hash, next);
     }
 
@@ -1334,7 +1324,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     }
 
     // Guarded By Segment.this
-    @Weak ReferenceEntry<K, V> nextWrite = nullEntry();
+    ReferenceEntry<K, V> nextWrite = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getNextInWriteQueue() {
@@ -1347,7 +1337,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     }
 
     // Guarded By Segment.this
-    @Weak ReferenceEntry<K, V> previousWrite = nullEntry();
+    ReferenceEntry<K, V> previousWrite = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getPreviousInWriteQueue() {
@@ -1362,7 +1352,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
 
   static final class WeakAccessWriteEntry<K, V> extends WeakEntry<K, V> {
     WeakAccessWriteEntry(
-        ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {
+        ReferenceQueue<K> queue, K key, int hash, ReferenceEntry<K, V> next) {
       super(queue, key, hash, next);
     }
 
@@ -1381,7 +1371,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     }
 
     // Guarded By Segment.this
-    @Weak ReferenceEntry<K, V> nextAccess = nullEntry();
+    ReferenceEntry<K, V> nextAccess = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getNextInAccessQueue() {
@@ -1394,7 +1384,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     }
 
     // Guarded By Segment.this
-    @Weak ReferenceEntry<K, V> previousAccess = nullEntry();
+    ReferenceEntry<K, V> previousAccess = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getPreviousInAccessQueue() {
@@ -1421,7 +1411,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     }
 
     // Guarded By Segment.this
-    @Weak ReferenceEntry<K, V> nextWrite = nullEntry();
+    ReferenceEntry<K, V> nextWrite = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getNextInWriteQueue() {
@@ -1434,7 +1424,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     }
 
     // Guarded By Segment.this
-    @Weak ReferenceEntry<K, V> previousWrite = nullEntry();
+    ReferenceEntry<K, V> previousWrite = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getPreviousInWriteQueue() {
@@ -1665,8 +1655,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
   /**
    * This method is a convenience for testing. Code should call {@link Segment#newEntry} directly.
    */
-  @VisibleForTesting
-  ReferenceEntry<K, V> newEntry(K key, int hash, @Nullable ReferenceEntry<K, V> next) {
+  ReferenceEntry<K, V> newEntry(K key, int hash, ReferenceEntry<K, V> next) {
     Segment<K, V> segment = segmentFor(hash);
     segment.lock();
     try {
@@ -1681,7 +1670,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
    */
   // Guarded By Segment.this
   @SuppressWarnings("GuardedBy")
-  @VisibleForTesting
   ReferenceEntry<K, V> copyEntry(ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {
     int hash = original.getHash();
     return segmentFor(hash).copyEntry(original, newNext);
@@ -1691,13 +1679,12 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
    * This method is a convenience for testing. Code should call {@link Segment#setValue} instead.
    */
   // Guarded By Segment.this
-  @VisibleForTesting
   ValueReference<K, V> newValueReference(ReferenceEntry<K, V> entry, V value, int weight) {
     int hash = entry.getHash();
     return valueStrength.referenceValue(segmentFor(hash), entry, checkNotNull(value), weight);
   }
 
-  int hash(@Nullable Object key) {
+  int hash(Object key) {
     int h = keyEquivalence.hash(key);
     return rehash(h);
   }
@@ -1717,7 +1704,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
    * This method is a convenience for testing. Code should call {@link Segment#getLiveValue}
    * instead.
    */
-  @VisibleForTesting
   boolean isLive(ReferenceEntry<K, V> entry, long now) {
     return segmentFor(entry.getHash()).getLiveValue(entry, now) != null;
   }
@@ -1744,7 +1730,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
    * cleanup stale entries. As such it should only be called outside of a segment context, such as
    * during iteration.
    */
-  @Nullable
   V getLiveValue(ReferenceEntry<K, V> entry, long now) {
     if (entry.getKey() == null) {
       return null;
@@ -1865,13 +1850,12 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
      * comments.
      */
 
-    @Weak final LocalCache<K, V> map;
+    final LocalCache<K, V> map;
 
     /** The number of live elements in this segment's region. */
     volatile int count;
 
     /** The weight of the live elements in this segment's region. */
-    @GuardedBy("this")
     long totalWeight;
 
     /**
@@ -1889,7 +1873,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     int threshold;
 
     /** The per-segment table. */
-    volatile @Nullable AtomicReferenceArray<ReferenceEntry<K, V>> table;
+    volatile AtomicReferenceArray<ReferenceEntry<K, V>> table;
 
     /** The maximum weight of this segment. UNSET_INT if there is no maximum. */
     final long maxSegmentWeight;
@@ -1898,13 +1882,13 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
      * The key reference queue contains entries whose keys have been garbage collected, and which
      * need to be cleaned up internally.
      */
-    final @Nullable ReferenceQueue<K> keyReferenceQueue;
+    final ReferenceQueue<K> keyReferenceQueue;
 
     /**
      * The value reference queue contains value references whose values have been garbage collected,
      * and which need to be cleaned up internally.
      */
-    final @Nullable ReferenceQueue<V> valueReferenceQueue;
+    final ReferenceQueue<V> valueReferenceQueue;
 
     /**
      * The recency queue is used to record which entries were accessed for updating the access
@@ -1923,14 +1907,12 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
      * A queue of elements currently in the map, ordered by write time. Elements are added to the
      * tail of the queue on write.
      */
-    @GuardedBy("this")
     final Queue<ReferenceEntry<K, V>> writeQueue;
 
     /**
      * A queue of elements currently in the map, ordered by access time. Elements are added to the
      * tail of the queue on access (note that writes count as accesses).
      */
-    @GuardedBy("this")
     final Queue<ReferenceEntry<K, V>> accessQueue;
 
     /** Accumulates cache statistics. */
@@ -1979,8 +1961,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
       this.table = newTable;
     }
 
-    @GuardedBy("this")
-    ReferenceEntry<K, V> newEntry(K key, int hash, @Nullable ReferenceEntry<K, V> next) {
+    ReferenceEntry<K, V> newEntry(K key, int hash, ReferenceEntry<K, V> next) {
       return map.entryFactory.newEntry(this, checkNotNull(key), hash, next);
     }
 
@@ -1988,7 +1969,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
      * Copies {@code original} into a new entry chained to {@code newNext}. Returns the new entry,
      * or {@code null} if {@code original} was already garbage collected.
      */
-    @GuardedBy("this")
     ReferenceEntry<K, V> copyEntry(ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {
       if (original.getKey() == null) {
         // key collected
@@ -2008,7 +1988,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     }
 
     /** Sets a new value of an entry. Adds newly created entries at the end of the access queue. */
-    @GuardedBy("this")
     void setValue(ReferenceEntry<K, V> entry, K key, V value, long now) {
       ValueReference<K, V> previous = entry.getValueReference();
       int weight = map.weigher.weigh(key, value);
@@ -2060,7 +2039,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
       }
     }
 
-    @Nullable
     V get(Object key, int hash) {
       try {
         if (count != 0) { // read-volatile
@@ -2353,7 +2331,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
      * {@code null} if another thread is performing the refresh or if an error occurs during
      * refresh.
      */
-    @Nullable
     V refresh(K key, int hash, CacheLoader<? super K, V> loader, boolean checkTime) {
       final LoadingValueReference<K, V> loadingValueReference =
           insertLoadingValueReference(key, hash, checkTime);
@@ -2376,7 +2353,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
      * Returns a newly inserted {@code LoadingValueReference}, or null if the live value reference
      * is already loading.
      */
-    @Nullable
     LoadingValueReference<K, V> insertLoadingValueReference(
         final K key, final int hash, boolean checkTime) {
       ReferenceEntry<K, V> e = null;
@@ -2444,7 +2420,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
      * Drain the key and value reference queues, cleaning up internal entries containing garbage
      * collected keys or values.
      */
-    @GuardedBy("this")
     void drainReferenceQueues() {
       if (map.usesKeyReferences()) {
         drainKeyReferenceQueue();
@@ -2454,7 +2429,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
       }
     }
 
-    @GuardedBy("this")
     void drainKeyReferenceQueue() {
       Reference<? extends K> ref;
       int i = 0;
@@ -2468,7 +2442,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
       }
     }
 
-    @GuardedBy("this")
     void drainValueReferenceQueue() {
       Reference<? extends V> ref;
       int i = 0;
@@ -2523,7 +2496,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
      * <p>Note: this method should only be called under lock, as it directly manipulates the
      * eviction queues. Unlocked reads should use {@link #recordRead}.
      */
-    @GuardedBy("this")
     void recordLockedRead(ReferenceEntry<K, V> entry, long now) {
       if (map.recordsAccess()) {
         entry.setAccessTime(now);
@@ -2535,7 +2507,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
      * Updates eviction metadata that {@code entry} was just written. This currently amounts to
      * adding {@code entry} to relevant eviction lists.
      */
-    @GuardedBy("this")
     void recordWrite(ReferenceEntry<K, V> entry, int weight, long now) {
       // we are already under lock, so drain the recency queue immediately
       drainRecencyQueue();
@@ -2557,7 +2528,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
      * lists (accounting for the fact that they could have been removed from the map since being
      * added to the recency queue).
      */
-    @GuardedBy("this")
     void drainRecencyQueue() {
       ReferenceEntry<K, V> e;
       while ((e = recencyQueue.poll()) != null) {
@@ -2585,7 +2555,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
       }
     }
 
-    @GuardedBy("this")
     void expireEntries(long now) {
       drainRecencyQueue();
 
@@ -2604,9 +2573,8 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
 
     // eviction
 
-    @GuardedBy("this")
     void enqueueNotification(
-        @Nullable K key, int hash, @Nullable V value, int weight, RemovalCause cause) {
+        K key, int hash, V value, int weight, RemovalCause cause) {
       totalWeight -= weight;
       if (cause.wasEvicted()) {
         statsCounter.recordEviction();
@@ -2623,7 +2591,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
      *
      * @param newest the most recently added entry
      */
-    @GuardedBy("this")
     void evictEntries(ReferenceEntry<K, V> newest) {
       if (!map.evictsBySize()) {
         return;
@@ -2648,7 +2615,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     }
 
     // TODO(fry): instead implement this with an eviction head
-    @GuardedBy("this")
     ReferenceEntry<K, V> getNextEvictable() {
       for (ReferenceEntry<K, V> e : accessQueue) {
         int weight = e.getValueReference().getWeight();
@@ -2668,7 +2634,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
 
     // Specialized implementations of map methods
 
-    @Nullable
     ReferenceEntry<K, V> getEntry(Object key, int hash) {
       for (ReferenceEntry<K, V> e = getFirst(hash); e != null; e = e.getNext()) {
         if (e.getHash() != hash) {
@@ -2689,7 +2654,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
       return null;
     }
 
-    @Nullable
     ReferenceEntry<K, V> getLiveEntry(Object key, int hash, long now) {
       ReferenceEntry<K, V> e = getEntry(key, hash);
       if (e == null) {
@@ -2744,7 +2708,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
      * This method is a convenience for testing. Code should call {@link LocalCache#containsValue}
      * directly.
      */
-    @VisibleForTesting
     boolean containsValue(Object value) {
       try {
         if (count != 0) { // read-volatile
@@ -2770,7 +2733,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
       }
     }
 
-    @Nullable
     V put(K key, int hash, V value, boolean onlyIfAbsent) {
       lock();
       try {
@@ -2846,7 +2808,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     }
 
     /** Expands the table if possible. */
-    @GuardedBy("this")
     void expand() {
       AtomicReferenceArray<ReferenceEntry<K, V>> oldTable = table;
       int oldCapacity = oldTable.length();
@@ -2976,7 +2937,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
       }
     }
 
-    @Nullable
     V replace(K key, int hash, V newValue) {
       lock();
       try {
@@ -3031,7 +2991,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
       }
     }
 
-    @Nullable
     V remove(Object key, int hash) {
       lock();
       try {
@@ -3222,12 +3181,10 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
       }
     }
 
-    @GuardedBy("this")
-    @Nullable
     ReferenceEntry<K, V> removeValueFromChain(
         ReferenceEntry<K, V> first,
         ReferenceEntry<K, V> entry,
-        @Nullable K key,
+        K key,
         int hash,
         V value,
         ValueReference<K, V> valueReference,
@@ -3244,8 +3201,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
       }
     }
 
-    @GuardedBy("this")
-    @Nullable
     ReferenceEntry<K, V> removeEntryFromChain(
         ReferenceEntry<K, V> first, ReferenceEntry<K, V> entry) {
       int newCount = count;
@@ -3263,7 +3218,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
       return newFirst;
     }
 
-    @GuardedBy("this")
     void removeCollectedEntry(ReferenceEntry<K, V> entry) {
       enqueueNotification(
           entry.getKey(),
@@ -3387,8 +3341,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
       }
     }
 
-    @VisibleForTesting
-    @GuardedBy("this")
     boolean removeEntry(ReferenceEntry<K, V> entry, int hash, RemovalCause cause) {
       int newCount = this.count - 1;
       AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
@@ -3433,7 +3385,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
      *
      * <p>Post-condition: expireEntries has been run.
      */
-    @GuardedBy("this")
     void preWriteCleanup(long now) {
       runLockedCleanup(now);
     }
@@ -3499,7 +3450,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
       return oldValue.getWeight();
     }
 
-    public boolean set(@Nullable V newValue) {
+    public boolean set(V newValue) {
       return futureValue.set(newValue);
     }
 
@@ -3512,7 +3463,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     }
 
     @Override
-    public void notifyNewValue(@Nullable V newValue) {
+    public void notifyNewValue(V newValue) {
       if (newValue != null) {
         // The pending load was clobbered by a manual write.
         // Unblock all pending gets, and have them return the new value.
@@ -3602,7 +3553,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
 
     @Override
     public ValueReference<K, V> copyFor(
-        ReferenceQueue<V> queue, @Nullable V value, ReferenceEntry<K, V> entry) {
+        ReferenceQueue<V> queue, V value, ReferenceEntry<K, V> entry) {
       return this;
     }
   }
@@ -3643,7 +3594,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
           @Override
           public void setWriteTime(long time) {}
 
-          @Weak ReferenceEntry<K, V> nextWrite = this;
+          ReferenceEntry<K, V> nextWrite = this;
 
           @Override
           public ReferenceEntry<K, V> getNextInWriteQueue() {
@@ -3655,7 +3606,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
             this.nextWrite = next;
           }
 
-          @Weak ReferenceEntry<K, V> previousWrite = this;
+          ReferenceEntry<K, V> previousWrite = this;
 
           @Override
           public ReferenceEntry<K, V> getPreviousInWriteQueue() {
@@ -3782,7 +3733,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
           @Override
           public void setAccessTime(long time) {}
 
-          @Weak ReferenceEntry<K, V> nextAccess = this;
+          ReferenceEntry<K, V> nextAccess = this;
 
           @Override
           public ReferenceEntry<K, V> getNextInAccessQueue() {
@@ -3794,7 +3745,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
             this.nextAccess = next;
           }
 
-          @Weak ReferenceEntry<K, V> previousAccess = this;
+          ReferenceEntry<K, V> previousAccess = this;
 
           @Override
           public ReferenceEntry<K, V> getPreviousInAccessQueue() {
@@ -3953,7 +3904,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
   }
 
   @Override
-  public @Nullable V get(@Nullable Object key) {
+  public V get(Object key) {
     if (key == null) {
       return null;
     }
@@ -3966,7 +3917,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     return segmentFor(hash).get(key, hash, loader);
   }
 
-  public @Nullable V getIfPresent(Object key) {
+  public V getIfPresent(Object key) {
     int hash = hash(checkNotNull(key));
     V value = segmentFor(hash).get(key, hash);
     if (value == null) {
@@ -3980,7 +3931,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
   // Only becomes available in Java 8 when it's on the interface.
   // @Override
   @Override
-  public @Nullable V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {
+  public V getOrDefault(Object key, V defaultValue) {
     V result = get(key);
     return (result != null) ? result : defaultValue;
   }
@@ -4060,7 +4011,6 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
    * Returns the result of calling {@link CacheLoader#loadAll}, or null if {@code loader} doesn't
    * implement {@code loadAll}.
    */
-  @Nullable
   Map<K, V> loadAll(Set<? extends K> keys, CacheLoader<? super K, V> loader)
       throws ExecutionException {
     checkNotNull(loader);
@@ -4124,7 +4074,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
    * Returns the internal entry for the specified key. The entry may be loading, expired, or
    * partially collected.
    */
-  ReferenceEntry<K, V> getEntry(@Nullable Object key) {
+  ReferenceEntry<K, V> getEntry(Object key) {
     // does not impact recency ordering
     if (key == null) {
       return null;
@@ -4139,7 +4089,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
   }
 
   @Override
-  public boolean containsKey(@Nullable Object key) {
+  public boolean containsKey(Object key) {
     // does not impact recency ordering
     if (key == null) {
       return false;
@@ -4149,7 +4099,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
   }
 
   @Override
-  public boolean containsValue(@Nullable Object value) {
+  public boolean containsValue(Object value) {
     // does not impact recency ordering
     if (value == null) {
       return false;
@@ -4243,7 +4193,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
   }
 
   @Override
-  public V remove(@Nullable Object key) {
+  public V remove(Object key) {
     if (key == null) {
       return null;
     }
@@ -4252,7 +4202,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
   }
 
   @Override
-  public boolean remove(@Nullable Object key, @Nullable Object value) {
+  public boolean remove(Object key, Object value) {
     if (key == null || value == null) {
       return false;
     }
@@ -4261,7 +4211,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
   }
 
   @Override
-  public boolean replace(K key, @Nullable V oldValue, V newValue) {
+  public boolean replace(K key, V oldValue, V newValue) {
     checkNotNull(key);
     checkNotNull(newValue);
     if (oldValue == null) {
@@ -4293,7 +4243,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     }
   }
 
-  @RetainedWith @Nullable Set<K> keySet;
+  Set<K> keySet;
 
   @Override
   public Set<K> keySet() {
@@ -4302,7 +4252,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     return (ks != null) ? ks : (keySet = new KeySet());
   }
 
-  @RetainedWith @Nullable Collection<V> values;
+  Collection<V> values;
 
   @Override
   public Collection<V> values() {
@@ -4311,10 +4261,10 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     return (vs != null) ? vs : (values = new Values());
   }
 
-  @RetainedWith @Nullable Set<Entry<K, V>> entrySet;
+  Set<Entry<K, V>> entrySet;
 
   @Override
-  @GwtIncompatible // Not supported.
+  // Not supported.
   public Set<Entry<K, V>> entrySet() {
     // does not impact recency ordering
     Set<Entry<K, V>> es = entrySet;
@@ -4327,11 +4277,11 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
 
     int nextSegmentIndex;
     int nextTableIndex;
-    @Nullable Segment<K, V> currentSegment;
-    @Nullable AtomicReferenceArray<ReferenceEntry<K, V>> currentTable;
-    @Nullable ReferenceEntry<K, V> nextEntry;
-    @Nullable WriteThroughEntry nextExternal;
-    @Nullable WriteThroughEntry lastReturned;
+    Segment<K, V> currentSegment;
+    AtomicReferenceArray<ReferenceEntry<K, V>> currentTable;
+    ReferenceEntry<K, V> nextEntry;
+    WriteThroughEntry nextExternal;
+    WriteThroughEntry lastReturned;
 
     HashIterator() {
       nextSegmentIndex = segments.length - 1;
@@ -4472,7 +4422,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     }
 
     @Override
-    public boolean equals(@Nullable Object object) {
+    public boolean equals(Object object) {
       // Cannot use key and value equivalence
       if (object instanceof Entry) {
         Entry<?, ?> that = (Entry<?, ?>) object;
@@ -4689,10 +4639,10 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     final Weigher<K, V> weigher;
     final int concurrencyLevel;
     final RemovalListener<? super K, ? super V> removalListener;
-    final @Nullable Ticker ticker;
+    final Ticker ticker;
     final CacheLoader<? super K, V> loader;
 
-    transient @Nullable Cache<K, V> delegate;
+    transient Cache<K, V> delegate;
 
     ManualSerializationProxy(LocalCache<K, V> cache) {
       this(
@@ -4797,7 +4747,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
       implements LoadingCache<K, V>, Serializable {
     private static final long serialVersionUID = 1;
 
-    transient @Nullable LoadingCache<K, V> autoDelegate;
+    transient LoadingCache<K, V> autoDelegate;
 
     LoadingSerializationProxy(LocalCache<K, V> cache) {
       super(cache);
@@ -4853,7 +4803,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     // Cache methods
 
     @Override
-    public @Nullable V getIfPresent(Object key) {
+    public V getIfPresent(Object key) {
       return localCache.getIfPresent(key);
     }
 
diff --git a/guava/src/com/google/common/cache/LongAddable.java b/guava/src/com/google/common/cache/LongAddable.java
index 9851052d68..ae150aadc3 100644
--- a/guava/src/com/google/common/cache/LongAddable.java
+++ b/guava/src/com/google/common/cache/LongAddable.java
@@ -14,14 +14,12 @@
 
 package com.google.common.cache;
 
-import com.google.common.annotations.GwtCompatible;
 
 /**
  * Abstract interface for objects that can concurrently add longs.
  *
  * @author Louis Wasserman
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 interface LongAddable {
   void increment();
diff --git a/guava/src/com/google/common/cache/LongAddables.java b/guava/src/com/google/common/cache/LongAddables.java
index cd5d14b1af..e268e33064 100644
--- a/guava/src/com/google/common/cache/LongAddables.java
+++ b/guava/src/com/google/common/cache/LongAddables.java
@@ -14,7 +14,6 @@
 
 package com.google.common.cache;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Supplier;
 import java.util.concurrent.atomic.AtomicLong;
 
@@ -23,7 +22,6 @@ import java.util.concurrent.atomic.AtomicLong;
  *
  * @author Louis Wasserman
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 final class LongAddables {
   private static final Supplier<LongAddable> SUPPLIER;
diff --git a/guava/src/com/google/common/cache/LongAdder.java b/guava/src/com/google/common/cache/LongAdder.java
index 7ead7e8ecc..088b4ae49a 100644
--- a/guava/src/com/google/common/cache/LongAdder.java
+++ b/guava/src/com/google/common/cache/LongAdder.java
@@ -11,7 +11,6 @@
 
 package com.google.common.cache;
 
-import com.google.common.annotations.GwtCompatible;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
@@ -39,7 +38,6 @@ import java.util.concurrent.atomic.AtomicLong;
  * @since 1.8
  * @author Doug Lea
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 final class LongAdder extends Striped64 implements Serializable, LongAddable {
   private static final long serialVersionUID = 7249069246863182397L;
diff --git a/guava/src/com/google/common/cache/ParametricNullness.java b/guava/src/com/google/common/cache/ParametricNullness.java
index 19305a6f93..4c0df9f07e 100644
--- a/guava/src/com/google/common/cache/ParametricNullness.java
+++ b/guava/src/com/google/common/cache/ParametricNullness.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import static javax.annotation.meta.When.UNKNOWN;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -35,7 +34,6 @@ import javax.annotation.meta.TypeQualifierNickname;
  * href="https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/NullFromTypeParam.java">{@code
  * NullFromTypeParam}</a>). We use this to "undo" {@link ElementTypesAreNonnullByDefault}.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target({FIELD, METHOD, PARAMETER})
 @TypeQualifierNickname
diff --git a/guava/src/com/google/common/cache/ReferenceEntry.java b/guava/src/com/google/common/cache/ReferenceEntry.java
index 8ff2e6c9b4..89936c2156 100644
--- a/guava/src/com/google/common/cache/ReferenceEntry.java
+++ b/guava/src/com/google/common/cache/ReferenceEntry.java
@@ -14,7 +14,6 @@
 
 package com.google.common.cache;
 
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.cache.LocalCache.ValueReference;
 import javax.annotation.CheckForNull;
 
@@ -38,7 +37,6 @@ import javax.annotation.CheckForNull;
  *   <li>Unset: marked as unset, awaiting cleanup or reuse
  * </ul>
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 interface ReferenceEntry<K, V> {
   /** Returns the value reference from this entry. */
diff --git a/guava/src/com/google/common/cache/RemovalCause.java b/guava/src/com/google/common/cache/RemovalCause.java
index 2e68e68b58..aed3352b0f 100644
--- a/guava/src/com/google/common/cache/RemovalCause.java
+++ b/guava/src/com/google/common/cache/RemovalCause.java
@@ -14,7 +14,6 @@
 
 package com.google.common.cache;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.concurrent.ConcurrentMap;
@@ -25,7 +24,6 @@ import java.util.concurrent.ConcurrentMap;
  * @author Charles Fry
  * @since 10.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public enum RemovalCause {
   /**
diff --git a/guava/src/com/google/common/cache/RemovalListener.java b/guava/src/com/google/common/cache/RemovalListener.java
index 4713be5721..8c6d47ea84 100644
--- a/guava/src/com/google/common/cache/RemovalListener.java
+++ b/guava/src/com/google/common/cache/RemovalListener.java
@@ -14,7 +14,6 @@
 
 package com.google.common.cache;
 
-import com.google.common.annotations.GwtCompatible;
 
 /**
  * An object that can receive a notification when an entry is removed from a cache. The removal
@@ -32,7 +31,6 @@ import com.google.common.annotations.GwtCompatible;
  * @author Charles Fry
  * @since 10.0
  */
-@GwtCompatible
 @FunctionalInterface
 @ElementTypesAreNonnullByDefault
 public interface RemovalListener<K, V> {
diff --git a/guava/src/com/google/common/cache/RemovalListeners.java b/guava/src/com/google/common/cache/RemovalListeners.java
index d0623e7e30..bc0f7c05b9 100644
--- a/guava/src/com/google/common/cache/RemovalListeners.java
+++ b/guava/src/com/google/common/cache/RemovalListeners.java
@@ -16,7 +16,6 @@ package com.google.common.cache;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtIncompatible;
 import java.util.concurrent.Executor;
 
 /**
@@ -25,7 +24,6 @@ import java.util.concurrent.Executor;
  * @author Charles Fry
  * @since 10.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class RemovalListeners {
 
diff --git a/guava/src/com/google/common/cache/RemovalNotification.java b/guava/src/com/google/common/cache/RemovalNotification.java
index dab7fe533e..124a0ca142 100644
--- a/guava/src/com/google/common/cache/RemovalNotification.java
+++ b/guava/src/com/google/common/cache/RemovalNotification.java
@@ -16,10 +16,8 @@ package com.google.common.cache;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.AbstractMap.SimpleImmutableEntry;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A notification of the removal of a single entry. The key and/or value may be null if they were
@@ -32,10 +30,9 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Charles Fry
  * @since 10.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class RemovalNotification<K, V>
-    extends SimpleImmutableEntry<@Nullable K, @Nullable V> {
+    extends SimpleImmutableEntry<K, V> {
   private final RemovalCause cause;
 
   /**
diff --git a/guava/src/com/google/common/cache/Striped64.java b/guava/src/com/google/common/cache/Striped64.java
index 0d2d75b9f3..d4544ca0af 100644
--- a/guava/src/com/google/common/cache/Striped64.java
+++ b/guava/src/com/google/common/cache/Striped64.java
@@ -11,17 +11,14 @@
 
 package com.google.common.cache;
 
-import com.google.common.annotations.GwtIncompatible;
 import java.util.Random;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A package-local class holding common representation and mechanics for classes supporting dynamic
  * striping on 64bit values. The class extends Number so that concrete subclasses must publicly do
  * so.
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 abstract class Striped64 extends Number {
   /*
@@ -127,7 +124,7 @@ abstract class Striped64 extends Number {
    * class, we use a suboptimal int[] representation to avoid introducing a new type that can impede
    * class-unloading when ThreadLocals are not removed.
    */
-  static final ThreadLocal<int @Nullable []> threadHashCode = new ThreadLocal<>();
+  static final ThreadLocal<int []> threadHashCode = new ThreadLocal<>();
 
   /** Generator of new random hash codes */
   static final Random rng = new Random();
diff --git a/guava/src/com/google/common/cache/Weigher.java b/guava/src/com/google/common/cache/Weigher.java
index bbee3f585e..62564a85cc 100644
--- a/guava/src/com/google/common/cache/Weigher.java
+++ b/guava/src/com/google/common/cache/Weigher.java
@@ -14,7 +14,6 @@
 
 package com.google.common.cache;
 
-import com.google.common.annotations.GwtCompatible;
 
 /**
  * Calculates the weights of cache entries.
@@ -22,7 +21,6 @@ import com.google.common.annotations.GwtCompatible;
  * @author Charles Fry
  * @since 11.0
  */
-@GwtCompatible
 @FunctionalInterface
 @ElementTypesAreNonnullByDefault
 public interface Weigher<K, V> {
diff --git a/guava/src/com/google/common/collect/AbstractBiMap.java b/guava/src/com/google/common/collect/AbstractBiMap.java
index 9b2ad2af57..de31e671ba 100644
--- a/guava/src/com/google/common/collect/AbstractBiMap.java
+++ b/guava/src/com/google/common/collect/AbstractBiMap.java
@@ -20,12 +20,7 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Objects;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.j2objc.annotations.RetainedWith;
-import com.google.j2objc.annotations.WeakOuter;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
@@ -36,7 +31,6 @@ import java.util.Map;
 import java.util.Set;
 import java.util.function.BiFunction;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A general-purpose bimap implementation using any two backing {@code Map} instances.
@@ -47,13 +41,12 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kevin Bourrillion
  * @author Mike Bostock
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
-abstract class AbstractBiMap<K extends @Nullable Object, V extends @Nullable Object>
+abstract class AbstractBiMap<K extends Object, V extends Object>
     extends ForwardingMap<K, V> implements BiMap<K, V>, Serializable {
 
   private transient Map<K, V> delegate;
-  @RetainedWith transient AbstractBiMap<V, K> inverse;
+  transient AbstractBiMap<V, K> inverse;
 
   /** Package-private constructor for creating a map-backed bimap. */
   AbstractBiMap(Map<K, V> forward, Map<V, K> backward) {
@@ -72,14 +65,12 @@ abstract class AbstractBiMap<K extends @Nullable Object, V extends @Nullable Obj
   }
 
   /** Returns its input, or throws an exception if this is not a valid key. */
-  @CanIgnoreReturnValue
   @ParametricNullness
   K checkKey(@ParametricNullness K key) {
     return key;
   }
 
   /** Returns its input, or throws an exception if this is not a valid value. */
-  @CanIgnoreReturnValue
   @ParametricNullness
   V checkValue(@ParametricNullness V value) {
     return value;
@@ -116,14 +107,12 @@ abstract class AbstractBiMap<K extends @Nullable Object, V extends @Nullable Obj
 
   // Modification Operations
 
-  @CanIgnoreReturnValue
   @Override
   @CheckForNull
   public V put(@ParametricNullness K key, @ParametricNullness V value) {
     return putInBothMaps(key, value, false);
   }
 
-  @CanIgnoreReturnValue
   @Override
   @CheckForNull
   public V forcePut(@ParametricNullness K key, @ParametricNullness V value) {
@@ -160,14 +149,12 @@ abstract class AbstractBiMap<K extends @Nullable Object, V extends @Nullable Obj
     inverse.delegate.put(newValue, key);
   }
 
-  @CanIgnoreReturnValue
   @Override
   @CheckForNull
   public V remove(@CheckForNull Object key) {
     return containsKey(key) ? removeFromBothMaps(key) : null;
   }
 
-  @CanIgnoreReturnValue
   @ParametricNullness
   private V removeFromBothMaps(@CheckForNull Object key) {
     // The cast is safe because the callers of this method first check that the key is present.
@@ -233,7 +220,6 @@ abstract class AbstractBiMap<K extends @Nullable Object, V extends @Nullable Obj
     return (result == null) ? keySet = new KeySet() : result;
   }
 
-  @WeakOuter
   private class KeySet extends ForwardingSet<K> {
     @Override
     protected Set<K> delegate() {
@@ -282,7 +268,6 @@ abstract class AbstractBiMap<K extends @Nullable Object, V extends @Nullable Obj
     return (result == null) ? valueSet = new ValueSet() : result;
   }
 
-  @WeakOuter
   private class ValueSet extends ForwardingSet<V> {
     final Set<V> valuesDelegate = inverse.keySet();
 
@@ -297,13 +282,13 @@ abstract class AbstractBiMap<K extends @Nullable Object, V extends @Nullable Obj
     }
 
     @Override
-    public @Nullable Object[] toArray() {
+    public Object[] toArray() {
       return standardToArray();
     }
 
     @Override
     @SuppressWarnings("nullness") // bug in our checker's handling of toArray signatures
-    public <T extends @Nullable Object> T[] toArray(T[] array) {
+    public <T extends Object> T[] toArray(T[] array) {
       return standardToArray(array);
     }
 
@@ -379,7 +364,6 @@ abstract class AbstractBiMap<K extends @Nullable Object, V extends @Nullable Obj
     };
   }
 
-  @WeakOuter
   private class EntrySet extends ForwardingSet<Entry<K, V>> {
     final Set<Entry<K, V>> esDelegate = delegate.entrySet();
 
@@ -435,7 +419,7 @@ abstract class AbstractBiMap<K extends @Nullable Object, V extends @Nullable Obj
 
     @Override
     @SuppressWarnings("nullness") // bug in our checker's handling of toArray signatures
-    public <T extends @Nullable Object> T[] toArray(T[] array) {
+    public <T extends Object> T[] toArray(T[] array) {
       return standardToArray(array);
     }
 
@@ -461,7 +445,7 @@ abstract class AbstractBiMap<K extends @Nullable Object, V extends @Nullable Obj
   }
 
   /** The inverse of any other {@code AbstractBiMap} subclass. */
-  static class Inverse<K extends @Nullable Object, V extends @Nullable Object>
+  static class Inverse<K extends Object, V extends Object>
       extends AbstractBiMap<K, V> {
     Inverse(Map<K, V> backward, AbstractBiMap<V, K> forward) {
       super(backward, forward);
@@ -489,28 +473,28 @@ abstract class AbstractBiMap<K extends @Nullable Object, V extends @Nullable Obj
     }
 
     /** @serialData the forward bimap */
-    @GwtIncompatible // java.io.ObjectOutputStream
+    // java.io.ObjectOutputStream
     private void writeObject(ObjectOutputStream stream) throws IOException {
       stream.defaultWriteObject();
       stream.writeObject(inverse());
     }
 
-    @GwtIncompatible // java.io.ObjectInputStream
+    // java.io.ObjectInputStream
     @SuppressWarnings("unchecked") // reading data stored by writeObject
     private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
       stream.defaultReadObject();
       setInverse((AbstractBiMap<V, K>) stream.readObject());
     }
 
-    @GwtIncompatible // Not needed in the emulated source.
+    // Not needed in the emulated source.
     Object readResolve() {
       return inverse().inverse();
     }
 
-    @GwtIncompatible // Not needed in emulated source.
+    // Not needed in emulated source.
     private static final long serialVersionUID = 0;
   }
 
-  @GwtIncompatible // Not needed in emulated source.
+  // Not needed in emulated source.
   private static final long serialVersionUID = 0;
 }
diff --git a/guava/src/com/google/common/collect/AbstractIndexedListIterator.java b/guava/src/com/google/common/collect/AbstractIndexedListIterator.java
index abb3960b26..025f9ab076 100644
--- a/guava/src/com/google/common/collect/AbstractIndexedListIterator.java
+++ b/guava/src/com/google/common/collect/AbstractIndexedListIterator.java
@@ -18,10 +18,8 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkPositionIndex;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.ListIterator;
 import java.util.NoSuchElementException;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * This class provides a skeletal implementation of the {@link ListIterator} interface across a
@@ -30,9 +28,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @author Jared Levy
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-abstract class AbstractIndexedListIterator<E extends @Nullable Object>
+abstract class AbstractIndexedListIterator<E extends Object>
     extends UnmodifiableListIterator<E> {
   private final int size;
   private int position;
diff --git a/guava/src/com/google/common/collect/AbstractIterator.java b/guava/src/com/google/common/collect/AbstractIterator.java
index 66273f438d..d08343bee6 100644
--- a/guava/src/com/google/common/collect/AbstractIterator.java
+++ b/guava/src/com/google/common/collect/AbstractIterator.java
@@ -19,11 +19,8 @@ package com.google.common.collect;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.NoSuchElementException;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * This class provides a skeletal implementation of the {@code Iterator} interface, to make this
@@ -62,9 +59,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  */
 // When making changes to this class, please also update the copy at
 // com.google.common.base.AbstractIterator
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public abstract class AbstractIterator<T extends @Nullable Object> extends UnmodifiableIterator<T> {
+public abstract class AbstractIterator<T extends Object> extends UnmodifiableIterator<T> {
   private State state = State.NOT_READY;
 
   /** Constructor for use by subclasses. */
@@ -120,14 +116,13 @@ public abstract class AbstractIterator<T extends @Nullable Object> extends Unmod
    * @return {@code null}; a convenience so your {@code computeNext} implementation can use the
    *     simple statement {@code return endOfData();}
    */
-  @CanIgnoreReturnValue
   @CheckForNull
   protected final T endOfData() {
     state = State.DONE;
     return null;
   }
 
-  @CanIgnoreReturnValue // TODO(kak): Should we remove this? Some people are using it to prefetch?
+  // TODO(kak): Should we remove this? Some people are using it to prefetch?
   @Override
   public final boolean hasNext() {
     checkState(state != State.FAILED);
@@ -151,7 +146,7 @@ public abstract class AbstractIterator<T extends @Nullable Object> extends Unmod
     return false;
   }
 
-  @CanIgnoreReturnValue // TODO(kak): Should we remove this?
+  // TODO(kak): Should we remove this?
   @Override
   @ParametricNullness
   public final T next() {
diff --git a/guava/src/com/google/common/collect/AbstractListMultimap.java b/guava/src/com/google/common/collect/AbstractListMultimap.java
index 46c4ee2448..809c8f7712 100644
--- a/guava/src/com/google/common/collect/AbstractListMultimap.java
+++ b/guava/src/com/google/common/collect/AbstractListMultimap.java
@@ -16,14 +16,11 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Basic implementation of the {@link ListMultimap} interface. It's a wrapper around {@link
@@ -33,9 +30,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Jared Levy
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-abstract class AbstractListMultimap<K extends @Nullable Object, V extends @Nullable Object>
+abstract class AbstractListMultimap<K extends Object, V extends Object>
     extends AbstractMapBasedMultimap<K, V> implements ListMultimap<K, V> {
   /**
    * Creates a new multimap that uses the provided map.
@@ -55,7 +51,7 @@ abstract class AbstractListMultimap<K extends @Nullable Object, V extends @Nulla
   }
 
   @Override
-  <E extends @Nullable Object> Collection<E> unmodifiableCollectionSubclass(
+  <E extends Object> Collection<E> unmodifiableCollectionSubclass(
       Collection<E> collection) {
     return Collections.unmodifiableList((List<E>) collection);
   }
@@ -86,7 +82,6 @@ abstract class AbstractListMultimap<K extends @Nullable Object, V extends @Nulla
    * this method returns a {@link List}, instead of the {@link Collection} specified in the {@link
    * Multimap} interface.
    */
-  @CanIgnoreReturnValue
   @Override
   public List<V> removeAll(@CheckForNull Object key) {
     return (List<V>) super.removeAll(key);
@@ -99,7 +94,6 @@ abstract class AbstractListMultimap<K extends @Nullable Object, V extends @Nulla
    * this method returns a {@link List}, instead of the {@link Collection} specified in the {@link
    * Multimap} interface.
    */
-  @CanIgnoreReturnValue
   @Override
   public List<V> replaceValues(@ParametricNullness K key, Iterable<? extends V> values) {
     return (List<V>) super.replaceValues(key, values);
@@ -112,7 +106,6 @@ abstract class AbstractListMultimap<K extends @Nullable Object, V extends @Nulla
    * @param value value to store in the multimap
    * @return {@code true} always
    */
-  @CanIgnoreReturnValue
   @Override
   public boolean put(@ParametricNullness K key, @ParametricNullness V value) {
     return super.put(key, value);
diff --git a/guava/src/com/google/common/collect/AbstractMapBasedMultimap.java b/guava/src/com/google/common/collect/AbstractMapBasedMultimap.java
index 4c5a0f0418..67ccc71ecd 100644
--- a/guava/src/com/google/common/collect/AbstractMapBasedMultimap.java
+++ b/guava/src/com/google/common/collect/AbstractMapBasedMultimap.java
@@ -22,9 +22,7 @@ import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.Maps.ViewCachingAbstractMap;
-import com.google.j2objc.annotations.WeakOuter;
 import java.io.Serializable;
 import java.util.AbstractCollection;
 import java.util.Collection;
@@ -45,7 +43,6 @@ import java.util.SortedSet;
 import java.util.Spliterator;
 import java.util.function.BiConsumer;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Basic implementation of the {@link Multimap} interface. This class represents a multimap as a map
@@ -85,9 +82,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Jared Levy
  * @author Louis Wasserman
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-abstract class AbstractMapBasedMultimap<K extends @Nullable Object, V extends @Nullable Object>
+abstract class AbstractMapBasedMultimap<K extends Object, V extends Object>
     extends AbstractMultimap<K, V> implements Serializable {
   /*
    * Here's an outline of the overall design.
@@ -264,7 +260,7 @@ abstract class AbstractMapBasedMultimap<K extends @Nullable Object, V extends @N
     return unmodifiableCollectionSubclass(output);
   }
 
-  <E extends @Nullable Object> Collection<E> unmodifiableCollectionSubclass(
+  <E extends Object> Collection<E> unmodifiableCollectionSubclass(
       Collection<E> collection) {
     return Collections.unmodifiableCollection(collection);
   }
@@ -325,7 +321,6 @@ abstract class AbstractMapBasedMultimap<K extends @Nullable Object, V extends @N
    * subcollection {@code refreshIfEmpty}, {@code removeIfEmpty}, and {@code addToMap} methods call
    * the corresponding methods of the full wrapped collection.
    */
-  @WeakOuter
   class WrappedCollection extends AbstractCollection<V> {
     @ParametricNullness final K key;
     Collection<V> delegate;
@@ -587,7 +582,7 @@ abstract class AbstractMapBasedMultimap<K extends @Nullable Object, V extends @N
     }
   }
 
-  private static <E extends @Nullable Object> Iterator<E> iteratorOrListIterator(
+  private static <E extends Object> Iterator<E> iteratorOrListIterator(
       Collection<E> collection) {
     return (collection instanceof List)
         ? ((List<E>) collection).listIterator()
@@ -595,7 +590,6 @@ abstract class AbstractMapBasedMultimap<K extends @Nullable Object, V extends @N
   }
 
   /** Set decorator that stays in sync with the multimap values for a key. */
-  @WeakOuter
   class WrappedSet extends WrappedCollection implements Set<V> {
     WrappedSet(@ParametricNullness K key, Set<V> delegate) {
       super(key, delegate, null);
@@ -622,7 +616,6 @@ abstract class AbstractMapBasedMultimap<K extends @Nullable Object, V extends @N
   }
 
   /** SortedSet decorator that stays in sync with the multimap values for a key. */
-  @WeakOuter
   class WrappedSortedSet extends WrappedCollection implements SortedSet<V> {
     WrappedSortedSet(
         @ParametricNullness K key,
@@ -683,7 +676,6 @@ abstract class AbstractMapBasedMultimap<K extends @Nullable Object, V extends @N
     }
   }
 
-  @WeakOuter
   class WrappedNavigableSet extends WrappedSortedSet implements NavigableSet<V> {
     WrappedNavigableSet(
         @ParametricNullness K key,
@@ -769,7 +761,6 @@ abstract class AbstractMapBasedMultimap<K extends @Nullable Object, V extends @N
   }
 
   /** List decorator that stays in sync with the multimap values for a key. */
-  @WeakOuter
   class WrappedList extends WrappedCollection implements List<V> {
     WrappedList(
         @ParametricNullness K key, List<V> delegate, @CheckForNull WrappedCollection ancestor) {
@@ -941,7 +932,6 @@ abstract class AbstractMapBasedMultimap<K extends @Nullable Object, V extends @N
     }
   }
 
-  @WeakOuter
   private class KeySet extends Maps.KeySet<K, Collection<V>> {
     KeySet(final Map<K, Collection<V>> subMap) {
       super(subMap);
@@ -1017,7 +1007,6 @@ abstract class AbstractMapBasedMultimap<K extends @Nullable Object, V extends @N
     }
   }
 
-  @WeakOuter
   private class SortedKeySet extends KeySet implements SortedSet<K> {
 
     SortedKeySet(SortedMap<K, Collection<V>> subMap) {
@@ -1062,7 +1051,6 @@ abstract class AbstractMapBasedMultimap<K extends @Nullable Object, V extends @N
     }
   }
 
-  @WeakOuter
   class NavigableKeySet extends SortedKeySet implements NavigableSet<K> {
     NavigableKeySet(NavigableMap<K, Collection<V>> subMap) {
       super(subMap);
@@ -1167,7 +1155,7 @@ abstract class AbstractMapBasedMultimap<K extends @Nullable Object, V extends @N
     }
   }
 
-  private abstract class Itr<T extends @Nullable Object> implements Iterator<T> {
+  private abstract class Itr<T extends Object> implements Iterator<T> {
     final Iterator<Entry<K, Collection<V>>> keyIterator;
     @CheckForNull K key;
     @CheckForNull Collection<V> collection;
@@ -1337,7 +1325,6 @@ abstract class AbstractMapBasedMultimap<K extends @Nullable Object, V extends @N
     }
   }
 
-  @WeakOuter
   private class AsMap extends ViewCachingAbstractMap<K, Collection<V>> {
     /**
      * Usually the same as map, but smaller for the headMap(), tailMap(), or subMap() of a
@@ -1427,7 +1414,6 @@ abstract class AbstractMapBasedMultimap<K extends @Nullable Object, V extends @N
       return Maps.immutableEntry(key, wrapCollection(key, entry.getValue()));
     }
 
-    @WeakOuter
     class AsMapEntries extends Maps.EntrySet<K, Collection<V>> {
       @Override
       Map<K, Collection<V>> map() {
@@ -1491,7 +1477,6 @@ abstract class AbstractMapBasedMultimap<K extends @Nullable Object, V extends @N
     }
   }
 
-  @WeakOuter
   private class SortedAsMap extends AsMap implements SortedMap<K, Collection<V>> {
     SortedAsMap(SortedMap<K, Collection<V>> submap) {
       super(submap);
diff --git a/guava/src/com/google/common/collect/AbstractMapBasedMultiset.java b/guava/src/com/google/common/collect/AbstractMapBasedMultiset.java
index b37214e022..4a867617b0 100644
--- a/guava/src/com/google/common/collect/AbstractMapBasedMultiset.java
+++ b/guava/src/com/google/common/collect/AbstractMapBasedMultiset.java
@@ -23,10 +23,7 @@ import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 import static com.google.common.collect.CollectPreconditions.checkRemove;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.primitives.Ints;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.InvalidObjectException;
 import java.io.ObjectStreamException;
 import java.io.Serializable;
@@ -36,7 +33,6 @@ import java.util.Map;
 import java.util.Set;
 import java.util.function.ObjIntConsumer;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Basic implementation of {@code Multiset<E>} backed by an instance of {@code Map<E, Count>}.
@@ -46,9 +42,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @author Kevin Bourrillion
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
-abstract class AbstractMapBasedMultiset<E extends @Nullable Object> extends AbstractMultiset<E>
+abstract class AbstractMapBasedMultiset<E extends Object> extends AbstractMultiset<E>
     implements Serializable {
   // TODO(lowasser): consider overhauling this back to Map<E, Integer>
   private transient Map<E, Count> backingMap;
@@ -261,7 +256,6 @@ abstract class AbstractMapBasedMultiset<E extends @Nullable Object> extends Abst
    * @throws IllegalArgumentException if the call would result in more than {@link
    *     Integer#MAX_VALUE} occurrences of {@code element} in this multiset.
    */
-  @CanIgnoreReturnValue
   @Override
   public int add(@ParametricNullness E element, int occurrences) {
     if (occurrences == 0) {
@@ -283,7 +277,6 @@ abstract class AbstractMapBasedMultiset<E extends @Nullable Object> extends Abst
     return oldCount;
   }
 
-  @CanIgnoreReturnValue
   @Override
   public int remove(@CheckForNull Object element, int occurrences) {
     if (occurrences == 0) {
@@ -311,7 +304,6 @@ abstract class AbstractMapBasedMultiset<E extends @Nullable Object> extends Abst
   }
 
   // Roughly a 33% performance improvement over AbstractMultiset.setCount().
-  @CanIgnoreReturnValue
   @Override
   public int setCount(@ParametricNullness E element, int count) {
     checkNonnegative(count, "count");
@@ -343,11 +335,11 @@ abstract class AbstractMapBasedMultiset<E extends @Nullable Object> extends Abst
   }
 
   // Don't allow default serialization.
-  @GwtIncompatible // java.io.ObjectStreamException
+  // java.io.ObjectStreamException
   private void readObjectNoData() throws ObjectStreamException {
     throw new InvalidObjectException("Stream data required");
   }
 
-  @GwtIncompatible // not needed in emulated source.
+  // not needed in emulated source.
   private static final long serialVersionUID = -2250766705698539974L;
 }
diff --git a/guava/src/com/google/common/collect/AbstractMapEntry.java b/guava/src/com/google/common/collect/AbstractMapEntry.java
index e9accf0592..9ef13e58be 100644
--- a/guava/src/com/google/common/collect/AbstractMapEntry.java
+++ b/guava/src/com/google/common/collect/AbstractMapEntry.java
@@ -16,11 +16,9 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Objects;
 import java.util.Map.Entry;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of the {@code equals}, {@code hashCode}, and {@code toString} methods of {@code
@@ -28,9 +26,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @author Jared Levy
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-abstract class AbstractMapEntry<K extends @Nullable Object, V extends @Nullable Object>
+abstract class AbstractMapEntry<K extends Object, V extends Object>
     implements Entry<K, V> {
 
   @Override
diff --git a/guava/src/com/google/common/collect/AbstractMultimap.java b/guava/src/com/google/common/collect/AbstractMultimap.java
index 299decbe6e..720a2699a5 100644
--- a/guava/src/com/google/common/collect/AbstractMultimap.java
+++ b/guava/src/com/google/common/collect/AbstractMultimap.java
@@ -18,10 +18,6 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.concurrent.LazyInit;
-import com.google.j2objc.annotations.WeakOuter;
 import java.util.AbstractCollection;
 import java.util.Collection;
 import java.util.Iterator;
@@ -31,16 +27,14 @@ import java.util.Set;
 import java.util.Spliterator;
 import java.util.Spliterators;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A skeleton {@code Multimap} implementation, not necessarily in terms of a {@code Map}.
  *
  * @author Louis Wasserman
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-abstract class AbstractMultimap<K extends @Nullable Object, V extends @Nullable Object>
+abstract class AbstractMultimap<K extends Object, V extends Object>
     implements Multimap<K, V> {
   @Override
   public boolean isEmpty() {
@@ -64,20 +58,17 @@ abstract class AbstractMultimap<K extends @Nullable Object, V extends @Nullable
     return collection != null && collection.contains(value);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public boolean remove(@CheckForNull Object key, @CheckForNull Object value) {
     Collection<V> collection = asMap().get(key);
     return collection != null && collection.remove(value);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public boolean put(@ParametricNullness K key, @ParametricNullness V value) {
     return get(key).add(value);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public boolean putAll(@ParametricNullness K key, Iterable<? extends V> values) {
     checkNotNull(values);
@@ -92,7 +83,6 @@ abstract class AbstractMultimap<K extends @Nullable Object, V extends @Nullable
     }
   }
 
-  @CanIgnoreReturnValue
   @Override
   public boolean putAll(Multimap<? extends K, ? extends V> multimap) {
     boolean changed = false;
@@ -102,7 +92,6 @@ abstract class AbstractMultimap<K extends @Nullable Object, V extends @Nullable
     return changed;
   }
 
-  @CanIgnoreReturnValue
   @Override
   public Collection<V> replaceValues(@ParametricNullness K key, Iterable<? extends V> values) {
     checkNotNull(values);
@@ -111,7 +100,7 @@ abstract class AbstractMultimap<K extends @Nullable Object, V extends @Nullable
     return result;
   }
 
-  @LazyInit @CheckForNull private transient Collection<Entry<K, V>> entries;
+  @CheckForNull private transient Collection<Entry<K, V>> entries;
 
   @Override
   public Collection<Entry<K, V>> entries() {
@@ -121,7 +110,6 @@ abstract class AbstractMultimap<K extends @Nullable Object, V extends @Nullable
 
   abstract Collection<Entry<K, V>> createEntries();
 
-  @WeakOuter
   class Entries extends Multimaps.Entries<K, V> {
     @Override
     Multimap<K, V> multimap() {
@@ -139,7 +127,6 @@ abstract class AbstractMultimap<K extends @Nullable Object, V extends @Nullable
     }
   }
 
-  @WeakOuter
   class EntrySet extends Entries implements Set<Entry<K, V>> {
     @Override
     public int hashCode() {
@@ -159,7 +146,7 @@ abstract class AbstractMultimap<K extends @Nullable Object, V extends @Nullable
         entryIterator(), size(), (this instanceof SetMultimap) ? Spliterator.DISTINCT : 0);
   }
 
-  @LazyInit @CheckForNull private transient Set<K> keySet;
+  @CheckForNull private transient Set<K> keySet;
 
   @Override
   public Set<K> keySet() {
@@ -169,7 +156,7 @@ abstract class AbstractMultimap<K extends @Nullable Object, V extends @Nullable
 
   abstract Set<K> createKeySet();
 
-  @LazyInit @CheckForNull private transient Multiset<K> keys;
+  @CheckForNull private transient Multiset<K> keys;
 
   @Override
   public Multiset<K> keys() {
@@ -179,7 +166,7 @@ abstract class AbstractMultimap<K extends @Nullable Object, V extends @Nullable
 
   abstract Multiset<K> createKeys();
 
-  @LazyInit @CheckForNull private transient Collection<V> values;
+  @CheckForNull private transient Collection<V> values;
 
   @Override
   public Collection<V> values() {
@@ -189,7 +176,6 @@ abstract class AbstractMultimap<K extends @Nullable Object, V extends @Nullable
 
   abstract Collection<V> createValues();
 
-  @WeakOuter
   class Values extends AbstractCollection<V> {
     @Override
     public Iterator<V> iterator() {
@@ -225,7 +211,7 @@ abstract class AbstractMultimap<K extends @Nullable Object, V extends @Nullable
     return Spliterators.spliterator(valueIterator(), size(), 0);
   }
 
-  @LazyInit @CheckForNull private transient Map<K, Collection<V>> asMap;
+  @CheckForNull private transient Map<K, Collection<V>> asMap;
 
   @Override
   public Map<K, Collection<V>> asMap() {
diff --git a/guava/src/com/google/common/collect/AbstractMultiset.java b/guava/src/com/google/common/collect/AbstractMultiset.java
index 8203e44598..c3132d2e12 100644
--- a/guava/src/com/google/common/collect/AbstractMultiset.java
+++ b/guava/src/com/google/common/collect/AbstractMultiset.java
@@ -18,16 +18,11 @@ package com.google.common.collect;
 
 import static com.google.common.collect.Multisets.setCountImpl;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.concurrent.LazyInit;
-import com.google.j2objc.annotations.WeakOuter;
 import java.util.AbstractCollection;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.Set;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * This class provides a skeletal implementation of the {@link Multiset} interface. A new multiset
@@ -42,9 +37,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kevin Bourrillion
  * @author Louis Wasserman
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-abstract class AbstractMultiset<E extends @Nullable Object> extends AbstractCollection<E>
+abstract class AbstractMultiset<E extends Object> extends AbstractCollection<E>
     implements Multiset<E> {
   // Query Operations
 
@@ -59,38 +53,32 @@ abstract class AbstractMultiset<E extends @Nullable Object> extends AbstractColl
   }
 
   // Modification Operations
-  @CanIgnoreReturnValue
   @Override
   public final boolean add(@ParametricNullness E element) {
     add(element, 1);
     return true;
   }
 
-  @CanIgnoreReturnValue
   @Override
   public int add(@ParametricNullness E element, int occurrences) {
     throw new UnsupportedOperationException();
   }
 
-  @CanIgnoreReturnValue
   @Override
   public final boolean remove(@CheckForNull Object element) {
     return remove(element, 1) > 0;
   }
 
-  @CanIgnoreReturnValue
   @Override
   public int remove(@CheckForNull Object element, int occurrences) {
     throw new UnsupportedOperationException();
   }
 
-  @CanIgnoreReturnValue
   @Override
   public int setCount(@ParametricNullness E element, int count) {
     return setCountImpl(this, element, count);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public boolean setCount(@ParametricNullness E element, int oldCount, int newCount) {
     return setCountImpl(this, element, oldCount, newCount);
@@ -104,19 +92,16 @@ abstract class AbstractMultiset<E extends @Nullable Object> extends AbstractColl
    * <p>This implementation is highly efficient when {@code elementsToAdd} is itself a {@link
    * Multiset}.
    */
-  @CanIgnoreReturnValue
   @Override
   public final boolean addAll(Collection<? extends E> elementsToAdd) {
     return Multisets.addAllImpl(this, elementsToAdd);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public final boolean removeAll(Collection<?> elementsToRemove) {
     return Multisets.removeAllImpl(this, elementsToRemove);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public final boolean retainAll(Collection<?> elementsToRetain) {
     return Multisets.retainAllImpl(this, elementsToRetain);
@@ -127,7 +112,7 @@ abstract class AbstractMultiset<E extends @Nullable Object> extends AbstractColl
 
   // Views
 
-  @LazyInit @CheckForNull private transient Set<E> elementSet;
+  @CheckForNull private transient Set<E> elementSet;
 
   @Override
   public Set<E> elementSet() {
@@ -146,7 +131,6 @@ abstract class AbstractMultiset<E extends @Nullable Object> extends AbstractColl
     return new ElementSet();
   }
 
-  @WeakOuter
   class ElementSet extends Multisets.ElementSet<E> {
     @Override
     Multiset<E> multiset() {
@@ -161,7 +145,7 @@ abstract class AbstractMultiset<E extends @Nullable Object> extends AbstractColl
 
   abstract Iterator<E> elementIterator();
 
-  @LazyInit @CheckForNull private transient Set<Entry<E>> entrySet;
+  @CheckForNull private transient Set<Entry<E>> entrySet;
 
   @Override
   public Set<Entry<E>> entrySet() {
@@ -172,7 +156,6 @@ abstract class AbstractMultiset<E extends @Nullable Object> extends AbstractColl
     return result;
   }
 
-  @WeakOuter
   class EntrySet extends Multisets.EntrySet<E> {
     @Override
     Multiset<E> multiset() {
diff --git a/guava/src/com/google/common/collect/AbstractNavigableMap.java b/guava/src/com/google/common/collect/AbstractNavigableMap.java
index 47048d06ac..d08ec666b3 100644
--- a/guava/src/com/google/common/collect/AbstractNavigableMap.java
+++ b/guava/src/com/google/common/collect/AbstractNavigableMap.java
@@ -16,7 +16,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.Maps.IteratorBasedAbstractMap;
 import java.util.Iterator;
 import java.util.NavigableMap;
@@ -25,16 +24,14 @@ import java.util.NoSuchElementException;
 import java.util.Set;
 import java.util.SortedMap;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Skeletal implementation of {@link NavigableMap}.
  *
  * @author Louis Wasserman
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
-abstract class AbstractNavigableMap<K extends @Nullable Object, V extends @Nullable Object>
+abstract class AbstractNavigableMap<K extends Object, V extends Object>
     extends IteratorBasedAbstractMap<K, V> implements NavigableMap<K, V> {
 
   @Override
diff --git a/guava/src/com/google/common/collect/AbstractRangeSet.java b/guava/src/com/google/common/collect/AbstractRangeSet.java
index d112a11f18..545b73b537 100644
--- a/guava/src/com/google/common/collect/AbstractRangeSet.java
+++ b/guava/src/com/google/common/collect/AbstractRangeSet.java
@@ -14,7 +14,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtIncompatible;
 import javax.annotation.CheckForNull;
 
 /**
@@ -22,7 +21,6 @@ import javax.annotation.CheckForNull;
  *
  * @author Louis Wasserman
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 abstract class AbstractRangeSet<C extends Comparable> implements RangeSet<C> {
   AbstractRangeSet() {}
diff --git a/guava/src/com/google/common/collect/AbstractSequentialIterator.java b/guava/src/com/google/common/collect/AbstractSequentialIterator.java
index 172fe356cb..db1ab50449 100644
--- a/guava/src/com/google/common/collect/AbstractSequentialIterator.java
+++ b/guava/src/com/google/common/collect/AbstractSequentialIterator.java
@@ -16,7 +16,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.NoSuchElementException;
 import javax.annotation.CheckForNull;
 
@@ -39,7 +38,6 @@ import javax.annotation.CheckForNull;
  * @author Chris Povirk
  * @since 12.0 (in Guava as {@code AbstractLinkedIterator} since 8.0)
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public abstract class AbstractSequentialIterator<T> extends UnmodifiableIterator<T> {
   @CheckForNull private T nextOrNull;
diff --git a/guava/src/com/google/common/collect/AbstractSetMultimap.java b/guava/src/com/google/common/collect/AbstractSetMultimap.java
index 90aa9dcb2f..a642da18b7 100644
--- a/guava/src/com/google/common/collect/AbstractSetMultimap.java
+++ b/guava/src/com/google/common/collect/AbstractSetMultimap.java
@@ -16,15 +16,12 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Basic implementation of the {@link SetMultimap} interface. It's a wrapper around {@link
@@ -33,9 +30,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @author Jared Levy
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-abstract class AbstractSetMultimap<K extends @Nullable Object, V extends @Nullable Object>
+abstract class AbstractSetMultimap<K extends Object, V extends Object>
     extends AbstractMapBasedMultimap<K, V> implements SetMultimap<K, V> {
   /**
    * Creates a new multimap that uses the provided map.
@@ -55,7 +51,7 @@ abstract class AbstractSetMultimap<K extends @Nullable Object, V extends @Nullab
   }
 
   @Override
-  <E extends @Nullable Object> Collection<E> unmodifiableCollectionSubclass(
+  <E extends Object> Collection<E> unmodifiableCollectionSubclass(
       Collection<E> collection) {
     return Collections.unmodifiableSet((Set<E>) collection);
   }
@@ -95,7 +91,6 @@ abstract class AbstractSetMultimap<K extends @Nullable Object, V extends @Nullab
    * <p>Because a {@code SetMultimap} has unique values for a given key, this method returns a
    * {@link Set}, instead of the {@link Collection} specified in the {@link Multimap} interface.
    */
-  @CanIgnoreReturnValue
   @Override
   public Set<V> removeAll(@CheckForNull Object key) {
     return (Set<V>) super.removeAll(key);
@@ -109,7 +104,6 @@ abstract class AbstractSetMultimap<K extends @Nullable Object, V extends @Nullab
    *
    * <p>Any duplicates in {@code values} will be stored in the multimap once.
    */
-  @CanIgnoreReturnValue
   @Override
   public Set<V> replaceValues(@ParametricNullness K key, Iterable<? extends V> values) {
     return (Set<V>) super.replaceValues(key, values);
@@ -134,7 +128,6 @@ abstract class AbstractSetMultimap<K extends @Nullable Object, V extends @Nullab
    * @return {@code true} if the method increased the size of the multimap, or {@code false} if the
    *     multimap already contained the key-value pair
    */
-  @CanIgnoreReturnValue
   @Override
   public boolean put(@ParametricNullness K key, @ParametricNullness V value) {
     return super.put(key, value);
diff --git a/guava/src/com/google/common/collect/AbstractSortedKeySortedSetMultimap.java b/guava/src/com/google/common/collect/AbstractSortedKeySortedSetMultimap.java
index 676936f057..a170b45f66 100644
--- a/guava/src/com/google/common/collect/AbstractSortedKeySortedSetMultimap.java
+++ b/guava/src/com/google/common/collect/AbstractSortedKeySortedSetMultimap.java
@@ -16,12 +16,10 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.Collection;
 import java.util.Set;
 import java.util.SortedMap;
 import java.util.SortedSet;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Basic implementation of a {@link SortedSetMultimap} with a sorted key set.
@@ -31,10 +29,9 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @author Louis Wasserman
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 abstract class AbstractSortedKeySortedSetMultimap<
-        K extends @Nullable Object, V extends @Nullable Object>
+        K extends Object, V extends Object>
     extends AbstractSortedSetMultimap<K, V> {
 
   AbstractSortedKeySortedSetMultimap(SortedMap<K, Collection<V>> map) {
diff --git a/guava/src/com/google/common/collect/AbstractSortedMultiset.java b/guava/src/com/google/common/collect/AbstractSortedMultiset.java
index fd4fce202a..c76a5b758e 100644
--- a/guava/src/com/google/common/collect/AbstractSortedMultiset.java
+++ b/guava/src/com/google/common/collect/AbstractSortedMultiset.java
@@ -16,13 +16,10 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.j2objc.annotations.WeakOuter;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.NavigableSet;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * This class provides a skeletal implementation of the {@link SortedMultiset} interface.
@@ -33,9 +30,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @author Louis Wasserman
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
-abstract class AbstractSortedMultiset<E extends @Nullable Object> extends AbstractMultiset<E>
+abstract class AbstractSortedMultiset<E extends Object> extends AbstractMultiset<E>
     implements SortedMultiset<E> {
   @GwtTransient final Comparator<? super E> comparator;
 
@@ -131,7 +127,6 @@ abstract class AbstractSortedMultiset<E extends @Nullable Object> extends Abstra
   }
 
   SortedMultiset<E> createDescendingMultiset() {
-    @WeakOuter
     class DescendingMultisetImpl extends DescendingMultiset<E> {
       @Override
       SortedMultiset<E> forwardMultiset() {
diff --git a/guava/src/com/google/common/collect/AbstractSortedSetMultimap.java b/guava/src/com/google/common/collect/AbstractSortedSetMultimap.java
index 32316133a0..a075ad18ee 100644
--- a/guava/src/com/google/common/collect/AbstractSortedSetMultimap.java
+++ b/guava/src/com/google/common/collect/AbstractSortedSetMultimap.java
@@ -16,15 +16,12 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Map;
 import java.util.NavigableSet;
 import java.util.SortedSet;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Basic implementation of the {@link SortedSetMultimap} interface. It's a wrapper around {@link
@@ -33,9 +30,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @author Jared Levy
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-abstract class AbstractSortedSetMultimap<K extends @Nullable Object, V extends @Nullable Object>
+abstract class AbstractSortedSetMultimap<K extends Object, V extends Object>
     extends AbstractSetMultimap<K, V> implements SortedSetMultimap<K, V> {
   /**
    * Creates a new multimap that uses the provided map.
@@ -55,7 +51,7 @@ abstract class AbstractSortedSetMultimap<K extends @Nullable Object, V extends @
   }
 
   @Override
-  <E extends @Nullable Object> SortedSet<E> unmodifiableCollectionSubclass(
+  <E extends Object> SortedSet<E> unmodifiableCollectionSubclass(
       Collection<E> collection) {
     if (collection instanceof NavigableSet) {
       return Sets.unmodifiableNavigableSet((NavigableSet<E>) collection);
@@ -97,7 +93,6 @@ abstract class AbstractSortedSetMultimap<K extends @Nullable Object, V extends @
    * returns a {@link SortedSet}, instead of the {@link Collection} specified in the {@link
    * Multimap} interface.
    */
-  @CanIgnoreReturnValue
   @Override
   public SortedSet<V> removeAll(@CheckForNull Object key) {
     return (SortedSet<V>) super.removeAll(key);
@@ -113,7 +108,6 @@ abstract class AbstractSortedSetMultimap<K extends @Nullable Object, V extends @
    *
    * <p>Any duplicates in {@code values} will be stored in the multimap once.
    */
-  @CanIgnoreReturnValue
   @Override
   public SortedSet<V> replaceValues(@ParametricNullness K key, Iterable<? extends V> values) {
     return (SortedSet<V>) super.replaceValues(key, values);
diff --git a/guava/src/com/google/common/collect/AbstractTable.java b/guava/src/com/google/common/collect/AbstractTable.java
index 99a1215906..be99b965dd 100644
--- a/guava/src/com/google/common/collect/AbstractTable.java
+++ b/guava/src/com/google/common/collect/AbstractTable.java
@@ -14,10 +14,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.concurrent.LazyInit;
-import com.google.j2objc.annotations.WeakOuter;
 import java.util.AbstractCollection;
 import java.util.AbstractSet;
 import java.util.Collection;
@@ -26,17 +22,15 @@ import java.util.Map;
 import java.util.Set;
 import java.util.Spliterator;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Skeletal, implementation-agnostic implementation of the {@link Table} interface.
  *
  * @author Louis Wasserman
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 abstract class AbstractTable<
-        R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object>
+        R extends Object, C extends Object, V extends Object>
     implements Table<R, C, V> {
 
   @Override
@@ -92,7 +86,6 @@ abstract class AbstractTable<
     Iterators.clear(cellSet().iterator());
   }
 
-  @CanIgnoreReturnValue
   @Override
   @CheckForNull
   public V remove(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
@@ -100,7 +93,6 @@ abstract class AbstractTable<
     return (row == null) ? null : Maps.safeRemove(row, columnKey);
   }
 
-  @CanIgnoreReturnValue
   @Override
   @CheckForNull
   public V put(
@@ -115,7 +107,7 @@ abstract class AbstractTable<
     }
   }
 
-  @LazyInit @CheckForNull private transient Set<Cell<R, C, V>> cellSet;
+  @CheckForNull private transient Set<Cell<R, C, V>> cellSet;
 
   @Override
   public Set<Cell<R, C, V>> cellSet() {
@@ -131,7 +123,6 @@ abstract class AbstractTable<
 
   abstract Spliterator<Table.Cell<R, C, V>> cellSpliterator();
 
-  @WeakOuter
   class CellSet extends AbstractSet<Cell<R, C, V>> {
     @Override
     public boolean contains(@CheckForNull Object o) {
@@ -178,7 +169,7 @@ abstract class AbstractTable<
     }
   }
 
-  @LazyInit @CheckForNull private transient Collection<V> values;
+  @CheckForNull private transient Collection<V> values;
 
   @Override
   public Collection<V> values() {
@@ -204,7 +195,6 @@ abstract class AbstractTable<
     return CollectSpliterators.map(cellSpliterator(), Table.Cell::getValue);
   }
 
-  @WeakOuter
   class Values extends AbstractCollection<V> {
     @Override
     public Iterator<V> iterator() {
diff --git a/guava/src/com/google/common/collect/AllEqualOrdering.java b/guava/src/com/google/common/collect/AllEqualOrdering.java
index f6ca6faff7..9a0ded5263 100644
--- a/guava/src/com/google/common/collect/AllEqualOrdering.java
+++ b/guava/src/com/google/common/collect/AllEqualOrdering.java
@@ -16,20 +16,17 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 import java.util.List;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An ordering that treats all references as equals, even nulls.
  *
  * @author Emily Soldal
  */
-@GwtCompatible(serializable = true)
 @ElementTypesAreNonnullByDefault
-final class AllEqualOrdering extends Ordering<@Nullable Object> implements Serializable {
+final class AllEqualOrdering extends Ordering<Object> implements Serializable {
   static final AllEqualOrdering INSTANCE = new AllEqualOrdering();
 
   @Override
@@ -38,19 +35,19 @@ final class AllEqualOrdering extends Ordering<@Nullable Object> implements Seria
   }
 
   @Override
-  public <E extends @Nullable Object> List<E> sortedCopy(Iterable<E> iterable) {
+  public <E extends Object> List<E> sortedCopy(Iterable<E> iterable) {
     return Lists.newArrayList(iterable);
   }
 
   @Override
   @SuppressWarnings("nullness") // unsafe: see supertype
-  public <E extends @Nullable Object> ImmutableList<E> immutableSortedCopy(Iterable<E> iterable) {
+  public <E extends Object> ImmutableList<E> immutableSortedCopy(Iterable<E> iterable) {
     return ImmutableList.copyOf(iterable);
   }
 
   @SuppressWarnings("unchecked")
   @Override
-  public <S extends @Nullable Object> Ordering<S> reverse() {
+  public <S extends Object> Ordering<S> reverse() {
     return (Ordering<S>) this;
   }
 
diff --git a/guava/src/com/google/common/collect/ArrayListMultimap.java b/guava/src/com/google/common/collect/ArrayListMultimap.java
index c8f7106d87..78e42d623a 100644
--- a/guava/src/com/google/common/collect/ArrayListMultimap.java
+++ b/guava/src/com/google/common/collect/ArrayListMultimap.java
@@ -18,9 +18,6 @@ package com.google.common.collect;
 
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
@@ -29,7 +26,6 @@ import java.util.Collection;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@code Multimap} that uses an {@code ArrayList} to store the values for a given
@@ -59,14 +55,13 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Jared Levy
  * @since 2.0
  */
-@GwtCompatible(serializable = true, emulated = true)
 @ElementTypesAreNonnullByDefault
-public final class ArrayListMultimap<K extends @Nullable Object, V extends @Nullable Object>
+public final class ArrayListMultimap<K extends Object, V extends Object>
     extends ArrayListMultimapGwtSerializationDependencies<K, V> {
   // Default from ArrayList
   private static final int DEFAULT_VALUES_PER_KEY = 3;
 
-  @VisibleForTesting transient int expectedValuesPerKey;
+  transient int expectedValuesPerKey;
 
   /**
    * Creates a new, empty {@code ArrayListMultimap} with the default initial capacities.
@@ -74,7 +69,7 @@ public final class ArrayListMultimap<K extends @Nullable Object, V extends @Null
    * <p>This method will soon be deprecated in favor of {@code
    * MultimapBuilder.hashKeys().arrayListValues().build()}.
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       ArrayListMultimap<K, V> create() {
     return new ArrayListMultimap<>();
   }
@@ -91,7 +86,7 @@ public final class ArrayListMultimap<K extends @Nullable Object, V extends @Null
    * @throws IllegalArgumentException if {@code expectedKeys} or {@code expectedValuesPerKey} is
    *     negative
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       ArrayListMultimap<K, V> create(int expectedKeys, int expectedValuesPerKey) {
     return new ArrayListMultimap<>(expectedKeys, expectedValuesPerKey);
   }
@@ -104,7 +99,7 @@ public final class ArrayListMultimap<K extends @Nullable Object, V extends @Null
    *
    * @param multimap the multimap whose contents are copied to this multimap
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       ArrayListMultimap<K, V> create(Multimap<? extends K, ? extends V> multimap) {
     return new ArrayListMultimap<>(multimap);
   }
@@ -155,13 +150,13 @@ public final class ArrayListMultimap<K extends @Nullable Object, V extends @Null
    * @serialData expectedValuesPerKey, number of distinct keys, and then for each distinct key: the
    *     key, number of values for that key, and the key's values
    */
-  @GwtIncompatible // java.io.ObjectOutputStream
+  // java.io.ObjectOutputStream
   private void writeObject(ObjectOutputStream stream) throws IOException {
     stream.defaultWriteObject();
     Serialization.writeMultimap(this, stream);
   }
 
-  @GwtIncompatible // java.io.ObjectOutputStream
+  // java.io.ObjectOutputStream
   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
     stream.defaultReadObject();
     expectedValuesPerKey = DEFAULT_VALUES_PER_KEY;
@@ -171,6 +166,6 @@ public final class ArrayListMultimap<K extends @Nullable Object, V extends @Null
     Serialization.populateMultimap(this, stream, distinctKeys);
   }
 
-  @GwtIncompatible // Not needed in emulated source.
+  // Not needed in emulated source.
   private static final long serialVersionUID = 0;
 }
diff --git a/guava/src/com/google/common/collect/ArrayListMultimapGwtSerializationDependencies.java b/guava/src/com/google/common/collect/ArrayListMultimapGwtSerializationDependencies.java
index 9a8cdfbdbd..15220cfeb9 100644
--- a/guava/src/com/google/common/collect/ArrayListMultimapGwtSerializationDependencies.java
+++ b/guava/src/com/google/common/collect/ArrayListMultimapGwtSerializationDependencies.java
@@ -16,7 +16,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.Collection;
 import java.util.Map;
 
@@ -29,7 +28,6 @@ import java.util.Map;
  *
  * <p>TODO(cpovirk): Consider applying this subclass approach to our other types.
  */
-@GwtCompatible(emulated = true)
 abstract class ArrayListMultimapGwtSerializationDependencies<K, V>
     extends AbstractListMultimap<K, V> {
   ArrayListMultimapGwtSerializationDependencies(Map<K, Collection<V>> map) {
diff --git a/guava/src/com/google/common/collect/ArrayTable.java b/guava/src/com/google/common/collect/ArrayTable.java
index 01652c5ff5..4c8fe6669c 100644
--- a/guava/src/com/google/common/collect/ArrayTable.java
+++ b/guava/src/com/google/common/collect/ArrayTable.java
@@ -21,14 +21,8 @@ import static com.google.common.base.Preconditions.checkElementIndex;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static java.util.Collections.emptyMap;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Objects;
 import com.google.common.collect.Maps.IteratorBasedAbstractMap;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotCall;
-import com.google.j2objc.annotations.WeakOuter;
 import java.io.Serializable;
 import java.lang.reflect.Array;
 import java.util.Arrays;
@@ -38,7 +32,6 @@ import java.util.Map;
 import java.util.Set;
 import java.util.Spliterator;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Fixed-size {@link Table} implementation backed by a two-dimensional array.
@@ -89,10 +82,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Jared Levy
  * @since 10.0
  */
-@Beta
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
-public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
+public final class ArrayTable<R, C, V> extends AbstractTable<R, C, V>
     implements Serializable {
 
   /**
@@ -133,7 +124,7 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
    *
    * @throws NullPointerException if {@code table} has a null key
    */
-  public static <R, C, V> ArrayTable<R, C, V> create(Table<R, C, ? extends @Nullable V> table) {
+  public static <R, C, V> ArrayTable<R, C, V> create(Table<R, C, ? extends V> table) {
     return (table instanceof ArrayTable)
         ? new ArrayTable<R, C, V>((ArrayTable<R, C, V>) table)
         : new ArrayTable<R, C, V>(table);
@@ -145,7 +136,7 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
   // TODO(jlevy): Add getters returning rowKeyToIndex and columnKeyToIndex?
   private final ImmutableMap<R, Integer> rowKeyToIndex;
   private final ImmutableMap<C, Integer> columnKeyToIndex;
-  private final @Nullable V[][] array;
+  private final V[][] array;
 
   private ArrayTable(Iterable<? extends R> rowKeys, Iterable<? extends C> columnKeys) {
     this.rowList = ImmutableList.copyOf(rowKeys);
@@ -162,14 +153,13 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
     columnKeyToIndex = Maps.indexMap(columnList);
 
     @SuppressWarnings("unchecked")
-    @Nullable
-    V[][] tmpArray = (@Nullable V[][]) new Object[rowList.size()][columnList.size()];
+    V[][] tmpArray = (V[][]) new Object[rowList.size()][columnList.size()];
     array = tmpArray;
     // Necessary because in GWT the arrays are initialized with "undefined" instead of null.
     eraseAll();
   }
 
-  private ArrayTable(Table<R, C, ? extends @Nullable V> table) {
+  private ArrayTable(Table<R, C, ? extends V> table) {
     this(table.rowKeySet(), table.columnKeySet());
     putAll(table);
   }
@@ -180,15 +170,14 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
     rowKeyToIndex = table.rowKeyToIndex;
     columnKeyToIndex = table.columnKeyToIndex;
     @SuppressWarnings("unchecked")
-    @Nullable
-    V[][] copy = (@Nullable V[][]) new Object[rowList.size()][columnList.size()];
+    V[][] copy = (V[][]) new Object[rowList.size()][columnList.size()];
     array = copy;
     for (int i = 0; i < rowList.size(); i++) {
       System.arraycopy(table.array[i], 0, copy[i], 0, table.array[i].length);
     }
   }
 
-  private abstract static class ArrayMap<K, V extends @Nullable Object>
+  private abstract static class ArrayMap<K, V extends Object>
       extends IteratorBasedAbstractMap<K, V> {
     private final ImmutableMap<K, Integer> keyIndex;
 
@@ -350,7 +339,6 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
    *     or equal to the number of allowed row keys, or {@code columnIndex} is greater than or equal
    *     to the number of allowed column keys
    */
-  @CanIgnoreReturnValue
   @CheckForNull
   public V set(int rowIndex, int columnIndex, @CheckForNull V value) {
     // In GWT array access never throws IndexOutOfBoundsException.
@@ -370,11 +358,10 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
    *
    * @param valueClass class of values stored in the returned array
    */
-  @GwtIncompatible // reflection
-  public @Nullable V[][] toArray(Class<V> valueClass) {
+  // reflection
+  public V[][] toArray(Class<V> valueClass) {
     @SuppressWarnings("unchecked") // TODO: safe?
-    @Nullable
-    V[][] copy = (@Nullable V[][]) Array.newInstance(valueClass, rowList.size(), columnList.size());
+    V[][] copy = (V[][]) Array.newInstance(valueClass, rowList.size(), columnList.size());
     for (int i = 0; i < rowList.size(); i++) {
       System.arraycopy(array[i], 0, copy[i], 0, array[i].length);
     }
@@ -387,7 +374,6 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
    * @throws UnsupportedOperationException always
    * @deprecated Use {@link #eraseAll}
    */
-  @DoNotCall("Always throws UnsupportedOperationException")
   @Override
   @Deprecated
   public void clear() {
@@ -396,7 +382,7 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
 
   /** Associates the value {@code null} with every pair of allowed row and column keys. */
   public void eraseAll() {
-    for (@Nullable V[] row : array) {
+    for (V[] row : array) {
       Arrays.fill(row, null);
     }
   }
@@ -430,7 +416,7 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
 
   @Override
   public boolean containsValue(@CheckForNull Object value) {
-    for (@Nullable V[] row : array) {
+    for (V[] row : array) {
       for (V element : row) {
         if (Objects.equal(value, element)) {
           return true;
@@ -462,7 +448,6 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
    * @throws IllegalArgumentException if {@code rowKey} is not in {@link #rowKeySet()} or {@code
    *     columnKey} is not in {@link #columnKeySet()}.
    */
-  @CanIgnoreReturnValue
   @Override
   @CheckForNull
   public V put(R rowKey, C columnKey, @CheckForNull V value) {
@@ -491,7 +476,7 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
    *     in {@link #rowKeySet()} or {@link #columnKeySet()}
    */
   @Override
-  public void putAll(Table<? extends R, ? extends C, ? extends @Nullable V> table) {
+  public void putAll(Table<? extends R, ? extends C, ? extends V> table) {
     super.putAll(table);
   }
 
@@ -501,8 +486,6 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
    * @throws UnsupportedOperationException always
    * @deprecated Use {@link #erase}
    */
-  @DoNotCall("Always throws UnsupportedOperationException")
-  @CanIgnoreReturnValue
   @Override
   @Deprecated
   @CheckForNull
@@ -523,7 +506,6 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
    * @return the value previously associated with the keys, or {@code null} if no mapping existed
    *     for the keys
    */
-  @CanIgnoreReturnValue
   @CheckForNull
   public V erase(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
     Integer rowIndex = rowKeyToIndex.get(rowKey);
@@ -553,28 +535,28 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
    * @return set of table cells consisting of row key / column key / value triplets
    */
   @Override
-  public Set<Cell<R, C, @Nullable V>> cellSet() {
+  public Set<Cell<R, C, V>> cellSet() {
     return super.cellSet();
   }
 
   @Override
-  Iterator<Cell<R, C, @Nullable V>> cellIterator() {
-    return new AbstractIndexedListIterator<Cell<R, C, @Nullable V>>(size()) {
+  Iterator<Cell<R, C, V>> cellIterator() {
+    return new AbstractIndexedListIterator<Cell<R, C, V>>(size()) {
       @Override
-      protected Cell<R, C, @Nullable V> get(final int index) {
+      protected Cell<R, C, V> get(final int index) {
         return getCell(index);
       }
     };
   }
 
   @Override
-  Spliterator<Cell<R, C, @Nullable V>> cellSpliterator() {
-    return CollectSpliterators.<Cell<R, C, @Nullable V>>indexed(
+  Spliterator<Cell<R, C, V>> cellSpliterator() {
+    return CollectSpliterators.<Cell<R, C, V>>indexed(
         size(), Spliterator.ORDERED | Spliterator.NONNULL | Spliterator.DISTINCT, this::getCell);
   }
 
-  private Cell<R, C, @Nullable V> getCell(final int index) {
-    return new Tables.AbstractCell<R, C, @Nullable V>() {
+  private Cell<R, C, V> getCell(final int index) {
+    return new Tables.AbstractCell<R, C, V>() {
       final int rowIndex = index / columnList.size();
       final int columnIndex = index % columnList.size();
 
@@ -615,7 +597,7 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
    * @return the corresponding map from row keys to values
    */
   @Override
-  public Map<R, @Nullable V> column(C columnKey) {
+  public Map<R, V> column(C columnKey) {
     checkNotNull(columnKey);
     Integer columnIndex = columnKeyToIndex.get(columnKey);
     if (columnIndex == null) {
@@ -625,7 +607,7 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
     }
   }
 
-  private class Column extends ArrayMap<R, @Nullable V> {
+  private class Column extends ArrayMap<R, V> {
     final int columnIndex;
 
     Column(int columnIndex) {
@@ -665,13 +647,12 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
   @CheckForNull private transient ColumnMap columnMap;
 
   @Override
-  public Map<C, Map<R, @Nullable V>> columnMap() {
+  public Map<C, Map<R, V>> columnMap() {
     ColumnMap map = columnMap;
     return (map == null) ? columnMap = new ColumnMap() : map;
   }
 
-  @WeakOuter
-  private class ColumnMap extends ArrayMap<C, Map<R, @Nullable V>> {
+  private class ColumnMap extends ArrayMap<C, Map<R, V>> {
     private ColumnMap() {
       super(columnKeyToIndex);
     }
@@ -682,18 +663,18 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
     }
 
     @Override
-    Map<R, @Nullable V> getValue(int index) {
+    Map<R, V> getValue(int index) {
       return new Column(index);
     }
 
     @Override
-    Map<R, @Nullable V> setValue(int index, Map<R, @Nullable V> newValue) {
+    Map<R, V> setValue(int index, Map<R, V> newValue) {
       throw new UnsupportedOperationException();
     }
 
     @Override
     @CheckForNull
-    public Map<R, @Nullable V> put(C key, Map<R, @Nullable V> value) {
+    public Map<R, V> put(C key, Map<R, V> value) {
       throw new UnsupportedOperationException();
     }
   }
@@ -710,7 +691,7 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
    * @return the corresponding map from column keys to values
    */
   @Override
-  public Map<C, @Nullable V> row(R rowKey) {
+  public Map<C, V> row(R rowKey) {
     checkNotNull(rowKey);
     Integer rowIndex = rowKeyToIndex.get(rowKey);
     if (rowIndex == null) {
@@ -720,7 +701,7 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
     }
   }
 
-  private class Row extends ArrayMap<C, @Nullable V> {
+  private class Row extends ArrayMap<C, V> {
     final int rowIndex;
 
     Row(int rowIndex) {
@@ -760,13 +741,12 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
   @CheckForNull private transient RowMap rowMap;
 
   @Override
-  public Map<R, Map<C, @Nullable V>> rowMap() {
+  public Map<R, Map<C, V>> rowMap() {
     RowMap map = rowMap;
     return (map == null) ? rowMap = new RowMap() : map;
   }
 
-  @WeakOuter
-  private class RowMap extends ArrayMap<R, Map<C, @Nullable V>> {
+  private class RowMap extends ArrayMap<R, Map<C, V>> {
     private RowMap() {
       super(rowKeyToIndex);
     }
@@ -777,18 +757,18 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
     }
 
     @Override
-    Map<C, @Nullable V> getValue(int index) {
+    Map<C, V> getValue(int index) {
       return new Row(index);
     }
 
     @Override
-    Map<C, @Nullable V> setValue(int index, Map<C, @Nullable V> newValue) {
+    Map<C, V> setValue(int index, Map<C, V> newValue) {
       throw new UnsupportedOperationException();
     }
 
     @Override
     @CheckForNull
-    public Map<C, @Nullable V> put(R key, Map<C, @Nullable V> value) {
+    public Map<C, V> put(R key, Map<C, V> value) {
       throw new UnsupportedOperationException();
     }
   }
@@ -803,13 +783,13 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
    * @return collection of values
    */
   @Override
-  public Collection<@Nullable V> values() {
+  public Collection<V> values() {
     return super.values();
   }
 
   @Override
-  Iterator<@Nullable V> valuesIterator() {
-    return new AbstractIndexedListIterator<@Nullable V>(size()) {
+  Iterator<V> valuesIterator() {
+    return new AbstractIndexedListIterator<V>(size()) {
       @Override
       @CheckForNull
       protected V get(int index) {
@@ -819,8 +799,8 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
   }
 
   @Override
-  Spliterator<@Nullable V> valuesSpliterator() {
-    return CollectSpliterators.<@Nullable V>indexed(size(), Spliterator.ORDERED, this::getValue);
+  Spliterator<V> valuesSpliterator() {
+    return CollectSpliterators.<V>indexed(size(), Spliterator.ORDERED, this::getValue);
   }
 
   private static final long serialVersionUID = 0;
diff --git a/guava/src/com/google/common/collect/BaseImmutableMultimap.java b/guava/src/com/google/common/collect/BaseImmutableMultimap.java
index 2e69c2a92e..d212bf4136 100644
--- a/guava/src/com/google/common/collect/BaseImmutableMultimap.java
+++ b/guava/src/com/google/common/collect/BaseImmutableMultimap.java
@@ -15,12 +15,10 @@
  */
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 
 /**
  * A dummy superclass of {@link ImmutableMultimap} that can be instanceof'd without ProGuard
  * retaining additional implementation details of {@link ImmutableMultimap}.
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 abstract class BaseImmutableMultimap<K, V> extends AbstractMultimap<K, V> {}
diff --git a/guava/src/com/google/common/collect/BiMap.java b/guava/src/com/google/common/collect/BiMap.java
index 12eb4e3e1b..eb7d89134c 100644
--- a/guava/src/com/google/common/collect/BiMap.java
+++ b/guava/src/com/google/common/collect/BiMap.java
@@ -16,12 +16,9 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A bimap (or "bidirectional map") is a map that preserves the uniqueness of its values as well as
@@ -34,9 +31,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kevin Bourrillion
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public interface BiMap<K extends @Nullable Object, V extends @Nullable Object> extends Map<K, V> {
+public interface BiMap<K extends Object, V extends Object> extends Map<K, V> {
   // Modification Operations
 
   /**
@@ -46,7 +42,6 @@ public interface BiMap<K extends @Nullable Object, V extends @Nullable Object> e
    *     bimap. The bimap will remain unmodified in this event. To avoid this exception, call {@link
    *     #forcePut} instead.
    */
-  @CanIgnoreReturnValue
   @Override
   @CheckForNull
   V put(@ParametricNullness K key, @ParametricNullness V value);
@@ -69,7 +64,6 @@ public interface BiMap<K extends @Nullable Object, V extends @Nullable Object> e
    *     put}, returns {@code null} both if the key is absent and if it is present with a null
    *     value.)
    */
-  @CanIgnoreReturnValue
   @CheckForNull
   V forcePut(@ParametricNullness K key, @ParametricNullness V value);
 
diff --git a/guava/src/com/google/common/collect/BoundType.java b/guava/src/com/google/common/collect/BoundType.java
index 00ac08c518..1387a45c8b 100644
--- a/guava/src/com/google/common/collect/BoundType.java
+++ b/guava/src/com/google/common/collect/BoundType.java
@@ -14,7 +14,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 
 /**
  * Indicates whether an endpoint of some range is contained in the range itself ("closed") or not
@@ -23,7 +22,6 @@ import com.google.common.annotations.GwtCompatible;
  *
  * @since 10.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public enum BoundType {
   /** The endpoint value <i>is not</i> considered part of the set ("exclusive"). */
diff --git a/guava/src/com/google/common/collect/ByFunctionOrdering.java b/guava/src/com/google/common/collect/ByFunctionOrdering.java
index 43ebdddf62..82cff0d129 100644
--- a/guava/src/com/google/common/collect/ByFunctionOrdering.java
+++ b/guava/src/com/google/common/collect/ByFunctionOrdering.java
@@ -18,20 +18,17 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Function;
 import com.google.common.base.Objects;
 import java.io.Serializable;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An ordering that orders elements by applying an order to the result of a function on those
  * elements.
  */
-@GwtCompatible(serializable = true)
 @ElementTypesAreNonnullByDefault
-final class ByFunctionOrdering<F extends @Nullable Object, T extends @Nullable Object>
+final class ByFunctionOrdering<F extends Object, T extends Object>
     extends Ordering<F> implements Serializable {
   final Function<F, ? extends T> function;
   final Ordering<T> ordering;
diff --git a/guava/src/com/google/common/collect/CartesianList.java b/guava/src/com/google/common/collect/CartesianList.java
index 475b3f2ec0..bf290a00a6 100644
--- a/guava/src/com/google/common/collect/CartesianList.java
+++ b/guava/src/com/google/common/collect/CartesianList.java
@@ -16,7 +16,6 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkElementIndex;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.math.IntMath;
 import java.util.AbstractList;
 import java.util.List;
@@ -29,7 +28,6 @@ import javax.annotation.CheckForNull;
  *
  * @author Louis Wasserman
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 final class CartesianList<E> extends AbstractList<List<E>> implements RandomAccess {
 
diff --git a/guava/src/com/google/common/collect/ClassToInstanceMap.java b/guava/src/com/google/common/collect/ClassToInstanceMap.java
index 9bd826fd92..c6b0da4db2 100644
--- a/guava/src/com/google/common/collect/ClassToInstanceMap.java
+++ b/guava/src/com/google/common/collect/ClassToInstanceMap.java
@@ -16,9 +16,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotMock;
 import java.util.Map;
 import javax.annotation.CheckForNull;
 
@@ -52,8 +49,6 @@ import javax.annotation.CheckForNull;
  * @author Kevin Bourrillion
  * @since 2.0
  */
-@DoNotMock("Use ImmutableClassToInstanceMap or MutableClassToInstanceMap")
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 // If we ever support non-null projections (https://github.com/jspecify/jspecify/issues/86), we
 // we might annotate this as...
@@ -75,7 +70,6 @@ public interface ClassToInstanceMap<B> extends Map<Class<? extends B>, B> {
    * @return the value previously associated with this class (possibly {@code null}), or {@code
    *     null} if there was no previous entry.
    */
-  @CanIgnoreReturnValue
   @CheckForNull
   <T extends B> T putInstance(Class<T> type, T value);
 }
diff --git a/guava/src/com/google/common/collect/CollectCollectors.java b/guava/src/com/google/common/collect/CollectCollectors.java
index 63eec1201e..229429f081 100644
--- a/guava/src/com/google/common/collect/CollectCollectors.java
+++ b/guava/src/com/google/common/collect/CollectCollectors.java
@@ -18,8 +18,6 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Preconditions;
 import java.util.Collection;
 import java.util.Comparator;
@@ -35,10 +33,8 @@ import java.util.stream.Collector;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** Collectors utilities for {@code common.collect} internals. */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 final class CollectCollectors {
 
@@ -56,7 +52,6 @@ final class CollectCollectors {
           ImmutableSet.Builder::combine,
           ImmutableSet.Builder::build);
 
-  @GwtIncompatible
   private static final Collector<Range<Comparable<?>>, ?, ImmutableRangeSet<Comparable<?>>>
       TO_IMMUTABLE_RANGE_SET =
           Collector.of(
@@ -131,7 +126,6 @@ final class CollectCollectors {
     }
   }
 
-  @GwtIncompatible
   @SuppressWarnings({"rawtypes", "unchecked"})
   static <E extends Comparable<? super E>>
       Collector<Range<E>, ?, ImmutableRangeSet<E>> toImmutableRangeSet() {
@@ -140,7 +134,7 @@ final class CollectCollectors {
 
   // Multisets
 
-  static <T extends @Nullable Object, E> Collector<T, ?, ImmutableMultiset<E>> toImmutableMultiset(
+  static <T extends Object, E> Collector<T, ?, ImmutableMultiset<E>> toImmutableMultiset(
       Function<? super T, ? extends E> elementFunction, ToIntFunction<? super T> countFunction) {
     checkNotNull(elementFunction);
     checkNotNull(countFunction);
@@ -155,7 +149,7 @@ final class CollectCollectors {
         (Multiset<E> multiset) -> ImmutableMultiset.copyFromEntries(multiset.entrySet()));
   }
 
-  static <T extends @Nullable Object, E extends @Nullable Object, M extends Multiset<E>>
+  static <T extends Object, E extends Object, M extends Multiset<E>>
       Collector<T, ?, M> toMultiset(
           Function<? super T, E> elementFunction,
           ToIntFunction<? super T> countFunction,
@@ -174,7 +168,7 @@ final class CollectCollectors {
 
   // Maps
 
-  static <T extends @Nullable Object, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(
+  static <T extends Object, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(
       Function<? super T, ? extends K> keyFunction,
       Function<? super T, ? extends V> valueFunction) {
     checkNotNull(keyFunction);
@@ -186,7 +180,7 @@ final class CollectCollectors {
         ImmutableMap.Builder::build);
   }
 
-  public static <T extends @Nullable Object, K, V>
+  public static <T extends Object, K, V>
       Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends V> valueFunction,
@@ -199,7 +193,7 @@ final class CollectCollectors {
         ImmutableMap::copyOf);
   }
 
-  static <T extends @Nullable Object, K, V>
+  static <T extends Object, K, V>
       Collector<T, ?, ImmutableSortedMap<K, V>> toImmutableSortedMap(
           Comparator<? super K> comparator,
           Function<? super T, ? extends K> keyFunction,
@@ -219,7 +213,7 @@ final class CollectCollectors {
         Collector.Characteristics.UNORDERED);
   }
 
-  static <T extends @Nullable Object, K, V>
+  static <T extends Object, K, V>
       Collector<T, ?, ImmutableSortedMap<K, V>> toImmutableSortedMap(
           Comparator<? super K> comparator,
           Function<? super T, ? extends K> keyFunction,
@@ -235,7 +229,7 @@ final class CollectCollectors {
         ImmutableSortedMap::copyOfSorted);
   }
 
-  static <T extends @Nullable Object, K, V> Collector<T, ?, ImmutableBiMap<K, V>> toImmutableBiMap(
+  static <T extends Object, K, V> Collector<T, ?, ImmutableBiMap<K, V>> toImmutableBiMap(
       Function<? super T, ? extends K> keyFunction,
       Function<? super T, ? extends V> valueFunction) {
     checkNotNull(keyFunction);
@@ -248,7 +242,7 @@ final class CollectCollectors {
         new Collector.Characteristics[0]);
   }
 
-  static <T extends @Nullable Object, K extends Enum<K>, V>
+  static <T extends Object, K extends Enum<K>, V>
       Collector<T, ?, ImmutableMap<K, V>> toImmutableEnumMap(
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends V> valueFunction) {
@@ -276,7 +270,7 @@ final class CollectCollectors {
         Collector.Characteristics.UNORDERED);
   }
 
-  static <T extends @Nullable Object, K extends Enum<K>, V>
+  static <T extends Object, K extends Enum<K>, V>
       Collector<T, ?, ImmutableMap<K, V>> toImmutableEnumMap(
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends V> valueFunction,
@@ -333,8 +327,7 @@ final class CollectCollectors {
     }
   }
 
-  @GwtIncompatible
-  static <T extends @Nullable Object, K extends Comparable<? super K>, V>
+  static <T extends Object, K extends Comparable<? super K>, V>
       Collector<T, ?, ImmutableRangeMap<K, V>> toImmutableRangeMap(
           Function<? super T, Range<K>> keyFunction,
           Function<? super T, ? extends V> valueFunction) {
@@ -349,7 +342,7 @@ final class CollectCollectors {
 
   // Multimaps
 
-  static <T extends @Nullable Object, K, V>
+  static <T extends Object, K, V>
       Collector<T, ?, ImmutableListMultimap<K, V>> toImmutableListMultimap(
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends V> valueFunction) {
@@ -362,7 +355,7 @@ final class CollectCollectors {
         ImmutableListMultimap.Builder::build);
   }
 
-  static <T extends @Nullable Object, K, V>
+  static <T extends Object, K, V>
       Collector<T, ?, ImmutableListMultimap<K, V>> flatteningToImmutableListMultimap(
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends Stream<? extends V>> valuesFunction) {
@@ -376,7 +369,7 @@ final class CollectCollectors {
         ImmutableListMultimap::copyOf);
   }
 
-  static <T extends @Nullable Object, K, V>
+  static <T extends Object, K, V>
       Collector<T, ?, ImmutableSetMultimap<K, V>> toImmutableSetMultimap(
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends V> valueFunction) {
@@ -389,7 +382,7 @@ final class CollectCollectors {
         ImmutableSetMultimap.Builder::build);
   }
 
-  static <T extends @Nullable Object, K, V>
+  static <T extends Object, K, V>
       Collector<T, ?, ImmutableSetMultimap<K, V>> flatteningToImmutableSetMultimap(
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends Stream<? extends V>> valuesFunction) {
@@ -404,9 +397,9 @@ final class CollectCollectors {
   }
 
   static <
-          T extends @Nullable Object,
-          K extends @Nullable Object,
-          V extends @Nullable Object,
+          T extends Object,
+          K extends Object,
+          V extends Object,
           M extends Multimap<K, V>>
       Collector<T, ?, M> toMultimap(
           Function<? super T, ? extends K> keyFunction,
@@ -425,9 +418,9 @@ final class CollectCollectors {
   }
 
   static <
-          T extends @Nullable Object,
-          K extends @Nullable Object,
-          V extends @Nullable Object,
+          T extends Object,
+          K extends Object,
+          V extends Object,
           M extends Multimap<K, V>>
       Collector<T, ?, M> flatteningToMultimap(
           Function<? super T, ? extends K> keyFunction,
diff --git a/guava/src/com/google/common/collect/CollectPreconditions.java b/guava/src/com/google/common/collect/CollectPreconditions.java
index c649b03233..a9fa1cd0a4 100644
--- a/guava/src/com/google/common/collect/CollectPreconditions.java
+++ b/guava/src/com/google/common/collect/CollectPreconditions.java
@@ -18,11 +18,8 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkState;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 
 /** Precondition checks useful in collection implementations. */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 final class CollectPreconditions {
 
@@ -34,7 +31,6 @@ final class CollectPreconditions {
     }
   }
 
-  @CanIgnoreReturnValue
   static int checkNonnegative(int value, String name) {
     if (value < 0) {
       throw new IllegalArgumentException(name + " cannot be negative but was: " + value);
@@ -42,7 +38,6 @@ final class CollectPreconditions {
     return value;
   }
 
-  @CanIgnoreReturnValue
   static long checkNonnegative(long value, String name) {
     if (value < 0) {
       throw new IllegalArgumentException(name + " cannot be negative but was: " + value);
diff --git a/guava/src/com/google/common/collect/CollectSpliterators.java b/guava/src/com/google/common/collect/CollectSpliterators.java
index 91f563dfe1..2b91898b1b 100644
--- a/guava/src/com/google/common/collect/CollectSpliterators.java
+++ b/guava/src/com/google/common/collect/CollectSpliterators.java
@@ -20,8 +20,6 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.j2objc.annotations.Weak;
 import java.util.Comparator;
 import java.util.Spliterator;
 import java.util.function.Consumer;
@@ -33,20 +31,18 @@ import java.util.function.LongConsumer;
 import java.util.function.Predicate;
 import java.util.stream.IntStream;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** Spliterator utilities for {@code common.collect} internals. */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 final class CollectSpliterators {
   private CollectSpliterators() {}
 
-  static <T extends @Nullable Object> Spliterator<T> indexed(
+  static <T extends Object> Spliterator<T> indexed(
       int size, int extraCharacteristics, IntFunction<T> function) {
     return indexed(size, extraCharacteristics, function, null);
   }
 
-  static <T extends @Nullable Object> Spliterator<T> indexed(
+  static <T extends Object> Spliterator<T> indexed(
       int size,
       int extraCharacteristics,
       IntFunction<T> function,
@@ -108,7 +104,7 @@ final class CollectSpliterators {
    * Returns a {@code Spliterator} over the elements of {@code fromSpliterator} mapped by {@code
    * function}.
    */
-  static <InElementT extends @Nullable Object, OutElementT extends @Nullable Object>
+  static <InElementT extends Object, OutElementT extends Object>
       Spliterator<OutElementT> map(
           Spliterator<InElementT> fromSpliterator,
           Function<? super InElementT, ? extends OutElementT> function) {
@@ -148,7 +144,7 @@ final class CollectSpliterators {
   }
 
   /** Returns a {@code Spliterator} filtered by the specified predicate. */
-  static <T extends @Nullable Object> Spliterator<T> filter(
+  static <T extends Object> Spliterator<T> filter(
       Spliterator<T> fromSpliterator, Predicate<? super T> predicate) {
     checkNotNull(fromSpliterator);
     checkNotNull(predicate);
@@ -211,7 +207,7 @@ final class CollectSpliterators {
    * Returns a {@code Spliterator} that iterates over the elements of the spliterators generated by
    * applying {@code function} to the elements of {@code fromSpliterator}.
    */
-  static <InElementT extends @Nullable Object, OutElementT extends @Nullable Object>
+  static <InElementT extends Object, OutElementT extends Object>
       Spliterator<OutElementT> flatMap(
           Spliterator<InElementT> fromSpliterator,
           Function<? super InElementT, Spliterator<OutElementT>> function,
@@ -234,7 +230,7 @@ final class CollectSpliterators {
    * generated by applying {@code function} to the elements of {@code fromSpliterator}. (If {@code
    * function} returns {@code null} for an input, it is replaced with an empty stream.)
    */
-  static <InElementT extends @Nullable Object> Spliterator.OfInt flatMapToInt(
+  static <InElementT extends Object> Spliterator.OfInt flatMapToInt(
       Spliterator<InElementT> fromSpliterator,
       Function<? super InElementT, Spliterator.OfInt> function,
       int topCharacteristics,
@@ -256,7 +252,7 @@ final class CollectSpliterators {
    * generated by applying {@code function} to the elements of {@code fromSpliterator}. (If {@code
    * function} returns {@code null} for an input, it is replaced with an empty stream.)
    */
-  static <InElementT extends @Nullable Object> Spliterator.OfLong flatMapToLong(
+  static <InElementT extends Object> Spliterator.OfLong flatMapToLong(
       Spliterator<InElementT> fromSpliterator,
       Function<? super InElementT, Spliterator.OfLong> function,
       int topCharacteristics,
@@ -278,7 +274,7 @@ final class CollectSpliterators {
    * generated by applying {@code function} to the elements of {@code fromSpliterator}. (If {@code
    * function} returns {@code null} for an input, it is replaced with an empty stream.)
    */
-  static <InElementT extends @Nullable Object> Spliterator.OfDouble flatMapToDouble(
+  static <InElementT extends Object> Spliterator.OfDouble flatMapToDouble(
       Spliterator<InElementT> fromSpliterator,
       Function<? super InElementT, Spliterator.OfDouble> function,
       int topCharacteristics,
@@ -303,13 +299,13 @@ final class CollectSpliterators {
    * @param <OutSpliteratorT> the type of the output spliterators
    */
   abstract static class FlatMapSpliterator<
-          InElementT extends @Nullable Object,
-          OutElementT extends @Nullable Object,
+          InElementT extends Object,
+          OutElementT extends Object,
           OutSpliteratorT extends Spliterator<OutElementT>>
       implements Spliterator<OutElementT> {
     /** Factory for constructing {@link FlatMapSpliterator} instances. */
     @FunctionalInterface
-    interface Factory<InElementT extends @Nullable Object, OutSpliteratorT extends Spliterator<?>> {
+    interface Factory<InElementT extends Object, OutSpliteratorT extends Spliterator<?>> {
       OutSpliteratorT newFlatMapSpliterator(
           @CheckForNull OutSpliteratorT prefix,
           Spliterator<InElementT> fromSplit,
@@ -318,7 +314,7 @@ final class CollectSpliterators {
           long estSplitSize);
     }
 
-    @Weak @CheckForNull OutSpliteratorT prefix;
+    @CheckForNull OutSpliteratorT prefix;
     final Spliterator<InElementT> from;
     final Function<? super InElementT, OutSpliteratorT> function;
     final Factory<InElementT, OutSpliteratorT> factory;
@@ -432,7 +428,7 @@ final class CollectSpliterators {
    * @param <OutElementT> the element type of the output spliterators
    */
   static final class FlatMapSpliteratorOfObject<
-          InElementT extends @Nullable Object, OutElementT extends @Nullable Object>
+          InElementT extends Object, OutElementT extends Object>
       extends FlatMapSpliterator<InElementT, OutElementT, Spliterator<OutElementT>> {
     FlatMapSpliteratorOfObject(
         @CheckForNull Spliterator<OutElementT> prefix,
@@ -454,8 +450,8 @@ final class CollectSpliterators {
    * @param <OutSpliteratorT> the primitive spliterator type associated with {@code OutElementT}
    */
   abstract static class FlatMapSpliteratorOfPrimitive<
-          InElementT extends @Nullable Object,
-          OutElementT extends @Nullable Object,
+          InElementT extends Object,
+          OutElementT extends Object,
           OutConsumerT,
           OutSpliteratorT extends
               Spliterator.OfPrimitive<OutElementT, OutConsumerT, OutSpliteratorT>>
@@ -507,7 +503,7 @@ final class CollectSpliterators {
   }
 
   /** Implementation of {@link #flatMapToInt}. */
-  static final class FlatMapSpliteratorOfInt<InElementT extends @Nullable Object>
+  static final class FlatMapSpliteratorOfInt<InElementT extends Object>
       extends FlatMapSpliteratorOfPrimitive<InElementT, Integer, IntConsumer, Spliterator.OfInt>
       implements Spliterator.OfInt {
     FlatMapSpliteratorOfInt(
@@ -521,7 +517,7 @@ final class CollectSpliterators {
   }
 
   /** Implementation of {@link #flatMapToLong}. */
-  static final class FlatMapSpliteratorOfLong<InElementT extends @Nullable Object>
+  static final class FlatMapSpliteratorOfLong<InElementT extends Object>
       extends FlatMapSpliteratorOfPrimitive<InElementT, Long, LongConsumer, Spliterator.OfLong>
       implements Spliterator.OfLong {
     FlatMapSpliteratorOfLong(
@@ -535,7 +531,7 @@ final class CollectSpliterators {
   }
 
   /** Implementation of {@link #flatMapToDouble}. */
-  static final class FlatMapSpliteratorOfDouble<InElementT extends @Nullable Object>
+  static final class FlatMapSpliteratorOfDouble<InElementT extends Object>
       extends FlatMapSpliteratorOfPrimitive<
           InElementT, Double, DoubleConsumer, Spliterator.OfDouble>
       implements Spliterator.OfDouble {
diff --git a/guava/src/com/google/common/collect/Collections2.java b/guava/src/com/google/common/collect/Collections2.java
index eb928596a3..e2480ed24f 100644
--- a/guava/src/com/google/common/collect/Collections2.java
+++ b/guava/src/com/google/common/collect/Collections2.java
@@ -21,8 +21,6 @@ import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Function;
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
@@ -39,7 +37,6 @@ import java.util.List;
 import java.util.Spliterator;
 import java.util.function.Consumer;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Provides static methods for working with {@code Collection} instances.
@@ -54,7 +51,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Jared Levy
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class Collections2 {
   private Collections2() {}
@@ -86,7 +82,7 @@ public final class Collections2 {
    */
   // TODO(kevinb): how can we omit that Iterables link when building gwt
   // javadoc?
-  public static <E extends @Nullable Object> Collection<E> filter(
+  public static <E extends Object> Collection<E> filter(
       Collection<E> unfiltered, Predicate<? super E> predicate) {
     if (unfiltered instanceof FilteredCollection) {
       // Support clear(), removeAll(), and retainAll() when filtering a filtered
@@ -123,7 +119,7 @@ public final class Collections2 {
     }
   }
 
-  static class FilteredCollection<E extends @Nullable Object> extends AbstractCollection<E> {
+  static class FilteredCollection<E extends Object> extends AbstractCollection<E> {
     final Collection<E> unfiltered;
     final Predicate<? super E> predicate;
 
@@ -230,14 +226,14 @@ public final class Collections2 {
     }
 
     @Override
-    public @Nullable Object[] toArray() {
+    public Object[] toArray() {
       // creating an ArrayList so filtering happens once
       return Lists.newArrayList(iterator()).toArray();
     }
 
     @Override
     @SuppressWarnings("nullness") // b/192354773 in our checker affects toArray declarations
-    public <T extends @Nullable Object> T[] toArray(T[] array) {
+    public <T extends Object> T[] toArray(T[] array) {
       return Lists.newArrayList(iterator()).toArray(array);
     }
   }
@@ -261,12 +257,12 @@ public final class Collections2 {
    *
    * <p><b>{@code Stream} equivalent:</b> {@link java.util.stream.Stream#map Stream.map}.
    */
-  public static <F extends @Nullable Object, T extends @Nullable Object> Collection<T> transform(
+  public static <F extends Object, T extends Object> Collection<T> transform(
       Collection<F> fromCollection, Function<? super F, T> function) {
     return new TransformedCollection<>(fromCollection, function);
   }
 
-  static class TransformedCollection<F extends @Nullable Object, T extends @Nullable Object>
+  static class TransformedCollection<F extends Object, T extends Object>
       extends AbstractCollection<T> {
     final Collection<F> fromCollection;
     final Function<? super F, ? extends T> function;
@@ -380,7 +376,6 @@ public final class Collections2 {
    * @throws NullPointerException if the specified iterable is null or has any null elements.
    * @since 12.0
    */
-  @Beta
   public static <E extends Comparable<? super E>> Collection<List<E>> orderedPermutations(
       Iterable<E> elements) {
     return orderedPermutations(elements, Ordering.natural());
@@ -432,7 +427,6 @@ public final class Collections2 {
    *     the specified comparator is null.
    * @since 12.0
    */
-  @Beta
   public static <E> Collection<List<E>> orderedPermutations(
       Iterable<E> elements, Comparator<? super E> comparator) {
     return new OrderedPermutationCollection<E>(elements, comparator);
@@ -594,7 +588,6 @@ public final class Collections2 {
    * @throws NullPointerException if the specified collection is null or has any null elements.
    * @since 12.0
    */
-  @Beta
   public static <E> Collection<List<E>> permutations(Collection<E> elements) {
     return new PermutationCollection<E>(ImmutableList.copyOf(elements));
   }
diff --git a/guava/src/com/google/common/collect/CompactHashMap.java b/guava/src/com/google/common/collect/CompactHashMap.java
index e40b05edae..421e4b754b 100644
--- a/guava/src/com/google/common/collect/CompactHashMap.java
+++ b/guava/src/com/google/common/collect/CompactHashMap.java
@@ -24,13 +24,9 @@ import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
 import static com.google.common.collect.NullnessCasts.unsafeNull;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Objects;
 import com.google.common.base.Preconditions;
 import com.google.common.primitives.Ints;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.j2objc.annotations.WeakOuter;
 import java.io.IOException;
 import java.io.InvalidObjectException;
 import java.io.ObjectInputStream;
@@ -51,7 +47,6 @@ import java.util.function.BiConsumer;
 import java.util.function.BiFunction;
 import java.util.function.Consumer;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * CompactHashMap is an implementation of a Map. All optional operations (put and remove) are
@@ -79,9 +74,9 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @author Jon Noack
  */
-@GwtIncompatible // not worth using in GWT for now
+// not worth using in GWT for now
 @ElementTypesAreNonnullByDefault
-class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
+class CompactHashMap<K extends Object, V extends Object>
     extends AbstractMap<K, V> implements Serializable {
   /*
    * TODO: Make this a drop-in replacement for j.u. versions, actually drop them in, and test the
@@ -92,7 +87,7 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
    */
 
   /** Creates an empty {@code CompactHashMap} instance. */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       CompactHashMap<K, V> create() {
     return new CompactHashMap<>();
   }
@@ -106,7 +101,7 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
    *     elements without resizing
    * @throws IllegalArgumentException if {@code expectedSize} is negative
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       CompactHashMap<K, V> createWithExpectedSize(int expectedSize) {
     return new CompactHashMap<>(expectedSize);
   }
@@ -117,8 +112,6 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
    * Maximum allowed false positive probability of detecting a hash flooding attack given random
    * input.
    */
-  @VisibleForTesting(
-      )
   static final double HASH_FLOODING_FPP = 0.001;
 
   /**
@@ -203,19 +196,19 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
    *
    * <p>The pointers in [size(), entries.length) are all "null" (UNSET).
    */
-  @VisibleForTesting @CheckForNull transient int[] entries;
+  @CheckForNull transient int[] entries;
 
   /**
    * The keys of the entries in the map, in the range of [0, size()). The keys in [size(),
    * keys.length) are all {@code null}.
    */
-  @VisibleForTesting @CheckForNull transient @Nullable Object[] keys;
+  @CheckForNull transient Object[] keys;
 
   /**
    * The values of the entries in the map, in the range of [0, size()). The values in [size(),
    * values.length) are all {@code null}.
    */
-  @VisibleForTesting @CheckForNull transient @Nullable Object[] values;
+  @CheckForNull transient Object[] values;
 
   /**
    * Keeps track of metadata like the number of hash table bits and modifications of this data
@@ -257,13 +250,11 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
   }
 
   /** Returns whether arrays need to be allocated. */
-  @VisibleForTesting
   boolean needsAllocArrays() {
     return table == null;
   }
 
   /** Handle lazy allocation of arrays. */
-  @CanIgnoreReturnValue
   int allocArrays() {
     Preconditions.checkState(needsAllocArrays(), "Arrays already allocated");
 
@@ -280,7 +271,6 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
   }
 
   @SuppressWarnings("unchecked")
-  @VisibleForTesting
   @CheckForNull
   Map<K, V> delegateOrNull() {
     if (table instanceof Map) {
@@ -293,8 +283,6 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
     return new LinkedHashMap<>(tableSize, 1.0f);
   }
 
-  @VisibleForTesting
-  @CanIgnoreReturnValue
   Map<K, V> convertToHashFloodingResistantImplementation() {
     Map<K, V> newDelegate = createHashFloodingResistantDelegate(hashTableMask() + 1);
     for (int i = firstEntryIndex(); i >= 0; i = getSuccessor(i)) {
@@ -332,7 +320,6 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
     // no-op by default
   }
 
-  @CanIgnoreReturnValue
   @Override
   @CheckForNull
   public V put(@ParametricNullness K key, @ParametricNullness V value) {
@@ -344,8 +331,8 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
       return delegate.put(key, value);
     }
     int[] entries = requireEntries();
-    @Nullable Object[] keys = requireKeys();
-    @Nullable Object[] values = requireValues();
+    Object[] keys = requireKeys();
+    Object[] values = requireValues();
 
     int newEntryIndex = this.size; // current size, and pointer to the entry to be appended
     int newSize = newEntryIndex + 1;
@@ -432,7 +419,6 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
     this.values = Arrays.copyOf(requireValues(), newCapacity);
   }
 
-  @CanIgnoreReturnValue
   private int resizeTable(int oldMask, int newCapacity, int targetHash, int targetEntryIndex) {
     Object newTable = CompactHashing.createTable(newCapacity);
     int newMask = newCapacity - 1;
@@ -523,7 +509,6 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
     return value(index);
   }
 
-  @CanIgnoreReturnValue
   @SuppressWarnings("unchecked") // known to be a V
   @Override
   @CheckForNull
@@ -536,7 +521,7 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
     return (oldValue == NOT_FOUND) ? null : (V) oldValue;
   }
 
-  private @Nullable Object removeHelper(@CheckForNull Object key) {
+  private Object removeHelper(@CheckForNull Object key) {
     if (needsAllocArrays()) {
       return NOT_FOUND;
     }
@@ -569,8 +554,8 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
   void moveLastEntry(int dstIndex, int mask) {
     Object table = requireTable();
     int[] entries = requireEntries();
-    @Nullable Object[] keys = requireKeys();
-    @Nullable Object[] values = requireValues();
+    Object[] keys = requireKeys();
+    Object[] values = requireValues();
     int srcIndex = size() - 1;
     if (dstIndex < srcIndex) {
       // move last entry to deleted spot
@@ -627,7 +612,7 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
     return indexBeforeRemove - 1;
   }
 
-  private abstract class Itr<T extends @Nullable Object> implements Iterator<T> {
+  private abstract class Itr<T extends Object> implements Iterator<T> {
     int expectedMetadata = metadata;
     int currentIndex = firstEntryIndex();
     int indexToRemove = -1;
@@ -698,14 +683,13 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
     return new KeySetView();
   }
 
-  @WeakOuter
   class KeySetView extends Maps.KeySet<K, V> {
     KeySetView() {
       super(CompactHashMap.this);
     }
 
     @Override
-    public @Nullable Object[] toArray() {
+    public Object[] toArray() {
       if (needsAllocArrays()) {
         return new Object[0];
       }
@@ -717,10 +701,10 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
 
     @Override
     @SuppressWarnings("nullness") // b/192354773 in our checker affects toArray declarations
-    public <T extends @Nullable Object> T[] toArray(T[] a) {
+    public <T extends Object> T[] toArray(T[] a) {
       if (needsAllocArrays()) {
         if (a.length > 0) {
-          @Nullable Object[] unsoundlyCovariantArray = a;
+          Object[] unsoundlyCovariantArray = a;
           unsoundlyCovariantArray[0] = null;
         }
         return a;
@@ -808,7 +792,6 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
     return new EntrySetView();
   }
 
-  @WeakOuter
   class EntrySetView extends Maps.EntrySet<K, V> {
     @Override
     Map<K, V> map() {
@@ -991,7 +974,6 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
     return new ValuesView();
   }
 
-  @WeakOuter
   class ValuesView extends Maps.Values<K, V> {
     ValuesView() {
       super(CompactHashMap.this);
@@ -1027,7 +1009,7 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
     }
 
     @Override
-    public @Nullable Object[] toArray() {
+    public Object[] toArray() {
       if (needsAllocArrays()) {
         return new Object[0];
       }
@@ -1039,10 +1021,10 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
 
     @Override
     @SuppressWarnings("nullness") // b/192354773 in our checker affects toArray declarations
-    public <T extends @Nullable Object> T[] toArray(T[] a) {
+    public <T extends Object> T[] toArray(T[] a) {
       if (needsAllocArrays()) {
         if (a.length > 0) {
-          @Nullable Object[] unsoundlyCovariantArray = a;
+          Object[] unsoundlyCovariantArray = a;
           unsoundlyCovariantArray[0] = null;
         }
         return a;
@@ -1162,11 +1144,11 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
     return requireNonNull(entries);
   }
 
-  private @Nullable Object[] requireKeys() {
+  private Object[] requireKeys() {
     return requireNonNull(keys);
   }
 
-  private @Nullable Object[] requireValues() {
+  private Object[] requireValues() {
     return requireNonNull(values);
   }
 
diff --git a/guava/src/com/google/common/collect/CompactHashSet.java b/guava/src/com/google/common/collect/CompactHashSet.java
index 2cfcf0a132..538dc0c54e 100644
--- a/guava/src/com/google/common/collect/CompactHashSet.java
+++ b/guava/src/com/google/common/collect/CompactHashSet.java
@@ -22,12 +22,9 @@ import static com.google.common.collect.CompactHashing.UNSET;
 import static com.google.common.collect.Hashing.smearedHash;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Objects;
 import com.google.common.base.Preconditions;
 import com.google.common.primitives.Ints;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.IOException;
 import java.io.InvalidObjectException;
 import java.io.ObjectInputStream;
@@ -46,7 +43,6 @@ import java.util.Spliterator;
 import java.util.Spliterators;
 import java.util.function.Consumer;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * CompactHashSet is an implementation of a Set. All optional operations (adding and removing) are
@@ -75,13 +71,13 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Dimitris Andreou
  * @author Jon Noack
  */
-@GwtIncompatible // not worth using in GWT for now
+// not worth using in GWT for now
 @ElementTypesAreNonnullByDefault
-class CompactHashSet<E extends @Nullable Object> extends AbstractSet<E> implements Serializable {
+class CompactHashSet<E extends Object> extends AbstractSet<E> implements Serializable {
   // TODO(user): cache all field accesses in local vars
 
   /** Creates an empty {@code CompactHashSet} instance. */
-  public static <E extends @Nullable Object> CompactHashSet<E> create() {
+  public static <E extends Object> CompactHashSet<E> create() {
     return new CompactHashSet<>();
   }
 
@@ -92,7 +88,7 @@ class CompactHashSet<E extends @Nullable Object> extends AbstractSet<E> implemen
    * @param collection the elements that the set should contain
    * @return a new {@code CompactHashSet} containing those elements (minus duplicates)
    */
-  public static <E extends @Nullable Object> CompactHashSet<E> create(
+  public static <E extends Object> CompactHashSet<E> create(
       Collection<? extends E> collection) {
     CompactHashSet<E> set = createWithExpectedSize(collection.size());
     set.addAll(collection);
@@ -107,7 +103,7 @@ class CompactHashSet<E extends @Nullable Object> extends AbstractSet<E> implemen
    * @return a new {@code CompactHashSet} containing those elements (minus duplicates)
    */
   @SafeVarargs
-  public static <E extends @Nullable Object> CompactHashSet<E> create(E... elements) {
+  public static <E extends Object> CompactHashSet<E> create(E... elements) {
     CompactHashSet<E> set = createWithExpectedSize(elements.length);
     Collections.addAll(set, elements);
     return set;
@@ -122,7 +118,7 @@ class CompactHashSet<E extends @Nullable Object> extends AbstractSet<E> implemen
    *     elements without resizing
    * @throws IllegalArgumentException if {@code expectedSize} is negative
    */
-  public static <E extends @Nullable Object> CompactHashSet<E> createWithExpectedSize(
+  public static <E extends Object> CompactHashSet<E> createWithExpectedSize(
       int expectedSize) {
     return new CompactHashSet<>(expectedSize);
   }
@@ -131,8 +127,6 @@ class CompactHashSet<E extends @Nullable Object> extends AbstractSet<E> implemen
    * Maximum allowed false positive probability of detecting a hash flooding attack given random
    * input.
    */
-  @VisibleForTesting(
-      )
   static final double HASH_FLOODING_FPP = 0.001;
 
   /**
@@ -187,7 +181,7 @@ class CompactHashSet<E extends @Nullable Object> extends AbstractSet<E> implemen
    * The elements contained in the set, in the range of [0, size()). The elements in [size(),
    * elements.length) are all {@code null}.
    */
-  @VisibleForTesting @CheckForNull transient @Nullable Object[] elements;
+  @CheckForNull transient Object[] elements;
 
   /**
    * Keeps track of metadata like the number of hash table bits and modifications of this data
@@ -223,13 +217,11 @@ class CompactHashSet<E extends @Nullable Object> extends AbstractSet<E> implemen
   }
 
   /** Returns whether arrays need to be allocated. */
-  @VisibleForTesting
   boolean needsAllocArrays() {
     return table == null;
   }
 
   /** Handle lazy allocation of arrays. */
-  @CanIgnoreReturnValue
   int allocArrays() {
     Preconditions.checkState(needsAllocArrays(), "Arrays already allocated");
 
@@ -245,7 +237,6 @@ class CompactHashSet<E extends @Nullable Object> extends AbstractSet<E> implemen
   }
 
   @SuppressWarnings("unchecked")
-  @VisibleForTesting
   @CheckForNull
   Set<E> delegateOrNull() {
     if (table instanceof Set) {
@@ -258,8 +249,6 @@ class CompactHashSet<E extends @Nullable Object> extends AbstractSet<E> implemen
     return new LinkedHashSet<>(tableSize, 1.0f);
   }
 
-  @VisibleForTesting
-  @CanIgnoreReturnValue
   Set<E> convertToHashFloodingResistantImplementation() {
     Set<E> newDelegate = createHashFloodingResistantDelegate(hashTableMask() + 1);
     for (int i = firstEntryIndex(); i >= 0; i = getSuccessor(i)) {
@@ -272,7 +261,6 @@ class CompactHashSet<E extends @Nullable Object> extends AbstractSet<E> implemen
     return newDelegate;
   }
 
-  @VisibleForTesting
   boolean isUsingHashFloodingResistance() {
     return delegateOrNull() != null;
   }
@@ -293,7 +281,6 @@ class CompactHashSet<E extends @Nullable Object> extends AbstractSet<E> implemen
     metadata += CompactHashing.MODIFICATION_COUNT_INCREMENT;
   }
 
-  @CanIgnoreReturnValue
   @Override
   public boolean add(@ParametricNullness E object) {
     if (needsAllocArrays()) {
@@ -304,7 +291,7 @@ class CompactHashSet<E extends @Nullable Object> extends AbstractSet<E> implemen
       return delegate.add(object);
     }
     int[] entries = requireEntries();
-    @Nullable Object[] elements = requireElements();
+    Object[] elements = requireElements();
 
     int newEntryIndex = this.size; // current size, and pointer to the entry to be appended
     int newSize = newEntryIndex + 1;
@@ -383,7 +370,6 @@ class CompactHashSet<E extends @Nullable Object> extends AbstractSet<E> implemen
     this.elements = Arrays.copyOf(requireElements(), newCapacity);
   }
 
-  @CanIgnoreReturnValue
   private int resizeTable(int oldMask, int newCapacity, int targetHash, int targetEntryIndex) {
     Object newTable = CompactHashing.createTable(newCapacity);
     int newMask = newCapacity - 1;
@@ -448,7 +434,6 @@ class CompactHashSet<E extends @Nullable Object> extends AbstractSet<E> implemen
     return false;
   }
 
-  @CanIgnoreReturnValue
   @Override
   public boolean remove(@CheckForNull Object object) {
     if (needsAllocArrays()) {
@@ -485,7 +470,7 @@ class CompactHashSet<E extends @Nullable Object> extends AbstractSet<E> implemen
   void moveLastEntry(int dstIndex, int mask) {
     Object table = requireTable();
     int[] entries = requireEntries();
-    @Nullable Object[] elements = requireElements();
+    Object[] elements = requireElements();
     int srcIndex = size() - 1;
     if (dstIndex < srcIndex) {
       // move last entry to deleted spot
@@ -627,7 +612,7 @@ class CompactHashSet<E extends @Nullable Object> extends AbstractSet<E> implemen
   }
 
   @Override
-  public @Nullable Object[] toArray() {
+  public Object[] toArray() {
     if (needsAllocArrays()) {
       return new Object[0];
     }
@@ -635,10 +620,9 @@ class CompactHashSet<E extends @Nullable Object> extends AbstractSet<E> implemen
     return (delegate != null) ? delegate.toArray() : Arrays.copyOf(requireElements(), size);
   }
 
-  @CanIgnoreReturnValue
   @Override
   @SuppressWarnings("nullness") // b/192354773 in our checker affects toArray declarations
-  public <T extends @Nullable Object> T[] toArray(T[] a) {
+  public <T extends Object> T[] toArray(T[] a) {
     if (needsAllocArrays()) {
       if (a.length > 0) {
         a[0] = null;
@@ -733,7 +717,7 @@ class CompactHashSet<E extends @Nullable Object> extends AbstractSet<E> implemen
     return requireNonNull(entries);
   }
 
-  private @Nullable Object[] requireElements() {
+  private Object[] requireElements() {
     return requireNonNull(elements);
   }
 
diff --git a/guava/src/com/google/common/collect/CompactHashing.java b/guava/src/com/google/common/collect/CompactHashing.java
index a8fe90214c..edd8e8ec33 100644
--- a/guava/src/com/google/common/collect/CompactHashing.java
+++ b/guava/src/com/google/common/collect/CompactHashing.java
@@ -16,19 +16,16 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Objects;
 import com.google.common.primitives.Ints;
 import java.util.Arrays;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Helper classes and static methods for implementing compact hash-based collections.
  *
  * @author Jon Noack
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 final class CompactHashing {
   private CompactHashing() {}
@@ -162,8 +159,8 @@ final class CompactHashing {
       int mask,
       Object table,
       int[] entries,
-      @Nullable Object[] keys,
-      @CheckForNull @Nullable Object[] values) {
+      Object[] keys,
+      @CheckForNull Object[] values) {
     int hash = Hashing.smearedHash(key);
     int tableIndex = hash & mask;
     int next = tableGet(table, tableIndex);
diff --git a/guava/src/com/google/common/collect/CompactLinkedHashMap.java b/guava/src/com/google/common/collect/CompactLinkedHashMap.java
index 97b3a4b1c3..7fd85fe591 100644
--- a/guava/src/com/google/common/collect/CompactLinkedHashMap.java
+++ b/guava/src/com/google/common/collect/CompactLinkedHashMap.java
@@ -18,10 +18,6 @@ package com.google.common.collect;
 
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.j2objc.annotations.WeakOuter;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.LinkedHashMap;
@@ -30,7 +26,6 @@ import java.util.Set;
 import java.util.Spliterator;
 import java.util.Spliterators;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * CompactLinkedHashMap is an implementation of a Map with insertion or LRU iteration order,
@@ -52,14 +47,14 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @author Louis Wasserman
  */
-@GwtIncompatible // not worth using in GWT for now
+// not worth using in GWT for now
 @ElementTypesAreNonnullByDefault
-class CompactLinkedHashMap<K extends @Nullable Object, V extends @Nullable Object>
+class CompactLinkedHashMap<K extends Object, V extends Object>
     extends CompactHashMap<K, V> {
   // TODO(lowasser): implement removeEldestEntry so this can be used as a drop-in replacement
 
   /** Creates an empty {@code CompactLinkedHashMap} instance. */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       CompactLinkedHashMap<K, V> create() {
     return new CompactLinkedHashMap<>();
   }
@@ -73,7 +68,7 @@ class CompactLinkedHashMap<K extends @Nullable Object, V extends @Nullable Objec
    *     expectedSize} elements without resizing
    * @throws IllegalArgumentException if {@code expectedSize} is negative
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       CompactLinkedHashMap<K, V> createWithExpectedSize(int expectedSize) {
     return new CompactLinkedHashMap<>(expectedSize);
   }
@@ -89,7 +84,7 @@ class CompactLinkedHashMap<K extends @Nullable Object, V extends @Nullable Objec
    * <p>A node with "prev" pointer equal to {@code ENDPOINT} is the first node in the linked list,
    * and a node with "next" pointer equal to {@code ENDPOINT} is the last node.
    */
-  @CheckForNull @VisibleForTesting transient long[] links;
+  @CheckForNull transient long[] links;
 
   /** Pointer to the first node in the linked list, or {@code ENDPOINT} if there are no entries. */
   private transient int firstEntry;
@@ -132,7 +127,6 @@ class CompactLinkedHashMap<K extends @Nullable Object, V extends @Nullable Objec
   }
 
   @Override
-  @CanIgnoreReturnValue
   Map<K, V> convertToHashFloodingResistantImplementation() {
     Map<K, V> result = super.convertToHashFloodingResistantImplementation();
     links = null;
@@ -229,7 +223,6 @@ class CompactLinkedHashMap<K extends @Nullable Object, V extends @Nullable Objec
 
   @Override
   Set<Entry<K, V>> createEntrySet() {
-    @WeakOuter
     class EntrySetImpl extends EntrySetView {
       @Override
       public Spliterator<Entry<K, V>> spliterator() {
@@ -241,16 +234,15 @@ class CompactLinkedHashMap<K extends @Nullable Object, V extends @Nullable Objec
 
   @Override
   Set<K> createKeySet() {
-    @WeakOuter
     class KeySetImpl extends KeySetView {
       @Override
-      public @Nullable Object[] toArray() {
+      public Object[] toArray() {
         return ObjectArrays.toArrayImpl(this);
       }
 
       @Override
       @SuppressWarnings("nullness") // b/192354773 in our checker affects toArray declarations
-      public <T extends @Nullable Object> T[] toArray(T[] a) {
+      public <T extends Object> T[] toArray(T[] a) {
         return ObjectArrays.toArrayImpl(this, a);
       }
 
@@ -264,16 +256,15 @@ class CompactLinkedHashMap<K extends @Nullable Object, V extends @Nullable Objec
 
   @Override
   Collection<V> createValues() {
-    @WeakOuter
     class ValuesImpl extends ValuesView {
       @Override
-      public @Nullable Object[] toArray() {
+      public Object[] toArray() {
         return ObjectArrays.toArrayImpl(this);
       }
 
       @Override
       @SuppressWarnings("nullness") // b/192354773 in our checker affects toArray declarations
-      public <T extends @Nullable Object> T[] toArray(T[] a) {
+      public <T extends Object> T[] toArray(T[] a) {
         return ObjectArrays.toArrayImpl(this, a);
       }
 
diff --git a/guava/src/com/google/common/collect/CompactLinkedHashSet.java b/guava/src/com/google/common/collect/CompactLinkedHashSet.java
index c1d813cdb4..144016ad66 100644
--- a/guava/src/com/google/common/collect/CompactLinkedHashSet.java
+++ b/guava/src/com/google/common/collect/CompactLinkedHashSet.java
@@ -18,8 +18,6 @@ package com.google.common.collect;
 
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
@@ -27,7 +25,6 @@ import java.util.Set;
 import java.util.Spliterator;
 import java.util.Spliterators;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * CompactLinkedHashSet is an implementation of a Set, which a predictable iteration order that
@@ -50,12 +47,12 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @author Louis Wasserman
  */
-@GwtIncompatible // not worth using in GWT for now
+// not worth using in GWT for now
 @ElementTypesAreNonnullByDefault
-class CompactLinkedHashSet<E extends @Nullable Object> extends CompactHashSet<E> {
+class CompactLinkedHashSet<E extends Object> extends CompactHashSet<E> {
 
   /** Creates an empty {@code CompactLinkedHashSet} instance. */
-  public static <E extends @Nullable Object> CompactLinkedHashSet<E> create() {
+  public static <E extends Object> CompactLinkedHashSet<E> create() {
     return new CompactLinkedHashSet<>();
   }
 
@@ -66,7 +63,7 @@ class CompactLinkedHashSet<E extends @Nullable Object> extends CompactHashSet<E>
    * @param collection the elements that the set should contain
    * @return a new {@code CompactLinkedHashSet} containing those elements (minus duplicates)
    */
-  public static <E extends @Nullable Object> CompactLinkedHashSet<E> create(
+  public static <E extends Object> CompactLinkedHashSet<E> create(
       Collection<? extends E> collection) {
     CompactLinkedHashSet<E> set = createWithExpectedSize(collection.size());
     set.addAll(collection);
@@ -81,7 +78,7 @@ class CompactLinkedHashSet<E extends @Nullable Object> extends CompactHashSet<E>
    * @return a new {@code CompactLinkedHashSet} containing those elements (minus duplicates)
    */
   @SafeVarargs
-  public static <E extends @Nullable Object> CompactLinkedHashSet<E> create(E... elements) {
+  public static <E extends Object> CompactLinkedHashSet<E> create(E... elements) {
     CompactLinkedHashSet<E> set = createWithExpectedSize(elements.length);
     Collections.addAll(set, elements);
     return set;
@@ -96,7 +93,7 @@ class CompactLinkedHashSet<E extends @Nullable Object> extends CompactHashSet<E>
    *     expectedSize} elements without resizing
    * @throws IllegalArgumentException if {@code expectedSize} is negative
    */
-  public static <E extends @Nullable Object> CompactLinkedHashSet<E> createWithExpectedSize(
+  public static <E extends Object> CompactLinkedHashSet<E> createWithExpectedSize(
       int expectedSize) {
     return new CompactLinkedHashSet<>(expectedSize);
   }
@@ -149,7 +146,6 @@ class CompactLinkedHashSet<E extends @Nullable Object> extends CompactHashSet<E>
   }
 
   @Override
-  @CanIgnoreReturnValue
   Set<E> convertToHashFloodingResistantImplementation() {
     Set<E> result = super.convertToHashFloodingResistantImplementation();
     this.predecessor = null;
@@ -233,13 +229,13 @@ class CompactLinkedHashSet<E extends @Nullable Object> extends CompactHashSet<E>
   }
 
   @Override
-  public @Nullable Object[] toArray() {
+  public Object[] toArray() {
     return ObjectArrays.toArrayImpl(this);
   }
 
   @Override
   @SuppressWarnings("nullness") // b/192354773 in our checker affects toArray declarations
-  public <T extends @Nullable Object> T[] toArray(T[] a) {
+  public <T extends Object> T[] toArray(T[] a) {
     return ObjectArrays.toArrayImpl(this, a);
   }
 
diff --git a/guava/src/com/google/common/collect/ComparatorOrdering.java b/guava/src/com/google/common/collect/ComparatorOrdering.java
index 8b34070744..83dabe84fe 100644
--- a/guava/src/com/google/common/collect/ComparatorOrdering.java
+++ b/guava/src/com/google/common/collect/ComparatorOrdering.java
@@ -18,16 +18,13 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 import java.util.Comparator;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** An ordering for a pre-existing comparator. */
-@GwtCompatible(serializable = true)
 @ElementTypesAreNonnullByDefault
-final class ComparatorOrdering<T extends @Nullable Object> extends Ordering<T>
+final class ComparatorOrdering<T extends Object> extends Ordering<T>
     implements Serializable {
   final Comparator<T> comparator;
 
diff --git a/guava/src/com/google/common/collect/Comparators.java b/guava/src/com/google/common/collect/Comparators.java
index 1b90fb89c5..dc01edfbb8 100644
--- a/guava/src/com/google/common/collect/Comparators.java
+++ b/guava/src/com/google/common/collect/Comparators.java
@@ -19,14 +19,11 @@ package com.google.common.collect;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Optional;
 import java.util.stream.Collector;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Provides static methods for working with {@link Comparator} instances. For many other helpful
@@ -43,7 +40,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @since 21.0
  * @author Louis Wasserman
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class Comparators {
   private Comparators() {}
@@ -62,8 +58,7 @@ public final class Comparators {
   // Note: 90% of the time we don't add type parameters or wildcards that serve only to "tweak" the
   // desired return type. However, *nested* generics introduce a special class of problems that we
   // think tip it over into being worthwhile.
-  @Beta
-  public static <T extends @Nullable Object, S extends T> Comparator<Iterable<S>> lexicographical(
+  public static <T extends Object, S extends T> Comparator<Iterable<S>> lexicographical(
       Comparator<T> comparator) {
     return new LexicographicalOrdering<S>(checkNotNull(comparator));
   }
@@ -73,8 +68,7 @@ public final class Comparators {
    * equal to the element that preceded it, according to the specified comparator. Note that this is
    * always true when the iterable has fewer than two elements.
    */
-  @Beta
-  public static <T extends @Nullable Object> boolean isInOrder(
+  public static <T extends Object> boolean isInOrder(
       Iterable<? extends T> iterable, Comparator<T> comparator) {
     checkNotNull(comparator);
     Iterator<? extends T> it = iterable.iterator();
@@ -96,8 +90,7 @@ public final class Comparators {
    * greater than the element that preceded it, according to the specified comparator. Note that
    * this is always true when the iterable has fewer than two elements.
    */
-  @Beta
-  public static <T extends @Nullable Object> boolean isInStrictOrder(
+  public static <T extends Object> boolean isInStrictOrder(
       Iterable<? extends T> iterable, Comparator<T> comparator) {
     checkNotNull(comparator);
     Iterator<? extends T> it = iterable.iterator();
@@ -134,7 +127,7 @@ public final class Comparators {
    * @throws IllegalArgumentException if {@code k < 0}
    * @since 22.0
    */
-  public static <T extends @Nullable Object> Collector<T, ?, List<T>> least(
+  public static <T extends Object> Collector<T, ?, List<T>> least(
       int k, Comparator<? super T> comparator) {
     checkNonnegative(k, "k");
     checkNotNull(comparator);
@@ -166,7 +159,7 @@ public final class Comparators {
    * @throws IllegalArgumentException if {@code k < 0}
    * @since 22.0
    */
-  public static <T extends @Nullable Object> Collector<T, ?, List<T>> greatest(
+  public static <T extends Object> Collector<T, ?, List<T>> greatest(
       int k, Comparator<? super T> comparator) {
     return least(k, comparator.reversed());
   }
@@ -178,10 +171,9 @@ public final class Comparators {
    *
    * @since 22.0
    */
-  @Beta
   public static <T> Comparator<Optional<T>> emptiesFirst(Comparator<? super T> valueComparator) {
     checkNotNull(valueComparator);
-    return Comparator.<Optional<T>, @Nullable T>comparing(
+    return Comparator.<Optional<T>, T>comparing(
         o -> o.orElse(null), Comparator.nullsFirst(valueComparator));
   }
 
@@ -192,10 +184,9 @@ public final class Comparators {
    *
    * @since 22.0
    */
-  @Beta
   public static <T> Comparator<Optional<T>> emptiesLast(Comparator<? super T> valueComparator) {
     checkNotNull(valueComparator);
-    return Comparator.<Optional<T>, @Nullable T>comparing(
+    return Comparator.<Optional<T>, T>comparing(
         o -> o.orElse(null), Comparator.nullsLast(valueComparator));
   }
 
@@ -212,7 +203,6 @@ public final class Comparators {
    * @throws ClassCastException if the parameters are not <i>mutually comparable</i>.
    * @since 30.0
    */
-  @Beta
   public static <T extends Comparable<? super T>> T min(T a, T b) {
     return (a.compareTo(b) <= 0) ? a : b;
   }
@@ -232,9 +222,8 @@ public final class Comparators {
    *     comparator.
    * @since 30.0
    */
-  @Beta
   @ParametricNullness
-  public static <T extends @Nullable Object> T min(
+  public static <T extends Object> T min(
       @ParametricNullness T a, @ParametricNullness T b, Comparator<T> comparator) {
     return (comparator.compare(a, b) <= 0) ? a : b;
   }
@@ -252,7 +241,6 @@ public final class Comparators {
    * @throws ClassCastException if the parameters are not <i>mutually comparable</i>.
    * @since 30.0
    */
-  @Beta
   public static <T extends Comparable<? super T>> T max(T a, T b) {
     return (a.compareTo(b) >= 0) ? a : b;
   }
@@ -272,9 +260,8 @@ public final class Comparators {
    *     comparator.
    * @since 30.0
    */
-  @Beta
   @ParametricNullness
-  public static <T extends @Nullable Object> T max(
+  public static <T extends Object> T max(
       @ParametricNullness T a, @ParametricNullness T b, Comparator<T> comparator) {
     return (comparator.compare(a, b) >= 0) ? a : b;
   }
diff --git a/guava/src/com/google/common/collect/ComparisonChain.java b/guava/src/com/google/common/collect/ComparisonChain.java
index 32aeb4d4bb..b7937f0515 100644
--- a/guava/src/com/google/common/collect/ComparisonChain.java
+++ b/guava/src/com/google/common/collect/ComparisonChain.java
@@ -16,12 +16,10 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.primitives.Booleans;
 import com.google.common.primitives.Ints;
 import com.google.common.primitives.Longs;
 import java.util.Comparator;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A utility for performing a chained comparison statement. For example:
@@ -56,7 +54,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kevin Bourrillion
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public abstract class ComparisonChain {
   private ComparisonChain() {}
@@ -75,7 +72,7 @@ public abstract class ComparisonChain {
         }
 
         @Override
-        public <T extends @Nullable Object> ComparisonChain compare(
+        public <T extends Object> ComparisonChain compare(
             @ParametricNullness T left, @ParametricNullness T right, Comparator<T> comparator) {
           return classify(comparator.compare(left, right));
         }
@@ -137,7 +134,7 @@ public abstract class ComparisonChain {
     }
 
     @Override
-    public <T extends @Nullable Object> ComparisonChain compare(
+    public <T extends Object> ComparisonChain compare(
         @ParametricNullness T left, @ParametricNullness T right, Comparator<T> comparator) {
       return this;
     }
@@ -200,7 +197,7 @@ public abstract class ComparisonChain {
    * Compares two objects using a comparator, <i>if</i> the result of this comparison chain has not
    * already been determined.
    */
-  public abstract <T extends @Nullable Object> ComparisonChain compare(
+  public abstract <T extends Object> ComparisonChain compare(
       @ParametricNullness T left, @ParametricNullness T right, Comparator<T> comparator);
 
   /**
diff --git a/guava/src/com/google/common/collect/CompoundOrdering.java b/guava/src/com/google/common/collect/CompoundOrdering.java
index 42feed3731..22f3c5990e 100644
--- a/guava/src/com/google/common/collect/CompoundOrdering.java
+++ b/guava/src/com/google/common/collect/CompoundOrdering.java
@@ -16,17 +16,14 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 import java.util.Arrays;
 import java.util.Comparator;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** An ordering that tries several comparators in order. */
-@GwtCompatible(serializable = true)
 @ElementTypesAreNonnullByDefault
-final class CompoundOrdering<T extends @Nullable Object> extends Ordering<T>
+final class CompoundOrdering<T extends Object> extends Ordering<T>
     implements Serializable {
   final Comparator<? super T>[] comparators;
 
diff --git a/guava/src/com/google/common/collect/ComputationException.java b/guava/src/com/google/common/collect/ComputationException.java
index b05577c412..101d25b149 100644
--- a/guava/src/com/google/common/collect/ComputationException.java
+++ b/guava/src/com/google/common/collect/ComputationException.java
@@ -16,7 +16,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import javax.annotation.CheckForNull;
 
 /**
@@ -33,7 +32,6 @@ import javax.annotation.CheckForNull;
  *     from Guava.)
  */
 @Deprecated
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public class ComputationException extends RuntimeException {
   /** Creates a new instance with the given cause. */
diff --git a/guava/src/com/google/common/collect/ConcurrentHashMultiset.java b/guava/src/com/google/common/collect/ConcurrentHashMultiset.java
index ab03eadd33..435e819ea9 100644
--- a/guava/src/com/google/common/collect/ConcurrentHashMultiset.java
+++ b/guava/src/com/google/common/collect/ConcurrentHashMultiset.java
@@ -21,14 +21,9 @@ import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.Serialization.FieldSetter;
 import com.google.common.math.IntMath;
 import com.google.common.primitives.Ints;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.j2objc.annotations.WeakOuter;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
@@ -42,7 +37,6 @@ import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.atomic.AtomicInteger;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A multiset that supports concurrent modifications and that provides atomic versions of most
@@ -56,7 +50,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author mike nonemacher
  * @since 2.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class ConcurrentHashMultiset<E> extends AbstractMultiset<E> implements Serializable {
 
@@ -119,12 +112,10 @@ public final class ConcurrentHashMultiset<E> extends AbstractMultiset<E> impleme
    * @throws IllegalArgumentException if {@code countMap} is not empty
    * @since 20.0
    */
-  @Beta
   public static <E> ConcurrentHashMultiset<E> create(ConcurrentMap<E, AtomicInteger> countMap) {
     return new ConcurrentHashMultiset<E>(countMap);
   }
 
-  @VisibleForTesting
   ConcurrentHashMultiset(ConcurrentMap<E, AtomicInteger> countMap) {
     checkArgument(countMap.isEmpty(), "the backing map (%s) must be empty", countMap);
     this.countMap = countMap;
@@ -171,7 +162,7 @@ public final class ConcurrentHashMultiset<E> extends AbstractMultiset<E> impleme
 
   @Override
   @SuppressWarnings("nullness") // b/192354773 in our checker affects toArray declarations
-  public <T extends @Nullable Object> T[] toArray(T[] array) {
+  public <T extends Object> T[] toArray(T[] array) {
     return snapshot().toArray(array);
   }
 
@@ -201,7 +192,6 @@ public final class ConcurrentHashMultiset<E> extends AbstractMultiset<E> impleme
    * @throws IllegalArgumentException if {@code occurrences} is negative, or if the resulting amount
    *     would exceed {@link Integer#MAX_VALUE}
    */
-  @CanIgnoreReturnValue
   @Override
   public int add(E element, int occurrences) {
     checkNotNull(element);
@@ -268,7 +258,6 @@ public final class ConcurrentHashMultiset<E> extends AbstractMultiset<E> impleme
    * we'll want to remove @Nullable, add an eager checkNotNull, and loosen up
    * testRemove_nullAllowed.
    */
-  @CanIgnoreReturnValue
   @Override
   public int remove(@CheckForNull Object element, int occurrences) {
     if (occurrences == 0) {
@@ -310,7 +299,6 @@ public final class ConcurrentHashMultiset<E> extends AbstractMultiset<E> impleme
    * @return {@code true} if the removal was possible (including if {@code occurrences} is zero)
    * @throws IllegalArgumentException if {@code occurrences} is negative
    */
-  @CanIgnoreReturnValue
   public boolean removeExactly(@CheckForNull Object element, int occurrences) {
     if (occurrences == 0) {
       return true;
@@ -345,7 +333,6 @@ public final class ConcurrentHashMultiset<E> extends AbstractMultiset<E> impleme
    * @return the count of {@code element} in the multiset before this call
    * @throws IllegalArgumentException if {@code count} is negative
    */
-  @CanIgnoreReturnValue
   @Override
   public int setCount(E element, int count) {
     checkNotNull(element);
@@ -401,7 +388,6 @@ public final class ConcurrentHashMultiset<E> extends AbstractMultiset<E> impleme
    *     method will return {@code true} if the condition was met.
    * @throws IllegalArgumentException if {@code expectedOldCount} or {@code newCount} is negative
    */
-  @CanIgnoreReturnValue
   @Override
   public boolean setCount(E element, int expectedOldCount, int newCount) {
     checkNotNull(element);
@@ -558,7 +544,6 @@ public final class ConcurrentHashMultiset<E> extends AbstractMultiset<E> impleme
     countMap.clear();
   }
 
-  @WeakOuter
   private class EntrySet extends AbstractMultiset<E>.EntrySet {
     @Override
     ConcurrentHashMultiset<E> multiset() {
@@ -577,7 +562,7 @@ public final class ConcurrentHashMultiset<E> extends AbstractMultiset<E> impleme
 
     @Override
     @SuppressWarnings("nullness") // b/192354773 in our checker affects toArray declarations
-    public <T extends @Nullable Object> T[] toArray(T[] array) {
+    public <T extends Object> T[] toArray(T[] array) {
       return snapshot().toArray(array);
     }
 
diff --git a/guava/src/com/google/common/collect/ConsumingQueueIterator.java b/guava/src/com/google/common/collect/ConsumingQueueIterator.java
index 7721e1277c..39e44f999a 100644
--- a/guava/src/com/google/common/collect/ConsumingQueueIterator.java
+++ b/guava/src/com/google/common/collect/ConsumingQueueIterator.java
@@ -16,18 +16,15 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.Queue;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An Iterator implementation which draws elements from a queue, removing them from the queue as it
  * iterates.
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-final class ConsumingQueueIterator<T extends @Nullable Object> extends AbstractIterator<T> {
+final class ConsumingQueueIterator<T extends Object> extends AbstractIterator<T> {
   private final Queue<T> queue;
 
   ConsumingQueueIterator(Queue<T> queue) {
diff --git a/guava/src/com/google/common/collect/ContiguousSet.java b/guava/src/com/google/common/collect/ContiguousSet.java
index cd77042616..44a24f4193 100644
--- a/guava/src/com/google/common/collect/ContiguousSet.java
+++ b/guava/src/com/google/common/collect/ContiguousSet.java
@@ -18,10 +18,6 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.DoNotCall;
 import java.util.Collections;
 import java.util.NoSuchElementException;
 import java.util.Set;
@@ -48,7 +44,6 @@ import java.util.Set;
  * @author Gregory Kick
  * @since 10.0
  */
-@GwtCompatible(emulated = true)
 @SuppressWarnings("rawtypes") // allow ungenerified Comparable types
 @ElementTypesAreNonnullByDefault
 public abstract class ContiguousSet<C extends Comparable> extends ImmutableSortedSet<C> {
@@ -103,7 +98,6 @@ public abstract class ContiguousSet<C extends Comparable> extends ImmutableSorte
    * @throws IllegalArgumentException if {@code lower} is greater than {@code upper}
    * @since 23.0
    */
-  @Beta
   public static ContiguousSet<Integer> closed(int lower, int upper) {
     return create(Range.closed(lower, upper), DiscreteDomain.integers());
   }
@@ -116,7 +110,6 @@ public abstract class ContiguousSet<C extends Comparable> extends ImmutableSorte
    * @throws IllegalArgumentException if {@code lower} is greater than {@code upper}
    * @since 23.0
    */
-  @Beta
   public static ContiguousSet<Long> closed(long lower, long upper) {
     return create(Range.closed(lower, upper), DiscreteDomain.longs());
   }
@@ -129,7 +122,6 @@ public abstract class ContiguousSet<C extends Comparable> extends ImmutableSorte
    * @throws IllegalArgumentException if {@code lower} is greater than {@code upper}
    * @since 23.0
    */
-  @Beta
   public static ContiguousSet<Integer> closedOpen(int lower, int upper) {
     return create(Range.closedOpen(lower, upper), DiscreteDomain.integers());
   }
@@ -142,7 +134,6 @@ public abstract class ContiguousSet<C extends Comparable> extends ImmutableSorte
    * @throws IllegalArgumentException if {@code lower} is greater than {@code upper}
    * @since 23.0
    */
-  @Beta
   public static ContiguousSet<Long> closedOpen(long lower, long upper) {
     return create(Range.closedOpen(lower, upper), DiscreteDomain.longs());
   }
@@ -160,7 +151,7 @@ public abstract class ContiguousSet<C extends Comparable> extends ImmutableSorte
   }
 
   /** @since 12.0 */
-  @GwtIncompatible // NavigableSet
+  // NavigableSet
   @Override
   public ContiguousSet<C> headSet(C toElement, boolean inclusive) {
     return headSetImpl(checkNotNull(toElement), inclusive);
@@ -175,7 +166,7 @@ public abstract class ContiguousSet<C extends Comparable> extends ImmutableSorte
   }
 
   /** @since 12.0 */
-  @GwtIncompatible // NavigableSet
+  // NavigableSet
   @Override
   public ContiguousSet<C> subSet(
       C fromElement, boolean fromInclusive, C toElement, boolean toInclusive) {
@@ -191,7 +182,7 @@ public abstract class ContiguousSet<C extends Comparable> extends ImmutableSorte
   }
 
   /** @since 12.0 */
-  @GwtIncompatible // NavigableSet
+  // NavigableSet
   @Override
   public ContiguousSet<C> tailSet(C fromElement, boolean inclusive) {
     return tailSetImpl(checkNotNull(fromElement), inclusive);
@@ -240,7 +231,7 @@ public abstract class ContiguousSet<C extends Comparable> extends ImmutableSorte
   public abstract Range<C> range(BoundType lowerBoundType, BoundType upperBoundType);
 
   @Override
-  @GwtIncompatible // NavigableSet
+  // NavigableSet
   ImmutableSortedSet<C> createDescendingSet() {
     return new DescendingImmutableSortedSet<C>(this);
   }
@@ -260,7 +251,6 @@ public abstract class ContiguousSet<C extends Comparable> extends ImmutableSorte
    * @deprecated Use {@link #create}.
    */
   @Deprecated
-  @DoNotCall("Always throws UnsupportedOperationException")
   public static <E> ImmutableSortedSet.Builder<E> builder() {
     throw new UnsupportedOperationException();
   }
diff --git a/guava/src/com/google/common/collect/Count.java b/guava/src/com/google/common/collect/Count.java
index 7aa5550801..9b1e17d6aa 100644
--- a/guava/src/com/google/common/collect/Count.java
+++ b/guava/src/com/google/common/collect/Count.java
@@ -14,7 +14,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 import javax.annotation.CheckForNull;
 
@@ -23,7 +22,6 @@ import javax.annotation.CheckForNull;
  *
  * @author Louis Wasserman
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 final class Count implements Serializable {
   private int value;
diff --git a/guava/src/com/google/common/collect/Cut.java b/guava/src/com/google/common/collect/Cut.java
index 4a8d4c7fc1..3aff92cb1a 100644
--- a/guava/src/com/google/common/collect/Cut.java
+++ b/guava/src/com/google/common/collect/Cut.java
@@ -16,7 +16,6 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.primitives.Booleans;
 import java.io.Serializable;
 import java.util.NoSuchElementException;
@@ -31,7 +30,6 @@ import javax.annotation.CheckForNull;
  *
  * @author Kevin Bourrillion
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 abstract class Cut<C extends Comparable> implements Comparable<Cut<C>>, Serializable {
   final C endpoint;
diff --git a/guava/src/com/google/common/collect/DenseImmutableTable.java b/guava/src/com/google/common/collect/DenseImmutableTable.java
index 9de77c57f2..162b8b09a6 100644
--- a/guava/src/com/google/common/collect/DenseImmutableTable.java
+++ b/guava/src/com/google/common/collect/DenseImmutableTable.java
@@ -16,17 +16,11 @@ package com.google.common.collect;
 
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.ImmutableMap.IteratorBasedImmutableMap;
-import com.google.errorprone.annotations.Immutable;
-import com.google.j2objc.annotations.WeakOuter;
 import java.util.Map;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** A {@code RegularImmutableTable} optimized for dense data. */
-@GwtCompatible
-@Immutable(containerOf = {"R", "C", "V"})
 @ElementTypesAreNonnullByDefault
 final class DenseImmutableTable<R, C, V> extends RegularImmutableTable<R, C, V> {
   private final ImmutableMap<R, Integer> rowKeyToIndex;
@@ -41,7 +35,7 @@ final class DenseImmutableTable<R, C, V> extends RegularImmutableTable<R, C, V>
   private final int[] columnCounts;
 
   @SuppressWarnings("Immutable") // We don't modify this after construction.
-  private final @Nullable V[][] values;
+  private final V[][] values;
 
   // For each cell in iteration order, the index of that cell's row key in the row key list.
   @SuppressWarnings("Immutable") // We don't modify this after construction.
@@ -56,8 +50,7 @@ final class DenseImmutableTable<R, C, V> extends RegularImmutableTable<R, C, V>
       ImmutableSet<R> rowSpace,
       ImmutableSet<C> columnSpace) {
     @SuppressWarnings("unchecked")
-    @Nullable
-    V[][] array = (@Nullable V[][]) new Object[rowSpace.size()][columnSpace.size()];
+    V[][] array = (V[][]) new Object[rowSpace.size()][columnSpace.size()];
     this.values = array;
     this.rowKeyToIndex = Maps.indexMap(rowSpace);
     this.columnKeyToIndex = Maps.indexMap(columnSpace);
@@ -196,7 +189,6 @@ final class DenseImmutableTable<R, C, V> extends RegularImmutableTable<R, C, V>
     }
   }
 
-  @WeakOuter
   private final class RowMap extends ImmutableArrayMap<R, ImmutableMap<C, V>> {
     private RowMap() {
       super(rowCounts.length);
@@ -218,7 +210,6 @@ final class DenseImmutableTable<R, C, V> extends RegularImmutableTable<R, C, V>
     }
   }
 
-  @WeakOuter
   private final class ColumnMap extends ImmutableArrayMap<C, ImmutableMap<R, V>> {
     private ColumnMap() {
       super(columnCounts.length);
diff --git a/guava/src/com/google/common/collect/DescendingImmutableSortedMultiset.java b/guava/src/com/google/common/collect/DescendingImmutableSortedMultiset.java
index 181731cc48..26c3e8f060 100644
--- a/guava/src/com/google/common/collect/DescendingImmutableSortedMultiset.java
+++ b/guava/src/com/google/common/collect/DescendingImmutableSortedMultiset.java
@@ -14,7 +14,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtIncompatible;
 import javax.annotation.CheckForNull;
 
 /**
@@ -23,7 +22,6 @@ import javax.annotation.CheckForNull;
  * @author Louis Wasserman
  */
 @SuppressWarnings("serial") // uses writeReplace, not default serialization
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 final class DescendingImmutableSortedMultiset<E> extends ImmutableSortedMultiset<E> {
   private final transient ImmutableSortedMultiset<E> forward;
diff --git a/guava/src/com/google/common/collect/DescendingImmutableSortedSet.java b/guava/src/com/google/common/collect/DescendingImmutableSortedSet.java
index 88c7d6b5cc..75d4bb8cb3 100644
--- a/guava/src/com/google/common/collect/DescendingImmutableSortedSet.java
+++ b/guava/src/com/google/common/collect/DescendingImmutableSortedSet.java
@@ -16,7 +16,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtIncompatible;
 import javax.annotation.CheckForNull;
 
 /**
@@ -24,7 +23,6 @@ import javax.annotation.CheckForNull;
  *
  * @author Louis Wasserman
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 final class DescendingImmutableSortedSet<E> extends ImmutableSortedSet<E> {
   private final ImmutableSortedSet<E> forward;
@@ -66,19 +64,16 @@ final class DescendingImmutableSortedSet<E> extends ImmutableSortedSet<E> {
   }
 
   @Override
-  @GwtIncompatible("NavigableSet")
   public ImmutableSortedSet<E> descendingSet() {
     return forward;
   }
 
   @Override
-  @GwtIncompatible("NavigableSet")
   public UnmodifiableIterator<E> descendingIterator() {
     return forward.iterator();
   }
 
   @Override
-  @GwtIncompatible("NavigableSet")
   ImmutableSortedSet<E> createDescendingSet() {
     throw new AssertionError("should never be called");
   }
diff --git a/guava/src/com/google/common/collect/DescendingMultiset.java b/guava/src/com/google/common/collect/DescendingMultiset.java
index ec5a1d0e36..264dc95479 100644
--- a/guava/src/com/google/common/collect/DescendingMultiset.java
+++ b/guava/src/com/google/common/collect/DescendingMultiset.java
@@ -16,14 +16,11 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.j2objc.annotations.WeakOuter;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.NavigableSet;
 import java.util.Set;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A skeleton implementation of a descending multiset. Only needs {@code forwardMultiset()} and
@@ -31,9 +28,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @author Louis Wasserman
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
-abstract class DescendingMultiset<E extends @Nullable Object> extends ForwardingMultiset<E>
+abstract class DescendingMultiset<E extends Object> extends ForwardingMultiset<E>
     implements SortedMultiset<E> {
   abstract SortedMultiset<E> forwardMultiset();
 
@@ -125,7 +121,6 @@ abstract class DescendingMultiset<E extends @Nullable Object> extends Forwarding
   }
 
   Set<Entry<E>> createEntrySet() {
-    @WeakOuter
     class EntrySetImpl extends Multisets.EntrySet<E> {
       @Override
       Multiset<E> multiset() {
@@ -151,13 +146,13 @@ abstract class DescendingMultiset<E extends @Nullable Object> extends Forwarding
   }
 
   @Override
-  public @Nullable Object[] toArray() {
+  public Object[] toArray() {
     return standardToArray();
   }
 
   @Override
   @SuppressWarnings("nullness") // b/192354773 in our checker affects toArray declarations
-  public <T extends @Nullable Object> T[] toArray(T[] array) {
+  public <T extends Object> T[] toArray(T[] array) {
     return standardToArray(array);
   }
 
diff --git a/guava/src/com/google/common/collect/DiscreteDomain.java b/guava/src/com/google/common/collect/DiscreteDomain.java
index bce7062221..c829d0bc8c 100644
--- a/guava/src/com/google/common/collect/DiscreteDomain.java
+++ b/guava/src/com/google/common/collect/DiscreteDomain.java
@@ -19,9 +19,7 @@ package com.google.common.collect;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.primitives.Ints;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.Serializable;
 import java.math.BigInteger;
 import java.util.NoSuchElementException;
@@ -43,7 +41,6 @@ import javax.annotation.CheckForNull;
  * @author Kevin Bourrillion
  * @since 10.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public abstract class DiscreteDomain<C extends Comparable> {
 
@@ -312,7 +309,6 @@ public abstract class DiscreteDomain<C extends Comparable> {
    * @throws NoSuchElementException if the type has no (practical) minimum value; for example,
    *     {@link java.math.BigInteger}
    */
-  @CanIgnoreReturnValue
   public C minValue() {
     throw new NoSuchElementException();
   }
@@ -328,7 +324,6 @@ public abstract class DiscreteDomain<C extends Comparable> {
    * @throws NoSuchElementException if the type has no (practical) maximum value; for example,
    *     {@link java.math.BigInteger}
    */
-  @CanIgnoreReturnValue
   public C maxValue() {
     throw new NoSuchElementException();
   }
diff --git a/guava/src/com/google/common/collect/ElementTypesAreNonnullByDefault.java b/guava/src/com/google/common/collect/ElementTypesAreNonnullByDefault.java
index e1c640ff5d..f69d83ec3e 100644
--- a/guava/src/com/google/common/collect/ElementTypesAreNonnullByDefault.java
+++ b/guava/src/com/google/common/collect/ElementTypesAreNonnullByDefault.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.ElementType.TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -33,7 +32,6 @@ import javax.annotation.meta.TypeQualifierDefault;
  * unfortunately includes type-variable usages, so we also provide {@link ParametricNullness} to
  * "undo" it as best we can.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target(TYPE)
 @TypeQualifierDefault({FIELD, METHOD, PARAMETER})
diff --git a/guava/src/com/google/common/collect/EmptyContiguousSet.java b/guava/src/com/google/common/collect/EmptyContiguousSet.java
index f4fe33ccac..1e3791247e 100644
--- a/guava/src/com/google/common/collect/EmptyContiguousSet.java
+++ b/guava/src/com/google/common/collect/EmptyContiguousSet.java
@@ -13,8 +13,6 @@
  */
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import java.io.Serializable;
 import java.util.NoSuchElementException;
 import java.util.Set;
@@ -25,7 +23,6 @@ import javax.annotation.CheckForNull;
  *
  * @author Gregory Kick
  */
-@GwtCompatible(emulated = true)
 @SuppressWarnings("rawtypes") // allow ungenerified Comparable types
 @ElementTypesAreNonnullByDefault
 final class EmptyContiguousSet<C extends Comparable> extends ContiguousSet<C> {
@@ -84,7 +81,7 @@ final class EmptyContiguousSet<C extends Comparable> extends ContiguousSet<C> {
     return false;
   }
 
-  @GwtIncompatible // not used by GWT emulation
+  // not used by GWT emulation
   @Override
   int indexOf(@CheckForNull Object target) {
     return -1;
@@ -95,7 +92,7 @@ final class EmptyContiguousSet<C extends Comparable> extends ContiguousSet<C> {
     return Iterators.emptyIterator();
   }
 
-  @GwtIncompatible // NavigableSet
+  // NavigableSet
   @Override
   public UnmodifiableIterator<C> descendingIterator() {
     return Iterators.emptyIterator();
@@ -130,7 +127,7 @@ final class EmptyContiguousSet<C extends Comparable> extends ContiguousSet<C> {
     return false;
   }
 
-  @GwtIncompatible // not used in GWT
+  // not used in GWT
   @Override
   boolean isHashCodeFast() {
     return true;
@@ -141,7 +138,7 @@ final class EmptyContiguousSet<C extends Comparable> extends ContiguousSet<C> {
     return 0;
   }
 
-  @GwtIncompatible // serialization
+  // serialization
   private static final class SerializedForm<C extends Comparable> implements Serializable {
     private final DiscreteDomain<C> domain;
 
@@ -156,13 +153,13 @@ final class EmptyContiguousSet<C extends Comparable> extends ContiguousSet<C> {
     private static final long serialVersionUID = 0;
   }
 
-  @GwtIncompatible // serialization
+  // serialization
   @Override
   Object writeReplace() {
     return new SerializedForm<C>(domain);
   }
 
-  @GwtIncompatible // NavigableSet
+  // NavigableSet
   @Override
   ImmutableSortedSet<C> createDescendingSet() {
     return ImmutableSortedSet.emptySet(Ordering.natural().reverse());
diff --git a/guava/src/com/google/common/collect/EmptyImmutableListMultimap.java b/guava/src/com/google/common/collect/EmptyImmutableListMultimap.java
index 10d030fbda..afd40c3adb 100644
--- a/guava/src/com/google/common/collect/EmptyImmutableListMultimap.java
+++ b/guava/src/com/google/common/collect/EmptyImmutableListMultimap.java
@@ -16,14 +16,12 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 
 /**
  * Implementation of {@link ImmutableListMultimap} with no entries.
  *
  * @author Jared Levy
  */
-@GwtCompatible(serializable = true)
 @ElementTypesAreNonnullByDefault
 class EmptyImmutableListMultimap extends ImmutableListMultimap<Object, Object> {
   static final EmptyImmutableListMultimap INSTANCE = new EmptyImmutableListMultimap();
diff --git a/guava/src/com/google/common/collect/EmptyImmutableSetMultimap.java b/guava/src/com/google/common/collect/EmptyImmutableSetMultimap.java
index bd0a67aa08..cc4afdb6d4 100644
--- a/guava/src/com/google/common/collect/EmptyImmutableSetMultimap.java
+++ b/guava/src/com/google/common/collect/EmptyImmutableSetMultimap.java
@@ -16,14 +16,12 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 
 /**
  * Implementation of {@link ImmutableListMultimap} with no entries.
  *
  * @author Mike Ward
  */
-@GwtCompatible(serializable = true)
 @ElementTypesAreNonnullByDefault
 class EmptyImmutableSetMultimap extends ImmutableSetMultimap<Object, Object> {
   static final EmptyImmutableSetMultimap INSTANCE = new EmptyImmutableSetMultimap();
diff --git a/guava/src/com/google/common/collect/EnumBiMap.java b/guava/src/com/google/common/collect/EnumBiMap.java
index 82aa052d65..e1598a7603 100644
--- a/guava/src/com/google/common/collect/EnumBiMap.java
+++ b/guava/src/com/google/common/collect/EnumBiMap.java
@@ -19,8 +19,6 @@ package com.google.common.collect;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
@@ -37,7 +35,6 @@ import java.util.Map;
  * @author Mike Bostock
  * @since 2.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class EnumBiMap<K extends Enum<K>, V extends Enum<V>> extends AbstractBiMap<K, V> {
   private transient Class<K> keyType;
@@ -118,7 +115,7 @@ public final class EnumBiMap<K extends Enum<K>, V extends Enum<V>> extends Abstr
    * @serialData the key class, value class, number of entries, first key, first value, second key,
    *     second value, and so on.
    */
-  @GwtIncompatible // java.io.ObjectOutputStream
+  // java.io.ObjectOutputStream
   private void writeObject(ObjectOutputStream stream) throws IOException {
     stream.defaultWriteObject();
     stream.writeObject(keyType);
@@ -127,7 +124,7 @@ public final class EnumBiMap<K extends Enum<K>, V extends Enum<V>> extends Abstr
   }
 
   @SuppressWarnings("unchecked") // reading fields populated by writeObject
-  @GwtIncompatible // java.io.ObjectInputStream
+  // java.io.ObjectInputStream
   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
     stream.defaultReadObject();
     keyType = (Class<K>) stream.readObject();
@@ -136,6 +133,6 @@ public final class EnumBiMap<K extends Enum<K>, V extends Enum<V>> extends Abstr
     Serialization.populateMap(this, stream);
   }
 
-  @GwtIncompatible // not needed in emulated source.
+  // not needed in emulated source.
   private static final long serialVersionUID = 0;
 }
diff --git a/guava/src/com/google/common/collect/EnumHashBiMap.java b/guava/src/com/google/common/collect/EnumHashBiMap.java
index f68bc4c200..cf3b633d4b 100644
--- a/guava/src/com/google/common/collect/EnumHashBiMap.java
+++ b/guava/src/com/google/common/collect/EnumHashBiMap.java
@@ -18,9 +18,6 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
@@ -28,7 +25,6 @@ import java.util.EnumMap;
 import java.util.HashMap;
 import java.util.Map;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@code BiMap} backed by an {@code EnumMap} instance for keys-to-values, and a {@code HashMap}
@@ -41,9 +37,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Mike Bostock
  * @since 2.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
-public final class EnumHashBiMap<K extends Enum<K>, V extends @Nullable Object>
+public final class EnumHashBiMap<K extends Enum<K>, V extends Object>
     extends AbstractBiMap<K, V> {
   private transient Class<K> keyType;
 
@@ -52,7 +47,7 @@ public final class EnumHashBiMap<K extends Enum<K>, V extends @Nullable Object>
    *
    * @param keyType the key type
    */
-  public static <K extends Enum<K>, V extends @Nullable Object> EnumHashBiMap<K, V> create(
+  public static <K extends Enum<K>, V extends Object> EnumHashBiMap<K, V> create(
       Class<K> keyType) {
     return new EnumHashBiMap<>(keyType);
   }
@@ -67,7 +62,7 @@ public final class EnumHashBiMap<K extends Enum<K>, V extends @Nullable Object>
    * @throws IllegalArgumentException if map is not an {@code EnumBiMap} or an {@code EnumHashBiMap}
    *     instance and contains no mappings
    */
-  public static <K extends Enum<K>, V extends @Nullable Object> EnumHashBiMap<K, V> create(
+  public static <K extends Enum<K>, V extends Object> EnumHashBiMap<K, V> create(
       Map<K, ? extends V> map) {
     EnumHashBiMap<K, V> bimap = create(EnumBiMap.inferKeyType(map));
     bimap.putAll(map);
@@ -88,7 +83,6 @@ public final class EnumHashBiMap<K extends Enum<K>, V extends @Nullable Object>
     return checkNotNull(key);
   }
 
-  @CanIgnoreReturnValue
   @Override
   @SuppressWarnings("RedundantOverride") // b/192446478: RedundantOverride ignores some annotations.
   // TODO(b/192446998): Remove this override after tools understand nullness better.
@@ -97,7 +91,6 @@ public final class EnumHashBiMap<K extends Enum<K>, V extends @Nullable Object>
     return super.put(key, value);
   }
 
-  @CanIgnoreReturnValue
   @Override
   @SuppressWarnings("RedundantOverride") // b/192446478: RedundantOverride ignores some annotations.
   // TODO(b/192446998): Remove this override after tools understand nullness better.
@@ -115,7 +108,7 @@ public final class EnumHashBiMap<K extends Enum<K>, V extends @Nullable Object>
    * @serialData the key class, number of entries, first key, first value, second key, second value,
    *     and so on.
    */
-  @GwtIncompatible // java.io.ObjectOutputStream
+  // java.io.ObjectOutputStream
   private void writeObject(ObjectOutputStream stream) throws IOException {
     stream.defaultWriteObject();
     stream.writeObject(keyType);
@@ -123,7 +116,7 @@ public final class EnumHashBiMap<K extends Enum<K>, V extends @Nullable Object>
   }
 
   @SuppressWarnings("unchecked") // reading field populated by writeObject
-  @GwtIncompatible // java.io.ObjectInputStream
+  // java.io.ObjectInputStream
   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
     stream.defaultReadObject();
     keyType = (Class<K>) stream.readObject();
@@ -132,6 +125,6 @@ public final class EnumHashBiMap<K extends Enum<K>, V extends @Nullable Object>
     Serialization.populateMap(this, stream);
   }
 
-  @GwtIncompatible // only needed in emulated source.
+  // only needed in emulated source.
   private static final long serialVersionUID = 0;
 }
diff --git a/guava/src/com/google/common/collect/EnumMultiset.java b/guava/src/com/google/common/collect/EnumMultiset.java
index 09dde1b938..ec96d64f25 100644
--- a/guava/src/com/google/common/collect/EnumMultiset.java
+++ b/guava/src/com/google/common/collect/EnumMultiset.java
@@ -19,10 +19,7 @@ import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 import static com.google.common.collect.CollectPreconditions.checkRemove;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.primitives.Ints;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
@@ -44,7 +41,6 @@ import javax.annotation.CheckForNull;
  * @author Jared Levy
  * @since 2.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class EnumMultiset<E extends Enum<E>> extends AbstractMultiset<E>
     implements Serializable {
@@ -136,7 +132,6 @@ public final class EnumMultiset<E extends Enum<E>> extends AbstractMultiset<E>
   }
 
   // Modification Operations
-  @CanIgnoreReturnValue
   @Override
   public int add(E element, int occurrences) {
     checkIsE(element);
@@ -157,7 +152,6 @@ public final class EnumMultiset<E extends Enum<E>> extends AbstractMultiset<E>
   }
 
   // Modification Operations
-  @CanIgnoreReturnValue
   @Override
   public int remove(@CheckForNull Object element, int occurrences) {
     // isActuallyE checks for null, but we check explicitly to help nullness checkers.
@@ -185,7 +179,6 @@ public final class EnumMultiset<E extends Enum<E>> extends AbstractMultiset<E>
   }
 
   // Modification Operations
-  @CanIgnoreReturnValue
   @Override
   public int setCount(E element, int count) {
     checkIsE(element);
@@ -293,7 +286,7 @@ public final class EnumMultiset<E extends Enum<E>> extends AbstractMultiset<E>
     return Multisets.iteratorImpl(this);
   }
 
-  @GwtIncompatible // java.io.ObjectOutputStream
+  // java.io.ObjectOutputStream
   private void writeObject(ObjectOutputStream stream) throws IOException {
     stream.defaultWriteObject();
     stream.writeObject(type);
@@ -304,7 +297,7 @@ public final class EnumMultiset<E extends Enum<E>> extends AbstractMultiset<E>
    * @serialData the {@code Class<E>} for the enum type, the number of distinct elements, the first
    *     element, its count, the second element, its count, and so on
    */
-  @GwtIncompatible // java.io.ObjectInputStream
+  // java.io.ObjectInputStream
   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
     stream.defaultReadObject();
     @SuppressWarnings("unchecked") // reading data stored by writeObject
@@ -315,6 +308,6 @@ public final class EnumMultiset<E extends Enum<E>> extends AbstractMultiset<E>
     Serialization.populateMultiset(this, stream);
   }
 
-  @GwtIncompatible // Not needed in emulated source
+  // Not needed in emulated source
   private static final long serialVersionUID = 0;
 }
diff --git a/guava/src/com/google/common/collect/EvictingQueue.java b/guava/src/com/google/common/collect/EvictingQueue.java
index 45f59f3676..ab5e384815 100644
--- a/guava/src/com/google/common/collect/EvictingQueue.java
+++ b/guava/src/com/google/common/collect/EvictingQueue.java
@@ -19,10 +19,6 @@ package com.google.common.collect;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.VisibleForTesting;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.Serializable;
 import java.util.ArrayDeque;
 import java.util.Collection;
@@ -43,14 +39,12 @@ import java.util.Queue;
  * @author Kurt Alfred Kluever
  * @since 15.0
  */
-@Beta
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class EvictingQueue<E> extends ForwardingQueue<E> implements Serializable {
 
   private final Queue<E> delegate;
 
-  @VisibleForTesting final int maxSize;
+  final int maxSize;
 
   private EvictingQueue(int maxSize) {
     checkArgument(maxSize >= 0, "maxSize (%s) must >= 0", maxSize);
@@ -90,7 +84,6 @@ public final class EvictingQueue<E> extends ForwardingQueue<E> implements Serial
    * @return {@code true} always
    */
   @Override
-  @CanIgnoreReturnValue
   public boolean offer(E e) {
     return add(e);
   }
@@ -102,7 +95,6 @@ public final class EvictingQueue<E> extends ForwardingQueue<E> implements Serial
    * @return {@code true} always
    */
   @Override
-  @CanIgnoreReturnValue
   public boolean add(E e) {
     checkNotNull(e); // check before removing
     if (maxSize == 0) {
@@ -116,7 +108,6 @@ public final class EvictingQueue<E> extends ForwardingQueue<E> implements Serial
   }
 
   @Override
-  @CanIgnoreReturnValue
   public boolean addAll(Collection<? extends E> collection) {
     int size = collection.size();
     if (size >= maxSize) {
diff --git a/guava/src/com/google/common/collect/ExplicitOrdering.java b/guava/src/com/google/common/collect/ExplicitOrdering.java
index 383318af5b..36ae7a7599 100644
--- a/guava/src/com/google/common/collect/ExplicitOrdering.java
+++ b/guava/src/com/google/common/collect/ExplicitOrdering.java
@@ -16,13 +16,11 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 import java.util.List;
 import javax.annotation.CheckForNull;
 
 /** An ordering that compares objects according to a given order. */
-@GwtCompatible(serializable = true)
 @ElementTypesAreNonnullByDefault
 final class ExplicitOrdering<T> extends Ordering<T> implements Serializable {
   final ImmutableMap<T, Integer> rankMap;
diff --git a/guava/src/com/google/common/collect/FilteredEntryMultimap.java b/guava/src/com/google/common/collect/FilteredEntryMultimap.java
index 3ff00b71b7..eac25eba87 100644
--- a/guava/src/com/google/common/collect/FilteredEntryMultimap.java
+++ b/guava/src/com/google/common/collect/FilteredEntryMultimap.java
@@ -21,11 +21,9 @@ import static com.google.common.base.Predicates.in;
 import static com.google.common.base.Predicates.not;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Predicate;
 import com.google.common.collect.Maps.ViewCachingAbstractMap;
-import com.google.j2objc.annotations.WeakOuter;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Iterator;
@@ -34,7 +32,6 @@ import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@link Multimaps#filterEntries(Multimap, Predicate)}.
@@ -42,9 +39,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Jared Levy
  * @author Louis Wasserman
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-class FilteredEntryMultimap<K extends @Nullable Object, V extends @Nullable Object>
+class FilteredEntryMultimap<K extends Object, V extends Object>
     extends AbstractMultimap<K, V> implements FilteredMultimap<K, V> {
   final Multimap<K, V> unfiltered;
   final Predicate<? super Entry<K, V>> predicate;
@@ -86,7 +82,7 @@ class FilteredEntryMultimap<K extends @Nullable Object, V extends @Nullable Obje
     }
   }
 
-  static <E extends @Nullable Object> Collection<E> filterCollection(
+  static <E extends Object> Collection<E> filterCollection(
       Collection<E> collection, Predicate<? super E> predicate) {
     if (collection instanceof Set) {
       return Sets.filter((Set<E>) collection, predicate);
@@ -166,7 +162,6 @@ class FilteredEntryMultimap<K extends @Nullable Object, V extends @Nullable Obje
     return changed;
   }
 
-  @WeakOuter
   class AsMap extends ViewCachingAbstractMap<K, Collection<V>> {
     @Override
     public boolean containsKey(@CheckForNull Object key) {
@@ -220,7 +215,6 @@ class FilteredEntryMultimap<K extends @Nullable Object, V extends @Nullable Obje
 
     @Override
     Set<K> createKeySet() {
-      @WeakOuter
       class KeySetImpl extends Maps.KeySet<K, Collection<V>> {
         KeySetImpl() {
           super(AsMap.this);
@@ -246,7 +240,6 @@ class FilteredEntryMultimap<K extends @Nullable Object, V extends @Nullable Obje
 
     @Override
     Set<Entry<K, Collection<V>>> createEntrySet() {
-      @WeakOuter
       class EntrySetImpl extends Maps.EntrySet<K, Collection<V>> {
         @Override
         Map<K, Collection<V>> map() {
@@ -296,7 +289,6 @@ class FilteredEntryMultimap<K extends @Nullable Object, V extends @Nullable Obje
 
     @Override
     Collection<Collection<V>> createValues() {
-      @WeakOuter
       class ValuesImpl extends Maps.Values<K, Collection<V>> {
         ValuesImpl() {
           super(AsMap.this);
@@ -345,7 +337,6 @@ class FilteredEntryMultimap<K extends @Nullable Object, V extends @Nullable Obje
     return new Keys();
   }
 
-  @WeakOuter
   class Keys extends Multimaps.Keys<K, V> {
     Keys() {
       super(FilteredEntryMultimap.this);
diff --git a/guava/src/com/google/common/collect/FilteredEntrySetMultimap.java b/guava/src/com/google/common/collect/FilteredEntrySetMultimap.java
index 20413f8c40..0f14d3abbc 100644
--- a/guava/src/com/google/common/collect/FilteredEntrySetMultimap.java
+++ b/guava/src/com/google/common/collect/FilteredEntrySetMultimap.java
@@ -16,21 +16,18 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Predicate;
 import java.util.Map.Entry;
 import java.util.Set;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@link Multimaps#filterEntries(SetMultimap, Predicate)}.
  *
  * @author Louis Wasserman
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-final class FilteredEntrySetMultimap<K extends @Nullable Object, V extends @Nullable Object>
+final class FilteredEntrySetMultimap<K extends Object, V extends Object>
     extends FilteredEntryMultimap<K, V> implements FilteredSetMultimap<K, V> {
 
   FilteredEntrySetMultimap(SetMultimap<K, V> unfiltered, Predicate<? super Entry<K, V>> predicate) {
diff --git a/guava/src/com/google/common/collect/FilteredKeyListMultimap.java b/guava/src/com/google/common/collect/FilteredKeyListMultimap.java
index c82c8daf77..e4db0ec194 100644
--- a/guava/src/com/google/common/collect/FilteredKeyListMultimap.java
+++ b/guava/src/com/google/common/collect/FilteredKeyListMultimap.java
@@ -16,20 +16,17 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Predicate;
 import java.util.List;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@link Multimaps#filterKeys(ListMultimap, Predicate)}.
  *
  * @author Louis Wasserman
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-final class FilteredKeyListMultimap<K extends @Nullable Object, V extends @Nullable Object>
+final class FilteredKeyListMultimap<K extends Object, V extends Object>
     extends FilteredKeyMultimap<K, V> implements ListMultimap<K, V> {
   FilteredKeyListMultimap(ListMultimap<K, V> unfiltered, Predicate<? super K> keyPredicate) {
     super(unfiltered, keyPredicate);
diff --git a/guava/src/com/google/common/collect/FilteredKeyMultimap.java b/guava/src/com/google/common/collect/FilteredKeyMultimap.java
index 68fad75b14..e3e81eb0fc 100644
--- a/guava/src/com/google/common/collect/FilteredKeyMultimap.java
+++ b/guava/src/com/google/common/collect/FilteredKeyMultimap.java
@@ -19,10 +19,7 @@ import static com.google.common.base.Preconditions.checkPositionIndex;
 import static java.util.Collections.emptyList;
 import static java.util.Collections.emptySet;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Predicate;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.j2objc.annotations.WeakOuter;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Iterator;
@@ -31,16 +28,14 @@ import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@link Multimaps#filterKeys(Multimap, Predicate)}.
  *
  * @author Louis Wasserman
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-class FilteredKeyMultimap<K extends @Nullable Object, V extends @Nullable Object>
+class FilteredKeyMultimap<K extends Object, V extends Object>
     extends AbstractMultimap<K, V> implements FilteredMultimap<K, V> {
   final Multimap<K, V> unfiltered;
   final Predicate<? super K> keyPredicate;
@@ -113,7 +108,7 @@ class FilteredKeyMultimap<K extends @Nullable Object, V extends @Nullable Object
     }
   }
 
-  static class AddRejectingSet<K extends @Nullable Object, V extends @Nullable Object>
+  static class AddRejectingSet<K extends Object, V extends Object>
       extends ForwardingSet<V> {
     @ParametricNullness final K key;
 
@@ -138,7 +133,7 @@ class FilteredKeyMultimap<K extends @Nullable Object, V extends @Nullable Object
     }
   }
 
-  static class AddRejectingList<K extends @Nullable Object, V extends @Nullable Object>
+  static class AddRejectingList<K extends Object, V extends Object>
       extends ForwardingList<V> {
     @ParametricNullness final K key;
 
@@ -164,7 +159,6 @@ class FilteredKeyMultimap<K extends @Nullable Object, V extends @Nullable Object
       return true;
     }
 
-    @CanIgnoreReturnValue
     @Override
     public boolean addAll(int index, Collection<? extends V> elements) {
       checkNotNull(elements);
@@ -188,7 +182,6 @@ class FilteredKeyMultimap<K extends @Nullable Object, V extends @Nullable Object
     return new Entries();
   }
 
-  @WeakOuter
   class Entries extends ForwardingCollection<Entry<K, V>> {
     @Override
     protected Collection<Entry<K, V>> delegate() {
diff --git a/guava/src/com/google/common/collect/FilteredKeySetMultimap.java b/guava/src/com/google/common/collect/FilteredKeySetMultimap.java
index e492a5c1de..ae9c335b83 100644
--- a/guava/src/com/google/common/collect/FilteredKeySetMultimap.java
+++ b/guava/src/com/google/common/collect/FilteredKeySetMultimap.java
@@ -16,21 +16,18 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Predicate;
 import java.util.Map.Entry;
 import java.util.Set;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@link Multimaps#filterKeys(SetMultimap, Predicate)}.
  *
  * @author Louis Wasserman
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-final class FilteredKeySetMultimap<K extends @Nullable Object, V extends @Nullable Object>
+final class FilteredKeySetMultimap<K extends Object, V extends Object>
     extends FilteredKeyMultimap<K, V> implements FilteredSetMultimap<K, V> {
 
   FilteredKeySetMultimap(SetMultimap<K, V> unfiltered, Predicate<? super K> keyPredicate) {
diff --git a/guava/src/com/google/common/collect/FilteredMultimap.java b/guava/src/com/google/common/collect/FilteredMultimap.java
index 4e1fa066f8..cd5d07c88f 100644
--- a/guava/src/com/google/common/collect/FilteredMultimap.java
+++ b/guava/src/com/google/common/collect/FilteredMultimap.java
@@ -16,19 +16,16 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Predicate;
 import java.util.Map.Entry;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An interface for all filtered multimap types.
  *
  * @author Louis Wasserman
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-interface FilteredMultimap<K extends @Nullable Object, V extends @Nullable Object>
+interface FilteredMultimap<K extends Object, V extends Object>
     extends Multimap<K, V> {
   Multimap<K, V> unfiltered();
 
diff --git a/guava/src/com/google/common/collect/FilteredMultimapValues.java b/guava/src/com/google/common/collect/FilteredMultimapValues.java
index ecbfab2a1d..73db1eab8f 100644
--- a/guava/src/com/google/common/collect/FilteredMultimapValues.java
+++ b/guava/src/com/google/common/collect/FilteredMultimapValues.java
@@ -16,28 +16,24 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Objects;
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
-import com.google.j2objc.annotations.Weak;
 import java.util.AbstractCollection;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.Map.Entry;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation for {@link FilteredMultimap#values()}.
  *
  * @author Louis Wasserman
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-final class FilteredMultimapValues<K extends @Nullable Object, V extends @Nullable Object>
+final class FilteredMultimapValues<K extends Object, V extends Object>
     extends AbstractCollection<V> {
-  @Weak private final FilteredMultimap<K, V> multimap;
+  private final FilteredMultimap<K, V> multimap;
 
   FilteredMultimapValues(FilteredMultimap<K, V> multimap) {
     this.multimap = checkNotNull(multimap);
diff --git a/guava/src/com/google/common/collect/FilteredSetMultimap.java b/guava/src/com/google/common/collect/FilteredSetMultimap.java
index 8e2ff7c0c1..2f03d1d2ba 100644
--- a/guava/src/com/google/common/collect/FilteredSetMultimap.java
+++ b/guava/src/com/google/common/collect/FilteredSetMultimap.java
@@ -16,17 +16,14 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A supertype for filtered {@link SetMultimap} implementations.
  *
  * @author Louis Wasserman
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-interface FilteredSetMultimap<K extends @Nullable Object, V extends @Nullable Object>
+interface FilteredSetMultimap<K extends Object, V extends Object>
     extends FilteredMultimap<K, V>, SetMultimap<K, V> {
   @Override
   SetMultimap<K, V> unfiltered();
diff --git a/guava/src/com/google/common/collect/FluentIterable.java b/guava/src/com/google/common/collect/FluentIterable.java
index 11bda3bde9..08cf1852fb 100644
--- a/guava/src/com/google/common/collect/FluentIterable.java
+++ b/guava/src/com/google/common/collect/FluentIterable.java
@@ -16,15 +16,10 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.InlineMe;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
@@ -34,7 +29,6 @@ import java.util.List;
 import java.util.SortedSet;
 import java.util.stream.Stream;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A discouraged (but not deprecated) precursor to Java's superior {@link Stream} library.
@@ -108,9 +102,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Marcin Mikosik
  * @since 12.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
-public abstract class FluentIterable<E extends @Nullable Object> implements Iterable<E> {
+public abstract class FluentIterable<E extends Object> implements Iterable<E> {
   // We store 'iterable' and use it instead of 'this' to allow Iterables to perform instanceof
   // checks on the _original_ iterable when FluentIterable.from is used.
   // To avoid a self retain cycle under j2objc, we store Optional.absent() instead of
@@ -138,7 +131,7 @@ public abstract class FluentIterable<E extends @Nullable Object> implements Iter
    * <p><b>{@code Stream} equivalent:</b> {@link Collection#stream} if {@code iterable} is a {@link
    * Collection}; {@link Streams#stream(Iterable)} otherwise.
    */
-  public static <E extends @Nullable Object> FluentIterable<E> from(final Iterable<E> iterable) {
+  public static <E extends Object> FluentIterable<E> from(final Iterable<E> iterable) {
     return (iterable instanceof FluentIterable)
         ? (FluentIterable<E>) iterable
         : new FluentIterable<E>(iterable) {
@@ -159,8 +152,7 @@ public abstract class FluentIterable<E extends @Nullable Object> implements Iter
    *
    * @since 20.0 (since 18.0 as an overload of {@code of})
    */
-  @Beta
-  public static <E extends @Nullable Object> FluentIterable<E> from(E[] elements) {
+  public static <E extends Object> FluentIterable<E> from(E[] elements) {
     return from(Arrays.asList(elements));
   }
 
@@ -173,10 +165,7 @@ public abstract class FluentIterable<E extends @Nullable Object> implements Iter
    *     FluentIterable}
    */
   @Deprecated
-  @InlineMe(
-      replacement = "checkNotNull(iterable)",
-      staticImports = {"com.google.common.base.Preconditions.checkNotNull"})
-  public static <E extends @Nullable Object> FluentIterable<E> from(FluentIterable<E> iterable) {
+  public static <E extends Object> FluentIterable<E> from(FluentIterable<E> iterable) {
     return checkNotNull(iterable);
   }
 
@@ -192,8 +181,7 @@ public abstract class FluentIterable<E extends @Nullable Object> implements Iter
    *
    * @since 20.0
    */
-  @Beta
-  public static <T extends @Nullable Object> FluentIterable<T> concat(
+  public static <T extends Object> FluentIterable<T> concat(
       Iterable<? extends T> a, Iterable<? extends T> b) {
     return concatNoDefensiveCopy(a, b);
   }
@@ -211,8 +199,7 @@ public abstract class FluentIterable<E extends @Nullable Object> implements Iter
    *
    * @since 20.0
    */
-  @Beta
-  public static <T extends @Nullable Object> FluentIterable<T> concat(
+  public static <T extends Object> FluentIterable<T> concat(
       Iterable<? extends T> a, Iterable<? extends T> b, Iterable<? extends T> c) {
     return concatNoDefensiveCopy(a, b, c);
   }
@@ -231,8 +218,7 @@ public abstract class FluentIterable<E extends @Nullable Object> implements Iter
    *
    * @since 20.0
    */
-  @Beta
-  public static <T extends @Nullable Object> FluentIterable<T> concat(
+  public static <T extends Object> FluentIterable<T> concat(
       Iterable<? extends T> a,
       Iterable<? extends T> b,
       Iterable<? extends T> c,
@@ -255,8 +241,7 @@ public abstract class FluentIterable<E extends @Nullable Object> implements Iter
    * @throws NullPointerException if any of the provided iterables is {@code null}
    * @since 20.0
    */
-  @Beta
-  public static <T extends @Nullable Object> FluentIterable<T> concat(
+  public static <T extends Object> FluentIterable<T> concat(
       Iterable<? extends T>... inputs) {
     return concatNoDefensiveCopy(Arrays.copyOf(inputs, inputs.length));
   }
@@ -275,8 +260,7 @@ public abstract class FluentIterable<E extends @Nullable Object> implements Iter
    *
    * @since 20.0
    */
-  @Beta
-  public static <T extends @Nullable Object> FluentIterable<T> concat(
+  public static <T extends Object> FluentIterable<T> concat(
       final Iterable<? extends Iterable<? extends T>> inputs) {
     checkNotNull(inputs);
     return new FluentIterable<T>() {
@@ -288,7 +272,7 @@ public abstract class FluentIterable<E extends @Nullable Object> implements Iter
   }
 
   /** Concatenates a varargs array of iterables without making a defensive copy of the array. */
-  private static <T extends @Nullable Object> FluentIterable<T> concatNoDefensiveCopy(
+  private static <T extends Object> FluentIterable<T> concatNoDefensiveCopy(
       final Iterable<? extends T>... inputs) {
     for (Iterable<? extends T> input : inputs) {
       checkNotNull(input);
@@ -315,8 +299,7 @@ public abstract class FluentIterable<E extends @Nullable Object> implements Iter
    *
    * @since 20.0
    */
-  @Beta
-  public static <E extends @Nullable Object> FluentIterable<E> of() {
+  public static <E extends Object> FluentIterable<E> of() {
     return FluentIterable.from(Collections.<E>emptyList());
   }
 
@@ -328,8 +311,7 @@ public abstract class FluentIterable<E extends @Nullable Object> implements Iter
    *
    * @since 20.0
    */
-  @Beta
-  public static <E extends @Nullable Object> FluentIterable<E> of(
+  public static <E extends Object> FluentIterable<E> of(
       @ParametricNullness E element, E... elements) {
     return from(Lists.asList(element, elements));
   }
@@ -397,7 +379,6 @@ public abstract class FluentIterable<E extends @Nullable Object> implements Iter
    *
    * @since 18.0
    */
-  @Beta
   public final FluentIterable<E> append(Iterable<? extends E> other) {
     return FluentIterable.concat(getDelegate(), other);
   }
@@ -410,7 +391,6 @@ public abstract class FluentIterable<E extends @Nullable Object> implements Iter
    *
    * @since 18.0
    */
-  @Beta
   public final FluentIterable<E> append(E... elements) {
     return FluentIterable.concat(getDelegate(), Arrays.asList(elements));
   }
@@ -438,7 +418,7 @@ public abstract class FluentIterable<E extends @Nullable Object> implements Iter
    *     (ImmutableList) stream.filter(NewType.class::isInstance).collect(toImmutableList());}
    * </pre>
    */
-  @GwtIncompatible // Class.isInstance
+  // Class.isInstance
   public final <T> FluentIterable<T> filter(Class<T> type) {
     return from(Iterables.filter(getDelegate(), type));
   }
@@ -486,7 +466,7 @@ public abstract class FluentIterable<E extends @Nullable Object> implements Iter
    *
    * <p><b>{@code Stream} equivalent:</b> {@link Stream#map}.
    */
-  public final <T extends @Nullable Object> FluentIterable<T> transform(
+  public final <T extends Object> FluentIterable<T> transform(
       Function<? super E, T> function) {
     return from(Iterables.transform(getDelegate(), function));
   }
@@ -504,7 +484,7 @@ public abstract class FluentIterable<E extends @Nullable Object> implements Iter
    *
    * @since 13.0 (required {@code Function<E, Iterable<T>>} until 14.0)
    */
-  public <T extends @Nullable Object> FluentIterable<T> transformAndConcat(
+  public <T extends Object> FluentIterable<T> transformAndConcat(
       Function<? super E, ? extends Iterable<? extends T>> function) {
     return FluentIterable.concat(transform(function));
   }
@@ -786,7 +766,7 @@ public abstract class FluentIterable<E extends @Nullable Object> implements Iter
    * @return a newly-allocated array into which all the elements of this fluent iterable have been
    *     copied
    */
-  @GwtIncompatible // Array.newArray(Class, int)
+  // Array.newArray(Class, int)
   /*
    * Both the declaration of our Class<E> parameter and its usage in a call to Iterables.toArray
    * produce a nullness error: E may be a nullable type, and our nullness checker has Class's type
@@ -795,7 +775,7 @@ public abstract class FluentIterable<E extends @Nullable Object> implements Iter
    * FluentIterable support null elements, and most of the other produce outright unsoundness.)
    */
   @SuppressWarnings("nullness")
-  public final @Nullable E[] toArray(Class<E> type) {
+  public final E[] toArray(Class<E> type) {
     return Iterables.toArray(getDelegate(), type);
   }
 
@@ -810,7 +790,6 @@ public abstract class FluentIterable<E extends @Nullable Object> implements Iter
    * @return {@code collection}, for convenience
    * @since 14.0
    */
-  @CanIgnoreReturnValue
   public final <C extends Collection<? super E>> C copyInto(C collection) {
     checkNotNull(collection);
     Iterable<E> iterable = getDelegate();
@@ -834,7 +813,6 @@ public abstract class FluentIterable<E extends @Nullable Object> implements Iter
    *
    * @since 18.0
    */
-  @Beta
   public final String join(Joiner joiner) {
     return joiner.join(this);
   }
@@ -871,7 +849,7 @@ public abstract class FluentIterable<E extends @Nullable Object> implements Iter
   }
 
   /** Function that transforms {@code Iterable<E>} into a fluent iterable. */
-  private static class FromIterableFunction<E extends @Nullable Object>
+  private static class FromIterableFunction<E extends Object>
       implements Function<Iterable<E>, FluentIterable<E>> {
     @Override
     public FluentIterable<E> apply(Iterable<E> fromObject) {
diff --git a/guava/src/com/google/common/collect/ForwardingBlockingDeque.java b/guava/src/com/google/common/collect/ForwardingBlockingDeque.java
index 49d4bcf6c2..b2fada9a94 100644
--- a/guava/src/com/google/common/collect/ForwardingBlockingDeque.java
+++ b/guava/src/com/google/common/collect/ForwardingBlockingDeque.java
@@ -16,7 +16,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtIncompatible;
 import java.util.Collection;
 import java.util.concurrent.BlockingDeque;
 import java.util.concurrent.TimeUnit;
@@ -46,7 +45,6 @@ import javax.annotation.CheckForNull;
  *     com.google.common.util.concurrent.ForwardingBlockingDeque} instead.
  */
 @Deprecated
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public abstract class ForwardingBlockingDeque<E> extends ForwardingDeque<E>
     implements BlockingDeque<E> {
diff --git a/guava/src/com/google/common/collect/ForwardingCollection.java b/guava/src/com/google/common/collect/ForwardingCollection.java
index ca1edc1183..38881acbbf 100644
--- a/guava/src/com/google/common/collect/ForwardingCollection.java
+++ b/guava/src/com/google/common/collect/ForwardingCollection.java
@@ -16,13 +16,10 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Objects;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Collection;
 import java.util.Iterator;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A collection which forwards all its method calls to another collection. Subclasses should
@@ -46,9 +43,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public abstract class ForwardingCollection<E extends @Nullable Object> extends ForwardingObject
+public abstract class ForwardingCollection<E extends Object> extends ForwardingObject
     implements Collection<E> {
   // TODO(lowasser): identify places where thread safety is actually lost
 
@@ -68,7 +64,6 @@ public abstract class ForwardingCollection<E extends @Nullable Object> extends F
     return delegate().size();
   }
 
-  @CanIgnoreReturnValue
   @Override
   public boolean removeAll(Collection<?> collection) {
     return delegate().removeAll(collection);
@@ -84,13 +79,11 @@ public abstract class ForwardingCollection<E extends @Nullable Object> extends F
     return delegate().contains(object);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public boolean add(@ParametricNullness E element) {
     return delegate().add(element);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public boolean remove(@CheckForNull Object object) {
     return delegate().remove(object);
@@ -101,13 +94,11 @@ public abstract class ForwardingCollection<E extends @Nullable Object> extends F
     return delegate().containsAll(collection);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public boolean addAll(Collection<? extends E> collection) {
     return delegate().addAll(collection);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public boolean retainAll(Collection<?> collection) {
     return delegate().retainAll(collection);
@@ -119,14 +110,13 @@ public abstract class ForwardingCollection<E extends @Nullable Object> extends F
   }
 
   @Override
-  public @Nullable Object[] toArray() {
+  public Object[] toArray() {
     return delegate().toArray();
   }
 
-  @CanIgnoreReturnValue
   @Override
   @SuppressWarnings("nullness") // b/192354773 in our checker affects toArray declarations
-  public <T extends @Nullable Object> T[] toArray(T[] array) {
+  public <T extends Object> T[] toArray(T[] array) {
     return delegate().toArray(array);
   }
 
@@ -242,8 +232,8 @@ public abstract class ForwardingCollection<E extends @Nullable Object> extends F
    *
    * @since 7.0
    */
-  protected @Nullable Object[] standardToArray() {
-    @Nullable Object[] newArray = new @Nullable Object[size()];
+  protected Object[] standardToArray() {
+    Object[] newArray = new Object[size()];
     return toArray(newArray);
   }
 
@@ -254,7 +244,7 @@ public abstract class ForwardingCollection<E extends @Nullable Object> extends F
    *
    * @since 7.0
    */
-  protected <T extends @Nullable Object> T[] standardToArray(T[] array) {
+  protected <T extends Object> T[] standardToArray(T[] array) {
     return ObjectArrays.toArrayImpl(this, array);
   }
 }
diff --git a/guava/src/com/google/common/collect/ForwardingConcurrentMap.java b/guava/src/com/google/common/collect/ForwardingConcurrentMap.java
index b662b0774a..0aed83783e 100644
--- a/guava/src/com/google/common/collect/ForwardingConcurrentMap.java
+++ b/guava/src/com/google/common/collect/ForwardingConcurrentMap.java
@@ -16,8 +16,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.concurrent.ConcurrentMap;
 import javax.annotation.CheckForNull;
 
@@ -36,7 +34,6 @@ import javax.annotation.CheckForNull;
  * @author Charles Fry
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public abstract class ForwardingConcurrentMap<K, V> extends ForwardingMap<K, V>
     implements ConcurrentMap<K, V> {
@@ -47,27 +44,23 @@ public abstract class ForwardingConcurrentMap<K, V> extends ForwardingMap<K, V>
   @Override
   protected abstract ConcurrentMap<K, V> delegate();
 
-  @CanIgnoreReturnValue
   @Override
   @CheckForNull
   public V putIfAbsent(K key, V value) {
     return delegate().putIfAbsent(key, value);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public boolean remove(@CheckForNull Object key, @CheckForNull Object value) {
     return delegate().remove(key, value);
   }
 
-  @CanIgnoreReturnValue
   @Override
   @CheckForNull
   public V replace(K key, V value) {
     return delegate().replace(key, value);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public boolean replace(K key, V oldValue, V newValue) {
     return delegate().replace(key, oldValue, newValue);
diff --git a/guava/src/com/google/common/collect/ForwardingDeque.java b/guava/src/com/google/common/collect/ForwardingDeque.java
index 571535cab9..6f0a56b976 100644
--- a/guava/src/com/google/common/collect/ForwardingDeque.java
+++ b/guava/src/com/google/common/collect/ForwardingDeque.java
@@ -16,12 +16,9 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Deque;
 import java.util.Iterator;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A deque which forwards all its method calls to another deque. Subclasses should override one or
@@ -40,9 +37,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kurt Alfred Kluever
  * @since 12.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
-public abstract class ForwardingDeque<E extends @Nullable Object> extends ForwardingQueue<E>
+public abstract class ForwardingDeque<E extends Object> extends ForwardingQueue<E>
     implements Deque<E> {
 
   /** Constructor for use by subclasses. */
@@ -78,13 +74,13 @@ public abstract class ForwardingDeque<E extends @Nullable Object> extends Forwar
     return delegate().getLast();
   }
 
-  @CanIgnoreReturnValue // TODO(cpovirk): Consider removing this?
+  // TODO(cpovirk): Consider removing this?
   @Override
   public boolean offerFirst(@ParametricNullness E e) {
     return delegate().offerFirst(e);
   }
 
-  @CanIgnoreReturnValue // TODO(cpovirk): Consider removing this?
+  // TODO(cpovirk): Consider removing this?
   @Override
   public boolean offerLast(@ParametricNullness E e) {
     return delegate().offerLast(e);
@@ -102,21 +98,20 @@ public abstract class ForwardingDeque<E extends @Nullable Object> extends Forwar
     return delegate().peekLast();
   }
 
-  @CanIgnoreReturnValue // TODO(cpovirk): Consider removing this?
+  // TODO(cpovirk): Consider removing this?
   @Override
   @CheckForNull
   public E pollFirst() {
     return delegate().pollFirst();
   }
 
-  @CanIgnoreReturnValue // TODO(cpovirk): Consider removing this?
+  // TODO(cpovirk): Consider removing this?
   @Override
   @CheckForNull
   public E pollLast() {
     return delegate().pollLast();
   }
 
-  @CanIgnoreReturnValue
   @Override
   @ParametricNullness
   public E pop() {
@@ -128,27 +123,23 @@ public abstract class ForwardingDeque<E extends @Nullable Object> extends Forwar
     delegate().push(e);
   }
 
-  @CanIgnoreReturnValue
   @Override
   @ParametricNullness
   public E removeFirst() {
     return delegate().removeFirst();
   }
 
-  @CanIgnoreReturnValue
   @Override
   @ParametricNullness
   public E removeLast() {
     return delegate().removeLast();
   }
 
-  @CanIgnoreReturnValue
   @Override
   public boolean removeFirstOccurrence(@CheckForNull Object o) {
     return delegate().removeFirstOccurrence(o);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public boolean removeLastOccurrence(@CheckForNull Object o) {
     return delegate().removeLastOccurrence(o);
diff --git a/guava/src/com/google/common/collect/ForwardingImmutableCollection.java b/guava/src/com/google/common/collect/ForwardingImmutableCollection.java
index 043fe58635..df64ca2563 100644
--- a/guava/src/com/google/common/collect/ForwardingImmutableCollection.java
+++ b/guava/src/com/google/common/collect/ForwardingImmutableCollection.java
@@ -16,14 +16,12 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 
 /**
  * Dummy class that makes the GWT serialization policy happy. It isn't used on the server-side.
  *
  * @author Hayward Chan
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 class ForwardingImmutableCollection {
   private ForwardingImmutableCollection() {}
diff --git a/guava/src/com/google/common/collect/ForwardingImmutableList.java b/guava/src/com/google/common/collect/ForwardingImmutableList.java
index bd5480d589..f1aeba74dd 100644
--- a/guava/src/com/google/common/collect/ForwardingImmutableList.java
+++ b/guava/src/com/google/common/collect/ForwardingImmutableList.java
@@ -16,14 +16,12 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 
 /**
  * Unused stub class, unreferenced under Java and manually emulated under GWT.
  *
  * @author Chris Povirk
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 abstract class ForwardingImmutableList<E> {
   private ForwardingImmutableList() {}
diff --git a/guava/src/com/google/common/collect/ForwardingImmutableMap.java b/guava/src/com/google/common/collect/ForwardingImmutableMap.java
index 22cc9ff871..84c4fb8cda 100644
--- a/guava/src/com/google/common/collect/ForwardingImmutableMap.java
+++ b/guava/src/com/google/common/collect/ForwardingImmutableMap.java
@@ -16,14 +16,12 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 
 /**
  * Unused stub class, unreferenced under Java and manually emulated under GWT.
  *
  * @author Chris Povirk
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 abstract class ForwardingImmutableMap<K, V> {
   private ForwardingImmutableMap() {}
diff --git a/guava/src/com/google/common/collect/ForwardingImmutableSet.java b/guava/src/com/google/common/collect/ForwardingImmutableSet.java
index 047d5fd322..e4ae3979d3 100644
--- a/guava/src/com/google/common/collect/ForwardingImmutableSet.java
+++ b/guava/src/com/google/common/collect/ForwardingImmutableSet.java
@@ -16,14 +16,12 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 
 /**
  * Unused stub class, unreferenced under Java and manually emulated under GWT.
  *
  * @author Chris Povirk
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 abstract class ForwardingImmutableSet<E> {
   private ForwardingImmutableSet() {}
diff --git a/guava/src/com/google/common/collect/ForwardingIterator.java b/guava/src/com/google/common/collect/ForwardingIterator.java
index 1f5a8f110e..a063f8e187 100644
--- a/guava/src/com/google/common/collect/ForwardingIterator.java
+++ b/guava/src/com/google/common/collect/ForwardingIterator.java
@@ -16,10 +16,7 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Iterator;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An iterator which forwards all its method calls to another iterator. Subclasses should override
@@ -36,9 +33,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kevin Bourrillion
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public abstract class ForwardingIterator<T extends @Nullable Object> extends ForwardingObject
+public abstract class ForwardingIterator<T extends Object> extends ForwardingObject
     implements Iterator<T> {
 
   /** Constructor for use by subclasses. */
@@ -52,7 +48,6 @@ public abstract class ForwardingIterator<T extends @Nullable Object> extends For
     return delegate().hasNext();
   }
 
-  @CanIgnoreReturnValue
   @Override
   @ParametricNullness
   public T next() {
diff --git a/guava/src/com/google/common/collect/ForwardingList.java b/guava/src/com/google/common/collect/ForwardingList.java
index 4b4551e5e3..5e51833d0f 100644
--- a/guava/src/com/google/common/collect/ForwardingList.java
+++ b/guava/src/com/google/common/collect/ForwardingList.java
@@ -16,15 +16,11 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.ListIterator;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A list which forwards all its method calls to another list. Subclasses should override one or
@@ -51,9 +47,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public abstract class ForwardingList<E extends @Nullable Object> extends ForwardingCollection<E>
+public abstract class ForwardingList<E extends Object> extends ForwardingCollection<E>
     implements List<E> {
   // TODO(lowasser): identify places where thread safety is actually lost
 
@@ -68,7 +63,6 @@ public abstract class ForwardingList<E extends @Nullable Object> extends Forward
     delegate().add(index, element);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public boolean addAll(int index, Collection<? extends E> elements) {
     return delegate().addAll(index, elements);
@@ -100,14 +94,12 @@ public abstract class ForwardingList<E extends @Nullable Object> extends Forward
     return delegate().listIterator(index);
   }
 
-  @CanIgnoreReturnValue
   @Override
   @ParametricNullness
   public E remove(int index) {
     return delegate().remove(index);
   }
 
-  @CanIgnoreReturnValue
   @Override
   @ParametricNullness
   public E set(int index, @ParametricNullness E element) {
@@ -204,7 +196,6 @@ public abstract class ForwardingList<E extends @Nullable Object> extends Forward
    *
    * @since 7.0
    */
-  @Beta
   protected ListIterator<E> standardListIterator(int start) {
     return Lists.listIteratorImpl(this, start);
   }
@@ -215,7 +206,6 @@ public abstract class ForwardingList<E extends @Nullable Object> extends Forward
    *
    * @since 7.0
    */
-  @Beta
   protected List<E> standardSubList(int fromIndex, int toIndex) {
     return Lists.subListImpl(this, fromIndex, toIndex);
   }
@@ -227,7 +217,6 @@ public abstract class ForwardingList<E extends @Nullable Object> extends Forward
    *
    * @since 7.0
    */
-  @Beta
   protected boolean standardEquals(@CheckForNull Object object) {
     return Lists.equalsImpl(this, object);
   }
@@ -239,7 +228,6 @@ public abstract class ForwardingList<E extends @Nullable Object> extends Forward
    *
    * @since 7.0
    */
-  @Beta
   protected int standardHashCode() {
     return Lists.hashCodeImpl(this);
   }
diff --git a/guava/src/com/google/common/collect/ForwardingListIterator.java b/guava/src/com/google/common/collect/ForwardingListIterator.java
index a2ac32b6fa..6f440c6519 100644
--- a/guava/src/com/google/common/collect/ForwardingListIterator.java
+++ b/guava/src/com/google/common/collect/ForwardingListIterator.java
@@ -16,10 +16,7 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.ListIterator;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A list iterator which forwards all its method calls to another list iterator. Subclasses should
@@ -36,9 +33,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Mike Bostock
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public abstract class ForwardingListIterator<E extends @Nullable Object>
+public abstract class ForwardingListIterator<E extends Object>
     extends ForwardingIterator<E> implements ListIterator<E> {
 
   /** Constructor for use by subclasses. */
@@ -62,7 +58,6 @@ public abstract class ForwardingListIterator<E extends @Nullable Object>
     return delegate().nextIndex();
   }
 
-  @CanIgnoreReturnValue
   @Override
   @ParametricNullness
   public E previous() {
diff --git a/guava/src/com/google/common/collect/ForwardingListMultimap.java b/guava/src/com/google/common/collect/ForwardingListMultimap.java
index 11779c0bb8..4ebcdc385a 100644
--- a/guava/src/com/google/common/collect/ForwardingListMultimap.java
+++ b/guava/src/com/google/common/collect/ForwardingListMultimap.java
@@ -16,11 +16,8 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.List;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A list multimap which forwards all its method calls to another list multimap. Subclasses should
@@ -34,9 +31,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kurt Alfred Kluever
  * @since 3.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public abstract class ForwardingListMultimap<K extends @Nullable Object, V extends @Nullable Object>
+public abstract class ForwardingListMultimap<K extends Object, V extends Object>
     extends ForwardingMultimap<K, V> implements ListMultimap<K, V> {
 
   /** Constructor for use by subclasses. */
@@ -50,13 +46,11 @@ public abstract class ForwardingListMultimap<K extends @Nullable Object, V exten
     return delegate().get(key);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public List<V> removeAll(@CheckForNull Object key) {
     return delegate().removeAll(key);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public List<V> replaceValues(@ParametricNullness K key, Iterable<? extends V> values) {
     return delegate().replaceValues(key, values);
diff --git a/guava/src/com/google/common/collect/ForwardingMap.java b/guava/src/com/google/common/collect/ForwardingMap.java
index 315a4fabca..58449f53cf 100644
--- a/guava/src/com/google/common/collect/ForwardingMap.java
+++ b/guava/src/com/google/common/collect/ForwardingMap.java
@@ -16,16 +16,12 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Objects;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A map which forwards all its method calls to another map. Subclasses should override one or more
@@ -55,9 +51,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public abstract class ForwardingMap<K extends @Nullable Object, V extends @Nullable Object>
+public abstract class ForwardingMap<K extends Object, V extends Object>
     extends ForwardingObject implements Map<K, V> {
   // TODO(lowasser): identify places where thread safety is actually lost
 
@@ -77,7 +72,6 @@ public abstract class ForwardingMap<K extends @Nullable Object, V extends @Nulla
     return delegate().isEmpty();
   }
 
-  @CanIgnoreReturnValue
   @Override
   @CheckForNull
   public V remove(@CheckForNull Object key) {
@@ -105,7 +99,6 @@ public abstract class ForwardingMap<K extends @Nullable Object, V extends @Nulla
     return delegate().get(key);
   }
 
-  @CanIgnoreReturnValue
   @Override
   @CheckForNull
   public V put(@ParametricNullness K key, @ParametricNullness V value) {
@@ -163,7 +156,6 @@ public abstract class ForwardingMap<K extends @Nullable Object, V extends @Nulla
    *
    * @since 7.0
    */
-  @Beta
   @CheckForNull
   protected V standardRemove(@CheckForNull Object key) {
     Iterator<Entry<K, V>> entryIterator = entrySet().iterator();
@@ -198,7 +190,6 @@ public abstract class ForwardingMap<K extends @Nullable Object, V extends @Nulla
    *
    * @since 10.0
    */
-  @Beta
   protected class StandardKeySet extends Maps.KeySet<K, V> {
     /** Constructor for use by subclasses. */
     public StandardKeySet() {
@@ -213,7 +204,6 @@ public abstract class ForwardingMap<K extends @Nullable Object, V extends @Nulla
    *
    * @since 7.0
    */
-  @Beta
   protected boolean standardContainsKey(@CheckForNull Object key) {
     return Maps.containsKeyImpl(this, key);
   }
@@ -227,7 +217,6 @@ public abstract class ForwardingMap<K extends @Nullable Object, V extends @Nulla
    *
    * @since 10.0
    */
-  @Beta
   protected class StandardValues extends Maps.Values<K, V> {
     /** Constructor for use by subclasses. */
     public StandardValues() {
@@ -255,7 +244,6 @@ public abstract class ForwardingMap<K extends @Nullable Object, V extends @Nulla
    *
    * @since 10.0
    */
-  @Beta
   protected abstract class StandardEntrySet extends Maps.EntrySet<K, V> {
     /** Constructor for use by subclasses. */
     public StandardEntrySet() {}
diff --git a/guava/src/com/google/common/collect/ForwardingMapEntry.java b/guava/src/com/google/common/collect/ForwardingMapEntry.java
index 6816ccbbef..475a982311 100644
--- a/guava/src/com/google/common/collect/ForwardingMapEntry.java
+++ b/guava/src/com/google/common/collect/ForwardingMapEntry.java
@@ -16,13 +16,10 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Objects;
 import java.util.Map;
 import java.util.Map.Entry;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A map entry which forwards all its method calls to another map entry. Subclasses should override
@@ -47,9 +44,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public abstract class ForwardingMapEntry<K extends @Nullable Object, V extends @Nullable Object>
+public abstract class ForwardingMapEntry<K extends Object, V extends Object>
     extends ForwardingObject implements Map.Entry<K, V> {
   // TODO(lowasser): identify places where thread safety is actually lost
 
@@ -123,7 +119,6 @@ public abstract class ForwardingMapEntry<K extends @Nullable Object, V extends @
    *
    * @since 7.0
    */
-  @Beta
   protected String standardToString() {
     return getKey() + "=" + getValue();
   }
diff --git a/guava/src/com/google/common/collect/ForwardingMultimap.java b/guava/src/com/google/common/collect/ForwardingMultimap.java
index a3db0618ed..e48c317e69 100644
--- a/guava/src/com/google/common/collect/ForwardingMultimap.java
+++ b/guava/src/com/google/common/collect/ForwardingMultimap.java
@@ -16,14 +16,11 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Collection;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A multimap which forwards all its method calls to another multimap. Subclasses should override
@@ -37,9 +34,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Robert Konigsberg
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public abstract class ForwardingMultimap<K extends @Nullable Object, V extends @Nullable Object>
+public abstract class ForwardingMultimap<K extends Object, V extends Object>
     extends ForwardingObject implements Multimap<K, V> {
 
   /** Constructor for use by subclasses. */
@@ -98,37 +94,31 @@ public abstract class ForwardingMultimap<K extends @Nullable Object, V extends @
     return delegate().keySet();
   }
 
-  @CanIgnoreReturnValue
   @Override
   public boolean put(@ParametricNullness K key, @ParametricNullness V value) {
     return delegate().put(key, value);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public boolean putAll(@ParametricNullness K key, Iterable<? extends V> values) {
     return delegate().putAll(key, values);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public boolean putAll(Multimap<? extends K, ? extends V> multimap) {
     return delegate().putAll(multimap);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public boolean remove(@CheckForNull Object key, @CheckForNull Object value) {
     return delegate().remove(key, value);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public Collection<V> removeAll(@CheckForNull Object key) {
     return delegate().removeAll(key);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public Collection<V> replaceValues(@ParametricNullness K key, Iterable<? extends V> values) {
     return delegate().replaceValues(key, values);
diff --git a/guava/src/com/google/common/collect/ForwardingMultiset.java b/guava/src/com/google/common/collect/ForwardingMultiset.java
index 857b9aec7b..987b051b00 100644
--- a/guava/src/com/google/common/collect/ForwardingMultiset.java
+++ b/guava/src/com/google/common/collect/ForwardingMultiset.java
@@ -16,15 +16,11 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Objects;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.Set;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A multiset which forwards all its method calls to another multiset. Subclasses should override
@@ -48,9 +44,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public abstract class ForwardingMultiset<E extends @Nullable Object> extends ForwardingCollection<E>
+public abstract class ForwardingMultiset<E extends Object> extends ForwardingCollection<E>
     implements Multiset<E> {
 
   /** Constructor for use by subclasses. */
@@ -64,13 +59,11 @@ public abstract class ForwardingMultiset<E extends @Nullable Object> extends For
     return delegate().count(element);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public int add(@ParametricNullness E element, int occurrences) {
     return delegate().add(element, occurrences);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public int remove(@CheckForNull Object element, int occurrences) {
     return delegate().remove(element, occurrences);
@@ -96,13 +89,11 @@ public abstract class ForwardingMultiset<E extends @Nullable Object> extends For
     return delegate().hashCode();
   }
 
-  @CanIgnoreReturnValue
   @Override
   public int setCount(@ParametricNullness E element, int count) {
     return delegate().setCount(element, count);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public boolean setCount(@ParametricNullness E element, int oldCount, int newCount) {
     return delegate().setCount(element, oldCount, newCount);
@@ -138,7 +129,6 @@ public abstract class ForwardingMultiset<E extends @Nullable Object> extends For
    *
    * @since 7.0
    */
-  @Beta
   protected int standardCount(@CheckForNull Object object) {
     for (Entry<?> entry : this.entrySet()) {
       if (Objects.equal(entry.getElement(), object)) {
@@ -167,7 +157,6 @@ public abstract class ForwardingMultiset<E extends @Nullable Object> extends For
    *
    * @since 7.0
    */
-  @Beta
   @Override
   protected boolean standardAddAll(Collection<? extends E> elementsToAdd) {
     return Multisets.addAllImpl(this, elementsToAdd);
@@ -243,7 +232,6 @@ public abstract class ForwardingMultiset<E extends @Nullable Object> extends For
    *
    * @since 10.0
    */
-  @Beta
   protected class StandardElementSet extends Multisets.ElementSet<E> {
     /** Constructor for use by subclasses. */
     public StandardElementSet() {}
diff --git a/guava/src/com/google/common/collect/ForwardingNavigableMap.java b/guava/src/com/google/common/collect/ForwardingNavigableMap.java
index c32468da1d..ee4b1278fa 100644
--- a/guava/src/com/google/common/collect/ForwardingNavigableMap.java
+++ b/guava/src/com/google/common/collect/ForwardingNavigableMap.java
@@ -18,8 +18,6 @@ package com.google.common.collect;
 
 import static com.google.common.collect.Maps.keyOrNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import java.util.Iterator;
 import java.util.NavigableMap;
 import java.util.NavigableSet;
@@ -27,7 +25,6 @@ import java.util.NoSuchElementException;
 import java.util.SortedMap;
 import java.util.function.BiFunction;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A navigable map which forwards all its method calls to another navigable map. Subclasses should
@@ -55,9 +52,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 12.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
-public abstract class ForwardingNavigableMap<K extends @Nullable Object, V extends @Nullable Object>
+public abstract class ForwardingNavigableMap<K extends Object, V extends Object>
     extends ForwardingSortedMap<K, V> implements NavigableMap<K, V> {
 
   /** Constructor for use by subclasses. */
@@ -301,7 +297,6 @@ public abstract class ForwardingNavigableMap<K extends @Nullable Object, V exten
    *
    * @since 12.0
    */
-  @Beta
   protected class StandardDescendingMap extends Maps.DescendingMap<K, V> {
     /** Constructor for use by subclasses. */
     public StandardDescendingMap() {}
@@ -365,7 +360,6 @@ public abstract class ForwardingNavigableMap<K extends @Nullable Object, V exten
    *
    * @since 12.0
    */
-  @Beta
   protected class StandardNavigableKeySet extends Maps.NavigableKeySet<K, V> {
     /** Constructor for use by subclasses. */
     public StandardNavigableKeySet() {
@@ -385,7 +379,6 @@ public abstract class ForwardingNavigableMap<K extends @Nullable Object, V exten
    * descendingMap}, you may wish to override {@code descendingKeySet} to forward to this
    * implementation.
    */
-  @Beta
   protected NavigableSet<K> standardDescendingKeySet() {
     return descendingMap().navigableKeySet();
   }
diff --git a/guava/src/com/google/common/collect/ForwardingNavigableSet.java b/guava/src/com/google/common/collect/ForwardingNavigableSet.java
index 6822aa87d4..a72b0a3c80 100644
--- a/guava/src/com/google/common/collect/ForwardingNavigableSet.java
+++ b/guava/src/com/google/common/collect/ForwardingNavigableSet.java
@@ -16,13 +16,10 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import java.util.Iterator;
 import java.util.NavigableSet;
 import java.util.SortedSet;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A navigable set which forwards all its method calls to another navigable set. Subclasses should
@@ -50,9 +47,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 12.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
-public abstract class ForwardingNavigableSet<E extends @Nullable Object>
+public abstract class ForwardingNavigableSet<E extends Object>
     extends ForwardingSortedSet<E> implements NavigableSet<E> {
 
   /** Constructor for use by subclasses. */
@@ -181,7 +177,6 @@ public abstract class ForwardingNavigableSet<E extends @Nullable Object>
    *
    * @since 12.0
    */
-  @Beta
   protected class StandardDescendingSet extends Sets.DescendingSet<E> {
     /** Constructor for use by subclasses. */
     public StandardDescendingSet() {
@@ -208,7 +203,6 @@ public abstract class ForwardingNavigableSet<E extends @Nullable Object>
    * {@code headSet} and {@code tailSet} methods. In many cases, you may wish to override {@link
    * #subSet(Object, boolean, Object, boolean)} to forward to this implementation.
    */
-  @Beta
   protected NavigableSet<E> standardSubSet(
       @ParametricNullness E fromElement,
       boolean fromInclusive,
diff --git a/guava/src/com/google/common/collect/ForwardingObject.java b/guava/src/com/google/common/collect/ForwardingObject.java
index 64af9082d2..e9195b3c8f 100644
--- a/guava/src/com/google/common/collect/ForwardingObject.java
+++ b/guava/src/com/google/common/collect/ForwardingObject.java
@@ -16,7 +16,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 
 /**
@@ -43,7 +42,6 @@ import java.io.Serializable;
  * @author Mike Bostock
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public abstract class ForwardingObject {
 
diff --git a/guava/src/com/google/common/collect/ForwardingQueue.java b/guava/src/com/google/common/collect/ForwardingQueue.java
index 43c2eaafb5..a16cc4b0c3 100644
--- a/guava/src/com/google/common/collect/ForwardingQueue.java
+++ b/guava/src/com/google/common/collect/ForwardingQueue.java
@@ -16,12 +16,9 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.NoSuchElementException;
 import java.util.Queue;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A queue which forwards all its method calls to another queue. Subclasses should override one or
@@ -45,9 +42,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public abstract class ForwardingQueue<E extends @Nullable Object> extends ForwardingCollection<E>
+public abstract class ForwardingQueue<E extends Object> extends ForwardingCollection<E>
     implements Queue<E> {
 
   /** Constructor for use by subclasses. */
@@ -56,20 +52,19 @@ public abstract class ForwardingQueue<E extends @Nullable Object> extends Forwar
   @Override
   protected abstract Queue<E> delegate();
 
-  @CanIgnoreReturnValue // TODO(cpovirk): Consider removing this?
+  // TODO(cpovirk): Consider removing this?
   @Override
   public boolean offer(@ParametricNullness E o) {
     return delegate().offer(o);
   }
 
-  @CanIgnoreReturnValue // TODO(cpovirk): Consider removing this?
+  // TODO(cpovirk): Consider removing this?
   @Override
   @CheckForNull
   public E poll() {
     return delegate().poll();
   }
 
-  @CanIgnoreReturnValue
   @Override
   @ParametricNullness
   public E remove() {
diff --git a/guava/src/com/google/common/collect/ForwardingSet.java b/guava/src/com/google/common/collect/ForwardingSet.java
index bc27272b02..2aa78c5ecf 100644
--- a/guava/src/com/google/common/collect/ForwardingSet.java
+++ b/guava/src/com/google/common/collect/ForwardingSet.java
@@ -18,11 +18,9 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.Collection;
 import java.util.Set;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A set which forwards all its method calls to another set. Subclasses should override one or more
@@ -46,9 +44,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public abstract class ForwardingSet<E extends @Nullable Object> extends ForwardingCollection<E>
+public abstract class ForwardingSet<E extends Object> extends ForwardingCollection<E>
     implements Set<E> {
   // TODO(lowasser): identify places where thread safety is actually lost
 
diff --git a/guava/src/com/google/common/collect/ForwardingSetMultimap.java b/guava/src/com/google/common/collect/ForwardingSetMultimap.java
index 5077c6803c..4f5d1b6a21 100644
--- a/guava/src/com/google/common/collect/ForwardingSetMultimap.java
+++ b/guava/src/com/google/common/collect/ForwardingSetMultimap.java
@@ -16,12 +16,9 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Map.Entry;
 import java.util.Set;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A set multimap which forwards all its method calls to another set multimap. Subclasses should
@@ -35,9 +32,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kurt Alfred Kluever
  * @since 3.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public abstract class ForwardingSetMultimap<K extends @Nullable Object, V extends @Nullable Object>
+public abstract class ForwardingSetMultimap<K extends Object, V extends Object>
     extends ForwardingMultimap<K, V> implements SetMultimap<K, V> {
 
   @Override
@@ -53,13 +49,11 @@ public abstract class ForwardingSetMultimap<K extends @Nullable Object, V extend
     return delegate().get(key);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public Set<V> removeAll(@CheckForNull Object key) {
     return delegate().removeAll(key);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public Set<V> replaceValues(@ParametricNullness K key, Iterable<? extends V> values) {
     return delegate().replaceValues(key, values);
diff --git a/guava/src/com/google/common/collect/ForwardingSortedMap.java b/guava/src/com/google/common/collect/ForwardingSortedMap.java
index e0882abc7a..c8b25c9671 100644
--- a/guava/src/com/google/common/collect/ForwardingSortedMap.java
+++ b/guava/src/com/google/common/collect/ForwardingSortedMap.java
@@ -18,13 +18,10 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import java.util.Comparator;
 import java.util.NoSuchElementException;
 import java.util.SortedMap;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A sorted map which forwards all its method calls to another sorted map. Subclasses should
@@ -51,9 +48,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public abstract class ForwardingSortedMap<K extends @Nullable Object, V extends @Nullable Object>
+public abstract class ForwardingSortedMap<K extends Object, V extends Object>
     extends ForwardingMap<K, V> implements SortedMap<K, V> {
   // TODO(lowasser): identify places where thread safety is actually lost
 
@@ -103,7 +99,6 @@ public abstract class ForwardingSortedMap<K extends @Nullable Object, V extends
    *
    * @since 15.0
    */
-  @Beta
   protected class StandardKeySet extends Maps.SortedKeySet<K, V> {
     /** Constructor for use by subclasses. */
     public StandardKeySet() {
@@ -116,9 +111,9 @@ public abstract class ForwardingSortedMap<K extends @Nullable Object, V extends
   static int unsafeCompare(
       @CheckForNull Comparator<?> comparator, @CheckForNull Object o1, @CheckForNull Object o2) {
     if (comparator == null) {
-      return ((Comparable<@Nullable Object>) o1).compareTo(o2);
+      return ((Comparable<Object>) o1).compareTo(o2);
     } else {
-      return ((Comparator<@Nullable Object>) comparator).compare(o1, o2);
+      return ((Comparator<Object>) comparator).compare(o1, o2);
     }
   }
 
@@ -130,12 +125,11 @@ public abstract class ForwardingSortedMap<K extends @Nullable Object, V extends
    * @since 7.0
    */
   @Override
-  @Beta
   protected boolean standardContainsKey(@CheckForNull Object key) {
     try {
       // any CCE or NPE will be caught
       @SuppressWarnings({"unchecked", "nullness"})
-      SortedMap<@Nullable Object, V> self = (SortedMap<@Nullable Object, V>) this;
+      SortedMap<Object, V> self = (SortedMap<Object, V>) this;
       Object ceilingKey = self.tailMap(key).firstKey();
       return unsafeCompare(comparator(), ceilingKey, key) == 0;
     } catch (ClassCastException | NoSuchElementException | NullPointerException e) {
@@ -150,7 +144,6 @@ public abstract class ForwardingSortedMap<K extends @Nullable Object, V extends
    *
    * @since 7.0
    */
-  @Beta
   protected SortedMap<K, V> standardSubMap(K fromKey, K toKey) {
     checkArgument(unsafeCompare(comparator(), fromKey, toKey) <= 0, "fromKey must be <= toKey");
     return tailMap(fromKey).headMap(toKey);
diff --git a/guava/src/com/google/common/collect/ForwardingSortedMultiset.java b/guava/src/com/google/common/collect/ForwardingSortedMultiset.java
index 4626d3193a..d7b4adb84a 100644
--- a/guava/src/com/google/common/collect/ForwardingSortedMultiset.java
+++ b/guava/src/com/google/common/collect/ForwardingSortedMultiset.java
@@ -14,13 +14,10 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.NavigableSet;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A sorted multiset which forwards all its method calls to another sorted multiset. Subclasses
@@ -44,10 +41,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 15.0
  */
-@Beta
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
-public abstract class ForwardingSortedMultiset<E extends @Nullable Object>
+public abstract class ForwardingSortedMultiset<E extends Object>
     extends ForwardingMultiset<E> implements SortedMultiset<E> {
   /** Constructor for use by subclasses. */
   protected ForwardingSortedMultiset() {}
diff --git a/guava/src/com/google/common/collect/ForwardingSortedSet.java b/guava/src/com/google/common/collect/ForwardingSortedSet.java
index 32625afd16..5ae16d3500 100644
--- a/guava/src/com/google/common/collect/ForwardingSortedSet.java
+++ b/guava/src/com/google/common/collect/ForwardingSortedSet.java
@@ -18,14 +18,11 @@ package com.google.common.collect;
 
 import static com.google.common.collect.ForwardingSortedMap.unsafeCompare;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.NoSuchElementException;
 import java.util.SortedSet;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A sorted set which forwards all its method calls to another sorted set. Subclasses should
@@ -54,9 +51,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public abstract class ForwardingSortedSet<E extends @Nullable Object> extends ForwardingSet<E>
+public abstract class ForwardingSortedSet<E extends Object> extends ForwardingSet<E>
     implements SortedSet<E> {
 
   /** Constructor for use by subclasses. */
@@ -106,12 +102,11 @@ public abstract class ForwardingSortedSet<E extends @Nullable Object> extends Fo
    * @since 7.0
    */
   @Override
-  @Beta
   protected boolean standardContains(@CheckForNull Object object) {
     try {
       // any ClassCastExceptions and NullPointerExceptions are caught
       @SuppressWarnings({"unchecked", "nullness"})
-      SortedSet<@Nullable Object> self = (SortedSet<@Nullable Object>) this;
+      SortedSet<Object> self = (SortedSet<Object>) this;
       Object ceiling = self.tailSet(object).first();
       return unsafeCompare(comparator(), ceiling, object) == 0;
     } catch (ClassCastException | NoSuchElementException | NullPointerException e) {
@@ -127,12 +122,11 @@ public abstract class ForwardingSortedSet<E extends @Nullable Object> extends Fo
    * @since 7.0
    */
   @Override
-  @Beta
   protected boolean standardRemove(@CheckForNull Object object) {
     try {
       // any ClassCastExceptions and NullPointerExceptions are caught
       @SuppressWarnings({"unchecked", "nullness"})
-      SortedSet<@Nullable Object> self = (SortedSet<@Nullable Object>) this;
+      SortedSet<Object> self = (SortedSet<Object>) this;
       Iterator<?> iterator = self.tailSet(object).iterator();
       if (iterator.hasNext()) {
         Object ceiling = iterator.next();
@@ -154,7 +148,6 @@ public abstract class ForwardingSortedSet<E extends @Nullable Object> extends Fo
    *
    * @since 7.0
    */
-  @Beta
   protected SortedSet<E> standardSubSet(
       @ParametricNullness E fromElement, @ParametricNullness E toElement) {
     return tailSet(fromElement).headSet(toElement);
diff --git a/guava/src/com/google/common/collect/ForwardingSortedSetMultimap.java b/guava/src/com/google/common/collect/ForwardingSortedSetMultimap.java
index b91a68b344..9df7a4601a 100644
--- a/guava/src/com/google/common/collect/ForwardingSortedSetMultimap.java
+++ b/guava/src/com/google/common/collect/ForwardingSortedSetMultimap.java
@@ -16,11 +16,9 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.Comparator;
 import java.util.SortedSet;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A sorted set multimap which forwards all its method calls to another sorted set multimap.
@@ -34,10 +32,9 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kurt Alfred Kluever
  * @since 3.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public abstract class ForwardingSortedSetMultimap<
-        K extends @Nullable Object, V extends @Nullable Object>
+        K extends Object, V extends Object>
     extends ForwardingSetMultimap<K, V> implements SortedSetMultimap<K, V> {
 
   /** Constructor for use by subclasses. */
diff --git a/guava/src/com/google/common/collect/ForwardingTable.java b/guava/src/com/google/common/collect/ForwardingTable.java
index 4fcb858b72..4b67ed6766 100644
--- a/guava/src/com/google/common/collect/ForwardingTable.java
+++ b/guava/src/com/google/common/collect/ForwardingTable.java
@@ -16,13 +16,10 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Collection;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A table which forwards all its method calls to another table. Subclasses should override one or
@@ -32,10 +29,9 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Gregory Kick
  * @since 7.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public abstract class ForwardingTable<
-        R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object>
+        R extends Object, C extends Object, V extends Object>
     extends ForwardingObject implements Table<R, C, V> {
   /** Constructor for use by subclasses. */
   protected ForwardingTable() {}
@@ -99,7 +95,6 @@ public abstract class ForwardingTable<
     return delegate().isEmpty();
   }
 
-  @CanIgnoreReturnValue
   @Override
   @CheckForNull
   public V put(
@@ -112,7 +107,6 @@ public abstract class ForwardingTable<
     delegate().putAll(table);
   }
 
-  @CanIgnoreReturnValue
   @Override
   @CheckForNull
   public V remove(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
diff --git a/guava/src/com/google/common/collect/GeneralRange.java b/guava/src/com/google/common/collect/GeneralRange.java
index 20cf4fbfc1..94c5e74f83 100644
--- a/guava/src/com/google/common/collect/GeneralRange.java
+++ b/guava/src/com/google/common/collect/GeneralRange.java
@@ -20,12 +20,10 @@ import static com.google.common.collect.BoundType.CLOSED;
 import static com.google.common.collect.BoundType.OPEN;
 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Objects;
 import java.io.Serializable;
 import java.util.Comparator;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A generalized interval on any ordering, for internal use. Supports {@code null}. Unlike {@link
@@ -36,9 +34,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @author Louis Wasserman
  */
-@GwtCompatible(serializable = true)
 @ElementTypesAreNonnullByDefault
-final class GeneralRange<T extends @Nullable Object> implements Serializable {
+final class GeneralRange<T extends Object> implements Serializable {
   /** Converts a Range to a GeneralRange. */
   static <T extends Comparable> GeneralRange<T> from(Range<T> range) {
     T lowerEndpoint = range.hasLowerBound() ? range.lowerEndpoint() : null;
@@ -57,7 +54,7 @@ final class GeneralRange<T extends @Nullable Object> implements Serializable {
   }
 
   /** Returns the whole range relative to the specified comparator. */
-  static <T extends @Nullable Object> GeneralRange<T> all(Comparator<? super T> comparator) {
+  static <T extends Object> GeneralRange<T> all(Comparator<? super T> comparator) {
     return new GeneralRange<T>(comparator, false, null, OPEN, false, null, OPEN);
   }
 
@@ -65,7 +62,7 @@ final class GeneralRange<T extends @Nullable Object> implements Serializable {
    * Returns everything above the endpoint relative to the specified comparator, with the specified
    * endpoint behavior.
    */
-  static <T extends @Nullable Object> GeneralRange<T> downTo(
+  static <T extends Object> GeneralRange<T> downTo(
       Comparator<? super T> comparator, @ParametricNullness T endpoint, BoundType boundType) {
     return new GeneralRange<T>(comparator, true, endpoint, boundType, false, null, OPEN);
   }
@@ -74,7 +71,7 @@ final class GeneralRange<T extends @Nullable Object> implements Serializable {
    * Returns everything below the endpoint relative to the specified comparator, with the specified
    * endpoint behavior.
    */
-  static <T extends @Nullable Object> GeneralRange<T> upTo(
+  static <T extends Object> GeneralRange<T> upTo(
       Comparator<? super T> comparator, @ParametricNullness T endpoint, BoundType boundType) {
     return new GeneralRange<T>(comparator, false, null, OPEN, true, endpoint, boundType);
   }
@@ -83,7 +80,7 @@ final class GeneralRange<T extends @Nullable Object> implements Serializable {
    * Returns everything between the endpoints relative to the specified comparator, with the
    * specified endpoint behavior.
    */
-  static <T extends @Nullable Object> GeneralRange<T> range(
+  static <T extends Object> GeneralRange<T> range(
       Comparator<? super T> comparator,
       @ParametricNullness T lower,
       BoundType lowerType,
diff --git a/guava/src/com/google/common/collect/GwtTransient.java b/guava/src/com/google/common/collect/GwtTransient.java
index ce5ea48848..1f5d2ce155 100644
--- a/guava/src/com/google/common/collect/GwtTransient.java
+++ b/guava/src/com/google/common/collect/GwtTransient.java
@@ -19,7 +19,6 @@ package com.google.common.collect;
 import static java.lang.annotation.ElementType.FIELD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
@@ -30,7 +29,6 @@ import java.lang.annotation.Target;
  * com.google.common.collect}.
  */
 @Documented
-@GwtCompatible
 @Retention(RUNTIME)
 @Target(FIELD)
 @ElementTypesAreNonnullByDefault
diff --git a/guava/src/com/google/common/collect/HashBasedTable.java b/guava/src/com/google/common/collect/HashBasedTable.java
index c8ba50fd15..cfc0822fe8 100644
--- a/guava/src/com/google/common/collect/HashBasedTable.java
+++ b/guava/src/com/google/common/collect/HashBasedTable.java
@@ -18,7 +18,6 @@ package com.google.common.collect;
 
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Supplier;
 import java.io.Serializable;
 import java.util.LinkedHashMap;
@@ -46,7 +45,6 @@ import java.util.Map;
  * @author Jared Levy
  * @since 7.0
  */
-@GwtCompatible(serializable = true)
 @ElementTypesAreNonnullByDefault
 public class HashBasedTable<R, C, V> extends StandardTable<R, C, V> {
   private static class Factory<C, V> implements Supplier<Map<C, V>>, Serializable {
diff --git a/guava/src/com/google/common/collect/HashBiMap.java b/guava/src/com/google/common/collect/HashBiMap.java
index b6e2042a24..30afef8158 100644
--- a/guava/src/com/google/common/collect/HashBiMap.java
+++ b/guava/src/com/google/common/collect/HashBiMap.java
@@ -20,14 +20,8 @@ import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 import static com.google.common.collect.Hashing.smearedHash;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Objects;
 import com.google.common.collect.Maps.IteratorBasedAbstractMap;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.concurrent.LazyInit;
-import com.google.j2objc.annotations.RetainedWith;
-import com.google.j2objc.annotations.Weak;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
@@ -41,7 +35,6 @@ import java.util.Set;
 import java.util.function.BiConsumer;
 import java.util.function.BiFunction;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link BiMap} backed by two hash tables. This implementation allows null keys and values. A
@@ -56,13 +49,12 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Mike Bostock
  * @since 2.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
-public final class HashBiMap<K extends @Nullable Object, V extends @Nullable Object>
+public final class HashBiMap<K extends Object, V extends Object>
     extends IteratorBasedAbstractMap<K, V> implements BiMap<K, V>, Serializable {
 
   /** Returns a new, empty {@code HashBiMap} with the default initial capacity (16). */
-  public static <K extends @Nullable Object, V extends @Nullable Object> HashBiMap<K, V> create() {
+  public static <K extends Object, V extends Object> HashBiMap<K, V> create() {
     return create(16);
   }
 
@@ -72,7 +64,7 @@ public final class HashBiMap<K extends @Nullable Object, V extends @Nullable Obj
    * @param expectedSize the expected number of entries
    * @throws IllegalArgumentException if the specified expected size is negative
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object> HashBiMap<K, V> create(
+  public static <K extends Object, V extends Object> HashBiMap<K, V> create(
       int expectedSize) {
     return new HashBiMap<>(expectedSize);
   }
@@ -81,14 +73,14 @@ public final class HashBiMap<K extends @Nullable Object, V extends @Nullable Obj
    * Constructs a new bimap containing initial values from {@code map}. The bimap is created with an
    * initial capacity sufficient to hold the mappings in the specified map.
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object> HashBiMap<K, V> create(
+  public static <K extends Object, V extends Object> HashBiMap<K, V> create(
       Map<? extends K, ? extends V> map) {
     HashBiMap<K, V> bimap = create(map.size());
     bimap.putAll(map);
     return bimap;
   }
 
-  private static final class BiEntry<K extends @Nullable Object, V extends @Nullable Object>
+  private static final class BiEntry<K extends Object, V extends Object>
       extends ImmutableEntry<K, V> {
     final int keyHash;
     final int valueHash;
@@ -100,10 +92,10 @@ public final class HashBiMap<K extends @Nullable Object, V extends @Nullable Obj
     // which would cause memory leaks when non-empty HashBiMap with cyclic BiEntry
     // instances is deallocated.
     @CheckForNull BiEntry<K, V> nextInKToVBucket;
-    @Weak @CheckForNull BiEntry<K, V> nextInVToKBucket;
+    @CheckForNull BiEntry<K, V> nextInVToKBucket;
 
-    @Weak @CheckForNull BiEntry<K, V> nextInKeyInsertionOrder;
-    @Weak @CheckForNull BiEntry<K, V> prevInKeyInsertionOrder;
+    @CheckForNull BiEntry<K, V> nextInKeyInsertionOrder;
+    @CheckForNull BiEntry<K, V> prevInKeyInsertionOrder;
 
     BiEntry(@ParametricNullness K key, int keyHash, @ParametricNullness V value, int valueHash) {
       super(key, value);
@@ -119,10 +111,10 @@ public final class HashBiMap<K extends @Nullable Object, V extends @Nullable Obj
    * they are not initialized inline in the constructor, they are initialized from init(), which the
    * constructor calls (as does readObject()).
    */
-  private transient @Nullable BiEntry<K, V>[] hashTableKToV;
-  private transient @Nullable BiEntry<K, V>[] hashTableVToK;
-  @Weak @CheckForNull private transient BiEntry<K, V> firstInKeyInsertionOrder;
-  @Weak @CheckForNull private transient BiEntry<K, V> lastInKeyInsertionOrder;
+  private transient BiEntry<K, V>[] hashTableKToV;
+  private transient BiEntry<K, V>[] hashTableVToK;
+  @CheckForNull private transient BiEntry<K, V> firstInKeyInsertionOrder;
+  @CheckForNull private transient BiEntry<K, V> lastInKeyInsertionOrder;
   private transient int size;
   private transient int mask;
   private transient int modCount;
@@ -283,7 +275,6 @@ public final class HashBiMap<K extends @Nullable Object, V extends @Nullable Obj
     return Maps.valueOrNull(seekByKey(key, smearedHash(key)));
   }
 
-  @CanIgnoreReturnValue
   @Override
   @CheckForNull
   public V put(@ParametricNullness K key, @ParametricNullness V value) {
@@ -325,7 +316,6 @@ public final class HashBiMap<K extends @Nullable Object, V extends @Nullable Obj
     }
   }
 
-  @CanIgnoreReturnValue
   @Override
   @CheckForNull
   public V forcePut(@ParametricNullness K key, @ParametricNullness V value) {
@@ -378,7 +368,7 @@ public final class HashBiMap<K extends @Nullable Object, V extends @Nullable Obj
   }
 
   private void rehashIfNecessary() {
-    @Nullable BiEntry<K, V>[] oldKToV = hashTableKToV;
+    BiEntry<K, V>[] oldKToV = hashTableKToV;
     if (Hashing.needsResizing(size, oldKToV.length, LOAD_FACTOR)) {
       int newTableSize = oldKToV.length * 2;
 
@@ -397,11 +387,10 @@ public final class HashBiMap<K extends @Nullable Object, V extends @Nullable Obj
   }
 
   @SuppressWarnings({"unchecked", "rawtypes"})
-  private @Nullable BiEntry<K, V>[] createTable(int length) {
-    return new @Nullable BiEntry[length];
+  private BiEntry<K, V>[] createTable(int length) {
+    return new BiEntry[length];
   }
 
-  @CanIgnoreReturnValue
   @Override
   @CheckForNull
   public V remove(@CheckForNull Object key) {
@@ -431,7 +420,7 @@ public final class HashBiMap<K extends @Nullable Object, V extends @Nullable Obj
     return size;
   }
 
-  abstract class Itr<T extends @Nullable Object> implements Iterator<T> {
+  abstract class Itr<T extends Object> implements Iterator<T> {
     @CheckForNull BiEntry<K, V> next = firstInKeyInsertionOrder;
     @CheckForNull BiEntry<K, V> toRemove = null;
     int expectedModCount = modCount;
@@ -583,7 +572,7 @@ public final class HashBiMap<K extends @Nullable Object, V extends @Nullable Obj
     }
   }
 
-  @LazyInit @RetainedWith @CheckForNull private transient BiMap<V, K> inverse;
+  @CheckForNull private transient BiMap<V, K> inverse;
 
   @Override
   public BiMap<V, K> inverse() {
@@ -618,7 +607,6 @@ public final class HashBiMap<K extends @Nullable Object, V extends @Nullable Obj
       return Maps.keyOrNull(seekByValue(value, smearedHash(value)));
     }
 
-    @CanIgnoreReturnValue
     @Override
     @CheckForNull
     public K put(@ParametricNullness V value, @ParametricNullness K key) {
@@ -754,7 +742,7 @@ public final class HashBiMap<K extends @Nullable Object, V extends @Nullable Obj
   }
 
   private static final class InverseSerializedForm<
-          K extends @Nullable Object, V extends @Nullable Object>
+          K extends Object, V extends Object>
       implements Serializable {
     private final HashBiMap<K, V> bimap;
 
@@ -770,13 +758,13 @@ public final class HashBiMap<K extends @Nullable Object, V extends @Nullable Obj
   /**
    * @serialData the number of entries, first key, first value, second key, second value, and so on.
    */
-  @GwtIncompatible // java.io.ObjectOutputStream
+  // java.io.ObjectOutputStream
   private void writeObject(ObjectOutputStream stream) throws IOException {
     stream.defaultWriteObject();
     Serialization.writeMap(this, stream);
   }
 
-  @GwtIncompatible // java.io.ObjectInputStream
+  // java.io.ObjectInputStream
   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
     stream.defaultReadObject();
     int size = Serialization.readCount(stream);
@@ -784,6 +772,6 @@ public final class HashBiMap<K extends @Nullable Object, V extends @Nullable Obj
     Serialization.populateMap(this, stream, size);
   }
 
-  @GwtIncompatible // Not needed in emulated source
+  // Not needed in emulated source
   private static final long serialVersionUID = 0;
 }
diff --git a/guava/src/com/google/common/collect/HashMultimap.java b/guava/src/com/google/common/collect/HashMultimap.java
index 9e4c1c2233..22bad0e8ec 100644
--- a/guava/src/com/google/common/collect/HashMultimap.java
+++ b/guava/src/com/google/common/collect/HashMultimap.java
@@ -16,9 +16,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Preconditions;
 import java.io.IOException;
 import java.io.ObjectInputStream;
@@ -26,7 +23,6 @@ import java.io.ObjectOutputStream;
 import java.util.Collection;
 import java.util.Map;
 import java.util.Set;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@link Multimap} using hash tables.
@@ -48,13 +44,12 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Jared Levy
  * @since 2.0
  */
-@GwtCompatible(serializable = true, emulated = true)
 @ElementTypesAreNonnullByDefault
-public final class HashMultimap<K extends @Nullable Object, V extends @Nullable Object>
+public final class HashMultimap<K extends Object, V extends Object>
     extends HashMultimapGwtSerializationDependencies<K, V> {
   private static final int DEFAULT_VALUES_PER_KEY = 2;
 
-  @VisibleForTesting transient int expectedValuesPerKey = DEFAULT_VALUES_PER_KEY;
+  transient int expectedValuesPerKey = DEFAULT_VALUES_PER_KEY;
 
   /**
    * Creates a new, empty {@code HashMultimap} with the default initial capacities.
@@ -62,7 +57,7 @@ public final class HashMultimap<K extends @Nullable Object, V extends @Nullable
    * <p>This method will soon be deprecated in favor of {@code
    * MultimapBuilder.hashKeys().hashSetValues().build()}.
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       HashMultimap<K, V> create() {
     return new HashMultimap<>();
   }
@@ -79,7 +74,7 @@ public final class HashMultimap<K extends @Nullable Object, V extends @Nullable
    * @throws IllegalArgumentException if {@code expectedKeys} or {@code expectedValuesPerKey} is
    *     negative
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object> HashMultimap<K, V> create(
+  public static <K extends Object, V extends Object> HashMultimap<K, V> create(
       int expectedKeys, int expectedValuesPerKey) {
     return new HashMultimap<>(expectedKeys, expectedValuesPerKey);
   }
@@ -94,7 +89,7 @@ public final class HashMultimap<K extends @Nullable Object, V extends @Nullable
    *
    * @param multimap the multimap whose contents are copied to this multimap
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object> HashMultimap<K, V> create(
+  public static <K extends Object, V extends Object> HashMultimap<K, V> create(
       Multimap<? extends K, ? extends V> multimap) {
     return new HashMultimap<>(multimap);
   }
@@ -130,13 +125,13 @@ public final class HashMultimap<K extends @Nullable Object, V extends @Nullable
    * @serialData expectedValuesPerKey, number of distinct keys, and then for each distinct key: the
    *     key, number of values for that key, and the key's values
    */
-  @GwtIncompatible // java.io.ObjectOutputStream
+  // java.io.ObjectOutputStream
   private void writeObject(ObjectOutputStream stream) throws IOException {
     stream.defaultWriteObject();
     Serialization.writeMultimap(this, stream);
   }
 
-  @GwtIncompatible // java.io.ObjectInputStream
+  // java.io.ObjectInputStream
   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
     stream.defaultReadObject();
     expectedValuesPerKey = DEFAULT_VALUES_PER_KEY;
@@ -146,6 +141,6 @@ public final class HashMultimap<K extends @Nullable Object, V extends @Nullable
     Serialization.populateMultimap(this, stream, distinctKeys);
   }
 
-  @GwtIncompatible // Not needed in emulated source
+  // Not needed in emulated source
   private static final long serialVersionUID = 0;
 }
diff --git a/guava/src/com/google/common/collect/HashMultimapGwtSerializationDependencies.java b/guava/src/com/google/common/collect/HashMultimapGwtSerializationDependencies.java
index 0922c38390..20a68ca2ec 100644
--- a/guava/src/com/google/common/collect/HashMultimapGwtSerializationDependencies.java
+++ b/guava/src/com/google/common/collect/HashMultimapGwtSerializationDependencies.java
@@ -16,7 +16,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.Collection;
 import java.util.Map;
 
@@ -29,7 +28,6 @@ import java.util.Map;
  *
  * <p>TODO(cpovirk): Consider applying this subclass approach to our other types.
  */
-@GwtCompatible(emulated = true)
 abstract class HashMultimapGwtSerializationDependencies<K, V> extends AbstractSetMultimap<K, V> {
   HashMultimapGwtSerializationDependencies(Map<K, Collection<V>> map) {
     super(map);
diff --git a/guava/src/com/google/common/collect/HashMultiset.java b/guava/src/com/google/common/collect/HashMultiset.java
index b91645739c..dbb67df498 100644
--- a/guava/src/com/google/common/collect/HashMultiset.java
+++ b/guava/src/com/google/common/collect/HashMultiset.java
@@ -16,13 +16,10 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.util.HashMap;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Multiset implementation backed by a {@link HashMap}.
@@ -31,12 +28,11 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Jared Levy
  * @since 2.0
  */
-@GwtCompatible(serializable = true, emulated = true)
 @ElementTypesAreNonnullByDefault
-public final class HashMultiset<E extends @Nullable Object> extends AbstractMapBasedMultiset<E> {
+public final class HashMultiset<E extends Object> extends AbstractMapBasedMultiset<E> {
 
   /** Creates a new, empty {@code HashMultiset} using the default initial capacity. */
-  public static <E extends @Nullable Object> HashMultiset<E> create() {
+  public static <E extends Object> HashMultiset<E> create() {
     return new HashMultiset<E>();
   }
 
@@ -47,7 +43,7 @@ public final class HashMultiset<E extends @Nullable Object> extends AbstractMapB
    * @param distinctElements the expected number of distinct elements
    * @throws IllegalArgumentException if {@code distinctElements} is negative
    */
-  public static <E extends @Nullable Object> HashMultiset<E> create(int distinctElements) {
+  public static <E extends Object> HashMultiset<E> create(int distinctElements) {
     return new HashMultiset<E>(distinctElements);
   }
 
@@ -58,7 +54,7 @@ public final class HashMultiset<E extends @Nullable Object> extends AbstractMapB
    *
    * @param elements the elements that the multiset should contain
    */
-  public static <E extends @Nullable Object> HashMultiset<E> create(
+  public static <E extends Object> HashMultiset<E> create(
       Iterable<? extends E> elements) {
     HashMultiset<E> multiset = create(Multisets.inferDistinctElements(elements));
     Iterables.addAll(multiset, elements);
@@ -77,13 +73,13 @@ public final class HashMultiset<E extends @Nullable Object> extends AbstractMapB
    * @serialData the number of distinct elements, the first element, its count, the second element,
    *     its count, and so on
    */
-  @GwtIncompatible // java.io.ObjectOutputStream
+  // java.io.ObjectOutputStream
   private void writeObject(ObjectOutputStream stream) throws IOException {
     stream.defaultWriteObject();
     Serialization.writeMultiset(this, stream);
   }
 
-  @GwtIncompatible // java.io.ObjectInputStream
+  // java.io.ObjectInputStream
   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
     stream.defaultReadObject();
     int distinctElements = Serialization.readCount(stream);
@@ -91,6 +87,6 @@ public final class HashMultiset<E extends @Nullable Object> extends AbstractMapB
     Serialization.populateMultiset(this, stream, distinctElements);
   }
 
-  @GwtIncompatible // Not needed in emulated source.
+  // Not needed in emulated source.
   private static final long serialVersionUID = 0;
 }
diff --git a/guava/src/com/google/common/collect/Hashing.java b/guava/src/com/google/common/collect/Hashing.java
index 81ef67ebbc..1a130f9d96 100644
--- a/guava/src/com/google/common/collect/Hashing.java
+++ b/guava/src/com/google/common/collect/Hashing.java
@@ -16,7 +16,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.primitives.Ints;
 import javax.annotation.CheckForNull;
 
@@ -27,7 +26,6 @@ import javax.annotation.CheckForNull;
  * @author Jesse Wilson
  * @author Austin Appleby
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 final class Hashing {
   private Hashing() {}
diff --git a/guava/src/com/google/common/collect/ImmutableAsList.java b/guava/src/com/google/common/collect/ImmutableAsList.java
index c397479317..aa1f821b51 100644
--- a/guava/src/com/google/common/collect/ImmutableAsList.java
+++ b/guava/src/com/google/common/collect/ImmutableAsList.java
@@ -16,8 +16,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import java.io.InvalidObjectException;
 import java.io.ObjectInputStream;
 import java.io.Serializable;
@@ -30,7 +28,6 @@ import javax.annotation.CheckForNull;
  * @author Jared Levy
  * @author Louis Wasserman
  */
-@GwtCompatible(serializable = true, emulated = true)
 @SuppressWarnings("serial")
 @ElementTypesAreNonnullByDefault
 abstract class ImmutableAsList<E> extends ImmutableList<E> {
@@ -59,7 +56,7 @@ abstract class ImmutableAsList<E> extends ImmutableList<E> {
   }
 
   /** Serialized form that leads to the same performance as the original list. */
-  @GwtIncompatible // serialization
+  // serialization
   static class SerializedForm implements Serializable {
     final ImmutableCollection<?> collection;
 
@@ -74,12 +71,12 @@ abstract class ImmutableAsList<E> extends ImmutableList<E> {
     private static final long serialVersionUID = 0;
   }
 
-  @GwtIncompatible // serialization
+  // serialization
   private void readObject(ObjectInputStream stream) throws InvalidObjectException {
     throw new InvalidObjectException("Use SerializedForm");
   }
 
-  @GwtIncompatible // serialization
+  // serialization
   @Override
   Object writeReplace() {
     return new SerializedForm(delegateCollection());
diff --git a/guava/src/com/google/common/collect/ImmutableBiMap.java b/guava/src/com/google/common/collect/ImmutableBiMap.java
index 2f2e9ab5ca..f77f2ef9a9 100644
--- a/guava/src/com/google/common/collect/ImmutableBiMap.java
+++ b/guava/src/com/google/common/collect/ImmutableBiMap.java
@@ -20,11 +20,6 @@ import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.VisibleForTesting;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotCall;
 import java.util.Arrays;
 import java.util.Comparator;
 import java.util.Map;
@@ -32,7 +27,6 @@ import java.util.function.Function;
 import java.util.stream.Collector;
 import java.util.stream.Collectors;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link BiMap} whose contents will never change, with many other important properties detailed
@@ -41,7 +35,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Jared Levy
  * @since 2.0
  */
-@GwtCompatible(serializable = true, emulated = true)
 @ElementTypesAreNonnullByDefault
 public abstract class ImmutableBiMap<K, V> extends ImmutableBiMapFauxverideShim<K, V>
     implements BiMap<K, V> {
@@ -58,7 +51,7 @@ public abstract class ImmutableBiMap<K, V> extends ImmutableBiMapFauxverideShim<
    *
    * @since 21.0
    */
-  public static <T extends @Nullable Object, K, V>
+  public static <T extends Object, K, V>
       Collector<T, ?, ImmutableBiMap<K, V>> toImmutableBiMap(
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends V> valueFunction) {
@@ -300,7 +293,6 @@ public abstract class ImmutableBiMap<K, V> extends ImmutableBiMapFauxverideShim<
    *
    * @since 23.1
    */
-  @Beta
   public static <K, V> Builder<K, V> builderWithExpectedSize(int expectedSize) {
     checkNonnegative(expectedSize, "expectedSize");
     return new Builder<>(expectedSize);
@@ -350,7 +342,6 @@ public abstract class ImmutableBiMap<K, V> extends ImmutableBiMapFauxverideShim<
      * Associates {@code key} with {@code value} in the built bimap. Duplicate keys or values are
      * not allowed, and will cause {@link #build} to fail.
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<K, V> put(K key, V value) {
       super.put(key, value);
@@ -363,7 +354,6 @@ public abstract class ImmutableBiMap<K, V> extends ImmutableBiMapFauxverideShim<
      *
      * @since 19.0
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<K, V> put(Entry<? extends K, ? extends V> entry) {
       super.put(entry);
@@ -376,7 +366,6 @@ public abstract class ImmutableBiMap<K, V> extends ImmutableBiMapFauxverideShim<
      *
      * @throws NullPointerException if any key or value in {@code map} is null
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<K, V> putAll(Map<? extends K, ? extends V> map) {
       super.putAll(map);
@@ -390,8 +379,6 @@ public abstract class ImmutableBiMap<K, V> extends ImmutableBiMapFauxverideShim<
      * @throws NullPointerException if any key, value, or entry is null
      * @since 19.0
      */
-    @CanIgnoreReturnValue
-    @Beta
     @Override
     public Builder<K, V> putAll(Iterable<? extends Entry<? extends K, ? extends V>> entries) {
       super.putAll(entries);
@@ -408,8 +395,6 @@ public abstract class ImmutableBiMap<K, V> extends ImmutableBiMapFauxverideShim<
      * @throws IllegalStateException if this method was already called
      * @since 19.0
      */
-    @CanIgnoreReturnValue
-    @Beta
     @Override
     public Builder<K, V> orderEntriesByValue(Comparator<? super V> valueComparator) {
       super.orderEntriesByValue(valueComparator);
@@ -417,7 +402,6 @@ public abstract class ImmutableBiMap<K, V> extends ImmutableBiMapFauxverideShim<
     }
 
     @Override
-    @CanIgnoreReturnValue
     Builder<K, V> combine(ImmutableMap.Builder<K, V> builder) {
       super.combine(builder);
       return this;
@@ -481,7 +465,6 @@ public abstract class ImmutableBiMap<K, V> extends ImmutableBiMapFauxverideShim<
     }
 
     @Override
-    @VisibleForTesting
     ImmutableBiMap<K, V> buildJdkBacked() {
       checkState(
           valueComparator == null,
@@ -538,7 +521,6 @@ public abstract class ImmutableBiMap<K, V> extends ImmutableBiMapFauxverideShim<
    * @throws NullPointerException if any key, value, or entry is null
    * @since 19.0
    */
-  @Beta
   public static <K, V> ImmutableBiMap<K, V> copyOf(
       Iterable<? extends Entry<? extends K, ? extends V>> entries) {
     @SuppressWarnings("unchecked") // we'll only be using getKey and getValue, which are covariant
@@ -588,10 +570,8 @@ public abstract class ImmutableBiMap<K, V> extends ImmutableBiMapFauxverideShim<
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   @CheckForNull
   public final V forcePut(K key, V value) {
     throw new UnsupportedOperationException();
diff --git a/guava/src/com/google/common/collect/ImmutableBiMapFauxverideShim.java b/guava/src/com/google/common/collect/ImmutableBiMapFauxverideShim.java
index 2f1f25c829..763d9e7633 100644
--- a/guava/src/com/google/common/collect/ImmutableBiMapFauxverideShim.java
+++ b/guava/src/com/google/common/collect/ImmutableBiMapFauxverideShim.java
@@ -16,12 +16,9 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.DoNotCall;
 import java.util.function.BinaryOperator;
 import java.util.function.Function;
 import java.util.stream.Collector;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * "Overrides" the {@link ImmutableMap} static methods that lack {@link ImmutableBiMap} equivalents
@@ -30,7 +27,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @author Louis Wasserman
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 abstract class ImmutableBiMapFauxverideShim<K, V> extends ImmutableMap<K, V> {
   /**
@@ -42,8 +38,7 @@ abstract class ImmutableBiMapFauxverideShim<K, V> extends ImmutableMap<K, V> {
    * @deprecated Use {@link ImmutableBiMap#toImmutableBiMap}.
    */
   @Deprecated
-  @DoNotCall("Use toImmutableBiMap")
-  public static <T extends @Nullable Object, K, V>
+  public static <T extends Object, K, V>
       Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends V> valueFunction) {
@@ -59,8 +54,7 @@ abstract class ImmutableBiMapFauxverideShim<K, V> extends ImmutableMap<K, V> {
    * @deprecated
    */
   @Deprecated
-  @DoNotCall("Use toImmutableBiMap")
-  public static <T extends @Nullable Object, K, V>
+  public static <T extends Object, K, V>
       Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends V> valueFunction,
diff --git a/guava/src/com/google/common/collect/ImmutableClassToInstanceMap.java b/guava/src/com/google/common/collect/ImmutableClassToInstanceMap.java
index 1253373d73..67447636ec 100644
--- a/guava/src/com/google/common/collect/ImmutableClassToInstanceMap.java
+++ b/guava/src/com/google/common/collect/ImmutableClassToInstanceMap.java
@@ -18,11 +18,7 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.primitives.Primitives;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotCall;
-import com.google.errorprone.annotations.Immutable;
 import java.io.Serializable;
 import java.util.Map;
 import javax.annotation.CheckForNull;
@@ -34,8 +30,6 @@ import javax.annotation.CheckForNull;
  * @author Kevin Bourrillion
  * @since 2.0
  */
-@Immutable(containerOf = "B")
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class ImmutableClassToInstanceMap<B> extends ForwardingMap<Class<? extends B>, B>
     implements ClassToInstanceMap<B>, Serializable {
@@ -97,7 +91,6 @@ public final class ImmutableClassToInstanceMap<B> extends ForwardingMap<Class<?
      * Associates {@code key} with {@code value} in the built map. Duplicate keys are not allowed,
      * and will cause {@link #build} to fail.
      */
-    @CanIgnoreReturnValue
     public <T extends B> Builder<B> put(Class<T> key, T value) {
       mapBuilder.put(key, value);
       return this;
@@ -110,7 +103,6 @@ public final class ImmutableClassToInstanceMap<B> extends ForwardingMap<Class<?
      * @throws NullPointerException if any key or value in {@code map} is null
      * @throws ClassCastException if any value is not an instance of the type specified by its key
      */
-    @CanIgnoreReturnValue
     public <T extends B> Builder<B> putAll(Map<? extends Class<? extends T>, ? extends T> map) {
       for (Entry<? extends Class<? extends T>, ? extends T> entry : map.entrySet()) {
         Class<? extends T> type = entry.getKey();
@@ -185,10 +177,8 @@ public final class ImmutableClassToInstanceMap<B> extends ForwardingMap<Class<?
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   @CheckForNull
   public <T extends B> T putInstance(Class<T> type, T value) {
     throw new UnsupportedOperationException();
diff --git a/guava/src/com/google/common/collect/ImmutableCollection.java b/guava/src/com/google/common/collect/ImmutableCollection.java
index 80fefb6e7e..d4087e5725 100644
--- a/guava/src/com/google/common/collect/ImmutableCollection.java
+++ b/guava/src/com/google/common/collect/ImmutableCollection.java
@@ -18,10 +18,6 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotCall;
-import com.google.errorprone.annotations.DoNotMock;
 import java.io.Serializable;
 import java.util.AbstractCollection;
 import java.util.Collection;
@@ -33,7 +29,6 @@ import java.util.Spliterator;
 import java.util.Spliterators;
 import java.util.function.Predicate;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link Collection} whose contents will never change, and which offers a few additional
@@ -160,8 +155,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @since 2.0
  */
-@DoNotMock("Use ImmutableList.of or another implementation")
-@GwtCompatible(emulated = true)
 @SuppressWarnings("serial") // we're overriding default serialization
 @ElementTypesAreNonnullByDefault
 // TODO(kevinb): I think we should push everything down to "BaseImmutableCollection" or something,
@@ -193,7 +186,6 @@ public abstract class ImmutableCollection<E> extends AbstractCollection<E> imple
     return toArray(EMPTY_ARRAY);
   }
 
-  @CanIgnoreReturnValue
   @Override
   /*
    * This suppression is here for two reasons:
@@ -208,7 +200,7 @@ public abstract class ImmutableCollection<E> extends AbstractCollection<E> imple
    * nullness perspective. The signature below at least has the virtue of being relatively simple.
    */
   @SuppressWarnings("nullness")
-  public final <T extends @Nullable Object> T[] toArray(T[] other) {
+  public final <T extends Object> T[] toArray(T[] other) {
     checkNotNull(other);
     int size = size();
 
@@ -256,10 +248,8 @@ public abstract class ImmutableCollection<E> extends AbstractCollection<E> imple
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final boolean add(E e) {
     throw new UnsupportedOperationException();
   }
@@ -270,10 +260,8 @@ public abstract class ImmutableCollection<E> extends AbstractCollection<E> imple
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final boolean remove(@CheckForNull Object object) {
     throw new UnsupportedOperationException();
   }
@@ -284,10 +272,8 @@ public abstract class ImmutableCollection<E> extends AbstractCollection<E> imple
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final boolean addAll(Collection<? extends E> newElements) {
     throw new UnsupportedOperationException();
   }
@@ -298,10 +284,8 @@ public abstract class ImmutableCollection<E> extends AbstractCollection<E> imple
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final boolean removeAll(Collection<?> oldElements) {
     throw new UnsupportedOperationException();
   }
@@ -312,10 +296,8 @@ public abstract class ImmutableCollection<E> extends AbstractCollection<E> imple
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final boolean removeIf(Predicate<? super E> filter) {
     throw new UnsupportedOperationException();
   }
@@ -328,7 +310,6 @@ public abstract class ImmutableCollection<E> extends AbstractCollection<E> imple
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final boolean retainAll(Collection<?> elementsToKeep) {
     throw new UnsupportedOperationException();
   }
@@ -341,7 +322,6 @@ public abstract class ImmutableCollection<E> extends AbstractCollection<E> imple
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final void clear() {
     throw new UnsupportedOperationException();
   }
@@ -379,8 +359,7 @@ public abstract class ImmutableCollection<E> extends AbstractCollection<E> imple
    * Copies the contents of this immutable collection into the specified array at the specified
    * offset. Returns {@code offset + size()}.
    */
-  @CanIgnoreReturnValue
-  int copyIntoArray(@Nullable Object[] dst, int offset) {
+  int copyIntoArray(Object[] dst, int offset) {
     for (E e : this) {
       dst[offset++] = e;
     }
@@ -397,7 +376,6 @@ public abstract class ImmutableCollection<E> extends AbstractCollection<E> imple
    *
    * @since 10.0
    */
-  @DoNotMock
   public abstract static class Builder<E> {
     static final int DEFAULT_INITIAL_CAPACITY = 4;
 
@@ -428,7 +406,6 @@ public abstract class ImmutableCollection<E> extends AbstractCollection<E> imple
      * @return this {@code Builder} instance
      * @throws NullPointerException if {@code element} is null
      */
-    @CanIgnoreReturnValue
     public abstract Builder<E> add(E element);
 
     /**
@@ -441,7 +418,6 @@ public abstract class ImmutableCollection<E> extends AbstractCollection<E> imple
      * @return this {@code Builder} instance
      * @throws NullPointerException if {@code elements} is null or contains a null element
      */
-    @CanIgnoreReturnValue
     public Builder<E> add(E... elements) {
       for (E element : elements) {
         add(element);
@@ -459,7 +435,6 @@ public abstract class ImmutableCollection<E> extends AbstractCollection<E> imple
      * @return this {@code Builder} instance
      * @throws NullPointerException if {@code elements} is null or contains a null element
      */
-    @CanIgnoreReturnValue
     public Builder<E> addAll(Iterable<? extends E> elements) {
       for (E element : elements) {
         add(element);
@@ -477,7 +452,6 @@ public abstract class ImmutableCollection<E> extends AbstractCollection<E> imple
      * @return this {@code Builder} instance
      * @throws NullPointerException if {@code elements} is null or contains a null element
      */
-    @CanIgnoreReturnValue
     public Builder<E> addAll(Iterator<? extends E> elements) {
       while (elements.hasNext()) {
         add(elements.next());
diff --git a/guava/src/com/google/common/collect/ImmutableEntry.java b/guava/src/com/google/common/collect/ImmutableEntry.java
index edc25f490f..a844223724 100644
--- a/guava/src/com/google/common/collect/ImmutableEntry.java
+++ b/guava/src/com/google/common/collect/ImmutableEntry.java
@@ -16,14 +16,11 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** @see com.google.common.collect.Maps#immutableEntry(Object, Object) */
-@GwtCompatible(serializable = true)
 @ElementTypesAreNonnullByDefault
-class ImmutableEntry<K extends @Nullable Object, V extends @Nullable Object>
+class ImmutableEntry<K extends Object, V extends Object>
     extends AbstractMapEntry<K, V> implements Serializable {
   @ParametricNullness final K key;
   @ParametricNullness final V value;
diff --git a/guava/src/com/google/common/collect/ImmutableEnumMap.java b/guava/src/com/google/common/collect/ImmutableEnumMap.java
index d1e10f97d0..0c731fc491 100644
--- a/guava/src/com/google/common/collect/ImmutableEnumMap.java
+++ b/guava/src/com/google/common/collect/ImmutableEnumMap.java
@@ -18,7 +18,6 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.ImmutableMap.IteratorBasedImmutableMap;
 import java.io.Serializable;
 import java.util.EnumMap;
@@ -31,7 +30,6 @@ import javax.annotation.CheckForNull;
  *
  * @author Louis Wasserman
  */
-@GwtCompatible(serializable = true, emulated = true)
 @SuppressWarnings("serial") // we're overriding default serialization
 @ElementTypesAreNonnullByDefault
 final class ImmutableEnumMap<K extends Enum<K>, V> extends IteratorBasedImmutableMap<K, V> {
diff --git a/guava/src/com/google/common/collect/ImmutableEnumSet.java b/guava/src/com/google/common/collect/ImmutableEnumSet.java
index 32287bdd2b..40b113fbc2 100644
--- a/guava/src/com/google/common/collect/ImmutableEnumSet.java
+++ b/guava/src/com/google/common/collect/ImmutableEnumSet.java
@@ -16,8 +16,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.concurrent.LazyInit;
 import java.io.Serializable;
 import java.util.Collection;
 import java.util.EnumSet;
@@ -30,7 +28,6 @@ import javax.annotation.CheckForNull;
  *
  * @author Jared Levy
  */
-@GwtCompatible(serializable = true, emulated = true)
 @SuppressWarnings("serial") // we're overriding default serialization
 @ElementTypesAreNonnullByDefault
 final class ImmutableEnumSet<E extends Enum<E>> extends ImmutableSet<E> {
@@ -119,7 +116,7 @@ final class ImmutableEnumSet<E extends Enum<E>> extends ImmutableSet<E> {
     return true;
   }
 
-  @LazyInit private transient int hashCode;
+  private transient int hashCode;
 
   @Override
   public int hashCode() {
diff --git a/guava/src/com/google/common/collect/ImmutableList.java b/guava/src/com/google/common/collect/ImmutableList.java
index 115c022479..20a7201570 100644
--- a/guava/src/com/google/common/collect/ImmutableList.java
+++ b/guava/src/com/google/common/collect/ImmutableList.java
@@ -25,12 +25,6 @@ import static com.google.common.collect.ObjectArrays.checkElementsNotNull;
 import static com.google.common.collect.RegularImmutableList.EMPTY;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.VisibleForTesting;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotCall;
-import com.google.errorprone.annotations.InlineMe;
 import java.io.InvalidObjectException;
 import java.io.ObjectInputStream;
 import java.io.Serializable;
@@ -46,7 +40,6 @@ import java.util.function.Consumer;
 import java.util.function.UnaryOperator;
 import java.util.stream.Collector;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link List} whose contents will never change, with many other important properties detailed at
@@ -60,7 +53,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kevin Bourrillion
  * @since 2.0
  */
-@GwtCompatible(serializable = true, emulated = true)
 @SuppressWarnings("serial") // we're overriding default serialization
 @ElementTypesAreNonnullByDefault
 public abstract class ImmutableList<E> extends ImmutableCollection<E>
@@ -366,7 +358,7 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
    * Views the array as an immutable list. Copies if the specified range does not cover the complete
    * array. Does not check for nulls.
    */
-  static <E> ImmutableList<E> asImmutableList(@Nullable Object[] elements, int length) {
+  static <E> ImmutableList<E> asImmutableList(Object[] elements, int length) {
     switch (length) {
       case 0:
         return of();
@@ -506,10 +498,8 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final boolean addAll(int index, Collection<? extends E> newElements) {
     throw new UnsupportedOperationException();
   }
@@ -520,10 +510,8 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final E set(int index, E element) {
     throw new UnsupportedOperationException();
   }
@@ -536,7 +524,6 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final void add(int index, E element) {
     throw new UnsupportedOperationException();
   }
@@ -547,10 +534,8 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final E remove(int index) {
     throw new UnsupportedOperationException();
   }
@@ -563,7 +548,6 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final void replaceAll(UnaryOperator<E> operator) {
     throw new UnsupportedOperationException();
   }
@@ -576,7 +560,6 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final void sort(Comparator<? super E> c) {
     throw new UnsupportedOperationException();
   }
@@ -587,7 +570,6 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
    * @since 2.0
    * @deprecated There is no reason to use this; it always returns {@code this}.
    */
-  @InlineMe(replacement = "this")
   @Deprecated
   @Override
   public final ImmutableList<E> asList() {
@@ -600,7 +582,7 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
   }
 
   @Override
-  int copyIntoArray(@Nullable Object[] dst, int offset) {
+  int copyIntoArray(Object[] dst, int offset) {
     // this loop is faster for RandomAccess instances, which ImmutableLists are
     int size = size();
     for (int i = 0; i < size; i++) {
@@ -745,7 +727,6 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
    *
    * @since 23.1
    */
-  @Beta
   public static <E> Builder<E> builderWithExpectedSize(int expectedSize) {
     checkNonnegative(expectedSize, "expectedSize");
     return new ImmutableList.Builder<E>(expectedSize);
@@ -773,7 +754,7 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
    */
   public static final class Builder<E> extends ImmutableCollection.Builder<E> {
     // The first `size` elements are non-null.
-    @VisibleForTesting @Nullable Object[] contents;
+    Object[] contents;
     private int size;
     private boolean forceCopy;
 
@@ -786,7 +767,7 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
     }
 
     Builder(int capacity) {
-      this.contents = new @Nullable Object[capacity];
+      this.contents = new Object[capacity];
       this.size = 0;
     }
 
@@ -807,7 +788,6 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
      * @return this {@code Builder} object
      * @throws NullPointerException if {@code element} is null
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<E> add(E element) {
       checkNotNull(element);
@@ -823,7 +803,6 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
      * @return this {@code Builder} object
      * @throws NullPointerException if {@code elements} is null or contains a null element
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<E> add(E... elements) {
       checkElementsNotNull(elements);
@@ -831,7 +810,7 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
       return this;
     }
 
-    private void add(@Nullable Object[] elements, int n) {
+    private void add(Object[] elements, int n) {
       getReadyToExpandTo(size + n);
       /*
        * The following call is not statically checked, since arraycopy accepts plain Object for its
@@ -852,7 +831,6 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
      * @return this {@code Builder} object
      * @throws NullPointerException if {@code elements} is null or contains a null element
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<E> addAll(Iterable<? extends E> elements) {
       checkNotNull(elements);
@@ -876,14 +854,12 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
      * @return this {@code Builder} object
      * @throws NullPointerException if {@code elements} is null or contains a null element
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<E> addAll(Iterator<? extends E> elements) {
       super.addAll(elements);
       return this;
     }
 
-    @CanIgnoreReturnValue
     Builder<E> combine(Builder<E> builder) {
       checkNotNull(builder);
       add(builder.contents, builder.size);
diff --git a/guava/src/com/google/common/collect/ImmutableListMultimap.java b/guava/src/com/google/common/collect/ImmutableListMultimap.java
index f84701624c..9af6a7523d 100644
--- a/guava/src/com/google/common/collect/ImmutableListMultimap.java
+++ b/guava/src/com/google/common/collect/ImmutableListMultimap.java
@@ -17,13 +17,6 @@
 package com.google.common.collect;
 
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotCall;
-import com.google.errorprone.annotations.concurrent.LazyInit;
-import com.google.j2objc.annotations.RetainedWith;
 import java.io.IOException;
 import java.io.InvalidObjectException;
 import java.io.ObjectInputStream;
@@ -36,7 +29,6 @@ import java.util.function.Function;
 import java.util.stream.Collector;
 import java.util.stream.Stream;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link ListMultimap} whose contents will never change, with many other important properties
@@ -48,7 +40,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Jared Levy
  * @since 2.0
  */
-@GwtCompatible(serializable = true, emulated = true)
 @ElementTypesAreNonnullByDefault
 public class ImmutableListMultimap<K, V> extends ImmutableMultimap<K, V>
     implements ListMultimap<K, V> {
@@ -80,7 +71,7 @@ public class ImmutableListMultimap<K, V> extends ImmutableMultimap<K, V>
    *
    * @since 21.0
    */
-  public static <T extends @Nullable Object, K, V>
+  public static <T extends Object, K, V>
       Collector<T, ?, ImmutableListMultimap<K, V>> toImmutableListMultimap(
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends V> valueFunction) {
@@ -118,7 +109,7 @@ public class ImmutableListMultimap<K, V> extends ImmutableMultimap<K, V>
    *
    * @since 21.0
    */
-  public static <T extends @Nullable Object, K, V>
+  public static <T extends Object, K, V>
       Collector<T, ?, ImmutableListMultimap<K, V>> flatteningToImmutableListMultimap(
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends Stream<? extends V>> valuesFunction) {
@@ -219,7 +210,6 @@ public class ImmutableListMultimap<K, V> extends ImmutableMultimap<K, V>
      */
     public Builder() {}
 
-    @CanIgnoreReturnValue
     @Override
     public Builder<K, V> put(K key, V value) {
       super.put(key, value);
@@ -231,7 +221,6 @@ public class ImmutableListMultimap<K, V> extends ImmutableMultimap<K, V>
      *
      * @since 11.0
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<K, V> put(Entry<? extends K, ? extends V> entry) {
       super.put(entry);
@@ -243,36 +232,30 @@ public class ImmutableListMultimap<K, V> extends ImmutableMultimap<K, V>
      *
      * @since 19.0
      */
-    @CanIgnoreReturnValue
-    @Beta
     @Override
     public Builder<K, V> putAll(Iterable<? extends Entry<? extends K, ? extends V>> entries) {
       super.putAll(entries);
       return this;
     }
 
-    @CanIgnoreReturnValue
     @Override
     public Builder<K, V> putAll(K key, Iterable<? extends V> values) {
       super.putAll(key, values);
       return this;
     }
 
-    @CanIgnoreReturnValue
     @Override
     public Builder<K, V> putAll(K key, V... values) {
       super.putAll(key, values);
       return this;
     }
 
-    @CanIgnoreReturnValue
     @Override
     public Builder<K, V> putAll(Multimap<? extends K, ? extends V> multimap) {
       super.putAll(multimap);
       return this;
     }
 
-    @CanIgnoreReturnValue
     @Override
     Builder<K, V> combine(ImmutableMultimap.Builder<K, V> other) {
       super.combine(other);
@@ -284,7 +267,6 @@ public class ImmutableListMultimap<K, V> extends ImmutableMultimap<K, V>
      *
      * @since 8.0
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<K, V> orderKeysBy(Comparator<? super K> keyComparator) {
       super.orderKeysBy(keyComparator);
@@ -296,7 +278,6 @@ public class ImmutableListMultimap<K, V> extends ImmutableMultimap<K, V>
      *
      * @since 8.0
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<K, V> orderValuesBy(Comparator<? super V> valueComparator) {
       super.orderValuesBy(valueComparator);
@@ -347,7 +328,6 @@ public class ImmutableListMultimap<K, V> extends ImmutableMultimap<K, V>
    * @throws NullPointerException if any key, value, or entry is null
    * @since 19.0
    */
-  @Beta
   public static <K, V> ImmutableListMultimap<K, V> copyOf(
       Iterable<? extends Entry<? extends K, ? extends V>> entries) {
     return new Builder<K, V>().putAll(entries).build();
@@ -356,7 +336,7 @@ public class ImmutableListMultimap<K, V> extends ImmutableMultimap<K, V>
   /** Creates an ImmutableListMultimap from an asMap.entrySet. */
   static <K, V> ImmutableListMultimap<K, V> fromMapEntries(
       Collection<? extends Map.Entry<? extends K, ? extends Collection<? extends V>>> mapEntries,
-      @Nullable Comparator<? super V> valueComparator) {
+      Comparator<? super V> valueComparator) {
     if (mapEntries.isEmpty()) {
       return of();
     }
@@ -398,7 +378,7 @@ public class ImmutableListMultimap<K, V> extends ImmutableMultimap<K, V>
     return (list == null) ? ImmutableList.<V>of() : list;
   }
 
-  @LazyInit @RetainedWith @CheckForNull private transient ImmutableListMultimap<V, K> inverse;
+  @CheckForNull private transient ImmutableListMultimap<V, K> inverse;
 
   /**
    * {@inheritDoc}
@@ -431,10 +411,8 @@ public class ImmutableListMultimap<K, V> extends ImmutableMultimap<K, V>
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final ImmutableList<V> removeAll(@CheckForNull Object key) {
     throw new UnsupportedOperationException();
   }
@@ -445,10 +423,8 @@ public class ImmutableListMultimap<K, V> extends ImmutableMultimap<K, V>
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final ImmutableList<V> replaceValues(K key, Iterable<? extends V> values) {
     throw new UnsupportedOperationException();
   }
@@ -457,13 +433,13 @@ public class ImmutableListMultimap<K, V> extends ImmutableMultimap<K, V>
    * @serialData number of distinct keys, and then for each distinct key: the key, the number of
    *     values for that key, and the key's values
    */
-  @GwtIncompatible // java.io.ObjectOutputStream
+  // java.io.ObjectOutputStream
   private void writeObject(ObjectOutputStream stream) throws IOException {
     stream.defaultWriteObject();
     Serialization.writeMultimap(this, stream);
   }
 
-  @GwtIncompatible // java.io.ObjectInputStream
+  // java.io.ObjectInputStream
   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
     stream.defaultReadObject();
     int keyCount = stream.readInt();
@@ -499,6 +475,6 @@ public class ImmutableListMultimap<K, V> extends ImmutableMultimap<K, V>
     FieldSettersHolder.SIZE_FIELD_SETTER.set(this, tmpSize);
   }
 
-  @GwtIncompatible // Not needed in emulated source
+  // Not needed in emulated source
   private static final long serialVersionUID = 0;
 }
diff --git a/guava/src/com/google/common/collect/ImmutableMap.java b/guava/src/com/google/common/collect/ImmutableMap.java
index 23335b2809..5897222df9 100644
--- a/guava/src/com/google/common/collect/ImmutableMap.java
+++ b/guava/src/com/google/common/collect/ImmutableMap.java
@@ -22,15 +22,6 @@ import static com.google.common.collect.CollectPreconditions.checkEntryNotNull;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.VisibleForTesting;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotCall;
-import com.google.errorprone.annotations.DoNotMock;
-import com.google.errorprone.annotations.concurrent.LazyInit;
-import com.google.j2objc.annotations.RetainedWith;
-import com.google.j2objc.annotations.WeakOuter;
 import java.io.Serializable;
 import java.util.AbstractMap;
 import java.util.Arrays;
@@ -49,7 +40,6 @@ import java.util.function.Function;
 import java.util.stream.Collector;
 import java.util.stream.Collectors;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link Map} whose contents will never change, with many other important properties detailed at
@@ -62,8 +52,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kevin Bourrillion
  * @since 2.0
  */
-@DoNotMock("Use ImmutableMap.of or another implementation")
-@GwtCompatible(serializable = true, emulated = true)
 @SuppressWarnings("serial") // we're overriding default serialization
 @ElementTypesAreNonnullByDefault
 public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
@@ -80,7 +68,7 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    *
    * @since 21.0
    */
-  public static <T extends @Nullable Object, K, V>
+  public static <T extends Object, K, V>
       Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends V> valueFunction) {
@@ -97,7 +85,7 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    *
    * @since 21.0
    */
-  public static <T extends @Nullable Object, K, V>
+  public static <T extends Object, K, V>
       Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends V> valueFunction,
@@ -358,7 +346,6 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    *
    * @since 23.1
    */
-  @Beta
   public static <K, V> Builder<K, V> builderWithExpectedSize(int expectedSize) {
     checkNonnegative(expectedSize, "expectedSize");
     return new Builder<>(expectedSize);
@@ -406,10 +393,9 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    *
    * @since 2.0
    */
-  @DoNotMock
   public static class Builder<K, V> {
     @CheckForNull Comparator<? super V> valueComparator;
-    @Nullable Entry<K, V>[] entries;
+    Entry<K, V>[] entries;
     int size;
     boolean entriesUsed;
 
@@ -423,7 +409,7 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
 
     @SuppressWarnings({"unchecked", "rawtypes"})
     Builder(int initialCapacity) {
-      this.entries = new @Nullable Entry[initialCapacity];
+      this.entries = new Entry[initialCapacity];
       this.size = 0;
       this.entriesUsed = false;
     }
@@ -441,7 +427,6 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
      * Associates {@code key} with {@code value} in the built map. Duplicate keys are not allowed,
      * and will cause {@link #build} to fail.
      */
-    @CanIgnoreReturnValue
     public Builder<K, V> put(K key, V value) {
       ensureCapacity(size + 1);
       Entry<K, V> entry = entryOf(key, value);
@@ -456,7 +441,6 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
      *
      * @since 11.0
      */
-    @CanIgnoreReturnValue
     public Builder<K, V> put(Entry<? extends K, ? extends V> entry) {
       return put(entry.getKey(), entry.getValue());
     }
@@ -467,7 +451,6 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
      *
      * @throws NullPointerException if any key or value in {@code map} is null
      */
-    @CanIgnoreReturnValue
     public Builder<K, V> putAll(Map<? extends K, ? extends V> map) {
       return putAll(map.entrySet());
     }
@@ -479,8 +462,6 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
      * @throws NullPointerException if any key, value, or entry is null
      * @since 19.0
      */
-    @CanIgnoreReturnValue
-    @Beta
     public Builder<K, V> putAll(Iterable<? extends Entry<? extends K, ? extends V>> entries) {
       if (entries instanceof Collection) {
         ensureCapacity(size + ((Collection<?>) entries).size());
@@ -501,15 +482,12 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
      * @throws IllegalStateException if this method was already called
      * @since 19.0
      */
-    @CanIgnoreReturnValue
-    @Beta
     public Builder<K, V> orderEntriesByValue(Comparator<? super V> valueComparator) {
       checkState(this.valueComparator == null, "valueComparator was already set");
       this.valueComparator = checkNotNull(valueComparator, "valueComparator");
       return this;
     }
 
-    @CanIgnoreReturnValue
     Builder<K, V> combine(Builder<K, V> other) {
       checkNotNull(other);
       ensureCapacity(this.size + other.size);
@@ -575,7 +553,7 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
       }
     }
 
-    @VisibleForTesting // only for testing JDK backed implementation
+    // only for testing JDK backed implementation
     ImmutableMap<K, V> buildJdkBacked() {
       checkState(
           valueComparator == null, "buildJdkBacked is only for testing; can't use valueComparator");
@@ -628,7 +606,6 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    * @throws IllegalArgumentException if two entries have the same key
    * @since 19.0
    */
-  @Beta
   public static <K, V> ImmutableMap<K, V> copyOf(
       Iterable<? extends Entry<? extends K, ? extends V>> entries) {
     @SuppressWarnings("unchecked") // we'll only be using getKey and getValue, which are covariant
@@ -705,10 +682,8 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   @CheckForNull
   public final V put(K k, V v) {
     throw new UnsupportedOperationException();
@@ -720,10 +695,8 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   @CheckForNull
   public final V putIfAbsent(K key, V value) {
     throw new UnsupportedOperationException();
@@ -737,7 +710,6 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final boolean replace(K key, V oldValue, V newValue) {
     throw new UnsupportedOperationException();
   }
@@ -751,7 +723,6 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
   @Deprecated
   @Override
   @CheckForNull
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final V replace(K key, V value) {
     throw new UnsupportedOperationException();
   }
@@ -764,7 +735,6 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {
     throw new UnsupportedOperationException();
   }
@@ -777,7 +747,6 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final V computeIfPresent(
       K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
     throw new UnsupportedOperationException();
@@ -791,9 +760,8 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final V compute(
-      K key, BiFunction<? super K, ? super @Nullable V, ? extends V> remappingFunction) {
+      K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
     throw new UnsupportedOperationException();
   }
 
@@ -805,7 +773,6 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final V merge(
       K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
     throw new UnsupportedOperationException();
@@ -819,7 +786,6 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final void putAll(Map<? extends K, ? extends V> map) {
     throw new UnsupportedOperationException();
   }
@@ -832,7 +798,6 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {
     throw new UnsupportedOperationException();
   }
@@ -845,7 +810,6 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   @CheckForNull
   public final V remove(@CheckForNull Object o) {
     throw new UnsupportedOperationException();
@@ -859,7 +823,6 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final boolean remove(@CheckForNull Object key, @CheckForNull Object value) {
     throw new UnsupportedOperationException();
   }
@@ -872,7 +835,6 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final void clear() {
     throw new UnsupportedOperationException();
   }
@@ -914,7 +876,7 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
     }
   }
 
-  @LazyInit @RetainedWith @CheckForNull private transient ImmutableSet<Entry<K, V>> entrySet;
+  @CheckForNull private transient ImmutableSet<Entry<K, V>> entrySet;
 
   /**
    * Returns an immutable set of the mappings in this map. The iteration order is specified by the
@@ -928,7 +890,7 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
 
   abstract ImmutableSet<Entry<K, V>> createEntrySet();
 
-  @LazyInit @RetainedWith @CheckForNull private transient ImmutableSet<K> keySet;
+  @CheckForNull private transient ImmutableSet<K> keySet;
 
   /**
    * Returns an immutable set of the keys in this map, in the same order that they appear in {@link
@@ -966,7 +928,7 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
     return CollectSpliterators.map(entrySet().spliterator(), Entry::getKey);
   }
 
-  @LazyInit @RetainedWith @CheckForNull private transient ImmutableCollection<V> values;
+  @CheckForNull private transient ImmutableCollection<V> values;
 
   /**
    * Returns an immutable collection of the values in this map, in the same order that they appear
@@ -986,7 +948,7 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
   abstract ImmutableCollection<V> createValues();
 
   // cached so that this.multimapView().inverse() only computes inverse once
-  @LazyInit @CheckForNull private transient ImmutableSetMultimap<K, V> multimapView;
+  @CheckForNull private transient ImmutableSetMultimap<K, V> multimapView;
 
   /**
    * Returns a multimap view of the map.
@@ -1004,7 +966,6 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
         : result;
   }
 
-  @WeakOuter
   private final class MapViewOfValuesAsSingletonSets
       extends IteratorBasedImmutableMap<K, ImmutableSet<V>> {
 
diff --git a/guava/src/com/google/common/collect/ImmutableMapEntry.java b/guava/src/com/google/common/collect/ImmutableMapEntry.java
index ac483d8fd8..b33d52476b 100644
--- a/guava/src/com/google/common/collect/ImmutableMapEntry.java
+++ b/guava/src/com/google/common/collect/ImmutableMapEntry.java
@@ -18,7 +18,6 @@ package com.google.common.collect;
 
 import static com.google.common.collect.CollectPreconditions.checkEntryNotNull;
 
-import com.google.common.annotations.GwtIncompatible;
 import javax.annotation.CheckForNull;
 
 /**
@@ -32,7 +31,7 @@ import javax.annotation.CheckForNull;
  *
  * @author Louis Wasserman
  */
-@GwtIncompatible // unnecessary
+// unnecessary
 @ElementTypesAreNonnullByDefault
 class ImmutableMapEntry<K, V> extends ImmutableEntry<K, V> {
   /**
diff --git a/guava/src/com/google/common/collect/ImmutableMapEntrySet.java b/guava/src/com/google/common/collect/ImmutableMapEntrySet.java
index 6f5503af5c..fe3ec85316 100644
--- a/guava/src/com/google/common/collect/ImmutableMapEntrySet.java
+++ b/guava/src/com/google/common/collect/ImmutableMapEntrySet.java
@@ -16,14 +16,11 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import java.io.Serializable;
 import java.util.Map.Entry;
 import java.util.Spliterator;
 import java.util.function.Consumer;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * {@code entrySet()} implementation for {@link ImmutableMap}.
@@ -31,7 +28,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Jesse Wilson
  * @author Kevin Bourrillion
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 abstract class ImmutableMapEntrySet<K, V> extends ImmutableSet.CachingAsList<Entry<K, V>> {
   static final class RegularEntrySet<K, V> extends ImmutableMapEntrySet<K, V> {
@@ -53,8 +49,7 @@ abstract class ImmutableMapEntrySet<K, V> extends ImmutableSet.CachingAsList<Ent
     }
 
     @Override
-    @GwtIncompatible("not used in GWT")
-    int copyIntoArray(@Nullable Object[] dst, int offset) {
+    int copyIntoArray(Object[] dst, int offset) {
       return entries.copyIntoArray(dst, offset);
     }
 
@@ -104,7 +99,7 @@ abstract class ImmutableMapEntrySet<K, V> extends ImmutableSet.CachingAsList<Ent
   }
 
   @Override
-  @GwtIncompatible // not used in GWT
+  // not used in GWT
   boolean isHashCodeFast() {
     return map().isHashCodeFast();
   }
@@ -114,13 +109,13 @@ abstract class ImmutableMapEntrySet<K, V> extends ImmutableSet.CachingAsList<Ent
     return map().hashCode();
   }
 
-  @GwtIncompatible // serialization
+  // serialization
   @Override
   Object writeReplace() {
     return new EntrySetSerializedForm<>(map());
   }
 
-  @GwtIncompatible // serialization
+  // serialization
   private static class EntrySetSerializedForm<K, V> implements Serializable {
     final ImmutableMap<K, V> map;
 
diff --git a/guava/src/com/google/common/collect/ImmutableMapKeySet.java b/guava/src/com/google/common/collect/ImmutableMapKeySet.java
index d10ee10e7a..01e7e38061 100644
--- a/guava/src/com/google/common/collect/ImmutableMapKeySet.java
+++ b/guava/src/com/google/common/collect/ImmutableMapKeySet.java
@@ -18,8 +18,6 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import java.io.Serializable;
 import java.util.Spliterator;
 import java.util.function.Consumer;
@@ -31,7 +29,6 @@ import javax.annotation.CheckForNull;
  * @author Jesse Wilson
  * @author Kevin Bourrillion
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 final class ImmutableMapKeySet<K, V> extends IndexedImmutableSet<K> {
   private final ImmutableMap<K, V> map;
@@ -77,7 +74,7 @@ final class ImmutableMapKeySet<K, V> extends IndexedImmutableSet<K> {
   }
 
   // No longer used for new writes, but kept so that old data can still be read.
-  @GwtIncompatible // serialization
+  // serialization
   @SuppressWarnings("unused")
   private static class KeySetSerializedForm<K> implements Serializable {
     final ImmutableMap<K, ?> map;
diff --git a/guava/src/com/google/common/collect/ImmutableMapValues.java b/guava/src/com/google/common/collect/ImmutableMapValues.java
index 702191c649..531aaa4de1 100644
--- a/guava/src/com/google/common/collect/ImmutableMapValues.java
+++ b/guava/src/com/google/common/collect/ImmutableMapValues.java
@@ -18,8 +18,6 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import java.io.Serializable;
 import java.util.Map.Entry;
 import java.util.Spliterator;
@@ -32,7 +30,6 @@ import javax.annotation.CheckForNull;
  * @author Jesse Wilson
  * @author Kevin Bourrillion
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 final class ImmutableMapValues<K, V> extends ImmutableCollection<V> {
   private final ImmutableMap<K, V> map;
@@ -94,7 +91,7 @@ final class ImmutableMapValues<K, V> extends ImmutableCollection<V> {
     };
   }
 
-  @GwtIncompatible // serialization
+  // serialization
   @Override
   public void forEach(Consumer<? super V> action) {
     checkNotNull(action);
@@ -102,7 +99,7 @@ final class ImmutableMapValues<K, V> extends ImmutableCollection<V> {
   }
 
   // No longer used for new writes, but kept so that old data can still be read.
-  @GwtIncompatible // serialization
+  // serialization
   @SuppressWarnings("unused")
   private static class SerializedForm<V> implements Serializable {
     final ImmutableMap<?, V> map;
diff --git a/guava/src/com/google/common/collect/ImmutableMultimap.java b/guava/src/com/google/common/collect/ImmutableMultimap.java
index 5dfbb9bca0..acebffe5cb 100644
--- a/guava/src/com/google/common/collect/ImmutableMultimap.java
+++ b/guava/src/com/google/common/collect/ImmutableMultimap.java
@@ -21,14 +21,6 @@ import static com.google.common.collect.CollectPreconditions.checkEntryNotNull;
 import static com.google.common.collect.Maps.immutableEntry;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotCall;
-import com.google.errorprone.annotations.DoNotMock;
-import com.google.j2objc.annotations.Weak;
-import com.google.j2objc.annotations.WeakOuter;
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -41,7 +33,6 @@ import java.util.Set;
 import java.util.Spliterator;
 import java.util.function.BiConsumer;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link Multimap} whose contents will never change, with many other important properties
@@ -69,7 +60,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Jared Levy
  * @since 2.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V>
     implements Serializable {
@@ -147,7 +137,6 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
    *
    * @since 2.0
    */
-  @DoNotMock
   public static class Builder<K, V> {
     final Map<K, Collection<V>> builderMap;
     @CheckForNull Comparator<? super K> keyComparator;
@@ -166,7 +155,6 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
     }
 
     /** Adds a key-value mapping to the built multimap. */
-    @CanIgnoreReturnValue
     public Builder<K, V> put(K key, V value) {
       checkEntryNotNull(key, value);
       Collection<V> valueCollection = builderMap.get(key);
@@ -182,7 +170,6 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
      *
      * @since 11.0
      */
-    @CanIgnoreReturnValue
     public Builder<K, V> put(Entry<? extends K, ? extends V> entry) {
       return put(entry.getKey(), entry.getValue());
     }
@@ -192,8 +179,6 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
      *
      * @since 19.0
      */
-    @CanIgnoreReturnValue
-    @Beta
     public Builder<K, V> putAll(Iterable<? extends Entry<? extends K, ? extends V>> entries) {
       for (Entry<? extends K, ? extends V> entry : entries) {
         put(entry);
@@ -207,7 +192,6 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
      * @throws NullPointerException if {@code key}, {@code values}, or any element in {@code values}
      *     is null. The builder is left in an invalid state.
      */
-    @CanIgnoreReturnValue
     public Builder<K, V> putAll(K key, Iterable<? extends V> values) {
       if (key == null) {
         throw new NullPointerException("null key in entry: null=" + Iterables.toString(values));
@@ -240,7 +224,6 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
      * @throws NullPointerException if the key or any value is null. The builder is left in an
      *     invalid state.
      */
-    @CanIgnoreReturnValue
     public Builder<K, V> putAll(K key, V... values) {
       return putAll(key, Arrays.asList(values));
     }
@@ -253,7 +236,6 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
      * @throws NullPointerException if any key or value in {@code multimap} is null. The builder is
      *     left in an invalid state.
      */
-    @CanIgnoreReturnValue
     public Builder<K, V> putAll(Multimap<? extends K, ? extends V> multimap) {
       for (Entry<? extends K, ? extends Collection<? extends V>> entry :
           multimap.asMap().entrySet()) {
@@ -267,7 +249,6 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
      *
      * @since 8.0
      */
-    @CanIgnoreReturnValue
     public Builder<K, V> orderKeysBy(Comparator<? super K> keyComparator) {
       this.keyComparator = checkNotNull(keyComparator);
       return this;
@@ -278,13 +259,11 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
      *
      * @since 8.0
      */
-    @CanIgnoreReturnValue
     public Builder<K, V> orderValuesBy(Comparator<? super V> valueComparator) {
       this.valueComparator = checkNotNull(valueComparator);
       return this;
     }
 
-    @CanIgnoreReturnValue
     Builder<K, V> combine(Builder<K, V> other) {
       for (Map.Entry<K, Collection<V>> entry : other.builderMap.entrySet()) {
         putAll(entry.getKey(), entry.getValue());
@@ -331,7 +310,6 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
    * @throws NullPointerException if any key, value, or entry is null
    * @since 19.0
    */
-  @Beta
   public static <K, V> ImmutableMultimap<K, V> copyOf(
       Iterable<? extends Entry<? extends K, ? extends V>> entries) {
     return ImmutableListMultimap.copyOf(entries);
@@ -343,7 +321,7 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
   // These constants allow the deserialization code to set final fields. This
   // holder class makes sure they are not initialized unless an instance is
   // deserialized.
-  @GwtIncompatible // java serialization is not supported
+  // java serialization is not supported
   static class FieldSettersHolder {
     static final Serialization.FieldSetter<ImmutableMultimap> MAP_FIELD_SETTER =
         Serialization.getFieldSetter(ImmutableMultimap.class, "map");
@@ -364,10 +342,8 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   // DoNotCall wants this to be final, but we want to override it to return more specific types.
   // Inheritance is closed, and all subtypes are @DoNotCall, so this is safe to suppress.
   @SuppressWarnings("DoNotCall")
@@ -381,10 +357,8 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   // DoNotCall wants this to be final, but we want to override it to return more specific types.
   // Inheritance is closed, and all subtypes are @DoNotCall, so this is safe to suppress.
   @SuppressWarnings("DoNotCall")
@@ -400,7 +374,6 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final void clear() {
     throw new UnsupportedOperationException();
   }
@@ -427,10 +400,8 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final boolean put(K key, V value) {
     throw new UnsupportedOperationException();
   }
@@ -441,10 +412,8 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final boolean putAll(K key, Iterable<? extends V> values) {
     throw new UnsupportedOperationException();
   }
@@ -455,10 +424,8 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final boolean putAll(Multimap<? extends K, ? extends V> multimap) {
     throw new UnsupportedOperationException();
   }
@@ -469,10 +436,8 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final boolean remove(@CheckForNull Object key, @CheckForNull Object value) {
     throw new UnsupportedOperationException();
   }
@@ -547,7 +512,7 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
   }
 
   private static class EntryCollection<K, V> extends ImmutableCollection<Entry<K, V>> {
-    @Weak final ImmutableMultimap<K, V> multimap;
+    final ImmutableMultimap<K, V> multimap;
 
     EntryCollection(ImmutableMultimap<K, V> multimap) {
       this.multimap = multimap;
@@ -647,7 +612,6 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
   }
 
   @SuppressWarnings("serial") // Uses writeReplace, not default serialization
-  @WeakOuter
   class Keys extends ImmutableMultiset<K> {
     @Override
     public boolean contains(@CheckForNull Object object) {
@@ -681,14 +645,12 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
       return true;
     }
 
-    @GwtIncompatible
     @Override
     Object writeReplace() {
       return new KeysSerializedForm(ImmutableMultimap.this);
     }
   }
 
-  @GwtIncompatible
   private static final class KeysSerializedForm implements Serializable {
     final ImmutableMultimap<?, ?> multimap;
 
@@ -737,7 +699,7 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
   }
 
   private static final class Values<K, V> extends ImmutableCollection<V> {
-    @Weak private final transient ImmutableMultimap<K, V> multimap;
+    private final transient ImmutableMultimap<K, V> multimap;
 
     Values(ImmutableMultimap<K, V> multimap) {
       this.multimap = multimap;
@@ -753,9 +715,9 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
       return multimap.valueIterator();
     }
 
-    @GwtIncompatible // not present in emulated superclass
+    // not present in emulated superclass
     @Override
-    int copyIntoArray(@Nullable Object[] dst, int offset) {
+    int copyIntoArray(Object[] dst, int offset) {
       for (ImmutableCollection<V> valueCollection : multimap.map.values()) {
         offset = valueCollection.copyIntoArray(dst, offset);
       }
diff --git a/guava/src/com/google/common/collect/ImmutableMultiset.java b/guava/src/com/google/common/collect/ImmutableMultiset.java
index f397a49af5..8d69f7de9d 100644
--- a/guava/src/com/google/common/collect/ImmutableMultiset.java
+++ b/guava/src/com/google/common/collect/ImmutableMultiset.java
@@ -19,13 +19,6 @@ package com.google.common.collect;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotCall;
-import com.google.errorprone.annotations.concurrent.LazyInit;
-import com.google.j2objc.annotations.WeakOuter;
 import java.io.Serializable;
 import java.util.Arrays;
 import java.util.Collection;
@@ -36,7 +29,6 @@ import java.util.function.Function;
 import java.util.function.ToIntFunction;
 import java.util.stream.Collector;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link Multiset} whose contents will never change, with many other important properties
@@ -53,7 +45,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 2.0
  */
-@GwtCompatible(serializable = true, emulated = true)
 @SuppressWarnings("serial") // we're overriding default serialization
 @ElementTypesAreNonnullByDefault
 public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializationDependencies<E>
@@ -81,7 +72,7 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
    *
    * @since 22.0
    */
-  public static <T extends @Nullable Object, E>
+  public static <T extends Object, E>
       Collector<T, ?, ImmutableMultiset<E>> toImmutableMultiset(
           Function<? super T, ? extends E> elementFunction,
           ToIntFunction<? super T> countFunction) {
@@ -254,7 +245,7 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
     };
   }
 
-  @LazyInit @CheckForNull private transient ImmutableList<E> asList;
+  @CheckForNull private transient ImmutableList<E> asList;
 
   @Override
   public ImmutableList<E> asList() {
@@ -273,10 +264,8 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final int add(E element, int occurrences) {
     throw new UnsupportedOperationException();
   }
@@ -287,10 +276,8 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final int remove(@CheckForNull Object element, int occurrences) {
     throw new UnsupportedOperationException();
   }
@@ -301,10 +288,8 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final int setCount(E element, int count) {
     throw new UnsupportedOperationException();
   }
@@ -315,15 +300,13 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final boolean setCount(E element, int oldCount, int newCount) {
     throw new UnsupportedOperationException();
   }
 
-  @GwtIncompatible // not present in emulated superclass
+  // not present in emulated superclass
   @Override
   int copyIntoArray(Object[] dst, int offset) {
     for (Multiset.Entry<E> entry : entrySet()) {
@@ -352,7 +335,7 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
   @Override
   public abstract ImmutableSet<E> elementSet();
 
-  @LazyInit @CheckForNull private transient ImmutableSet<Entry<E>> entrySet;
+  @CheckForNull private transient ImmutableSet<Entry<E>> entrySet;
 
   @Override
   public ImmutableSet<Entry<E>> entrySet() {
@@ -366,7 +349,6 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
 
   abstract Entry<E> getEntry(int index);
 
-  @WeakOuter
   private final class EntrySet extends IndexedImmutableSet<Entry<E>> {
     @Override
     boolean isPartialView() {
@@ -401,7 +383,6 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
       return ImmutableMultiset.this.hashCode();
     }
 
-    @GwtIncompatible
     @Override
     Object writeReplace() {
       return new EntrySetSerializedForm<E>(ImmutableMultiset.this);
@@ -410,7 +391,6 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
     private static final long serialVersionUID = 0;
   }
 
-  @GwtIncompatible
   static class EntrySetSerializedForm<E> implements Serializable {
     final ImmutableMultiset<E> multiset;
 
@@ -423,7 +403,6 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
     }
   }
 
-  @GwtIncompatible
   @Override
   Object writeReplace() {
     return new SerializedForm(this);
@@ -478,7 +457,6 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
      * @return this {@code Builder} object
      * @throws NullPointerException if {@code element} is null
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<E> add(E element) {
       contents.add(checkNotNull(element));
@@ -492,7 +470,6 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
      * @return this {@code Builder} object
      * @throws NullPointerException if {@code elements} is null or contains a null element
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<E> add(E... elements) {
       super.add(elements);
@@ -510,7 +487,6 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
      * @throws IllegalArgumentException if {@code occurrences} is negative, or if this operation
      *     would result in more than {@link Integer#MAX_VALUE} occurrences of the element
      */
-    @CanIgnoreReturnValue
     public Builder<E> addCopies(E element, int occurrences) {
       contents.add(checkNotNull(element), occurrences);
       return this;
@@ -526,7 +502,6 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
      * @throws NullPointerException if {@code element} is null
      * @throws IllegalArgumentException if {@code count} is negative
      */
-    @CanIgnoreReturnValue
     public Builder<E> setCount(E element, int count) {
       contents.setCount(checkNotNull(element), count);
       return this;
@@ -539,7 +514,6 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
      * @return this {@code Builder} object
      * @throws NullPointerException if {@code elements} is null or contains a null element
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<E> addAll(Iterable<? extends E> elements) {
       if (elements instanceof Multiset) {
@@ -558,7 +532,6 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
      * @return this {@code Builder} object
      * @throws NullPointerException if {@code elements} is null or contains a null element
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<E> addAll(Iterator<? extends E> elements) {
       super.addAll(elements);
@@ -574,7 +547,6 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
       return copyOf(contents);
     }
 
-    @VisibleForTesting
     ImmutableMultiset<E> buildJdkBacked() {
       if (contents.isEmpty()) {
         return of();
diff --git a/guava/src/com/google/common/collect/ImmutableMultisetGwtSerializationDependencies.java b/guava/src/com/google/common/collect/ImmutableMultisetGwtSerializationDependencies.java
index 2469a188a2..3eb8232317 100644
--- a/guava/src/com/google/common/collect/ImmutableMultisetGwtSerializationDependencies.java
+++ b/guava/src/com/google/common/collect/ImmutableMultisetGwtSerializationDependencies.java
@@ -16,7 +16,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 
 /**
  * A dummy superclass to support GWT serialization of the element type of an {@link
@@ -36,6 +35,5 @@ import com.google.common.annotations.GwtCompatible;
  * anyway, since it doesn't require us to declare dummy methods (though occasionally constructors)
  * and make types non-final.
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 abstract class ImmutableMultisetGwtSerializationDependencies<E> extends ImmutableCollection<E> {}
diff --git a/guava/src/com/google/common/collect/ImmutableRangeMap.java b/guava/src/com/google/common/collect/ImmutableRangeMap.java
index e1979ab65f..88f5e4bc05 100644
--- a/guava/src/com/google/common/collect/ImmutableRangeMap.java
+++ b/guava/src/com/google/common/collect/ImmutableRangeMap.java
@@ -18,13 +18,8 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkElementIndex;
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.SortedLists.KeyAbsentBehavior;
 import com.google.common.collect.SortedLists.KeyPresentBehavior;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotCall;
-import com.google.errorprone.annotations.DoNotMock;
 import java.io.Serializable;
 import java.util.Collections;
 import java.util.List;
@@ -35,7 +30,6 @@ import java.util.function.BiFunction;
 import java.util.function.Function;
 import java.util.stream.Collector;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link RangeMap} whose contents will never change, with many other important properties
@@ -44,8 +38,7 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 14.0
  */
-@Beta
-@GwtIncompatible // NavigableMap
+// NavigableMap
 @ElementTypesAreNonnullByDefault
 public class ImmutableRangeMap<K extends Comparable<?>, V> implements RangeMap<K, V>, Serializable {
 
@@ -58,7 +51,7 @@ public class ImmutableRangeMap<K extends Comparable<?>, V> implements RangeMap<K
    *
    * @since 23.1
    */
-  public static <T extends @Nullable Object, K extends Comparable<? super K>, V>
+  public static <T extends Object, K extends Comparable<? super K>, V>
       Collector<T, ?, ImmutableRangeMap<K, V>> toImmutableRangeMap(
           Function<? super T, Range<K>> keyFunction,
           Function<? super T, ? extends V> valueFunction) {
@@ -106,7 +99,6 @@ public class ImmutableRangeMap<K extends Comparable<?>, V> implements RangeMap<K
    *
    * @since 14.0
    */
-  @DoNotMock
   public static final class Builder<K extends Comparable<?>, V> {
     private final List<Entry<Range<K>, V>> entries;
 
@@ -119,7 +111,6 @@ public class ImmutableRangeMap<K extends Comparable<?>, V> implements RangeMap<K
      *
      * @throws IllegalArgumentException if {@code range} is empty
      */
-    @CanIgnoreReturnValue
     public Builder<K, V> put(Range<K> range, V value) {
       checkNotNull(range);
       checkNotNull(value);
@@ -129,7 +120,6 @@ public class ImmutableRangeMap<K extends Comparable<?>, V> implements RangeMap<K
     }
 
     /** Copies all associations from the specified range map into this builder. */
-    @CanIgnoreReturnValue
     public Builder<K, V> putAll(RangeMap<K, ? extends V> rangeMap) {
       for (Entry<Range<K>, ? extends V> entry : rangeMap.asMapOfRanges().entrySet()) {
         put(entry.getKey(), entry.getValue());
@@ -137,7 +127,6 @@ public class ImmutableRangeMap<K extends Comparable<?>, V> implements RangeMap<K
       return this;
     }
 
-    @CanIgnoreReturnValue
     Builder<K, V> combine(Builder<K, V> builder) {
       entries.addAll(builder.entries);
       return this;
@@ -231,7 +220,6 @@ public class ImmutableRangeMap<K extends Comparable<?>, V> implements RangeMap<K
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final void put(Range<K> range, V value) {
     throw new UnsupportedOperationException();
   }
@@ -244,7 +232,6 @@ public class ImmutableRangeMap<K extends Comparable<?>, V> implements RangeMap<K
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final void putCoalescing(Range<K> range, V value) {
     throw new UnsupportedOperationException();
   }
@@ -257,7 +244,6 @@ public class ImmutableRangeMap<K extends Comparable<?>, V> implements RangeMap<K
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final void putAll(RangeMap<K, V> rangeMap) {
     throw new UnsupportedOperationException();
   }
@@ -270,7 +256,6 @@ public class ImmutableRangeMap<K extends Comparable<?>, V> implements RangeMap<K
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final void clear() {
     throw new UnsupportedOperationException();
   }
@@ -283,7 +268,6 @@ public class ImmutableRangeMap<K extends Comparable<?>, V> implements RangeMap<K
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final void remove(Range<K> range) {
     throw new UnsupportedOperationException();
   }
@@ -296,11 +280,10 @@ public class ImmutableRangeMap<K extends Comparable<?>, V> implements RangeMap<K
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final void merge(
       Range<K> range,
       @CheckForNull V value,
-      BiFunction<? super V, ? super @Nullable V, ? extends @Nullable V> remappingFunction) {
+      BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
     throw new UnsupportedOperationException();
   }
 
diff --git a/guava/src/com/google/common/collect/ImmutableRangeSet.java b/guava/src/com/google/common/collect/ImmutableRangeSet.java
index f279aae0c5..dadaa98189 100644
--- a/guava/src/com/google/common/collect/ImmutableRangeSet.java
+++ b/guava/src/com/google/common/collect/ImmutableRangeSet.java
@@ -22,14 +22,9 @@ import static com.google.common.collect.SortedLists.KeyAbsentBehavior.NEXT_LOWER
 import static com.google.common.collect.SortedLists.KeyPresentBehavior.ANY_PRESENT;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.SortedLists.KeyAbsentBehavior;
 import com.google.common.collect.SortedLists.KeyPresentBehavior;
 import com.google.common.primitives.Ints;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotCall;
-import com.google.errorprone.annotations.concurrent.LazyInit;
 import java.io.Serializable;
 import java.util.Collections;
 import java.util.Iterator;
@@ -46,8 +41,6 @@ import javax.annotation.CheckForNull;
  * @author Louis Wasserman
  * @since 14.0
  */
-@Beta
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class ImmutableRangeSet<C extends Comparable> extends AbstractRangeSet<C>
     implements Serializable {
@@ -226,7 +219,6 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public void add(Range<C> range) {
     throw new UnsupportedOperationException();
   }
@@ -239,7 +231,6 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public void addAll(RangeSet<C> other) {
     throw new UnsupportedOperationException();
   }
@@ -252,7 +243,6 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public void addAll(Iterable<Range<C>> other) {
     throw new UnsupportedOperationException();
   }
@@ -265,7 +255,6 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public void remove(Range<C> range) {
     throw new UnsupportedOperationException();
   }
@@ -278,7 +267,6 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public void removeAll(RangeSet<C> other) {
     throw new UnsupportedOperationException();
   }
@@ -291,7 +279,6 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public void removeAll(Iterable<Range<C>> other) {
     throw new UnsupportedOperationException();
   }
@@ -312,7 +299,7 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
     return new RegularImmutableSortedSet<>(ranges.reverse(), Range.<C>rangeLexOrdering().reverse());
   }
 
-  @LazyInit @CheckForNull private transient ImmutableRangeSet<C> complement;
+  @CheckForNull private transient ImmutableRangeSet<C> complement;
 
   private final class ComplementRanges extends ImmutableList<Range<C>> {
     // True if the "positive" range set is empty or bounded below.
@@ -595,7 +582,6 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
     }
 
     @Override
-    @GwtIncompatible("NavigableSet")
     public UnmodifiableIterator<C> descendingIterator() {
       return new AbstractIterator<C>() {
         final Iterator<Range<C>> rangeItr = ranges.reverse().iterator();
@@ -744,7 +730,6 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
      *
      * @throws IllegalArgumentException if {@code range} is empty
      */
-    @CanIgnoreReturnValue
     public Builder<C> add(Range<C> range) {
       checkArgument(!range.isEmpty(), "range must not be empty, but was %s", range);
       ranges.add(range);
@@ -756,7 +741,6 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
      * and will be merged, but overlapping ranges will cause an exception when {@link #build()} is
      * called.
      */
-    @CanIgnoreReturnValue
     public Builder<C> addAll(RangeSet<C> ranges) {
       return addAll(ranges.asRanges());
     }
@@ -768,7 +752,6 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
      * @throws IllegalArgumentException if any inserted ranges are empty
      * @since 21.0
      */
-    @CanIgnoreReturnValue
     public Builder<C> addAll(Iterable<Range<C>> ranges) {
       for (Range<C> range : ranges) {
         add(range);
@@ -776,7 +759,6 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
       return this;
     }
 
-    @CanIgnoreReturnValue
     Builder<C> combine(Builder<C> builder) {
       addAll(builder.ranges);
       return this;
diff --git a/guava/src/com/google/common/collect/ImmutableSet.java b/guava/src/com/google/common/collect/ImmutableSet.java
index 73d5b09bf2..ccb47f567e 100644
--- a/guava/src/com/google/common/collect/ImmutableSet.java
+++ b/guava/src/com/google/common/collect/ImmutableSet.java
@@ -21,14 +21,8 @@ import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.math.IntMath;
 import com.google.common.primitives.Ints;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.concurrent.LazyInit;
-import com.google.j2objc.annotations.RetainedWith;
 import java.io.Serializable;
 import java.math.RoundingMode;
 import java.util.Arrays;
@@ -42,7 +36,6 @@ import java.util.Spliterator;
 import java.util.function.Consumer;
 import java.util.stream.Collector;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link Set} whose contents will never change, with many other important properties detailed at
@@ -50,7 +43,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @since 2.0
  */
-@GwtCompatible(serializable = true, emulated = true)
 @SuppressWarnings("serial") // we're overriding default serialization
 @ElementTypesAreNonnullByDefault
 public abstract class ImmutableSet<E> extends ImmutableCollection<E> implements Set<E> {
@@ -335,9 +327,8 @@ public abstract class ImmutableSet<E> extends ImmutableCollection<E> implements
   @Override
   public abstract UnmodifiableIterator<E> iterator();
 
-  @GwtCompatible
   abstract static class CachingAsList<E> extends ImmutableSet<E> {
-    @LazyInit @RetainedWith @CheckForNull private transient ImmutableList<E> asList;
+    @CheckForNull private transient ImmutableList<E> asList;
 
     @Override
     public ImmutableList<E> asList() {
@@ -377,7 +368,7 @@ public abstract class ImmutableSet<E> extends ImmutableCollection<E> implements
     }
 
     @Override
-    int copyIntoArray(@Nullable Object[] dst, int offset) {
+    int copyIntoArray(Object[] dst, int offset) {
       return asList().copyIntoArray(dst, offset);
     }
 
@@ -443,7 +434,6 @@ public abstract class ImmutableSet<E> extends ImmutableCollection<E> implements
    *
    * @since 23.1
    */
-  @Beta
   public static <E> Builder<E> builderWithExpectedSize(int expectedSize) {
     checkNonnegative(expectedSize, "expectedSize");
     return new Builder<E>(expectedSize);
@@ -492,7 +482,6 @@ public abstract class ImmutableSet<E> extends ImmutableCollection<E> implements
       this.impl = null; // unused
     }
 
-    @VisibleForTesting
     void forceJdk() {
       requireNonNull(impl); // see the comment on the field
       this.impl = new JdkBackedSetBuilderImpl<E>(impl);
@@ -511,7 +500,6 @@ public abstract class ImmutableSet<E> extends ImmutableCollection<E> implements
     }
 
     @Override
-    @CanIgnoreReturnValue
     public Builder<E> add(E element) {
       requireNonNull(impl); // see the comment on the field
       checkNotNull(element);
@@ -521,7 +509,6 @@ public abstract class ImmutableSet<E> extends ImmutableCollection<E> implements
     }
 
     @Override
-    @CanIgnoreReturnValue
     public Builder<E> add(E... elements) {
       super.add(elements);
       return this;
@@ -536,14 +523,12 @@ public abstract class ImmutableSet<E> extends ImmutableCollection<E> implements
      * @throws NullPointerException if {@code elements} is null or contains a null element
      */
     @Override
-    @CanIgnoreReturnValue
     public Builder<E> addAll(Iterable<? extends E> elements) {
       super.addAll(elements);
       return this;
     }
 
     @Override
-    @CanIgnoreReturnValue
     public Builder<E> addAll(Iterator<? extends E> elements) {
       super.addAll(elements);
       return this;
@@ -717,7 +702,7 @@ public abstract class ImmutableSet<E> extends ImmutableCollection<E> implements
    */
   private static final class RegularSetBuilderImpl<E> extends SetBuilderImpl<E> {
     // null until at least two elements are present
-    private @Nullable Object @Nullable [] hashTable;
+    private Object [] hashTable;
     private int maxRunBeforeFallback;
     private int expandTableThreshold;
     private int hashCode;
@@ -822,8 +807,8 @@ public abstract class ImmutableSet<E> extends ImmutableCollection<E> implements
     }
 
     /** Builds a new open-addressed hash table from the first n objects in elements. */
-    static @Nullable Object[] rebuildHashTable(int newTableSize, Object[] elements, int n) {
-      @Nullable Object[] hashTable = new @Nullable Object[newTableSize];
+    static Object[] rebuildHashTable(int newTableSize, Object[] elements, int n) {
+      Object[] hashTable = new Object[newTableSize];
       int mask = hashTable.length - 1;
       for (int i = 0; i < n; i++) {
         // requireNonNull is safe because we ensure that the first n elements have been populated.
@@ -883,7 +868,7 @@ public abstract class ImmutableSet<E> extends ImmutableCollection<E> implements
      * <p>This method may return {@code true} even on truly random input, but {@code
      * ImmutableSetTest} tests that the probability of that is low.
      */
-    static boolean hashFloodingDetected(@Nullable Object[] hashTable) {
+    static boolean hashFloodingDetected(Object[] hashTable) {
       int maxRunBeforeFallback = maxRunBeforeFallback(hashTable.length);
       int mask = hashTable.length - 1;
 
diff --git a/guava/src/com/google/common/collect/ImmutableSetMultimap.java b/guava/src/com/google/common/collect/ImmutableSetMultimap.java
index 007c16b777..4e87350770 100644
--- a/guava/src/com/google/common/collect/ImmutableSetMultimap.java
+++ b/guava/src/com/google/common/collect/ImmutableSetMultimap.java
@@ -18,15 +18,7 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.MoreObjects;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotCall;
-import com.google.errorprone.annotations.concurrent.LazyInit;
-import com.google.j2objc.annotations.RetainedWith;
-import com.google.j2objc.annotations.Weak;
 import java.io.IOException;
 import java.io.InvalidObjectException;
 import java.io.ObjectInputStream;
@@ -40,7 +32,6 @@ import java.util.function.Function;
 import java.util.stream.Collector;
 import java.util.stream.Stream;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link SetMultimap} whose contents will never change, with many other important properties
@@ -56,7 +47,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Mike Ward
  * @since 2.0
  */
-@GwtCompatible(serializable = true, emulated = true)
 @ElementTypesAreNonnullByDefault
 public class ImmutableSetMultimap<K, V> extends ImmutableMultimap<K, V>
     implements SetMultimap<K, V> {
@@ -88,7 +78,7 @@ public class ImmutableSetMultimap<K, V> extends ImmutableMultimap<K, V>
    *
    * @since 21.0
    */
-  public static <T extends @Nullable Object, K, V>
+  public static <T extends Object, K, V>
       Collector<T, ?, ImmutableSetMultimap<K, V>> toImmutableSetMultimap(
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends V> valueFunction) {
@@ -135,7 +125,7 @@ public class ImmutableSetMultimap<K, V> extends ImmutableMultimap<K, V>
    *
    * @since 21.0
    */
-  public static <T extends @Nullable Object, K, V>
+  public static <T extends Object, K, V>
       Collector<T, ?, ImmutableSetMultimap<K, V>> flatteningToImmutableSetMultimap(
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends Stream<? extends V>> valuesFunction) {
@@ -253,7 +243,6 @@ public class ImmutableSetMultimap<K, V> extends ImmutableMultimap<K, V>
     }
 
     /** Adds a key-value mapping to the built multimap if it is not already present. */
-    @CanIgnoreReturnValue
     @Override
     public Builder<K, V> put(K key, V value) {
       super.put(key, value);
@@ -265,7 +254,6 @@ public class ImmutableSetMultimap<K, V> extends ImmutableMultimap<K, V>
      *
      * @since 11.0
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<K, V> put(Entry<? extends K, ? extends V> entry) {
       super.put(entry);
@@ -277,28 +265,23 @@ public class ImmutableSetMultimap<K, V> extends ImmutableMultimap<K, V>
      *
      * @since 19.0
      */
-    @CanIgnoreReturnValue
-    @Beta
     @Override
     public Builder<K, V> putAll(Iterable<? extends Entry<? extends K, ? extends V>> entries) {
       super.putAll(entries);
       return this;
     }
 
-    @CanIgnoreReturnValue
     @Override
     public Builder<K, V> putAll(K key, Iterable<? extends V> values) {
       super.putAll(key, values);
       return this;
     }
 
-    @CanIgnoreReturnValue
     @Override
     public Builder<K, V> putAll(K key, V... values) {
       return putAll(key, Arrays.asList(values));
     }
 
-    @CanIgnoreReturnValue
     @Override
     public Builder<K, V> putAll(Multimap<? extends K, ? extends V> multimap) {
       for (Entry<? extends K, ? extends Collection<? extends V>> entry :
@@ -308,7 +291,6 @@ public class ImmutableSetMultimap<K, V> extends ImmutableMultimap<K, V>
       return this;
     }
 
-    @CanIgnoreReturnValue
     @Override
     Builder<K, V> combine(ImmutableMultimap.Builder<K, V> other) {
       super.combine(other);
@@ -320,7 +302,6 @@ public class ImmutableSetMultimap<K, V> extends ImmutableMultimap<K, V>
      *
      * @since 8.0
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<K, V> orderKeysBy(Comparator<? super K> keyComparator) {
       super.orderKeysBy(keyComparator);
@@ -338,7 +319,6 @@ public class ImmutableSetMultimap<K, V> extends ImmutableMultimap<K, V>
      * @since 8.0
      */
     // TODO: Make serialization behavior consistent.
-    @CanIgnoreReturnValue
     @Override
     public Builder<K, V> orderValuesBy(Comparator<? super V> valueComparator) {
       super.orderValuesBy(valueComparator);
@@ -401,7 +381,6 @@ public class ImmutableSetMultimap<K, V> extends ImmutableMultimap<K, V>
    * @throws NullPointerException if any key, value, or entry is null
    * @since 19.0
    */
-  @Beta
   public static <K, V> ImmutableSetMultimap<K, V> copyOf(
       Iterable<? extends Entry<? extends K, ? extends V>> entries) {
     return new Builder<K, V>().putAll(entries).build();
@@ -459,7 +438,7 @@ public class ImmutableSetMultimap<K, V> extends ImmutableMultimap<K, V>
     return MoreObjects.firstNonNull(set, emptySet);
   }
 
-  @LazyInit @RetainedWith @CheckForNull private transient ImmutableSetMultimap<V, K> inverse;
+  @CheckForNull private transient ImmutableSetMultimap<V, K> inverse;
 
   /**
    * {@inheritDoc}
@@ -490,10 +469,8 @@ public class ImmutableSetMultimap<K, V> extends ImmutableMultimap<K, V>
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final ImmutableSet<V> removeAll(@CheckForNull Object key) {
     throw new UnsupportedOperationException();
   }
@@ -504,15 +481,13 @@ public class ImmutableSetMultimap<K, V> extends ImmutableMultimap<K, V>
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final ImmutableSet<V> replaceValues(K key, Iterable<? extends V> values) {
     throw new UnsupportedOperationException();
   }
 
-  @LazyInit @RetainedWith @CheckForNull private transient ImmutableSet<Entry<K, V>> entries;
+  @CheckForNull private transient ImmutableSet<Entry<K, V>> entries;
 
   /**
    * Returns an immutable collection of all key-value pairs in the multimap. Its iterator traverses
@@ -525,7 +500,7 @@ public class ImmutableSetMultimap<K, V> extends ImmutableMultimap<K, V>
   }
 
   private static final class EntrySet<K, V> extends ImmutableSet<Entry<K, V>> {
-    @Weak private final transient ImmutableSetMultimap<K, V> multimap;
+    private final transient ImmutableSetMultimap<K, V> multimap;
 
     EntrySet(ImmutableSetMultimap<K, V> multimap) {
       this.multimap = multimap;
@@ -580,7 +555,7 @@ public class ImmutableSetMultimap<K, V> extends ImmutableMultimap<K, V>
    * @serialData number of distinct keys, and then for each distinct key: the key, the number of
    *     values for that key, and the key's values
    */
-  @GwtIncompatible // java.io.ObjectOutputStream
+  // java.io.ObjectOutputStream
   private void writeObject(ObjectOutputStream stream) throws IOException {
     stream.defaultWriteObject();
     stream.writeObject(valueComparator());
@@ -594,13 +569,13 @@ public class ImmutableSetMultimap<K, V> extends ImmutableMultimap<K, V>
         : null;
   }
 
-  @GwtIncompatible // java serialization
+  // java serialization
   private static final class SetFieldSettersHolder {
     static final Serialization.FieldSetter<ImmutableSetMultimap> EMPTY_SET_FIELD_SETTER =
         Serialization.getFieldSetter(ImmutableSetMultimap.class, "emptySet");
   }
 
-  @GwtIncompatible // java.io.ObjectInputStream
+  // java.io.ObjectInputStream
   // Serialization type safety is at the caller's mercy.
   @SuppressWarnings("unchecked")
   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
@@ -644,6 +619,6 @@ public class ImmutableSetMultimap<K, V> extends ImmutableMultimap<K, V>
     SetFieldSettersHolder.EMPTY_SET_FIELD_SETTER.set(this, emptySet(valueComparator));
   }
 
-  @GwtIncompatible // not needed in emulated source.
+  // not needed in emulated source.
   private static final long serialVersionUID = 0;
 }
diff --git a/guava/src/com/google/common/collect/ImmutableSortedAsList.java b/guava/src/com/google/common/collect/ImmutableSortedAsList.java
index 30f19a02e3..350f8f8d05 100644
--- a/guava/src/com/google/common/collect/ImmutableSortedAsList.java
+++ b/guava/src/com/google/common/collect/ImmutableSortedAsList.java
@@ -14,8 +14,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import java.util.Comparator;
 import java.util.Spliterator;
 import javax.annotation.CheckForNull;
@@ -26,7 +24,6 @@ import javax.annotation.CheckForNull;
  * @author Jared Levy
  * @author Louis Wasserman
  */
-@GwtCompatible(emulated = true)
 @SuppressWarnings("serial")
 @ElementTypesAreNonnullByDefault
 final class ImmutableSortedAsList<E> extends RegularImmutableAsList<E>
@@ -47,7 +44,7 @@ final class ImmutableSortedAsList<E> extends RegularImmutableAsList<E>
 
   // Override indexOf() and lastIndexOf() to be O(log N) instead of O(N).
 
-  @GwtIncompatible // ImmutableSortedSet.indexOf
+  // ImmutableSortedSet.indexOf
   // TODO(cpovirk): consider manual binary search under GWT to preserve O(log N) lookup
   @Override
   public int indexOf(@CheckForNull Object target) {
@@ -61,7 +58,7 @@ final class ImmutableSortedAsList<E> extends RegularImmutableAsList<E>
     return (index >= 0 && get(index).equals(target)) ? index : -1;
   }
 
-  @GwtIncompatible // ImmutableSortedSet.indexOf
+  // ImmutableSortedSet.indexOf
   @Override
   public int lastIndexOf(@CheckForNull Object target) {
     return indexOf(target);
@@ -73,7 +70,7 @@ final class ImmutableSortedAsList<E> extends RegularImmutableAsList<E>
     return indexOf(target) >= 0;
   }
 
-  @GwtIncompatible // super.subListUnchecked does not exist; inherited subList is valid if slow
+  // super.subListUnchecked does not exist; inherited subList is valid if slow
   /*
    * TODO(cpovirk): if we start to override indexOf/lastIndexOf under GWT, we'll want some way to
    * override subList to return an ImmutableSortedAsList for better performance. Right now, I'm not
diff --git a/guava/src/com/google/common/collect/ImmutableSortedMap.java b/guava/src/com/google/common/collect/ImmutableSortedMap.java
index c4b59c826d..3eda6d8083 100644
--- a/guava/src/com/google/common/collect/ImmutableSortedMap.java
+++ b/guava/src/com/google/common/collect/ImmutableSortedMap.java
@@ -22,10 +22,6 @@ import static com.google.common.collect.CollectPreconditions.checkEntryNotNull;
 import static com.google.common.collect.Maps.keyOrNull;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotCall;
 import java.util.AbstractMap;
 import java.util.Arrays;
 import java.util.Comparator;
@@ -41,7 +37,6 @@ import java.util.function.Function;
 import java.util.stream.Collector;
 import java.util.stream.Collectors;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link NavigableMap} whose contents will never change, with many other important properties
@@ -60,7 +55,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 2.0 (implements {@code NavigableMap} since 12.0)
  */
-@GwtCompatible(serializable = true, emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxverideShim<K, V>
     implements NavigableMap<K, V> {
@@ -76,7 +70,7 @@ public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxveride
    *
    * @since 21.0
    */
-  public static <T extends @Nullable Object, K, V>
+  public static <T extends Object, K, V>
       Collector<T, ?, ImmutableSortedMap<K, V>> toImmutableSortedMap(
           Comparator<? super K> comparator,
           Function<? super T, ? extends K> keyFunction,
@@ -95,7 +89,7 @@ public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxveride
    *
    * @since 21.0
    */
-  public static <T extends @Nullable Object, K, V>
+  public static <T extends Object, K, V>
       Collector<T, ?, ImmutableSortedMap<K, V>> toImmutableSortedMap(
           Comparator<? super K> comparator,
           Function<? super T, ? extends K> keyFunction,
@@ -403,7 +397,6 @@ public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxveride
    * @throws IllegalArgumentException if any two keys are equal according to the comparator
    * @since 19.0
    */
-  @Beta
   public static <K, V> ImmutableSortedMap<K, V> copyOf(
       Iterable<? extends Entry<? extends K, ? extends V>> entries) {
     // Hack around K not being a subtype of Comparable.
@@ -421,7 +414,6 @@ public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxveride
    * @throws IllegalArgumentException if any two keys are equal according to the comparator
    * @since 19.0
    */
-  @Beta
   public static <K, V> ImmutableSortedMap<K, V> copyOf(
       Iterable<? extends Entry<? extends K, ? extends V>> entries,
       Comparator<? super K> comparator) {
@@ -504,7 +496,7 @@ public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxveride
   private static <K, V> ImmutableSortedMap<K, V> fromEntries(
       final Comparator<? super K> comparator,
       boolean sameComparator,
-      @Nullable Entry<K, V>[] entryArray,
+      Entry<K, V>[] entryArray,
       int size) {
     switch (size) {
       case 0:
@@ -535,7 +527,7 @@ public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxveride
               entryArray,
               0,
               size,
-              new Comparator<@Nullable Entry<K, V>>() {
+              new Comparator<Entry<K, V>>() {
                 @Override
                 public int compare(@CheckForNull Entry<K, V> e1, @CheckForNull Entry<K, V> e2) {
                   // requireNonNull is safe because the first `size` elements have been filled in.
@@ -635,7 +627,6 @@ public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxveride
      * comparator (which might be the keys' natural order), are not allowed, and will cause {@link
      * #build} to fail.
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<K, V> put(K key, V value) {
       super.put(key, value);
@@ -649,7 +640,6 @@ public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxveride
      *
      * @since 11.0
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<K, V> put(Entry<? extends K, ? extends V> entry) {
       super.put(entry);
@@ -663,7 +653,6 @@ public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxveride
      *
      * @throws NullPointerException if any key or value in {@code map} is null
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<K, V> putAll(Map<? extends K, ? extends V> map) {
       super.putAll(map);
@@ -678,8 +667,6 @@ public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxveride
      * @throws NullPointerException if any key, value, or entry is null
      * @since 19.0
      */
-    @CanIgnoreReturnValue
-    @Beta
     @Override
     public Builder<K, V> putAll(Iterable<? extends Entry<? extends K, ? extends V>> entries) {
       super.putAll(entries);
@@ -692,11 +679,8 @@ public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxveride
      * @since 19.0
      * @deprecated Unsupported by ImmutableSortedMap.Builder.
      */
-    @CanIgnoreReturnValue
-    @Beta
     @Override
     @Deprecated
-    @DoNotCall("Always throws UnsupportedOperationException")
     public final Builder<K, V> orderEntriesByValue(Comparator<? super V> valueComparator) {
       throw new UnsupportedOperationException("Not available on ImmutableSortedMap.Builder");
     }
@@ -1065,10 +1049,8 @@ public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxveride
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   @CheckForNull
   public final Entry<K, V> pollFirstEntry() {
     throw new UnsupportedOperationException();
@@ -1080,10 +1062,8 @@ public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxveride
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   @CheckForNull
   public final Entry<K, V> pollLastEntry() {
     throw new UnsupportedOperationException();
diff --git a/guava/src/com/google/common/collect/ImmutableSortedMapFauxverideShim.java b/guava/src/com/google/common/collect/ImmutableSortedMapFauxverideShim.java
index 7b2e4d7552..f65f274897 100644
--- a/guava/src/com/google/common/collect/ImmutableSortedMapFauxverideShim.java
+++ b/guava/src/com/google/common/collect/ImmutableSortedMapFauxverideShim.java
@@ -16,12 +16,9 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.DoNotCall;
 import java.util.function.BinaryOperator;
 import java.util.function.Function;
 import java.util.stream.Collector;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * "Overrides" the {@link ImmutableMap} static methods that lack {@link ImmutableSortedMap}
@@ -30,7 +27,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @author Chris Povirk
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V> {
   /**
@@ -41,9 +37,8 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    * @throws UnsupportedOperationException always
    * @deprecated Use {@link ImmutableSortedMap#toImmutableSortedMap}.
    */
-  @DoNotCall("Use toImmutableSortedMap")
   @Deprecated
-  public static <T extends @Nullable Object, K, V>
+  public static <T extends Object, K, V>
       Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends V> valueFunction) {
@@ -58,9 +53,8 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    * @throws UnsupportedOperationException always
    * @deprecated Use {@link ImmutableSortedMap#toImmutableSortedMap}.
    */
-  @DoNotCall("Use toImmutableSortedMap")
   @Deprecated
-  public static <T extends @Nullable Object, K, V>
+  public static <T extends Object, K, V>
       Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends V> valueFunction,
@@ -76,7 +70,6 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    * @throws UnsupportedOperationException always
    * @deprecated Use {@link ImmutableSortedMap#naturalOrder}, which offers better type-safety.
    */
-  @DoNotCall("Use naturalOrder")
   @Deprecated
   public static <K, V> ImmutableSortedMap.Builder<K, V> builder() {
     throw new UnsupportedOperationException();
@@ -88,7 +81,6 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    * @throws UnsupportedOperationException always
    * @deprecated Not supported for ImmutableSortedMap.
    */
-  @DoNotCall("Use naturalOrder (which does not accept an expected size)")
   @Deprecated
   public static <K, V> ImmutableSortedMap.Builder<K, V> builderWithExpectedSize(int expectedSize) {
     throw new UnsupportedOperationException();
@@ -103,7 +95,6 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    * @deprecated <b>Pass a key of type {@code Comparable} to use {@link
    *     ImmutableSortedMap#of(Comparable, Object)}.</b>
    */
-  @DoNotCall("Pass a key of type Comparable")
   @Deprecated
   public static <K, V> ImmutableSortedMap<K, V> of(K k1, V v1) {
     throw new UnsupportedOperationException();
@@ -118,7 +109,6 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    * @deprecated <b>Pass keys of type {@code Comparable} to use {@link
    *     ImmutableSortedMap#of(Comparable, Object, Comparable, Object)}.</b>
    */
-  @DoNotCall("Pass keys of type Comparable")
   @Deprecated
   public static <K, V> ImmutableSortedMap<K, V> of(K k1, V v1, K k2, V v2) {
     throw new UnsupportedOperationException();
@@ -133,7 +123,6 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    * @deprecated <b>Pass keys of type {@code Comparable} to use {@link
    *     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object)}.</b>
    */
-  @DoNotCall("Pass keys of type Comparable")
   @Deprecated
   public static <K, V> ImmutableSortedMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3) {
     throw new UnsupportedOperationException();
@@ -149,7 +138,6 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    *     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
    *     Comparable, Object)}.</b>
    */
-  @DoNotCall("Pass keys of type Comparable")
   @Deprecated
   public static <K, V> ImmutableSortedMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {
     throw new UnsupportedOperationException();
@@ -165,7 +153,6 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    *     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
    *     Comparable, Object, Comparable, Object)}.</b>
    */
-  @DoNotCall("Pass keys of type Comparable")
   @Deprecated
   public static <K, V> ImmutableSortedMap<K, V> of(
       K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {
@@ -182,7 +169,6 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    *     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
    *     Comparable, Object, Comparable, Object)}.</b>
    */
-  @DoNotCall("Pass keys of type Comparable")
   @Deprecated
   public static <K, V> ImmutableSortedMap<K, V> of(
       K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6) {
@@ -199,7 +185,6 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    *     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
    *     Comparable, Object, Comparable, Object)}.</b>
    */
-  @DoNotCall("Pass keys of type Comparable")
   @Deprecated
   public static <K, V> ImmutableSortedMap<K, V> of(
       K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7) {
@@ -216,7 +201,6 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    *     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
    *     Comparable, Object, Comparable, Object)}.</b>
    */
-  @DoNotCall("Pass keys of type Comparable")
   @Deprecated
   public static <K, V> ImmutableSortedMap<K, V> of(
       K k1,
@@ -248,7 +232,6 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    *     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
    *     Comparable, Object, Comparable, Object)}.</b>
    */
-  @DoNotCall("Pass keys of type Comparable")
   @Deprecated
   public static <K, V> ImmutableSortedMap<K, V> of(
       K k1,
@@ -282,7 +265,6 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    *     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
    *     Comparable, Object, Comparable, Object)}.</b>
    */
-  @DoNotCall("Pass keys of type Comparable")
   @Deprecated
   public static <K, V> ImmutableSortedMap<K, V> of(
       K k1,
@@ -313,7 +295,6 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    *
    * @deprecated Use {@code ImmutableSortedMap.copyOf(ImmutableMap.ofEntries(...))}.
    */
-  @DoNotCall("ImmutableSortedMap.ofEntries not currently available; use ImmutableSortedMap.copyOf")
   @Deprecated
   public static <K, V> ImmutableSortedMap<K, V> ofEntries(
       Entry<? extends K, ? extends V>... entries) {
diff --git a/guava/src/com/google/common/collect/ImmutableSortedMultiset.java b/guava/src/com/google/common/collect/ImmutableSortedMultiset.java
index bf5a2f4d03..4741e083d0 100644
--- a/guava/src/com/google/common/collect/ImmutableSortedMultiset.java
+++ b/guava/src/com/google/common/collect/ImmutableSortedMultiset.java
@@ -17,10 +17,6 @@ package com.google.common.collect;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotCall;
-import com.google.errorprone.annotations.concurrent.LazyInit;
 import java.io.Serializable;
 import java.util.Arrays;
 import java.util.Collection;
@@ -32,7 +28,6 @@ import java.util.function.Function;
 import java.util.function.ToIntFunction;
 import java.util.stream.Collector;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link SortedMultiset} whose contents will never change, with many other important properties
@@ -50,7 +45,7 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 12.0
  */
-@GwtIncompatible // hasn't been tested yet
+// hasn't been tested yet
 @ElementTypesAreNonnullByDefault
 public abstract class ImmutableSortedMultiset<E> extends ImmutableSortedMultisetFauxverideShim<E>
     implements SortedMultiset<E> {
@@ -81,7 +76,7 @@ public abstract class ImmutableSortedMultiset<E> extends ImmutableSortedMultiset
    *
    * @since 22.0
    */
-  public static <T extends @Nullable Object, E>
+  public static <T extends Object, E>
       Collector<T, ?, ImmutableSortedMultiset<E>> toImmutableSortedMultiset(
           Comparator<? super E> comparator,
           Function<? super T, ? extends E> elementFunction,
@@ -331,7 +326,7 @@ public abstract class ImmutableSortedMultiset<E> extends ImmutableSortedMultiset
   @Override
   public abstract ImmutableSortedSet<E> elementSet();
 
-  @LazyInit @CheckForNull transient ImmutableSortedMultiset<E> descendingMultiset;
+  @CheckForNull transient ImmutableSortedMultiset<E> descendingMultiset;
 
   @Override
   public ImmutableSortedMultiset<E> descendingMultiset() {
@@ -353,10 +348,8 @@ public abstract class ImmutableSortedMultiset<E> extends ImmutableSortedMultiset
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   @CheckForNull
   public final Entry<E> pollFirstEntry() {
     throw new UnsupportedOperationException();
@@ -370,10 +363,8 @@ public abstract class ImmutableSortedMultiset<E> extends ImmutableSortedMultiset
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   @CheckForNull
   public final Entry<E> pollLastEntry() {
     throw new UnsupportedOperationException();
@@ -469,7 +460,6 @@ public abstract class ImmutableSortedMultiset<E> extends ImmutableSortedMultiset
      * @return this {@code Builder} object
      * @throws NullPointerException if {@code element} is null
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<E> add(E element) {
       super.add(element);
@@ -483,7 +473,6 @@ public abstract class ImmutableSortedMultiset<E> extends ImmutableSortedMultiset
      * @return this {@code Builder} object
      * @throws NullPointerException if {@code elements} is null or contains a null element
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<E> add(E... elements) {
       super.add(elements);
@@ -501,7 +490,6 @@ public abstract class ImmutableSortedMultiset<E> extends ImmutableSortedMultiset
      * @throws IllegalArgumentException if {@code occurrences} is negative, or if this operation
      *     would result in more than {@link Integer#MAX_VALUE} occurrences of the element
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<E> addCopies(E element, int occurrences) {
       super.addCopies(element, occurrences);
@@ -518,7 +506,6 @@ public abstract class ImmutableSortedMultiset<E> extends ImmutableSortedMultiset
      * @throws NullPointerException if {@code element} is null
      * @throws IllegalArgumentException if {@code count} is negative
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<E> setCount(E element, int count) {
       super.setCount(element, count);
@@ -532,7 +519,6 @@ public abstract class ImmutableSortedMultiset<E> extends ImmutableSortedMultiset
      * @return this {@code Builder} object
      * @throws NullPointerException if {@code elements} is null or contains a null element
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<E> addAll(Iterable<? extends E> elements) {
       super.addAll(elements);
@@ -546,7 +532,6 @@ public abstract class ImmutableSortedMultiset<E> extends ImmutableSortedMultiset
      * @return this {@code Builder} object
      * @throws NullPointerException if {@code elements} is null or contains a null element
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<E> addAll(Iterator<? extends E> elements) {
       super.addAll(elements);
diff --git a/guava/src/com/google/common/collect/ImmutableSortedMultisetFauxverideShim.java b/guava/src/com/google/common/collect/ImmutableSortedMultisetFauxverideShim.java
index 94a2f560da..36d4cb9215 100644
--- a/guava/src/com/google/common/collect/ImmutableSortedMultisetFauxverideShim.java
+++ b/guava/src/com/google/common/collect/ImmutableSortedMultisetFauxverideShim.java
@@ -14,12 +14,9 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.DoNotCall;
 import java.util.function.Function;
 import java.util.function.ToIntFunction;
 import java.util.stream.Collector;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * "Overrides" the {@link ImmutableMultiset} static methods that lack {@link
@@ -38,7 +35,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @author Louis Wasserman
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 abstract class ImmutableSortedMultisetFauxverideShim<E> extends ImmutableMultiset<E> {
   /**
@@ -50,7 +46,6 @@ abstract class ImmutableSortedMultisetFauxverideShim<E> extends ImmutableMultise
    * @deprecated Use {@link ImmutableSortedMultiset#toImmutableSortedMultiset}.
    * @since 21.0
    */
-  @DoNotCall("Use toImmutableSortedMultiset.")
   @Deprecated
   public static <E> Collector<E, ?, ImmutableMultiset<E>> toImmutableMultiset() {
     throw new UnsupportedOperationException();
@@ -65,9 +60,8 @@ abstract class ImmutableSortedMultisetFauxverideShim<E> extends ImmutableMultise
    * @deprecated Use {@link ImmutableSortedMultiset#toImmutableSortedMultiset}.
    * @since 22.0
    */
-  @DoNotCall("Use toImmutableSortedMultiset.")
   @Deprecated
-  public static <T extends @Nullable Object, E>
+  public static <T extends Object, E>
       Collector<T, ?, ImmutableMultiset<E>> toImmutableMultiset(
           Function<? super T, ? extends E> elementFunction,
           ToIntFunction<? super T> countFunction) {
@@ -82,7 +76,6 @@ abstract class ImmutableSortedMultisetFauxverideShim<E> extends ImmutableMultise
    * @throws UnsupportedOperationException always
    * @deprecated Use {@link ImmutableSortedMultiset#naturalOrder}, which offers better type-safety.
    */
-  @DoNotCall("Use naturalOrder.")
   @Deprecated
   public static <E> ImmutableSortedMultiset.Builder<E> builder() {
     throw new UnsupportedOperationException();
@@ -97,7 +90,6 @@ abstract class ImmutableSortedMultisetFauxverideShim<E> extends ImmutableMultise
    * @deprecated <b>Pass a parameter of type {@code Comparable} to use {@link
    *     ImmutableSortedMultiset#of(Comparable)}.</b>
    */
-  @DoNotCall("Elements must be Comparable. (Or, pass a Comparator to orderedBy or copyOf.)")
   @Deprecated
   public static <E> ImmutableSortedMultiset<E> of(E element) {
     throw new UnsupportedOperationException();
@@ -112,7 +104,6 @@ abstract class ImmutableSortedMultisetFauxverideShim<E> extends ImmutableMultise
    * @deprecated <b>Pass the parameters of type {@code Comparable} to use {@link
    *     ImmutableSortedMultiset#of(Comparable, Comparable)}.</b>
    */
-  @DoNotCall("Elements must be Comparable. (Or, pass a Comparator to orderedBy or copyOf.)")
   @Deprecated
   public static <E> ImmutableSortedMultiset<E> of(E e1, E e2) {
     throw new UnsupportedOperationException();
@@ -127,7 +118,6 @@ abstract class ImmutableSortedMultisetFauxverideShim<E> extends ImmutableMultise
    * @deprecated <b>Pass the parameters of type {@code Comparable} to use {@link
    *     ImmutableSortedMultiset#of(Comparable, Comparable, Comparable)}.</b>
    */
-  @DoNotCall("Elements must be Comparable. (Or, pass a Comparator to orderedBy or copyOf.)")
   @Deprecated
   public static <E> ImmutableSortedMultiset<E> of(E e1, E e2, E e3) {
     throw new UnsupportedOperationException();
@@ -142,7 +132,6 @@ abstract class ImmutableSortedMultisetFauxverideShim<E> extends ImmutableMultise
    * @deprecated <b>Pass the parameters of type {@code Comparable} to use {@link
    *     ImmutableSortedMultiset#of(Comparable, Comparable, Comparable, Comparable)}. </b>
    */
-  @DoNotCall("Elements must be Comparable. (Or, pass a Comparator to orderedBy or copyOf.)")
   @Deprecated
   public static <E> ImmutableSortedMultiset<E> of(E e1, E e2, E e3, E e4) {
     throw new UnsupportedOperationException();
@@ -158,7 +147,6 @@ abstract class ImmutableSortedMultisetFauxverideShim<E> extends ImmutableMultise
    *     ImmutableSortedMultiset#of(Comparable, Comparable, Comparable, Comparable, Comparable)} .
    *     </b>
    */
-  @DoNotCall("Elements must be Comparable. (Or, pass a Comparator to orderedBy or copyOf.)")
   @Deprecated
   public static <E> ImmutableSortedMultiset<E> of(E e1, E e2, E e3, E e4, E e5) {
     throw new UnsupportedOperationException();
@@ -174,7 +162,6 @@ abstract class ImmutableSortedMultisetFauxverideShim<E> extends ImmutableMultise
    *     ImmutableSortedMultiset#of(Comparable, Comparable, Comparable, Comparable, Comparable,
    *     Comparable, Comparable...)} . </b>
    */
-  @DoNotCall("Elements must be Comparable. (Or, pass a Comparator to orderedBy or copyOf.)")
   @Deprecated
   public static <E> ImmutableSortedMultiset<E> of(
       E e1, E e2, E e3, E e4, E e5, E e6, E... remaining) {
@@ -190,7 +177,6 @@ abstract class ImmutableSortedMultisetFauxverideShim<E> extends ImmutableMultise
    * @deprecated <b>Pass parameters of type {@code Comparable} to use {@link
    *     ImmutableSortedMultiset#copyOf(Comparable[])}.</b>
    */
-  @DoNotCall("Elements must be Comparable. (Or, pass a Comparator to orderedBy or copyOf.)")
   @Deprecated
   public static <E> ImmutableSortedMultiset<E> copyOf(E[] elements) {
     throw new UnsupportedOperationException();
diff --git a/guava/src/com/google/common/collect/ImmutableSortedSet.java b/guava/src/com/google/common/collect/ImmutableSortedSet.java
index 8a7aec16c4..5ef558d33f 100644
--- a/guava/src/com/google/common/collect/ImmutableSortedSet.java
+++ b/guava/src/com/google/common/collect/ImmutableSortedSet.java
@@ -20,11 +20,6 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.ObjectArrays.checkElementsNotNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotCall;
-import com.google.errorprone.annotations.concurrent.LazyInit;
 import java.io.InvalidObjectException;
 import java.io.ObjectInputStream;
 import java.io.Serializable;
@@ -40,7 +35,6 @@ import java.util.Spliterators;
 import java.util.function.Consumer;
 import java.util.stream.Collector;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link NavigableSet} whose contents will never change, with many other important properties
@@ -60,7 +54,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @since 2.0 (implements {@code NavigableSet} since 12.0)
  */
 // TODO(benyu): benchmark and optimize all creation paths, which are a mess now
-@GwtCompatible(serializable = true, emulated = true)
 @SuppressWarnings("serial") // we're overriding default serialization
 @ElementTypesAreNonnullByDefault
 public abstract class ImmutableSortedSet<E> extends ImmutableSortedSetFauxverideShim<E>
@@ -480,7 +473,6 @@ public abstract class ImmutableSortedSet<E> extends ImmutableSortedSetFauxveride
      * @return this {@code Builder} object
      * @throws NullPointerException if {@code element} is null
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<E> add(E element) {
       checkNotNull(element);
@@ -509,7 +501,6 @@ public abstract class ImmutableSortedSet<E> extends ImmutableSortedSetFauxveride
      * @return this {@code Builder} object
      * @throws NullPointerException if {@code elements} contains a null element
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<E> add(E... elements) {
       checkElementsNotNull(elements);
@@ -527,7 +518,6 @@ public abstract class ImmutableSortedSet<E> extends ImmutableSortedSetFauxveride
      * @return this {@code Builder} object
      * @throws NullPointerException if {@code elements} contains a null element
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<E> addAll(Iterable<? extends E> elements) {
       super.addAll(elements);
@@ -542,14 +532,12 @@ public abstract class ImmutableSortedSet<E> extends ImmutableSortedSetFauxveride
      * @return this {@code Builder} object
      * @throws NullPointerException if {@code elements} contains a null element
      */
-    @CanIgnoreReturnValue
     @Override
     public Builder<E> addAll(Iterator<? extends E> elements) {
       super.addAll(elements);
       return this;
     }
 
-    @CanIgnoreReturnValue
     @Override
     Builder<E> combine(ImmutableSet.Builder<E> builder) {
       copyIfNecessary();
@@ -586,7 +574,7 @@ public abstract class ImmutableSortedSet<E> extends ImmutableSortedSetFauxveride
     // compare a and b, we should get a CCE or NPE on the subsequent line. Only methods
     // that are spec'd to throw CCE and NPE should call this.
     @SuppressWarnings({"unchecked", "nullness"})
-    Comparator<@Nullable Object> unsafeComparator = (Comparator<@Nullable Object>) comparator;
+    Comparator<Object> unsafeComparator = (Comparator<Object>) comparator;
     return unsafeComparator.compare(a, b);
   }
 
@@ -648,7 +636,7 @@ public abstract class ImmutableSortedSet<E> extends ImmutableSortedSetFauxveride
   }
 
   /** @since 12.0 */
-  @GwtIncompatible // NavigableSet
+  // NavigableSet
   @Override
   public ImmutableSortedSet<E> subSet(
       E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
@@ -691,7 +679,7 @@ public abstract class ImmutableSortedSet<E> extends ImmutableSortedSetFauxveride
   abstract ImmutableSortedSet<E> tailSetImpl(E fromElement, boolean inclusive);
 
   /** @since 12.0 */
-  @GwtIncompatible // NavigableSet
+  // NavigableSet
   @Override
   @CheckForNull
   public E lower(E e) {
@@ -713,7 +701,7 @@ public abstract class ImmutableSortedSet<E> extends ImmutableSortedSetFauxveride
   }
 
   /** @since 12.0 */
-  @GwtIncompatible // NavigableSet
+  // NavigableSet
   @Override
   @CheckForNull
   public E higher(E e) {
@@ -737,11 +725,9 @@ public abstract class ImmutableSortedSet<E> extends ImmutableSortedSetFauxveride
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
-  @GwtIncompatible // NavigableSet
+  // NavigableSet
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   @CheckForNull
   public final E pollFirst() {
     throw new UnsupportedOperationException();
@@ -754,23 +740,20 @@ public abstract class ImmutableSortedSet<E> extends ImmutableSortedSetFauxveride
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
-  @GwtIncompatible // NavigableSet
+  // NavigableSet
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   @CheckForNull
   public final E pollLast() {
     throw new UnsupportedOperationException();
   }
 
-  @GwtIncompatible // NavigableSet
-  @LazyInit
+  // NavigableSet
   @CheckForNull
   transient ImmutableSortedSet<E> descendingSet;
 
   /** @since 12.0 */
-  @GwtIncompatible // NavigableSet
+  // NavigableSet
   @Override
   public ImmutableSortedSet<E> descendingSet() {
     // racy single-check idiom
@@ -785,7 +768,7 @@ public abstract class ImmutableSortedSet<E> extends ImmutableSortedSetFauxveride
   // Most classes should implement this as new DescendingImmutableSortedSet<E>(this),
   // but we push down that implementation because ProGuard can't eliminate it even when it's always
   // overridden.
-  @GwtIncompatible // NavigableSet
+  // NavigableSet
   abstract ImmutableSortedSet<E> createDescendingSet();
 
   @Override
@@ -812,7 +795,7 @@ public abstract class ImmutableSortedSet<E> extends ImmutableSortedSetFauxveride
   }
 
   /** @since 12.0 */
-  @GwtIncompatible // NavigableSet
+  // NavigableSet
   @Override
   public abstract UnmodifiableIterator<E> descendingIterator();
 
diff --git a/guava/src/com/google/common/collect/ImmutableSortedSetFauxverideShim.java b/guava/src/com/google/common/collect/ImmutableSortedSetFauxverideShim.java
index ff3ac12d5e..46a1c23cfd 100644
--- a/guava/src/com/google/common/collect/ImmutableSortedSetFauxverideShim.java
+++ b/guava/src/com/google/common/collect/ImmutableSortedSetFauxverideShim.java
@@ -16,8 +16,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.DoNotCall;
 import java.util.stream.Collector;
 
 /**
@@ -37,7 +35,6 @@ import java.util.stream.Collector;
  *
  * @author Chris Povirk
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 abstract class ImmutableSortedSetFauxverideShim<E> extends ImmutableSet.CachingAsList<E> {
   /**
@@ -48,7 +45,6 @@ abstract class ImmutableSortedSetFauxverideShim<E> extends ImmutableSet.CachingA
    * @deprecated Use {@link ImmutableSortedSet#toImmutableSortedSet}.
    * @since 21.0
    */
-  @DoNotCall("Use toImmutableSortedSet")
   @Deprecated
   public static <E> Collector<E, ?, ImmutableSet<E>> toImmutableSet() {
     throw new UnsupportedOperationException();
@@ -62,7 +58,6 @@ abstract class ImmutableSortedSetFauxverideShim<E> extends ImmutableSet.CachingA
    * @throws UnsupportedOperationException always
    * @deprecated Use {@link ImmutableSortedSet#naturalOrder}, which offers better type-safety.
    */
-  @DoNotCall("Use naturalOrder")
   @Deprecated
   public static <E> ImmutableSortedSet.Builder<E> builder() {
     throw new UnsupportedOperationException();
@@ -75,7 +70,6 @@ abstract class ImmutableSortedSetFauxverideShim<E> extends ImmutableSet.CachingA
    * @throws UnsupportedOperationException always
    * @deprecated Not supported by ImmutableSortedSet.
    */
-  @DoNotCall("Use naturalOrder (which does not accept an expected size)")
   @Deprecated
   public static <E> ImmutableSortedSet.Builder<E> builderWithExpectedSize(int expectedSize) {
     throw new UnsupportedOperationException();
@@ -90,7 +84,6 @@ abstract class ImmutableSortedSetFauxverideShim<E> extends ImmutableSet.CachingA
    * @deprecated <b>Pass a parameter of type {@code Comparable} to use {@link
    *     ImmutableSortedSet#of(Comparable)}.</b>
    */
-  @DoNotCall("Pass a parameter of type Comparable")
   @Deprecated
   public static <E> ImmutableSortedSet<E> of(E element) {
     throw new UnsupportedOperationException();
@@ -105,7 +98,6 @@ abstract class ImmutableSortedSetFauxverideShim<E> extends ImmutableSet.CachingA
    * @deprecated <b>Pass the parameters of type {@code Comparable} to use {@link
    *     ImmutableSortedSet#of(Comparable, Comparable)}.</b>
    */
-  @DoNotCall("Pass parameters of type Comparable")
   @Deprecated
   public static <E> ImmutableSortedSet<E> of(E e1, E e2) {
     throw new UnsupportedOperationException();
@@ -120,7 +112,6 @@ abstract class ImmutableSortedSetFauxverideShim<E> extends ImmutableSet.CachingA
    * @deprecated <b>Pass the parameters of type {@code Comparable} to use {@link
    *     ImmutableSortedSet#of(Comparable, Comparable, Comparable)}.</b>
    */
-  @DoNotCall("Pass parameters of type Comparable")
   @Deprecated
   public static <E> ImmutableSortedSet<E> of(E e1, E e2, E e3) {
     throw new UnsupportedOperationException();
@@ -135,7 +126,6 @@ abstract class ImmutableSortedSetFauxverideShim<E> extends ImmutableSet.CachingA
    * @deprecated <b>Pass the parameters of type {@code Comparable} to use {@link
    *     ImmutableSortedSet#of(Comparable, Comparable, Comparable, Comparable)}. </b>
    */
-  @DoNotCall("Pass parameters of type Comparable")
   @Deprecated
   public static <E> ImmutableSortedSet<E> of(E e1, E e2, E e3, E e4) {
     throw new UnsupportedOperationException();
@@ -150,7 +140,6 @@ abstract class ImmutableSortedSetFauxverideShim<E> extends ImmutableSet.CachingA
    * @deprecated <b>Pass the parameters of type {@code Comparable} to use {@link
    *     ImmutableSortedSet#of( Comparable, Comparable, Comparable, Comparable, Comparable)}. </b>
    */
-  @DoNotCall("Pass parameters of type Comparable")
   @Deprecated
   public static <E> ImmutableSortedSet<E> of(E e1, E e2, E e3, E e4, E e5) {
     throw new UnsupportedOperationException();
@@ -166,7 +155,6 @@ abstract class ImmutableSortedSetFauxverideShim<E> extends ImmutableSet.CachingA
    *     ImmutableSortedSet#of(Comparable, Comparable, Comparable, Comparable, Comparable,
    *     Comparable, Comparable...)}. </b>
    */
-  @DoNotCall("Pass parameters of type Comparable")
   @Deprecated
   public static <E> ImmutableSortedSet<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E... remaining) {
     throw new UnsupportedOperationException();
@@ -181,7 +169,6 @@ abstract class ImmutableSortedSetFauxverideShim<E> extends ImmutableSet.CachingA
    * @deprecated <b>Pass parameters of type {@code Comparable} to use {@link
    *     ImmutableSortedSet#copyOf(Comparable[])}.</b>
    */
-  @DoNotCall("Pass parameters of type Comparable")
   @Deprecated
   public static <E> ImmutableSortedSet<E> copyOf(E[] elements) {
     throw new UnsupportedOperationException();
diff --git a/guava/src/com/google/common/collect/ImmutableTable.java b/guava/src/com/google/common/collect/ImmutableTable.java
index 6d159389f6..4e3a58adff 100644
--- a/guava/src/com/google/common/collect/ImmutableTable.java
+++ b/guava/src/com/google/common/collect/ImmutableTable.java
@@ -18,11 +18,7 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.MoreObjects;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotCall;
-import com.google.errorprone.annotations.DoNotMock;
 import java.io.Serializable;
 import java.util.Comparator;
 import java.util.Iterator;
@@ -33,7 +29,6 @@ import java.util.function.BinaryOperator;
 import java.util.function.Function;
 import java.util.stream.Collector;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link Table} whose contents will never change, with many other important properties detailed
@@ -45,7 +40,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Gregory Kick
  * @since 11.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>
     implements Serializable {
@@ -60,7 +54,7 @@ public abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>
    *
    * @since 21.0
    */
-  public static <T extends @Nullable Object, R, C, V>
+  public static <T extends Object, R, C, V>
       Collector<T, ?, ImmutableTable<R, C, V>> toImmutableTable(
           Function<? super T, ? extends R> rowFunction,
           Function<? super T, ? extends C> columnFunction,
@@ -79,7 +73,7 @@ public abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>
    *
    * @since 21.0
    */
-  public static <T extends @Nullable Object, R, C, V>
+  public static <T extends Object, R, C, V>
       Collector<T, ?, ImmutableTable<R, C, V>> toImmutableTable(
           Function<? super T, ? extends R> rowFunction,
           Function<? super T, ? extends C> columnFunction,
@@ -182,7 +176,6 @@ public abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>
    *
    * @since 11.0
    */
-  @DoNotMock
   public static final class Builder<R, C, V> {
     private final List<Cell<R, C, V>> cells = Lists.newArrayList();
     @CheckForNull private Comparator<? super R> rowComparator;
@@ -195,14 +188,12 @@ public abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>
     public Builder() {}
 
     /** Specifies the ordering of the generated table's rows. */
-    @CanIgnoreReturnValue
     public Builder<R, C, V> orderRowsBy(Comparator<? super R> rowComparator) {
       this.rowComparator = checkNotNull(rowComparator, "rowComparator");
       return this;
     }
 
     /** Specifies the ordering of the generated table's columns. */
-    @CanIgnoreReturnValue
     public Builder<R, C, V> orderColumnsBy(Comparator<? super C> columnComparator) {
       this.columnComparator = checkNotNull(columnComparator, "columnComparator");
       return this;
@@ -212,7 +203,6 @@ public abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>
      * Associates the ({@code rowKey}, {@code columnKey}) pair with {@code value} in the built
      * table. Duplicate key pairs are not allowed and will cause {@link #build} to fail.
      */
-    @CanIgnoreReturnValue
     public Builder<R, C, V> put(R rowKey, C columnKey, V value) {
       cells.add(cellOf(rowKey, columnKey, value));
       return this;
@@ -222,7 +212,6 @@ public abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>
      * Adds the given {@code cell} to the table, making it immutable if necessary. Duplicate key
      * pairs are not allowed and will cause {@link #build} to fail.
      */
-    @CanIgnoreReturnValue
     public Builder<R, C, V> put(Cell<? extends R, ? extends C, ? extends V> cell) {
       if (cell instanceof Tables.ImmutableCell) {
         checkNotNull(cell.getRowKey(), "row");
@@ -243,7 +232,6 @@ public abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>
      *
      * @throws NullPointerException if any key or value in {@code table} is null
      */
-    @CanIgnoreReturnValue
     public Builder<R, C, V> putAll(Table<? extends R, ? extends C, ? extends V> table) {
       for (Cell<? extends R, ? extends C, ? extends V> cell : table.cellSet()) {
         put(cell);
@@ -251,7 +239,6 @@ public abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>
       return this;
     }
 
-    @CanIgnoreReturnValue
     Builder<R, C, V> combine(Builder<R, C, V> other) {
       this.cells.addAll(other.cells);
       return this;
@@ -393,7 +380,6 @@ public abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final void clear() {
     throw new UnsupportedOperationException();
   }
@@ -404,10 +390,8 @@ public abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   @CheckForNull
   public final V put(R rowKey, C columnKey, V value) {
     throw new UnsupportedOperationException();
@@ -421,7 +405,6 @@ public abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final void putAll(Table<? extends R, ? extends C, ? extends V> table) {
     throw new UnsupportedOperationException();
   }
@@ -432,10 +415,8 @@ public abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   @CheckForNull
   public final V remove(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
     throw new UnsupportedOperationException();
diff --git a/guava/src/com/google/common/collect/IndexedImmutableSet.java b/guava/src/com/google/common/collect/IndexedImmutableSet.java
index 20dfacbab8..67c327d508 100644
--- a/guava/src/com/google/common/collect/IndexedImmutableSet.java
+++ b/guava/src/com/google/common/collect/IndexedImmutableSet.java
@@ -18,13 +18,9 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import java.util.Spliterator;
 import java.util.function.Consumer;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 abstract class IndexedImmutableSet<E> extends ImmutableSet.CachingAsList<E> {
   abstract E get(int index);
@@ -49,8 +45,7 @@ abstract class IndexedImmutableSet<E> extends ImmutableSet.CachingAsList<E> {
   }
 
   @Override
-  @GwtIncompatible
-  int copyIntoArray(@Nullable Object[] dst, int offset) {
+  int copyIntoArray(Object[] dst, int offset) {
     return asList().copyIntoArray(dst, offset);
   }
 
diff --git a/guava/src/com/google/common/collect/Interner.java b/guava/src/com/google/common/collect/Interner.java
index bfc2035f10..969fd64e15 100644
--- a/guava/src/com/google/common/collect/Interner.java
+++ b/guava/src/com/google/common/collect/Interner.java
@@ -16,9 +16,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotMock;
 
 /**
  * Provides similar behavior to {@link String#intern} for any immutable type. Common implementations
@@ -31,8 +28,6 @@ import com.google.errorprone.annotations.DoNotMock;
  * @author Kevin Bourrillion
  * @since 3.0
  */
-@DoNotMock("Use Interners.new*Interner")
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public interface Interner<E> {
   /**
@@ -47,6 +42,6 @@ public interface Interner<E> {
    *
    * @throws NullPointerException if {@code sample} is null
    */
-  @CanIgnoreReturnValue // TODO(cpovirk): Consider removing this?
+  // TODO(cpovirk): Consider removing this?
   E intern(E sample);
 }
diff --git a/guava/src/com/google/common/collect/Interners.java b/guava/src/com/google/common/collect/Interners.java
index a3ae374962..1e5bec42d7 100644
--- a/guava/src/com/google/common/collect/Interners.java
+++ b/guava/src/com/google/common/collect/Interners.java
@@ -16,8 +16,6 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Function;
 import com.google.common.collect.MapMaker.Dummy;
@@ -30,7 +28,6 @@ import javax.annotation.CheckForNull;
  * @author Kevin Bourrillion
  * @since 3.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class Interners {
   private Interners() {}
@@ -61,7 +58,6 @@ public final class Interners {
      *
      * @see Interners#newWeakInterner()
      */
-    @GwtIncompatible("java.lang.ref.WeakReference")
     public InternerBuilder weak() {
       this.strong = false;
       return this;
@@ -105,15 +101,13 @@ public final class Interners {
    * likely does not perform as well as {@link #newStrongInterner}, but is the best alternative when
    * the memory usage of that implementation is unacceptable.
    */
-  @GwtIncompatible("java.lang.ref.WeakReference")
   public static <E> Interner<E> newWeakInterner() {
     return newBuilder().weak().build();
   }
 
-  @VisibleForTesting
   static final class InternerImpl<E> implements Interner<E> {
     // MapMaker is our friend, we know about this type
-    @VisibleForTesting final MapMakerInternalMap<E, Dummy, ?, ?> map;
+    final MapMakerInternalMap<E, Dummy, ?, ?> map;
 
     private InternerImpl(MapMaker mapMaker) {
       this.map =
diff --git a/guava/src/com/google/common/collect/Iterables.java b/guava/src/com/google/common/collect/Iterables.java
index fb2b5438e3..a4f4027dd9 100644
--- a/guava/src/com/google/common/collect/Iterables.java
+++ b/guava/src/com/google/common/collect/Iterables.java
@@ -20,14 +20,10 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkRemove;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Collection;
 import java.util.Comparator;
 import java.util.Iterator;
@@ -40,7 +36,6 @@ import java.util.Spliterator;
 import java.util.function.Consumer;
 import java.util.stream.Stream;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An assortment of mainly legacy static utility methods that operate on or return objects of type
@@ -64,13 +59,12 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Jared Levy
  * @since 2.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class Iterables {
   private Iterables() {}
 
   /** Returns an unmodifiable view of {@code iterable}. */
-  public static <T extends @Nullable Object> Iterable<T> unmodifiableIterable(
+  public static <T extends Object> Iterable<T> unmodifiableIterable(
       final Iterable<? extends T> iterable) {
     checkNotNull(iterable);
     if (iterable instanceof UnmodifiableIterable || iterable instanceof ImmutableCollection) {
@@ -92,7 +86,7 @@ public final class Iterables {
     return checkNotNull(iterable);
   }
 
-  private static final class UnmodifiableIterable<T extends @Nullable Object>
+  private static final class UnmodifiableIterable<T extends Object>
       extends FluentIterable<T> {
     private final Iterable<? extends T> iterable;
 
@@ -138,7 +132,7 @@ public final class Iterables {
    */
   // <? extends @Nullable Object> instead of <?> because of Kotlin b/189937072, discussed in Joiner.
   public static boolean contains(
-      Iterable<? extends @Nullable Object> iterable, @CheckForNull Object element) {
+      Iterable<? extends Object> iterable, @CheckForNull Object element) {
     if (iterable instanceof Collection) {
       Collection<?> collection = (Collection<?>) iterable;
       return Collections2.safeContains(collection, element);
@@ -156,7 +150,6 @@ public final class Iterables {
    * @param elementsToRemove the elements to remove
    * @return {@code true} if any element was removed from {@code iterable}
    */
-  @CanIgnoreReturnValue
   public static boolean removeAll(Iterable<?> removeFrom, Collection<?> elementsToRemove) {
     return (removeFrom instanceof Collection)
         ? ((Collection<?>) removeFrom).removeAll(checkNotNull(elementsToRemove))
@@ -173,7 +166,6 @@ public final class Iterables {
    * @param elementsToRetain the elements to retain
    * @return {@code true} if any element was removed from {@code iterable}
    */
-  @CanIgnoreReturnValue
   public static boolean retainAll(Iterable<?> removeFrom, Collection<?> elementsToRetain) {
     return (removeFrom instanceof Collection)
         ? ((Collection<?>) removeFrom).retainAll(checkNotNull(elementsToRetain))
@@ -196,8 +188,7 @@ public final class Iterables {
    * @throws UnsupportedOperationException if the iterable does not support {@code remove()}.
    * @since 2.0
    */
-  @CanIgnoreReturnValue
-  public static <T extends @Nullable Object> boolean removeIf(
+  public static <T extends Object> boolean removeIf(
       Iterable<T> removeFrom, Predicate<? super T> predicate) {
     if (removeFrom instanceof Collection) {
       return ((Collection<T>) removeFrom).removeIf(predicate);
@@ -207,7 +198,7 @@ public final class Iterables {
 
   /** Removes and returns the first matching element, or returns {@code null} if there is none. */
   @CheckForNull
-  static <T extends @Nullable Object> T removeFirstMatching(
+  static <T extends Object> T removeFirstMatching(
       Iterable<T> removeFrom, Predicate<? super T> predicate) {
     checkNotNull(predicate);
     Iterator<T> iterator = removeFrom.iterator();
@@ -259,7 +250,7 @@ public final class Iterables {
    * @throws IllegalArgumentException if the iterable contains multiple elements
    */
   @ParametricNullness
-  public static <T extends @Nullable Object> T getOnlyElement(Iterable<T> iterable) {
+  public static <T extends Object> T getOnlyElement(Iterable<T> iterable) {
     return Iterators.getOnlyElement(iterable.iterator());
   }
 
@@ -273,7 +264,7 @@ public final class Iterables {
    * @throws IllegalArgumentException if the iterator contains multiple elements
    */
   @ParametricNullness
-  public static <T extends @Nullable Object> T getOnlyElement(
+  public static <T extends Object> T getOnlyElement(
       Iterable<? extends T> iterable, @ParametricNullness T defaultValue) {
     return Iterators.getOnlyElement(iterable.iterator(), defaultValue);
   }
@@ -285,17 +276,17 @@ public final class Iterables {
    * @param type the type of the elements
    * @return a newly-allocated array into which all the elements of the iterable have been copied
    */
-  @GwtIncompatible // Array.newInstance(Class, int)
+  // Array.newInstance(Class, int)
   /*
    * If we could express Class<@Nonnull T>, we could generalize the type parameter to <T extends
    * @Nullable Object>, and then we could accept an Iterable<? extends T> and return a plain T[]
    * instead of a @Nullable T[].
    */
-  public static <T> @Nullable T[] toArray(Iterable<? extends @Nullable T> iterable, Class<T> type) {
+  public static <T> T[] toArray(Iterable<? extends T> iterable, Class<T> type) {
     return toArray(iterable, ObjectArrays.newArray(type, 0));
   }
 
-  static <T extends @Nullable Object> T[] toArray(Iterable<? extends T> iterable, T[] array) {
+  static <T extends Object> T[] toArray(Iterable<? extends T> iterable, T[] array) {
     Collection<? extends T> collection = castOrCopyToCollection(iterable);
     return collection.toArray(array);
   }
@@ -306,7 +297,7 @@ public final class Iterables {
    * @param iterable the iterable to copy
    * @return a newly-allocated array into which all the elements of the iterable have been copied
    */
-  static @Nullable Object[] toArray(Iterable<?> iterable) {
+  static Object[] toArray(Iterable<?> iterable) {
     return castOrCopyToCollection(iterable).toArray();
   }
 
@@ -315,7 +306,7 @@ public final class Iterables {
    * returned. Otherwise, an {@link java.util.ArrayList} is created with the contents of the
    * iterable in the same iteration order.
    */
-  private static <E extends @Nullable Object> Collection<E> castOrCopyToCollection(
+  private static <E extends Object> Collection<E> castOrCopyToCollection(
       Iterable<E> iterable) {
     return (iterable instanceof Collection)
         ? (Collection<E>) iterable
@@ -327,8 +318,7 @@ public final class Iterables {
    *
    * @return {@code true} if {@code collection} was modified as a result of this operation.
    */
-  @CanIgnoreReturnValue
-  public static <T extends @Nullable Object> boolean addAll(
+  public static <T extends Object> boolean addAll(
       Collection<T> addTo, Iterable<? extends T> elementsToAdd) {
     if (elementsToAdd instanceof Collection) {
       Collection<? extends T> c = (Collection<? extends T>) elementsToAdd;
@@ -375,7 +365,7 @@ public final class Iterables {
    * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code
    * Stream.generate(() -> iterable).flatMap(Streams::stream)}.
    */
-  public static <T extends @Nullable Object> Iterable<T> cycle(final Iterable<T> iterable) {
+  public static <T extends Object> Iterable<T> cycle(final Iterable<T> iterable) {
     checkNotNull(iterable);
     return new FluentIterable<T>() {
       @Override
@@ -416,7 +406,7 @@ public final class Iterables {
    * and use {@code Stream.generate(() -> collection).flatMap(Collection::stream)}.
    */
   @SafeVarargs
-  public static <T extends @Nullable Object> Iterable<T> cycle(T... elements) {
+  public static <T extends Object> Iterable<T> cycle(T... elements) {
     return cycle(Lists.newArrayList(elements));
   }
 
@@ -431,7 +421,7 @@ public final class Iterables {
    * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code Stream.concat(a,
    * b)}.
    */
-  public static <T extends @Nullable Object> Iterable<T> concat(
+  public static <T extends Object> Iterable<T> concat(
       Iterable<? extends T> a, Iterable<? extends T> b) {
     return FluentIterable.concat(a, b);
   }
@@ -447,7 +437,7 @@ public final class Iterables {
    * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code
    * Streams.concat(a, b, c)}.
    */
-  public static <T extends @Nullable Object> Iterable<T> concat(
+  public static <T extends Object> Iterable<T> concat(
       Iterable<? extends T> a, Iterable<? extends T> b, Iterable<? extends T> c) {
     return FluentIterable.concat(a, b, c);
   }
@@ -464,7 +454,7 @@ public final class Iterables {
    * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code
    * Streams.concat(a, b, c, d)}.
    */
-  public static <T extends @Nullable Object> Iterable<T> concat(
+  public static <T extends Object> Iterable<T> concat(
       Iterable<? extends T> a,
       Iterable<? extends T> b,
       Iterable<? extends T> c,
@@ -486,7 +476,7 @@ public final class Iterables {
    * @throws NullPointerException if any of the provided iterables is null
    */
   @SafeVarargs
-  public static <T extends @Nullable Object> Iterable<T> concat(Iterable<? extends T>... inputs) {
+  public static <T extends Object> Iterable<T> concat(Iterable<? extends T>... inputs) {
     return FluentIterable.concat(inputs);
   }
 
@@ -502,7 +492,7 @@ public final class Iterables {
    * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code
    * streamOfStreams.flatMap(s -> s)}.
    */
-  public static <T extends @Nullable Object> Iterable<T> concat(
+  public static <T extends Object> Iterable<T> concat(
       Iterable<? extends Iterable<? extends T>> inputs) {
     return FluentIterable.concat(inputs);
   }
@@ -525,7 +515,7 @@ public final class Iterables {
    *     into partitions
    * @throws IllegalArgumentException if {@code size} is nonpositive
    */
-  public static <T extends @Nullable Object> Iterable<List<T>> partition(
+  public static <T extends Object> Iterable<List<T>> partition(
       final Iterable<T> iterable, final int size) {
     checkNotNull(iterable);
     checkArgument(size > 0);
@@ -552,13 +542,13 @@ public final class Iterables {
    *     into partitions (the final iterable may have trailing null elements)
    * @throws IllegalArgumentException if {@code size} is nonpositive
    */
-  public static <T extends @Nullable Object> Iterable<List<@Nullable T>> paddedPartition(
+  public static <T extends Object> Iterable<List<T>> paddedPartition(
       final Iterable<T> iterable, final int size) {
     checkNotNull(iterable);
     checkArgument(size > 0);
-    return new FluentIterable<List<@Nullable T>>() {
+    return new FluentIterable<List<T>>() {
       @Override
-      public Iterator<List<@Nullable T>> iterator() {
+      public Iterator<List<T>> iterator() {
         return Iterators.paddedPartition(iterable.iterator(), size);
       }
     };
@@ -570,7 +560,7 @@ public final class Iterables {
    *
    * <p><b>{@code Stream} equivalent:</b> {@link Stream#filter}.
    */
-  public static <T extends @Nullable Object> Iterable<T> filter(
+  public static <T extends Object> Iterable<T> filter(
       final Iterable<T> unfiltered, final Predicate<? super T> retainIfTrue) {
     checkNotNull(unfiltered);
     checkNotNull(retainIfTrue);
@@ -613,7 +603,7 @@ public final class Iterables {
    * </pre>
    */
   @SuppressWarnings("unchecked")
-  @GwtIncompatible // Class.isInstance
+  // Class.isInstance
   public static <T> Iterable<T> filter(final Iterable<?> unfiltered, final Class<T> desiredType) {
     checkNotNull(unfiltered);
     checkNotNull(desiredType);
@@ -625,7 +615,7 @@ public final class Iterables {
    *
    * <p><b>{@code Stream} equivalent:</b> {@link Stream#anyMatch}.
    */
-  public static <T extends @Nullable Object> boolean any(
+  public static <T extends Object> boolean any(
       Iterable<T> iterable, Predicate<? super T> predicate) {
     return Iterators.any(iterable.iterator(), predicate);
   }
@@ -636,7 +626,7 @@ public final class Iterables {
    *
    * <p><b>{@code Stream} equivalent:</b> {@link Stream#allMatch}.
    */
-  public static <T extends @Nullable Object> boolean all(
+  public static <T extends Object> boolean all(
       Iterable<T> iterable, Predicate<? super T> predicate) {
     return Iterators.all(iterable.iterator(), predicate);
   }
@@ -651,7 +641,7 @@ public final class Iterables {
    * @throws NoSuchElementException if no element in {@code iterable} matches the given predicate
    */
   @ParametricNullness
-  public static <T extends @Nullable Object> T find(
+  public static <T extends Object> T find(
       Iterable<T> iterable, Predicate<? super T> predicate) {
     return Iterators.find(iterable.iterator(), predicate);
   }
@@ -682,7 +672,7 @@ public final class Iterables {
   //
   // - @JointlyNullable means "@Nullable or no annotation"
   @CheckForNull
-  public static <T extends @Nullable Object> T find(
+  public static <T extends Object> T find(
       Iterable<? extends T> iterable,
       Predicate<? super T> predicate,
       @CheckForNull T defaultValue) {
@@ -714,7 +704,7 @@ public final class Iterables {
    *
    * @since 2.0
    */
-  public static <T extends @Nullable Object> int indexOf(
+  public static <T extends Object> int indexOf(
       Iterable<T> iterable, Predicate<? super T> predicate) {
     return Iterators.indexOf(iterable.iterator(), predicate);
   }
@@ -732,7 +722,7 @@ public final class Iterables {
    *
    * <p><b>{@code Stream} equivalent:</b> {@link Stream#map}
    */
-  public static <F extends @Nullable Object, T extends @Nullable Object> Iterable<T> transform(
+  public static <F extends Object, T extends Object> Iterable<T> transform(
       final Iterable<F> fromIterable, final Function<? super F, ? extends T> function) {
     checkNotNull(fromIterable);
     checkNotNull(function);
@@ -767,7 +757,7 @@ public final class Iterables {
    *     the size of {@code iterable}
    */
   @ParametricNullness
-  public static <T extends @Nullable Object> T get(Iterable<T> iterable, int position) {
+  public static <T extends Object> T get(Iterable<T> iterable, int position) {
     checkNotNull(iterable);
     return (iterable instanceof List)
         ? ((List<T>) iterable).get(position)
@@ -790,7 +780,7 @@ public final class Iterables {
    * @since 4.0
    */
   @ParametricNullness
-  public static <T extends @Nullable Object> T get(
+  public static <T extends Object> T get(
       Iterable<? extends T> iterable, int position, @ParametricNullness T defaultValue) {
     checkNotNull(iterable);
     Iterators.checkNonnegative(position);
@@ -822,7 +812,7 @@ public final class Iterables {
    * @since 7.0
    */
   @ParametricNullness
-  public static <T extends @Nullable Object> T getFirst(
+  public static <T extends Object> T getFirst(
       Iterable<? extends T> iterable, @ParametricNullness T defaultValue) {
     return Iterators.getNext(iterable.iterator(), defaultValue);
   }
@@ -837,7 +827,7 @@ public final class Iterables {
    * @throws NoSuchElementException if the iterable is empty
    */
   @ParametricNullness
-  public static <T extends @Nullable Object> T getLast(Iterable<T> iterable) {
+  public static <T extends Object> T getLast(Iterable<T> iterable) {
     // TODO(kevinb): Support a concurrently modified collection?
     if (iterable instanceof List) {
       List<T> list = (List<T>) iterable;
@@ -862,7 +852,7 @@ public final class Iterables {
    * @since 3.0
    */
   @ParametricNullness
-  public static <T extends @Nullable Object> T getLast(
+  public static <T extends Object> T getLast(
       Iterable<? extends T> iterable, @ParametricNullness T defaultValue) {
     if (iterable instanceof Collection) {
       Collection<? extends T> c = (Collection<? extends T>) iterable;
@@ -877,7 +867,7 @@ public final class Iterables {
   }
 
   @ParametricNullness
-  private static <T extends @Nullable Object> T getLastInNonemptyList(List<T> list) {
+  private static <T extends Object> T getLastInNonemptyList(List<T> list) {
     return list.get(list.size() - 1);
   }
 
@@ -900,7 +890,7 @@ public final class Iterables {
    *
    * @since 3.0
    */
-  public static <T extends @Nullable Object> Iterable<T> skip(
+  public static <T extends Object> Iterable<T> skip(
       final Iterable<T> iterable, final int numberToSkip) {
     checkNotNull(iterable);
     checkArgument(numberToSkip >= 0, "number to skip cannot be negative");
@@ -972,7 +962,7 @@ public final class Iterables {
    * @throws IllegalArgumentException if {@code limitSize} is negative
    * @since 3.0
    */
-  public static <T extends @Nullable Object> Iterable<T> limit(
+  public static <T extends Object> Iterable<T> limit(
       final Iterable<T> iterable, final int limitSize) {
     checkNotNull(iterable);
     checkArgument(limitSize >= 0, "limit is negative");
@@ -1005,7 +995,7 @@ public final class Iterables {
    * @see Iterators#consumingIterator(Iterator)
    * @since 2.0
    */
-  public static <T extends @Nullable Object> Iterable<T> consumingIterable(
+  public static <T extends Object> Iterable<T> consumingIterable(
       final Iterable<T> iterable) {
     checkNotNull(iterable);
 
@@ -1056,8 +1046,7 @@ public final class Iterables {
    *
    * @since 11.0
    */
-  @Beta
-  public static <T extends @Nullable Object> Iterable<T> mergeSorted(
+  public static <T extends Object> Iterable<T> mergeSorted(
       final Iterable<? extends Iterable<? extends T>> iterables,
       final Comparator<? super T> comparator) {
     checkNotNull(iterables, "iterables");
@@ -1075,7 +1064,7 @@ public final class Iterables {
 
   // TODO(user): Is this the best place for this? Move to fluent functions?
   // Useful as a public method?
-  static <T extends @Nullable Object>
+  static <T extends Object>
       Function<Iterable<? extends T>, Iterator<? extends T>> toIterator() {
     return new Function<Iterable<? extends T>, Iterator<? extends T>>() {
       @Override
diff --git a/guava/src/com/google/common/collect/Iterators.java b/guava/src/com/google/common/collect/Iterators.java
index 5ea2da9da5..723267d6a0 100644
--- a/guava/src/com/google/common/collect/Iterators.java
+++ b/guava/src/com/google/common/collect/Iterators.java
@@ -24,16 +24,12 @@ import static com.google.common.collect.CollectPreconditions.checkRemove;
 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Function;
 import com.google.common.base.Objects;
 import com.google.common.base.Optional;
 import com.google.common.base.Preconditions;
 import com.google.common.base.Predicate;
 import com.google.common.primitives.Ints;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.ArrayDeque;
 import java.util.Arrays;
 import java.util.Collection;
@@ -48,7 +44,6 @@ import java.util.NoSuchElementException;
 import java.util.PriorityQueue;
 import java.util.Queue;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * This class contains static utility methods that operate on or return objects of type {@link
@@ -67,7 +62,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Jared Levy
  * @since 2.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class Iterators {
   private Iterators() {}
@@ -77,7 +71,7 @@ public final class Iterators {
    *
    * <p>The {@link Iterable} equivalent of this method is {@link ImmutableSet#of()}.
    */
-  static <T extends @Nullable Object> UnmodifiableIterator<T> emptyIterator() {
+  static <T extends Object> UnmodifiableIterator<T> emptyIterator() {
     return emptyListIterator();
   }
 
@@ -88,7 +82,7 @@ public final class Iterators {
    */
   // Casting to any type is safe since there are no actual elements.
   @SuppressWarnings("unchecked")
-  static <T extends @Nullable Object> UnmodifiableListIterator<T> emptyListIterator() {
+  static <T extends Object> UnmodifiableListIterator<T> emptyListIterator() {
     return (UnmodifiableListIterator<T>) ArrayItr.EMPTY;
   }
 
@@ -121,12 +115,12 @@ public final class Iterators {
    */
   // Casting to any type is safe since there are no actual elements.
   @SuppressWarnings("unchecked")
-  static <T extends @Nullable Object> Iterator<T> emptyModifiableIterator() {
+  static <T extends Object> Iterator<T> emptyModifiableIterator() {
     return (Iterator<T>) EmptyModifiableIterator.INSTANCE;
   }
 
   /** Returns an unmodifiable view of {@code iterator}. */
-  public static <T extends @Nullable Object> UnmodifiableIterator<T> unmodifiableIterator(
+  public static <T extends Object> UnmodifiableIterator<T> unmodifiableIterator(
       final Iterator<? extends T> iterator) {
     checkNotNull(iterator);
     if (iterator instanceof UnmodifiableIterator) {
@@ -155,7 +149,7 @@ public final class Iterators {
    * @since 10.0
    */
   @Deprecated
-  public static <T extends @Nullable Object> UnmodifiableIterator<T> unmodifiableIterator(
+  public static <T extends Object> UnmodifiableIterator<T> unmodifiableIterator(
       UnmodifiableIterator<T> iterator) {
     return checkNotNull(iterator);
   }
@@ -199,7 +193,6 @@ public final class Iterators {
    * @param elementsToRemove the elements to remove
    * @return {@code true} if any element was removed from {@code iterator}
    */
-  @CanIgnoreReturnValue
   public static boolean removeAll(Iterator<?> removeFrom, Collection<?> elementsToRemove) {
     checkNotNull(elementsToRemove);
     boolean result = false;
@@ -221,8 +214,7 @@ public final class Iterators {
    * @return {@code true} if any elements were removed from the iterator
    * @since 2.0
    */
-  @CanIgnoreReturnValue
-  public static <T extends @Nullable Object> boolean removeIf(
+  public static <T extends Object> boolean removeIf(
       Iterator<T> removeFrom, Predicate<? super T> predicate) {
     checkNotNull(predicate);
     boolean modified = false;
@@ -244,7 +236,6 @@ public final class Iterators {
    * @param elementsToRetain the elements to retain
    * @return {@code true} if any element was removed from {@code iterator}
    */
-  @CanIgnoreReturnValue
   public static boolean retainAll(Iterator<?> removeFrom, Collection<?> elementsToRetain) {
     checkNotNull(elementsToRetain);
     boolean result = false;
@@ -305,7 +296,7 @@ public final class Iterators {
    *     iterator is unspecified.
    */
   @ParametricNullness
-  public static <T extends @Nullable Object> T getOnlyElement(Iterator<T> iterator) {
+  public static <T extends Object> T getOnlyElement(Iterator<T> iterator) {
     T first = iterator.next();
     if (!iterator.hasNext()) {
       return first;
@@ -331,7 +322,7 @@ public final class Iterators {
    *     iterator is unspecified.
    */
   @ParametricNullness
-  public static <T extends @Nullable Object> T getOnlyElement(
+  public static <T extends Object> T getOnlyElement(
       Iterator<? extends T> iterator, @ParametricNullness T defaultValue) {
     return iterator.hasNext() ? getOnlyElement(iterator) : defaultValue;
   }
@@ -344,10 +335,10 @@ public final class Iterators {
    * @param type the type of the elements
    * @return a newly-allocated array into which all the elements of the iterator have been copied
    */
-  @GwtIncompatible // Array.newInstance(Class, int)
+  // Array.newInstance(Class, int)
   // For discussion of this signature, see the corresponding overload of *Iterables*.toArray.
-  public static <T> @Nullable T[] toArray(Iterator<? extends @Nullable T> iterator, Class<T> type) {
-    List<@Nullable T> list = Lists.newArrayList(iterator);
+  public static <T> T[] toArray(Iterator<? extends T> iterator, Class<T> type) {
+    List<T> list = Lists.newArrayList(iterator);
     return Iterables.toArray(list, type);
   }
 
@@ -357,8 +348,7 @@ public final class Iterators {
    *
    * @return {@code true} if {@code collection} was modified as a result of this operation
    */
-  @CanIgnoreReturnValue
-  public static <T extends @Nullable Object> boolean addAll(
+  public static <T extends Object> boolean addAll(
       Collection<T> addTo, Iterator<? extends T> iterator) {
     checkNotNull(addTo);
     checkNotNull(iterator);
@@ -397,7 +387,7 @@ public final class Iterators {
    * should use an explicit {@code break} or be certain that you will eventually remove all the
    * elements.
    */
-  public static <T extends @Nullable Object> Iterator<T> cycle(final Iterable<T> iterable) {
+  public static <T extends Object> Iterator<T> cycle(final Iterable<T> iterable) {
     checkNotNull(iterable);
     return new Iterator<T>() {
       Iterator<T> iterator = emptyModifiableIterator();
@@ -448,7 +438,7 @@ public final class Iterators {
    * elements.
    */
   @SafeVarargs
-  public static <T extends @Nullable Object> Iterator<T> cycle(T... elements) {
+  public static <T extends Object> Iterator<T> cycle(T... elements) {
     return cycle(Lists.newArrayList(elements));
   }
 
@@ -463,7 +453,7 @@ public final class Iterators {
    * <p>This is mainly just to avoid the intermediate ArrayDeque in ConsumingQueueIterator.
    */
   private static <I extends Iterator<?>> Iterator<I> consumingForArray(
-      final @Nullable I... elements) {
+      final I... elements) {
     return new UnmodifiableIterator<I>() {
       int index = 0;
 
@@ -497,7 +487,7 @@ public final class Iterators {
    * <p>The returned iterator supports {@code remove()} when the corresponding input iterator
    * supports it.
    */
-  public static <T extends @Nullable Object> Iterator<T> concat(
+  public static <T extends Object> Iterator<T> concat(
       Iterator<? extends T> a, Iterator<? extends T> b) {
     checkNotNull(a);
     checkNotNull(b);
@@ -512,7 +502,7 @@ public final class Iterators {
    * <p>The returned iterator supports {@code remove()} when the corresponding input iterator
    * supports it.
    */
-  public static <T extends @Nullable Object> Iterator<T> concat(
+  public static <T extends Object> Iterator<T> concat(
       Iterator<? extends T> a, Iterator<? extends T> b, Iterator<? extends T> c) {
     checkNotNull(a);
     checkNotNull(b);
@@ -529,7 +519,7 @@ public final class Iterators {
    * <p>The returned iterator supports {@code remove()} when the corresponding input iterator
    * supports it.
    */
-  public static <T extends @Nullable Object> Iterator<T> concat(
+  public static <T extends Object> Iterator<T> concat(
       Iterator<? extends T> a,
       Iterator<? extends T> b,
       Iterator<? extends T> c,
@@ -551,7 +541,7 @@ public final class Iterators {
    *
    * @throws NullPointerException if any of the provided iterators is null
    */
-  public static <T extends @Nullable Object> Iterator<T> concat(Iterator<? extends T>... inputs) {
+  public static <T extends Object> Iterator<T> concat(Iterator<? extends T>... inputs) {
     return concatNoDefensiveCopy(Arrays.copyOf(inputs, inputs.length));
   }
 
@@ -564,13 +554,13 @@ public final class Iterators {
    * supports it. The methods of the returned iterator may throw {@code NullPointerException} if any
    * of the input iterators is null.
    */
-  public static <T extends @Nullable Object> Iterator<T> concat(
+  public static <T extends Object> Iterator<T> concat(
       Iterator<? extends Iterator<? extends T>> inputs) {
     return new ConcatenatedIterator<T>(inputs);
   }
 
   /** Concats a varargs array of iterators without making a defensive copy of the array. */
-  static <T extends @Nullable Object> Iterator<T> concatNoDefensiveCopy(
+  static <T extends Object> Iterator<T> concatNoDefensiveCopy(
       Iterator<? extends T>... inputs) {
     for (Iterator<? extends T> input : checkNotNull(inputs)) {
       checkNotNull(input);
@@ -592,7 +582,7 @@ public final class Iterators {
    *     partitions
    * @throws IllegalArgumentException if {@code size} is nonpositive
    */
-  public static <T extends @Nullable Object> UnmodifiableIterator<List<T>> partition(
+  public static <T extends Object> UnmodifiableIterator<List<T>> partition(
       Iterator<T> iterator, int size) {
     return partitionImpl(iterator, size, false);
   }
@@ -611,29 +601,28 @@ public final class Iterators {
    *     partitions (the final iterable may have trailing null elements)
    * @throws IllegalArgumentException if {@code size} is nonpositive
    */
-  public static <T extends @Nullable Object>
-      UnmodifiableIterator<List<@Nullable T>> paddedPartition(Iterator<T> iterator, int size) {
+  public static <T extends Object>
+      UnmodifiableIterator<List<T>> paddedPartition(Iterator<T> iterator, int size) {
     return partitionImpl(iterator, size, true);
   }
 
-  private static <T extends @Nullable Object> UnmodifiableIterator<List<@Nullable T>> partitionImpl(
+  private static <T extends Object> UnmodifiableIterator<List<T>> partitionImpl(
       final Iterator<T> iterator, final int size, final boolean pad) {
     checkNotNull(iterator);
     checkArgument(size > 0);
-    return new UnmodifiableIterator<List<@Nullable T>>() {
+    return new UnmodifiableIterator<List<T>>() {
       @Override
       public boolean hasNext() {
         return iterator.hasNext();
       }
 
       @Override
-      public List<@Nullable T> next() {
+      public List<T> next() {
         if (!hasNext()) {
           throw new NoSuchElementException();
         }
         @SuppressWarnings("unchecked") // we only put Ts in it
-        @Nullable
-        T[] array = (@Nullable T[]) new Object[size];
+        T[] array = (T[]) new Object[size];
         int count = 0;
         for (; count < size && iterator.hasNext(); count++) {
           array[count] = iterator.next();
@@ -642,7 +631,7 @@ public final class Iterators {
           array[i] = null; // for GWT
         }
 
-        List<@Nullable T> list = Collections.unmodifiableList(Arrays.asList(array));
+        List<T> list = Collections.unmodifiableList(Arrays.asList(array));
         // TODO(b/192579700): Use a ternary once it no longer confuses our nullness checker.
         if (pad || count == size) {
           return list;
@@ -657,7 +646,7 @@ public final class Iterators {
    * Returns a view of {@code unfiltered} containing all elements that satisfy the input predicate
    * {@code retainIfTrue}.
    */
-  public static <T extends @Nullable Object> UnmodifiableIterator<T> filter(
+  public static <T extends Object> UnmodifiableIterator<T> filter(
       final Iterator<T> unfiltered, final Predicate<? super T> retainIfTrue) {
     checkNotNull(unfiltered);
     checkNotNull(retainIfTrue);
@@ -681,7 +670,7 @@ public final class Iterators {
    * desiredType}.
    */
   @SuppressWarnings("unchecked") // can cast to <T> because non-Ts are removed
-  @GwtIncompatible // Class.isInstance
+  // Class.isInstance
   public static <T> UnmodifiableIterator<T> filter(Iterator<?> unfiltered, Class<T> desiredType) {
     return (UnmodifiableIterator<T>) filter(unfiltered, instanceOf(desiredType));
   }
@@ -690,7 +679,7 @@ public final class Iterators {
    * Returns {@code true} if one or more elements returned by {@code iterator} satisfy the given
    * predicate.
    */
-  public static <T extends @Nullable Object> boolean any(
+  public static <T extends Object> boolean any(
       Iterator<T> iterator, Predicate<? super T> predicate) {
     return indexOf(iterator, predicate) != -1;
   }
@@ -699,7 +688,7 @@ public final class Iterators {
    * Returns {@code true} if every element returned by {@code iterator} satisfies the given
    * predicate. If {@code iterator} is empty, {@code true} is returned.
    */
-  public static <T extends @Nullable Object> boolean all(
+  public static <T extends Object> boolean all(
       Iterator<T> iterator, Predicate<? super T> predicate) {
     checkNotNull(predicate);
     while (iterator.hasNext()) {
@@ -721,7 +710,7 @@ public final class Iterators {
    * @throws NoSuchElementException if no element in {@code iterator} matches the given predicate
    */
   @ParametricNullness
-  public static <T extends @Nullable Object> T find(
+  public static <T extends Object> T find(
       Iterator<T> iterator, Predicate<? super T> predicate) {
     checkNotNull(iterator);
     checkNotNull(predicate);
@@ -744,7 +733,7 @@ public final class Iterators {
    */
   // For discussion of this signature, see the corresponding overload of *Iterables*.find.
   @CheckForNull
-  public static <T extends @Nullable Object> T find(
+  public static <T extends Object> T find(
       Iterator<? extends T> iterator,
       Predicate<? super T> predicate,
       @CheckForNull T defaultValue) {
@@ -796,7 +785,7 @@ public final class Iterators {
    *
    * @since 2.0
    */
-  public static <T extends @Nullable Object> int indexOf(
+  public static <T extends Object> int indexOf(
       Iterator<T> iterator, Predicate<? super T> predicate) {
     checkNotNull(predicate, "predicate");
     for (int i = 0; iterator.hasNext(); i++) {
@@ -816,7 +805,7 @@ public final class Iterators {
    * successful {@code remove()} call, {@code fromIterator} no longer contains the corresponding
    * element.
    */
-  public static <F extends @Nullable Object, T extends @Nullable Object> Iterator<T> transform(
+  public static <F extends Object, T extends Object> Iterator<T> transform(
       final Iterator<F> fromIterator, final Function<? super F, ? extends T> function) {
     checkNotNull(function);
     return new TransformedIterator<F, T>(fromIterator) {
@@ -838,7 +827,7 @@ public final class Iterators {
    *     the number of elements remaining in {@code iterator}
    */
   @ParametricNullness
-  public static <T extends @Nullable Object> T get(Iterator<T> iterator, int position) {
+  public static <T extends Object> T get(Iterator<T> iterator, int position) {
     checkNonnegative(position);
     int skipped = advance(iterator, position);
     if (!iterator.hasNext()) {
@@ -865,7 +854,7 @@ public final class Iterators {
    * @since 4.0
    */
   @ParametricNullness
-  public static <T extends @Nullable Object> T get(
+  public static <T extends Object> T get(
       Iterator<? extends T> iterator, int position, @ParametricNullness T defaultValue) {
     checkNonnegative(position);
     advance(iterator, position);
@@ -887,7 +876,7 @@ public final class Iterators {
    * @since 7.0
    */
   @ParametricNullness
-  public static <T extends @Nullable Object> T getNext(
+  public static <T extends Object> T getNext(
       Iterator<? extends T> iterator, @ParametricNullness T defaultValue) {
     return iterator.hasNext() ? iterator.next() : defaultValue;
   }
@@ -899,7 +888,7 @@ public final class Iterators {
    * @throws NoSuchElementException if the iterator is empty
    */
   @ParametricNullness
-  public static <T extends @Nullable Object> T getLast(Iterator<T> iterator) {
+  public static <T extends Object> T getLast(Iterator<T> iterator) {
     while (true) {
       T current = iterator.next();
       if (!iterator.hasNext()) {
@@ -917,7 +906,7 @@ public final class Iterators {
    * @since 3.0
    */
   @ParametricNullness
-  public static <T extends @Nullable Object> T getLast(
+  public static <T extends Object> T getLast(
       Iterator<? extends T> iterator, @ParametricNullness T defaultValue) {
     return iterator.hasNext() ? getLast(iterator) : defaultValue;
   }
@@ -929,7 +918,6 @@ public final class Iterators {
    * @return the number of elements the iterator was advanced
    * @since 13.0 (since 3.0 as {@code Iterators.skip})
    */
-  @CanIgnoreReturnValue
   public static int advance(Iterator<?> iterator, int numberToAdvance) {
     checkNotNull(iterator);
     checkArgument(numberToAdvance >= 0, "numberToAdvance must be nonnegative");
@@ -951,7 +939,7 @@ public final class Iterators {
    * @throws IllegalArgumentException if {@code limitSize} is negative
    * @since 3.0
    */
-  public static <T extends @Nullable Object> Iterator<T> limit(
+  public static <T extends Object> Iterator<T> limit(
       final Iterator<T> iterator, final int limitSize) {
     checkNotNull(iterator);
     checkArgument(limitSize >= 0, "limit is negative");
@@ -991,7 +979,7 @@ public final class Iterators {
    * @return an iterator that removes and returns elements from the supplied iterator
    * @since 2.0
    */
-  public static <T extends @Nullable Object> Iterator<T> consumingIterator(
+  public static <T extends Object> Iterator<T> consumingIterator(
       final Iterator<T> iterator) {
     checkNotNull(iterator);
     return new UnmodifiableIterator<T>() {
@@ -1020,7 +1008,7 @@ public final class Iterators {
    * such value.
    */
   @CheckForNull
-  static <T extends @Nullable Object> T pollNext(Iterator<T> iterator) {
+  static <T extends Object> T pollNext(Iterator<T> iterator) {
     if (iterator.hasNext()) {
       T result = iterator.next();
       iterator.remove();
@@ -1052,7 +1040,7 @@ public final class Iterators {
    * {@link ImmutableList#copyOf(Object[])}}, or {@link ImmutableList#of}.
    */
   @SafeVarargs
-  public static <T extends @Nullable Object> UnmodifiableIterator<T> forArray(final T... array) {
+  public static <T extends Object> UnmodifiableIterator<T> forArray(final T... array) {
     return forArray(array, 0, array.length, 0);
   }
 
@@ -1063,7 +1051,7 @@ public final class Iterators {
    * <p>The {@code Iterable} equivalent of this method is {@code
    * Arrays.asList(array).subList(offset, offset + length).listIterator(index)}.
    */
-  static <T extends @Nullable Object> UnmodifiableListIterator<T> forArray(
+  static <T extends Object> UnmodifiableListIterator<T> forArray(
       final T[] array, final int offset, int length, int index) {
     checkArgument(length >= 0);
     int end = offset + length;
@@ -1077,7 +1065,7 @@ public final class Iterators {
     return new ArrayItr<T>(array, offset, length, index);
   }
 
-  private static final class ArrayItr<T extends @Nullable Object>
+  private static final class ArrayItr<T extends Object>
       extends AbstractIndexedListIterator<T> {
     static final UnmodifiableListIterator<Object> EMPTY = new ArrayItr<>(new Object[0], 0, 0, 0);
 
@@ -1102,7 +1090,7 @@ public final class Iterators {
    *
    * <p>The {@link Iterable} equivalent of this method is {@link Collections#singleton}.
    */
-  public static <T extends @Nullable Object> UnmodifiableIterator<T> singletonIterator(
+  public static <T extends Object> UnmodifiableIterator<T> singletonIterator(
       @ParametricNullness final T value) {
     return new UnmodifiableIterator<T>() {
       boolean done;
@@ -1134,7 +1122,7 @@ public final class Iterators {
    * <p><b>Java 9 users:</b> use {@code enumeration.asIterator()} instead, unless it is important to
    * return an {@code UnmodifiableIterator} instead of a plain {@code Iterator}.
    */
-  public static <T extends @Nullable Object> UnmodifiableIterator<T> forEnumeration(
+  public static <T extends Object> UnmodifiableIterator<T> forEnumeration(
       final Enumeration<T> enumeration) {
     checkNotNull(enumeration);
     return new UnmodifiableIterator<T>() {
@@ -1157,7 +1145,7 @@ public final class Iterators {
    * <p>The {@code Iterable} equivalent of this method is either {@link Collections#enumeration} (if
    * you have a {@link Collection}), or {@code Iterators.asEnumeration(collection.iterator())}.
    */
-  public static <T extends @Nullable Object> Enumeration<T> asEnumeration(
+  public static <T extends Object> Enumeration<T> asEnumeration(
       final Iterator<T> iterator) {
     checkNotNull(iterator);
     return new Enumeration<T>() {
@@ -1175,7 +1163,7 @@ public final class Iterators {
   }
 
   /** Implementation of PeekingIterator that avoids peeking unless necessary. */
-  private static class PeekingImpl<E extends @Nullable Object> implements PeekingIterator<E> {
+  private static class PeekingImpl<E extends Object> implements PeekingIterator<E> {
 
     private final Iterator<? extends E> iterator;
     private boolean hasPeeked;
@@ -1257,7 +1245,7 @@ public final class Iterators {
    * @return a peeking iterator backed by that iterator. Apart from the additional {@link
    *     PeekingIterator#peek()} method, this iterator behaves exactly the same as {@code iterator}.
    */
-  public static <T extends @Nullable Object> PeekingIterator<T> peekingIterator(
+  public static <T extends Object> PeekingIterator<T> peekingIterator(
       Iterator<? extends T> iterator) {
     if (iterator instanceof PeekingImpl) {
       // Safe to cast <? extends T> to <T> because PeekingImpl only uses T
@@ -1276,7 +1264,7 @@ public final class Iterators {
    * @since 10.0
    */
   @Deprecated
-  public static <T extends @Nullable Object> PeekingIterator<T> peekingIterator(
+  public static <T extends Object> PeekingIterator<T> peekingIterator(
       PeekingIterator<T> iterator) {
     return checkNotNull(iterator);
   }
@@ -1293,8 +1281,7 @@ public final class Iterators {
    *
    * @since 11.0
    */
-  @Beta
-  public static <T extends @Nullable Object> UnmodifiableIterator<T> mergeSorted(
+  public static <T extends Object> UnmodifiableIterator<T> mergeSorted(
       Iterable<? extends Iterator<? extends T>> iterators, Comparator<? super T> comparator) {
     checkNotNull(iterators, "iterators");
     checkNotNull(comparator, "comparator");
@@ -1311,7 +1298,7 @@ public final class Iterators {
    * iterators. (Retrieving all elements takes approximately O(N*log(M)) time, where N is the total
    * number of elements.)
    */
-  private static class MergingIterator<T extends @Nullable Object> extends UnmodifiableIterator<T> {
+  private static class MergingIterator<T extends Object> extends UnmodifiableIterator<T> {
     final Queue<PeekingIterator<T>> queue;
 
     public MergingIterator(
@@ -1353,7 +1340,7 @@ public final class Iterators {
     }
   }
 
-  private static class ConcatenatedIterator<T extends @Nullable Object> implements Iterator<T> {
+  private static class ConcatenatedIterator<T extends Object> implements Iterator<T> {
     /* The last iterator to return an element.  Calls to remove() go to this iterator. */
     @CheckForNull private Iterator<? extends T> toRemove;
 
@@ -1450,7 +1437,7 @@ public final class Iterators {
   }
 
   /** Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557 */
-  static <T extends @Nullable Object> ListIterator<T> cast(Iterator<T> iterator) {
+  static <T extends Object> ListIterator<T> cast(Iterator<T> iterator) {
     return (ListIterator<T>) iterator;
   }
 }
diff --git a/guava/src/com/google/common/collect/JdkBackedImmutableBiMap.java b/guava/src/com/google/common/collect/JdkBackedImmutableBiMap.java
index 09f3135217..168a0f645f 100644
--- a/guava/src/com/google/common/collect/JdkBackedImmutableBiMap.java
+++ b/guava/src/com/google/common/collect/JdkBackedImmutableBiMap.java
@@ -17,24 +17,16 @@ package com.google.common.collect;
 
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.VisibleForTesting;
-import com.google.errorprone.annotations.concurrent.LazyInit;
-import com.google.j2objc.annotations.RetainedWith;
-import com.google.j2objc.annotations.WeakOuter;
 import java.util.Map;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of ImmutableBiMap backed by a pair of JDK HashMaps, which have smartness
  * protecting against hash flooding.
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 final class JdkBackedImmutableBiMap<K, V> extends ImmutableBiMap<K, V> {
-  @VisibleForTesting
-  static <K, V> ImmutableBiMap<K, V> create(int n, @Nullable Entry<K, V>[] entryArray) {
+  static <K, V> ImmutableBiMap<K, V> create(int n, Entry<K, V>[] entryArray) {
     Map<K, V> forwardDelegate = Maps.newHashMapWithExpectedSize(n);
     Map<V, K> backwardDelegate = Maps.newHashMapWithExpectedSize(n);
     for (int i = 0; i < n; i++) {
@@ -70,7 +62,7 @@ final class JdkBackedImmutableBiMap<K, V> extends ImmutableBiMap<K, V> {
     return entries.size();
   }
 
-  @LazyInit @RetainedWith @CheckForNull private transient JdkBackedImmutableBiMap<V, K> inverse;
+  @CheckForNull private transient JdkBackedImmutableBiMap<V, K> inverse;
 
   @Override
   public ImmutableBiMap<V, K> inverse() {
@@ -85,7 +77,6 @@ final class JdkBackedImmutableBiMap<K, V> extends ImmutableBiMap<K, V> {
     return result;
   }
 
-  @WeakOuter
   private final class InverseEntries extends ImmutableList<Entry<V, K>> {
     @Override
     public Entry<V, K> get(int index) {
diff --git a/guava/src/com/google/common/collect/JdkBackedImmutableMap.java b/guava/src/com/google/common/collect/JdkBackedImmutableMap.java
index 5b323b9539..275e27bfbe 100644
--- a/guava/src/com/google/common/collect/JdkBackedImmutableMap.java
+++ b/guava/src/com/google/common/collect/JdkBackedImmutableMap.java
@@ -20,17 +20,14 @@ import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.RegularImmutableMap.makeImmutable;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.Map;
 import java.util.function.BiConsumer;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of ImmutableMap backed by a JDK HashMap, which has smartness protecting against
  * hash flooding.
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 final class JdkBackedImmutableMap<K, V> extends ImmutableMap<K, V> {
   /**
@@ -38,7 +35,7 @@ final class JdkBackedImmutableMap<K, V> extends ImmutableMap<K, V> {
    * detected. This implementation may replace the entries in entryArray with its own entry objects
    * (though they will have the same key/value contents), and will take ownership of entryArray.
    */
-  static <K, V> ImmutableMap<K, V> create(int n, @Nullable Entry<K, V>[] entryArray) {
+  static <K, V> ImmutableMap<K, V> create(int n, Entry<K, V>[] entryArray) {
     Map<K, V> delegateMap = Maps.newHashMapWithExpectedSize(n);
     for (int i = 0; i < n; i++) {
       // requireNonNull is safe because the first `n` elements have been filled in.
diff --git a/guava/src/com/google/common/collect/JdkBackedImmutableMultiset.java b/guava/src/com/google/common/collect/JdkBackedImmutableMultiset.java
index 7bdd9e851d..dbea8c5464 100644
--- a/guava/src/com/google/common/collect/JdkBackedImmutableMultiset.java
+++ b/guava/src/com/google/common/collect/JdkBackedImmutableMultiset.java
@@ -16,7 +16,6 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.primitives.Ints;
 import java.util.Collection;
 import java.util.Map;
@@ -28,7 +27,6 @@ import javax.annotation.CheckForNull;
  *
  * @author Louis Wasserman
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 final class JdkBackedImmutableMultiset<E> extends ImmutableMultiset<E> {
   private final Map<E, Integer> delegateMap;
diff --git a/guava/src/com/google/common/collect/JdkBackedImmutableSet.java b/guava/src/com/google/common/collect/JdkBackedImmutableSet.java
index c00167713c..a5df162e9c 100644
--- a/guava/src/com/google/common/collect/JdkBackedImmutableSet.java
+++ b/guava/src/com/google/common/collect/JdkBackedImmutableSet.java
@@ -14,7 +14,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.Set;
 import javax.annotation.CheckForNull;
 
@@ -25,7 +24,6 @@ import javax.annotation.CheckForNull;
  *
  * @author Louis Wasserman
  */
-@GwtCompatible(serializable = true)
 @ElementTypesAreNonnullByDefault
 final class JdkBackedImmutableSet<E> extends IndexedImmutableSet<E> {
   private final Set<?> delegate;
diff --git a/guava/src/com/google/common/collect/LexicographicalOrdering.java b/guava/src/com/google/common/collect/LexicographicalOrdering.java
index 91fc7bf724..7cc490205e 100644
--- a/guava/src/com/google/common/collect/LexicographicalOrdering.java
+++ b/guava/src/com/google/common/collect/LexicographicalOrdering.java
@@ -16,17 +16,14 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 import java.util.Comparator;
 import java.util.Iterator;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** An ordering which sorts iterables by comparing corresponding elements pairwise. */
-@GwtCompatible(serializable = true)
 @ElementTypesAreNonnullByDefault
-final class LexicographicalOrdering<T extends @Nullable Object> extends Ordering<Iterable<T>>
+final class LexicographicalOrdering<T extends Object> extends Ordering<Iterable<T>>
     implements Serializable {
   final Comparator<? super T> elementOrder;
 
diff --git a/guava/src/com/google/common/collect/LinkedHashMultimap.java b/guava/src/com/google/common/collect/LinkedHashMultimap.java
index b4d2ab9435..b3309989d3 100644
--- a/guava/src/com/google/common/collect/LinkedHashMultimap.java
+++ b/guava/src/com/google/common/collect/LinkedHashMultimap.java
@@ -21,12 +21,7 @@ import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Objects;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.j2objc.annotations.WeakOuter;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
@@ -42,7 +37,6 @@ import java.util.Spliterator;
 import java.util.Spliterators;
 import java.util.function.Consumer;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@code Multimap} that does not allow duplicate key-value entries and that
@@ -83,13 +77,12 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 2.0
  */
-@GwtCompatible(serializable = true, emulated = true)
 @ElementTypesAreNonnullByDefault
-public final class LinkedHashMultimap<K extends @Nullable Object, V extends @Nullable Object>
+public final class LinkedHashMultimap<K extends Object, V extends Object>
     extends LinkedHashMultimapGwtSerializationDependencies<K, V> {
 
   /** Creates a new, empty {@code LinkedHashMultimap} with the default initial capacities. */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       LinkedHashMultimap<K, V> create() {
     return new LinkedHashMultimap<>(DEFAULT_KEY_CAPACITY, DEFAULT_VALUE_SET_CAPACITY);
   }
@@ -103,7 +96,7 @@ public final class LinkedHashMultimap<K extends @Nullable Object, V extends @Nul
    * @throws IllegalArgumentException if {@code expectedKeys} or {@code expectedValuesPerKey} is
    *     negative
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       LinkedHashMultimap<K, V> create(int expectedKeys, int expectedValuesPerKey) {
     return new LinkedHashMultimap<>(
         Maps.capacity(expectedKeys), Maps.capacity(expectedValuesPerKey));
@@ -117,14 +110,14 @@ public final class LinkedHashMultimap<K extends @Nullable Object, V extends @Nul
    *
    * @param multimap the multimap whose contents are copied to this multimap
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       LinkedHashMultimap<K, V> create(Multimap<? extends K, ? extends V> multimap) {
     LinkedHashMultimap<K, V> result = create(multimap.keySet().size(), DEFAULT_VALUE_SET_CAPACITY);
     result.putAll(multimap);
     return result;
   }
 
-  private interface ValueSetLink<K extends @Nullable Object, V extends @Nullable Object> {
+  private interface ValueSetLink<K extends Object, V extends Object> {
     ValueSetLink<K, V> getPredecessorInValueSet();
 
     ValueSetLink<K, V> getSuccessorInValueSet();
@@ -134,24 +127,24 @@ public final class LinkedHashMultimap<K extends @Nullable Object, V extends @Nul
     void setSuccessorInValueSet(ValueSetLink<K, V> entry);
   }
 
-  private static <K extends @Nullable Object, V extends @Nullable Object> void succeedsInValueSet(
+  private static <K extends Object, V extends Object> void succeedsInValueSet(
       ValueSetLink<K, V> pred, ValueSetLink<K, V> succ) {
     pred.setSuccessorInValueSet(succ);
     succ.setPredecessorInValueSet(pred);
   }
 
-  private static <K extends @Nullable Object, V extends @Nullable Object> void succeedsInMultimap(
+  private static <K extends Object, V extends Object> void succeedsInMultimap(
       ValueEntry<K, V> pred, ValueEntry<K, V> succ) {
     pred.setSuccessorInMultimap(succ);
     succ.setPredecessorInMultimap(pred);
   }
 
-  private static <K extends @Nullable Object, V extends @Nullable Object> void deleteFromValueSet(
+  private static <K extends Object, V extends Object> void deleteFromValueSet(
       ValueSetLink<K, V> entry) {
     succeedsInValueSet(entry.getPredecessorInValueSet(), entry.getSuccessorInValueSet());
   }
 
-  private static <K extends @Nullable Object, V extends @Nullable Object> void deleteFromMultimap(
+  private static <K extends Object, V extends Object> void deleteFromMultimap(
       ValueEntry<K, V> entry) {
     succeedsInMultimap(entry.getPredecessorInMultimap(), entry.getSuccessorInMultimap());
   }
@@ -162,8 +155,7 @@ public final class LinkedHashMultimap<K extends @Nullable Object, V extends @Nul
    * entries in that {@code Set<V>}, and the linked list of entries in the LinkedHashMultimap as a
    * whole.
    */
-  @VisibleForTesting
-  static final class ValueEntry<K extends @Nullable Object, V extends @Nullable Object>
+  static final class ValueEntry<K extends Object, V extends Object>
       extends ImmutableEntry<K, V> implements ValueSetLink<K, V> {
     final int smearedValueHash;
 
@@ -210,7 +202,7 @@ public final class LinkedHashMultimap<K extends @Nullable Object, V extends @Nul
     }
 
     @SuppressWarnings("nullness") // see the comment on the class fields, especially about newHeader
-    static <K extends @Nullable Object, V extends @Nullable Object> ValueEntry<K, V> newHeader() {
+    static <K extends Object, V extends Object> ValueEntry<K, V> newHeader() {
       return new ValueEntry<>(null, null, 0, null);
     }
 
@@ -257,9 +249,9 @@ public final class LinkedHashMultimap<K extends @Nullable Object, V extends @Nul
 
   private static final int DEFAULT_KEY_CAPACITY = 16;
   private static final int DEFAULT_VALUE_SET_CAPACITY = 2;
-  @VisibleForTesting static final double VALUE_SET_LOAD_FACTOR = 1.0;
+  static final double VALUE_SET_LOAD_FACTOR = 1.0;
 
-  @VisibleForTesting transient int valueSetCapacity = DEFAULT_VALUE_SET_CAPACITY;
+  transient int valueSetCapacity = DEFAULT_VALUE_SET_CAPACITY;
   private transient ValueEntry<K, V> multimapHeaderEntry;
 
   private LinkedHashMultimap(int keyCapacity, int valueSetCapacity) {
@@ -304,7 +296,6 @@ public final class LinkedHashMultimap<K extends @Nullable Object, V extends @Nul
    * the {@code keySet()} ordering is unchanged. However, the provided values always come last in
    * the {@link #entries()} and {@link #values()} iteration orderings.
    */
-  @CanIgnoreReturnValue
   @Override
   public Set<V> replaceValues(@ParametricNullness K key, Iterable<? extends V> values) {
     return super.replaceValues(key, values);
@@ -353,8 +344,6 @@ public final class LinkedHashMultimap<K extends @Nullable Object, V extends @Nul
     return super.values();
   }
 
-  @VisibleForTesting
-  @WeakOuter
   final class ValueSet extends Sets.ImprovedAbstractSet<V> implements ValueSetLink<K, V> {
     /*
      * We currently use a fixed load factor of 1.0, a bit higher than normal to reduce memory
@@ -362,7 +351,7 @@ public final class LinkedHashMultimap<K extends @Nullable Object, V extends @Nul
      */
 
     @ParametricNullness private final K key;
-    @VisibleForTesting @Nullable ValueEntry<K, V>[] hashTable;
+    ValueEntry<K, V>[] hashTable;
     private int size = 0;
     private int modCount = 0;
 
@@ -379,8 +368,7 @@ public final class LinkedHashMultimap<K extends @Nullable Object, V extends @Nul
       int tableSize = Hashing.closedTableSize(expectedValues, VALUE_SET_LOAD_FACTOR);
 
       @SuppressWarnings({"rawtypes", "unchecked"})
-      @Nullable
-      ValueEntry<K, V>[] hashTable = new @Nullable ValueEntry[tableSize];
+      ValueEntry<K, V>[] hashTable = new ValueEntry[tableSize];
       this.hashTable = hashTable;
     }
 
@@ -519,7 +507,6 @@ public final class LinkedHashMultimap<K extends @Nullable Object, V extends @Nul
       }
     }
 
-    @CanIgnoreReturnValue
     @Override
     public boolean remove(@CheckForNull Object o) {
       int smearedHash = Hashing.smearedHash(o);
@@ -616,7 +603,7 @@ public final class LinkedHashMultimap<K extends @Nullable Object, V extends @Nul
    * @serialData the expected values per key, the number of distinct keys, the number of entries,
    *     and the entries in order
    */
-  @GwtIncompatible // java.io.ObjectOutputStream
+  // java.io.ObjectOutputStream
   private void writeObject(ObjectOutputStream stream) throws IOException {
     stream.defaultWriteObject();
     stream.writeInt(keySet().size());
@@ -630,7 +617,7 @@ public final class LinkedHashMultimap<K extends @Nullable Object, V extends @Nul
     }
   }
 
-  @GwtIncompatible // java.io.ObjectInputStream
+  // java.io.ObjectInputStream
   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
     stream.defaultReadObject();
     multimapHeaderEntry = ValueEntry.newHeader();
@@ -658,6 +645,6 @@ public final class LinkedHashMultimap<K extends @Nullable Object, V extends @Nul
     setMap(map);
   }
 
-  @GwtIncompatible // java serialization not supported
+  // java serialization not supported
   private static final long serialVersionUID = 1;
 }
diff --git a/guava/src/com/google/common/collect/LinkedHashMultimapGwtSerializationDependencies.java b/guava/src/com/google/common/collect/LinkedHashMultimapGwtSerializationDependencies.java
index bb4a2e490e..994ff54a20 100644
--- a/guava/src/com/google/common/collect/LinkedHashMultimapGwtSerializationDependencies.java
+++ b/guava/src/com/google/common/collect/LinkedHashMultimapGwtSerializationDependencies.java
@@ -16,7 +16,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.Collection;
 import java.util.Map;
 
@@ -29,7 +28,6 @@ import java.util.Map;
  *
  * <p>TODO(cpovirk): Consider applying this subclass approach to our other types.
  */
-@GwtCompatible(emulated = true)
 abstract class LinkedHashMultimapGwtSerializationDependencies<K, V>
     extends AbstractSetMultimap<K, V> {
   LinkedHashMultimapGwtSerializationDependencies(Map<K, Collection<V>> map) {
diff --git a/guava/src/com/google/common/collect/LinkedHashMultiset.java b/guava/src/com/google/common/collect/LinkedHashMultiset.java
index 13f70a7c94..a9785271b5 100644
--- a/guava/src/com/google/common/collect/LinkedHashMultiset.java
+++ b/guava/src/com/google/common/collect/LinkedHashMultiset.java
@@ -16,13 +16,10 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.util.LinkedHashMap;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@code Multiset} implementation with predictable iteration order. Its iterator orders elements
@@ -39,13 +36,12 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Jared Levy
  * @since 2.0
  */
-@GwtCompatible(serializable = true, emulated = true)
 @ElementTypesAreNonnullByDefault
-public final class LinkedHashMultiset<E extends @Nullable Object>
+public final class LinkedHashMultiset<E extends Object>
     extends AbstractMapBasedMultiset<E> {
 
   /** Creates a new, empty {@code LinkedHashMultiset} using the default initial capacity. */
-  public static <E extends @Nullable Object> LinkedHashMultiset<E> create() {
+  public static <E extends Object> LinkedHashMultiset<E> create() {
     return new LinkedHashMultiset<E>();
   }
 
@@ -56,7 +52,7 @@ public final class LinkedHashMultiset<E extends @Nullable Object>
    * @param distinctElements the expected number of distinct elements
    * @throws IllegalArgumentException if {@code distinctElements} is negative
    */
-  public static <E extends @Nullable Object> LinkedHashMultiset<E> create(int distinctElements) {
+  public static <E extends Object> LinkedHashMultiset<E> create(int distinctElements) {
     return new LinkedHashMultiset<E>(distinctElements);
   }
 
@@ -67,7 +63,7 @@ public final class LinkedHashMultiset<E extends @Nullable Object>
    *
    * @param elements the elements that the multiset should contain
    */
-  public static <E extends @Nullable Object> LinkedHashMultiset<E> create(
+  public static <E extends Object> LinkedHashMultiset<E> create(
       Iterable<? extends E> elements) {
     LinkedHashMultiset<E> multiset = create(Multisets.inferDistinctElements(elements));
     Iterables.addAll(multiset, elements);
@@ -86,13 +82,13 @@ public final class LinkedHashMultiset<E extends @Nullable Object>
    * @serialData the number of distinct elements, the first element, its count, the second element,
    *     its count, and so on
    */
-  @GwtIncompatible // java.io.ObjectOutputStream
+  // java.io.ObjectOutputStream
   private void writeObject(ObjectOutputStream stream) throws IOException {
     stream.defaultWriteObject();
     Serialization.writeMultiset(this, stream);
   }
 
-  @GwtIncompatible // java.io.ObjectInputStream
+  // java.io.ObjectInputStream
   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
     stream.defaultReadObject();
     int distinctElements = Serialization.readCount(stream);
@@ -100,6 +96,6 @@ public final class LinkedHashMultiset<E extends @Nullable Object>
     Serialization.populateMultiset(this, stream, distinctElements);
   }
 
-  @GwtIncompatible // not needed in emulated source
+  // not needed in emulated source
   private static final long serialVersionUID = 0;
 }
diff --git a/guava/src/com/google/common/collect/LinkedListMultimap.java b/guava/src/com/google/common/collect/LinkedListMultimap.java
index a557870d42..44ce4260d4 100644
--- a/guava/src/com/google/common/collect/LinkedListMultimap.java
+++ b/guava/src/com/google/common/collect/LinkedListMultimap.java
@@ -22,10 +22,6 @@ import static com.google.common.base.Preconditions.checkState;
 import static java.util.Collections.unmodifiableList;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.j2objc.annotations.WeakOuter;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
@@ -42,7 +38,6 @@ import java.util.NoSuchElementException;
 import java.util.Set;
 import java.util.function.Consumer;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An implementation of {@code ListMultimap} that supports deterministic iteration order for both
@@ -96,9 +91,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Mike Bostock
  * @since 2.0
  */
-@GwtCompatible(serializable = true, emulated = true)
 @ElementTypesAreNonnullByDefault
-public class LinkedListMultimap<K extends @Nullable Object, V extends @Nullable Object>
+public class LinkedListMultimap<K extends Object, V extends Object>
     extends AbstractMultimap<K, V> implements ListMultimap<K, V>, Serializable {
   /*
    * Order is maintained using a linked list containing all key-value pairs. In
@@ -107,7 +101,7 @@ public class LinkedListMultimap<K extends @Nullable Object, V extends @Nullable
    * ValueForKeyIterator} in constant time.
    */
 
-  private static final class Node<K extends @Nullable Object, V extends @Nullable Object>
+  private static final class Node<K extends Object, V extends Object>
       extends AbstractMapEntry<K, V> {
     @ParametricNullness final K key;
     @ParametricNullness V value;
@@ -142,7 +136,7 @@ public class LinkedListMultimap<K extends @Nullable Object, V extends @Nullable
     }
   }
 
-  private static class KeyList<K extends @Nullable Object, V extends @Nullable Object> {
+  private static class KeyList<K extends Object, V extends Object> {
     Node<K, V> head;
     Node<K, V> tail;
     int count;
@@ -169,7 +163,7 @@ public class LinkedListMultimap<K extends @Nullable Object, V extends @Nullable
   private transient int modCount;
 
   /** Creates a new, empty {@code LinkedListMultimap} with the default initial capacity. */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       LinkedListMultimap<K, V> create() {
     return new LinkedListMultimap<>();
   }
@@ -181,7 +175,7 @@ public class LinkedListMultimap<K extends @Nullable Object, V extends @Nullable
    * @param expectedKeys the expected number of distinct keys
    * @throws IllegalArgumentException if {@code expectedKeys} is negative
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       LinkedListMultimap<K, V> create(int expectedKeys) {
     return new LinkedListMultimap<>(expectedKeys);
   }
@@ -193,7 +187,7 @@ public class LinkedListMultimap<K extends @Nullable Object, V extends @Nullable
    *
    * @param multimap the multimap whose contents are copied to this multimap
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       LinkedListMultimap<K, V> create(Multimap<? extends K, ? extends V> multimap) {
     return new LinkedListMultimap<>(multimap);
   }
@@ -216,7 +210,6 @@ public class LinkedListMultimap<K extends @Nullable Object, V extends @Nullable
    * element, or at the end of the list if {@code nextSibling} is null. Note: if {@code nextSibling}
    * is specified, it MUST be for an node for the same {@code key}!
    */
-  @CanIgnoreReturnValue
   private Node<K, V> addNode(
       @ParametricNullness K key,
       @ParametricNullness V value,
@@ -360,7 +353,6 @@ public class LinkedListMultimap<K extends @Nullable Object, V extends @Nullable
       return next != null;
     }
 
-    @CanIgnoreReturnValue
     @Override
     public Node<K, V> next() {
       checkForConcurrentModification();
@@ -394,7 +386,6 @@ public class LinkedListMultimap<K extends @Nullable Object, V extends @Nullable
       return previous != null;
     }
 
-    @CanIgnoreReturnValue
     @Override
     public Node<K, V> previous() {
       checkForConcurrentModification();
@@ -525,7 +516,6 @@ public class LinkedListMultimap<K extends @Nullable Object, V extends @Nullable
       return next != null;
     }
 
-    @CanIgnoreReturnValue
     @Override
     @ParametricNullness
     public V next() {
@@ -543,7 +533,6 @@ public class LinkedListMultimap<K extends @Nullable Object, V extends @Nullable
       return previous != null;
     }
 
-    @CanIgnoreReturnValue
     @Override
     @ParametricNullness
     public V previous() {
@@ -624,7 +613,6 @@ public class LinkedListMultimap<K extends @Nullable Object, V extends @Nullable
    * @param value value to store in the multimap
    * @return {@code true} always
    */
-  @CanIgnoreReturnValue
   @Override
   public boolean put(@ParametricNullness K key, @ParametricNullness V value) {
     addNode(key, value, null);
@@ -641,7 +629,6 @@ public class LinkedListMultimap<K extends @Nullable Object, V extends @Nullable
    *
    * <p>The returned list is immutable and implements {@link java.util.RandomAccess}.
    */
-  @CanIgnoreReturnValue
   @Override
   public List<V> replaceValues(@ParametricNullness K key, Iterable<? extends V> values) {
     List<V> oldValues = getCopy(key);
@@ -677,9 +664,8 @@ public class LinkedListMultimap<K extends @Nullable Object, V extends @Nullable
    *
    * <p>The returned list is immutable and implements {@link java.util.RandomAccess}.
    */
-  @CanIgnoreReturnValue
   @Override
-  public List<V> removeAll(@Nullable Object key) {
+  public List<V> removeAll(Object key) {
     /*
      * Safe because all we do is remove values for the key, not add them. (If we wanted to make sure
      * to call getCopy and removeAllNodes only with a true K, then we could check containsKey first.
@@ -730,7 +716,6 @@ public class LinkedListMultimap<K extends @Nullable Object, V extends @Nullable
 
   @Override
   Set<K> createKeySet() {
-    @WeakOuter
     class KeySetImpl extends Sets.ImprovedAbstractSet<K> {
       @Override
       public int size() {
@@ -775,7 +760,6 @@ public class LinkedListMultimap<K extends @Nullable Object, V extends @Nullable
 
   @Override
   List<V> createValues() {
-    @WeakOuter
     class ValuesImpl extends AbstractSequentialList<V> {
       @Override
       public int size() {
@@ -825,7 +809,6 @@ public class LinkedListMultimap<K extends @Nullable Object, V extends @Nullable
 
   @Override
   List<Entry<K, V>> createEntries() {
-    @WeakOuter
     class EntriesImpl extends AbstractSequentialList<Entry<K, V>> {
       @Override
       public int size() {
@@ -863,7 +846,7 @@ public class LinkedListMultimap<K extends @Nullable Object, V extends @Nullable
    *     number of values for that key, and the key's values, followed by successive keys and values
    *     from the entries() ordering
    */
-  @GwtIncompatible // java.io.ObjectOutputStream
+  // java.io.ObjectOutputStream
   private void writeObject(ObjectOutputStream stream) throws IOException {
     stream.defaultWriteObject();
     stream.writeInt(size());
@@ -873,7 +856,7 @@ public class LinkedListMultimap<K extends @Nullable Object, V extends @Nullable
     }
   }
 
-  @GwtIncompatible // java.io.ObjectInputStream
+  // java.io.ObjectInputStream
   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
     stream.defaultReadObject();
     keyToKeyList = Maps.newLinkedHashMap();
@@ -887,6 +870,6 @@ public class LinkedListMultimap<K extends @Nullable Object, V extends @Nullable
     }
   }
 
-  @GwtIncompatible // java serialization not supported
+  // java serialization not supported
   private static final long serialVersionUID = 0;
 }
diff --git a/guava/src/com/google/common/collect/ListMultimap.java b/guava/src/com/google/common/collect/ListMultimap.java
index 1686068409..117c3bcd27 100644
--- a/guava/src/com/google/common/collect/ListMultimap.java
+++ b/guava/src/com/google/common/collect/ListMultimap.java
@@ -16,13 +16,10 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Collection;
 import java.util.List;
 import java.util.Map;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@code Multimap} that can hold duplicate key-value pairs and that maintains the insertion
@@ -40,9 +37,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Jared Levy
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public interface ListMultimap<K extends @Nullable Object, V extends @Nullable Object>
+public interface ListMultimap<K extends Object, V extends Object>
     extends Multimap<K, V> {
   /**
    * {@inheritDoc}
@@ -61,7 +57,6 @@ public interface ListMultimap<K extends @Nullable Object, V extends @Nullable Ob
    * this method returns a {@link List}, instead of the {@link java.util.Collection} specified in
    * the {@link Multimap} interface.
    */
-  @CanIgnoreReturnValue
   @Override
   List<V> removeAll(@CheckForNull Object key);
 
@@ -72,7 +67,6 @@ public interface ListMultimap<K extends @Nullable Object, V extends @Nullable Ob
    * this method returns a {@link List}, instead of the {@link java.util.Collection} specified in
    * the {@link Multimap} interface.
    */
-  @CanIgnoreReturnValue
   @Override
   List<V> replaceValues(@ParametricNullness K key, Iterable<? extends V> values);
 
diff --git a/guava/src/com/google/common/collect/Lists.java b/guava/src/com/google/common/collect/Lists.java
index 31d6e2a4f3..aee563502d 100644
--- a/guava/src/com/google/common/collect/Lists.java
+++ b/guava/src/com/google/common/collect/Lists.java
@@ -25,10 +25,6 @@ import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 import static com.google.common.collect.CollectPreconditions.checkRemove;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Function;
 import com.google.common.base.Objects;
 import com.google.common.math.IntMath;
@@ -50,7 +46,6 @@ import java.util.RandomAccess;
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.function.Predicate;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to {@link List} instances. Also see this class's counterparts
@@ -64,7 +59,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 2.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class Lists {
   private Lists() {}
@@ -80,8 +74,7 @@ public final class Lists {
    * deprecated. Instead, use the {@code ArrayList} {@linkplain ArrayList#ArrayList() constructor}
    * directly, taking advantage of the new <a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.
    */
-  @GwtCompatible(serializable = true)
-  public static <E extends @Nullable Object> ArrayList<E> newArrayList() {
+  public static <E extends Object> ArrayList<E> newArrayList() {
     return new ArrayList<>();
   }
 
@@ -100,8 +93,7 @@ public final class Lists {
    * not actually very useful and will likely be deprecated in the future.
    */
   @SafeVarargs
-  @GwtCompatible(serializable = true)
-  public static <E extends @Nullable Object> ArrayList<E> newArrayList(E... elements) {
+  public static <E extends Object> ArrayList<E> newArrayList(E... elements) {
     checkNotNull(elements); // for GWT
     // Avoid integer overflow when a large array is passed in
     int capacity = computeArrayListCapacity(elements.length);
@@ -123,8 +115,7 @@ public final class Lists {
    * constructor} directly, taking advantage of the new <a href="http://goo.gl/iz2Wi">"diamond"
    * syntax</a>.
    */
-  @GwtCompatible(serializable = true)
-  public static <E extends @Nullable Object> ArrayList<E> newArrayList(
+  public static <E extends Object> ArrayList<E> newArrayList(
       Iterable<? extends E> elements) {
     checkNotNull(elements); // for GWT
     // Let ArrayList's sizing logic work, if possible
@@ -140,15 +131,13 @@ public final class Lists {
    * <p><b>Note:</b> if mutability is not required and the elements are non-null, use {@link
    * ImmutableList#copyOf(Iterator)} instead.
    */
-  @GwtCompatible(serializable = true)
-  public static <E extends @Nullable Object> ArrayList<E> newArrayList(
+  public static <E extends Object> ArrayList<E> newArrayList(
       Iterator<? extends E> elements) {
     ArrayList<E> list = newArrayList();
     Iterators.addAll(list, elements);
     return list;
   }
 
-  @VisibleForTesting
   static int computeArrayListCapacity(int arraySize) {
     checkNonnegative(arraySize, "arraySize");
 
@@ -172,8 +161,7 @@ public final class Lists {
    *     reaches {@code initialArraySize + 1}
    * @throws IllegalArgumentException if {@code initialArraySize} is negative
    */
-  @GwtCompatible(serializable = true)
-  public static <E extends @Nullable Object> ArrayList<E> newArrayListWithCapacity(
+  public static <E extends Object> ArrayList<E> newArrayListWithCapacity(
       int initialArraySize) {
     checkNonnegative(initialArraySize, "initialArraySize"); // for GWT.
     return new ArrayList<>(initialArraySize);
@@ -192,8 +180,7 @@ public final class Lists {
    *     elements
    * @throws IllegalArgumentException if {@code estimatedSize} is negative
    */
-  @GwtCompatible(serializable = true)
-  public static <E extends @Nullable Object> ArrayList<E> newArrayListWithExpectedSize(
+  public static <E extends Object> ArrayList<E> newArrayListWithExpectedSize(
       int estimatedSize) {
     return new ArrayList<>(computeArrayListCapacity(estimatedSize));
   }
@@ -215,8 +202,7 @@ public final class Lists {
    * constructor} directly, taking advantage of the new <a href="http://goo.gl/iz2Wi">"diamond"
    * syntax</a>.
    */
-  @GwtCompatible(serializable = true)
-  public static <E extends @Nullable Object> LinkedList<E> newLinkedList() {
+  public static <E extends Object> LinkedList<E> newLinkedList() {
     return new LinkedList<>();
   }
 
@@ -237,8 +223,7 @@ public final class Lists {
    * constructor} directly, taking advantage of the new <a href="http://goo.gl/iz2Wi">"diamond"
    * syntax</a>.
    */
-  @GwtCompatible(serializable = true)
-  public static <E extends @Nullable Object> LinkedList<E> newLinkedList(
+  public static <E extends Object> LinkedList<E> newLinkedList(
       Iterable<? extends E> elements) {
     LinkedList<E> list = newLinkedList();
     Iterables.addAll(list, elements);
@@ -254,8 +239,8 @@ public final class Lists {
    * @return a new, empty {@code CopyOnWriteArrayList}
    * @since 12.0
    */
-  @GwtIncompatible // CopyOnWriteArrayList
-  public static <E extends @Nullable Object> CopyOnWriteArrayList<E> newCopyOnWriteArrayList() {
+  // CopyOnWriteArrayList
+  public static <E extends Object> CopyOnWriteArrayList<E> newCopyOnWriteArrayList() {
     return new CopyOnWriteArrayList<>();
   }
 
@@ -266,8 +251,8 @@ public final class Lists {
    * @return a new {@code CopyOnWriteArrayList} containing those elements
    * @since 12.0
    */
-  @GwtIncompatible // CopyOnWriteArrayList
-  public static <E extends @Nullable Object> CopyOnWriteArrayList<E> newCopyOnWriteArrayList(
+  // CopyOnWriteArrayList
+  public static <E extends Object> CopyOnWriteArrayList<E> newCopyOnWriteArrayList(
       Iterable<? extends E> elements) {
     // We copy elements to an ArrayList first, rather than incurring the
     // quadratic cost of adding them to the COWAL directly.
@@ -292,7 +277,7 @@ public final class Lists {
    * @param rest an array of additional elements, possibly empty
    * @return an unmodifiable list containing the specified elements
    */
-  public static <E extends @Nullable Object> List<E> asList(@ParametricNullness E first, E[] rest) {
+  public static <E extends Object> List<E> asList(@ParametricNullness E first, E[] rest) {
     return new OnePlusArrayList<>(first, rest);
   }
 
@@ -312,13 +297,13 @@ public final class Lists {
    * @param rest an array of additional elements, possibly empty
    * @return an unmodifiable list containing the specified elements
    */
-  public static <E extends @Nullable Object> List<E> asList(
+  public static <E extends Object> List<E> asList(
       @ParametricNullness E first, @ParametricNullness E second, E[] rest) {
     return new TwoPlusArrayList<>(first, second, rest);
   }
 
   /** @see Lists#asList(Object, Object[]) */
-  private static class OnePlusArrayList<E extends @Nullable Object> extends AbstractList<E>
+  private static class OnePlusArrayList<E extends Object> extends AbstractList<E>
       implements Serializable, RandomAccess {
     @ParametricNullness final E first;
     final E[] rest;
@@ -345,7 +330,7 @@ public final class Lists {
   }
 
   /** @see Lists#asList(Object, Object, Object[]) */
-  private static class TwoPlusArrayList<E extends @Nullable Object> extends AbstractList<E>
+  private static class TwoPlusArrayList<E extends Object> extends AbstractList<E>
       implements Serializable, RandomAccess {
     @ParametricNullness final E first;
     @ParametricNullness final E second;
@@ -529,7 +514,7 @@ public final class Lists {
    * java.util.stream.Stream#map}. This method is not being deprecated, but we gently encourage you
    * to migrate to streams.
    */
-  public static <F extends @Nullable Object, T extends @Nullable Object> List<T> transform(
+  public static <F extends Object, T extends Object> List<T> transform(
       List<F> fromList, Function<? super F, ? extends T> function) {
     return (fromList instanceof RandomAccess)
         ? new TransformingRandomAccessList<>(fromList, function)
@@ -542,7 +527,7 @@ public final class Lists {
    * @see Lists#transform
    */
   private static class TransformingSequentialList<
-          F extends @Nullable Object, T extends @Nullable Object>
+          F extends Object, T extends Object>
       extends AbstractSequentialList<T> implements Serializable {
     final List<F> fromList;
     final Function<? super F, ? extends T> function;
@@ -594,7 +579,7 @@ public final class Lists {
    * @see Lists#transform
    */
   private static class TransformingRandomAccessList<
-          F extends @Nullable Object, T extends @Nullable Object>
+          F extends Object, T extends Object>
       extends AbstractList<T> implements RandomAccess, Serializable {
     final List<F> fromList;
     final Function<? super F, ? extends T> function;
@@ -670,7 +655,7 @@ public final class Lists {
    * @return a list of consecutive sublists
    * @throws IllegalArgumentException if {@code partitionSize} is nonpositive
    */
-  public static <T extends @Nullable Object> List<List<T>> partition(List<T> list, int size) {
+  public static <T extends Object> List<List<T>> partition(List<T> list, int size) {
     checkNotNull(list);
     checkArgument(size > 0);
     return (list instanceof RandomAccess)
@@ -678,7 +663,7 @@ public final class Lists {
         : new Partition<>(list, size);
   }
 
-  private static class Partition<T extends @Nullable Object> extends AbstractList<List<T>> {
+  private static class Partition<T extends Object> extends AbstractList<List<T>> {
     final List<T> list;
     final int size;
 
@@ -706,7 +691,7 @@ public final class Lists {
     }
   }
 
-  private static class RandomAccessPartition<T extends @Nullable Object> extends Partition<T>
+  private static class RandomAccessPartition<T extends Object> extends Partition<T>
       implements RandomAccess {
     RandomAccessPartition(List<T> list, int size) {
       super(list, size);
@@ -731,7 +716,6 @@ public final class Lists {
    * @return an {@code List<Character>} view of the character sequence
    * @since 7.0
    */
-  @Beta
   public static List<Character> charactersOf(CharSequence sequence) {
     return new CharSequenceAsList(checkNotNull(sequence));
   }
@@ -808,7 +792,7 @@ public final class Lists {
    *
    * @since 7.0
    */
-  public static <T extends @Nullable Object> List<T> reverse(List<T> list) {
+  public static <T extends Object> List<T> reverse(List<T> list) {
     if (list instanceof ImmutableList) {
       // Avoid nullness warnings.
       List<?> reversed = ((ImmutableList<?>) list).reverse();
@@ -824,7 +808,7 @@ public final class Lists {
     }
   }
 
-  private static class ReverseList<T extends @Nullable Object> extends AbstractList<T> {
+  private static class ReverseList<T extends Object> extends AbstractList<T> {
     private final List<T> forwardList;
 
     ReverseList(List<T> forwardList) {
@@ -967,7 +951,7 @@ public final class Lists {
     }
   }
 
-  private static class RandomAccessReverseList<T extends @Nullable Object> extends ReverseList<T>
+  private static class RandomAccessReverseList<T extends Object> extends ReverseList<T>
       implements RandomAccess {
     RandomAccessReverseList(List<T> forwardList) {
       super(forwardList);
@@ -1014,7 +998,7 @@ public final class Lists {
   }
 
   /** An implementation of {@link List#addAll(int, Collection)}. */
-  static <E extends @Nullable Object> boolean addAllImpl(
+  static <E extends Object> boolean addAllImpl(
       List<E> list, int index, Iterable<? extends E> elements) {
     boolean changed = false;
     ListIterator<E> listIterator = list.listIterator(index);
@@ -1091,12 +1075,12 @@ public final class Lists {
   }
 
   /** Returns an implementation of {@link List#listIterator(int)}. */
-  static <E extends @Nullable Object> ListIterator<E> listIteratorImpl(List<E> list, int index) {
+  static <E extends Object> ListIterator<E> listIteratorImpl(List<E> list, int index) {
     return new AbstractListWrapper<>(list).listIterator(index);
   }
 
   /** An implementation of {@link List#subList(int, int)}. */
-  static <E extends @Nullable Object> List<E> subListImpl(
+  static <E extends Object> List<E> subListImpl(
       final List<E> list, int fromIndex, int toIndex) {
     List<E> wrapper;
     if (list instanceof RandomAccess) {
@@ -1123,7 +1107,7 @@ public final class Lists {
     return wrapper.subList(fromIndex, toIndex);
   }
 
-  private static class AbstractListWrapper<E extends @Nullable Object> extends AbstractList<E> {
+  private static class AbstractListWrapper<E extends Object> extends AbstractList<E> {
     final List<E> backingList;
 
     AbstractListWrapper(List<E> backingList) {
@@ -1169,7 +1153,7 @@ public final class Lists {
     }
   }
 
-  private static class RandomAccessListWrapper<E extends @Nullable Object>
+  private static class RandomAccessListWrapper<E extends Object>
       extends AbstractListWrapper<E> implements RandomAccess {
     RandomAccessListWrapper(List<E> backingList) {
       super(backingList);
@@ -1177,7 +1161,7 @@ public final class Lists {
   }
 
   /** Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557 */
-  static <T extends @Nullable Object> List<T> cast(Iterable<T> iterable) {
+  static <T extends Object> List<T> cast(Iterable<T> iterable) {
     return (List<T>) iterable;
   }
 }
diff --git a/guava/src/com/google/common/collect/MapDifference.java b/guava/src/com/google/common/collect/MapDifference.java
index 5000e4b527..4df988a4e5 100644
--- a/guava/src/com/google/common/collect/MapDifference.java
+++ b/guava/src/com/google/common/collect/MapDifference.java
@@ -16,11 +16,8 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.DoNotMock;
 import java.util.Map;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An object representing the differences between two maps.
@@ -28,10 +25,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kevin Bourrillion
  * @since 2.0
  */
-@DoNotMock("Use Maps.difference")
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public interface MapDifference<K extends @Nullable Object, V extends @Nullable Object> {
+public interface MapDifference<K extends Object, V extends Object> {
   /**
    * Returns {@code true} if there are no differences between the two maps; that is, if the maps are
    * equal.
@@ -88,8 +83,7 @@ public interface MapDifference<K extends @Nullable Object, V extends @Nullable O
    *
    * @since 2.0
    */
-  @DoNotMock("Use Maps.difference")
-  interface ValueDifference<V extends @Nullable Object> {
+  interface ValueDifference<V extends Object> {
     /** Returns the value from the left map (possibly null). */
     @ParametricNullness
     V leftValue();
diff --git a/guava/src/com/google/common/collect/MapMaker.java b/guava/src/com/google/common/collect/MapMaker.java
index a2612c1bd2..842886d75f 100644
--- a/guava/src/com/google/common/collect/MapMaker.java
+++ b/guava/src/com/google/common/collect/MapMaker.java
@@ -18,13 +18,10 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Ascii;
 import com.google.common.base.Equivalence;
 import com.google.common.base.MoreObjects;
 import com.google.common.collect.MapMakerInternalMap.Strength;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.lang.ref.WeakReference;
 import java.util.ConcurrentModificationException;
 import java.util.Map;
@@ -85,7 +82,6 @@ import javax.annotation.CheckForNull;
  * @author Kevin Bourrillion
  * @since 2.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class MapMaker {
   private static final int DEFAULT_INITIAL_CAPACITY = 16;
@@ -117,8 +113,7 @@ public final class MapMaker {
    * #weakKeys} is specified, and {@link Equivalence#equals()} otherwise. The only place this is
    * used is in {@link Interners.WeakInterner}.
    */
-  @CanIgnoreReturnValue
-  @GwtIncompatible // To be supported
+  // To be supported
   MapMaker keyEquivalence(Equivalence<Object> equivalence) {
     checkState(keyEquivalence == null, "key equivalence was already set to %s", keyEquivalence);
     keyEquivalence = checkNotNull(equivalence);
@@ -140,7 +135,6 @@ public final class MapMaker {
    * @throws IllegalArgumentException if {@code initialCapacity} is negative
    * @throws IllegalStateException if an initial capacity was already set
    */
-  @CanIgnoreReturnValue
   public MapMaker initialCapacity(int initialCapacity) {
     checkState(
         this.initialCapacity == UNSET_INT,
@@ -174,7 +168,6 @@ public final class MapMaker {
    * @throws IllegalArgumentException if {@code concurrencyLevel} is nonpositive
    * @throws IllegalStateException if a concurrency level was already set
    */
-  @CanIgnoreReturnValue
   public MapMaker concurrencyLevel(int concurrencyLevel) {
     checkState(
         this.concurrencyLevel == UNSET_INT,
@@ -200,8 +193,7 @@ public final class MapMaker {
    * @throws IllegalStateException if the key strength was already set
    * @see WeakReference
    */
-  @CanIgnoreReturnValue
-  @GwtIncompatible // java.lang.ref.WeakReference
+  // java.lang.ref.WeakReference
   public MapMaker weakKeys() {
     return setKeyStrength(Strength.WEAK);
   }
@@ -236,8 +228,7 @@ public final class MapMaker {
    * @throws IllegalStateException if the value strength was already set
    * @see WeakReference
    */
-  @CanIgnoreReturnValue
-  @GwtIncompatible // java.lang.ref.WeakReference
+  // java.lang.ref.WeakReference
   public MapMaker weakValues() {
     return setValueStrength(Strength.WEAK);
   }
diff --git a/guava/src/com/google/common/collect/MapMakerInternalMap.java b/guava/src/com/google/common/collect/MapMakerInternalMap.java
index 3725d9723b..b972e97b1a 100644
--- a/guava/src/com/google/common/collect/MapMakerInternalMap.java
+++ b/guava/src/com/google/common/collect/MapMakerInternalMap.java
@@ -17,15 +17,9 @@ package com.google.common.collect;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkRemove;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Equivalence;
 import com.google.common.collect.MapMaker.Dummy;
 import com.google.common.primitives.Ints;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.concurrent.GuardedBy;
-import com.google.j2objc.annotations.Weak;
-import com.google.j2objc.annotations.WeakOuter;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
@@ -47,7 +41,6 @@ import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReferenceArray;
 import java.util.concurrent.locks.ReentrantLock;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * The concurrent hash map implementation built by {@link MapMaker}.
@@ -64,7 +57,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Doug Lea ({@code ConcurrentHashMap})
  */
 // TODO(kak): Consider removing @CanIgnoreReturnValue from this class.
-@GwtIncompatible
 @SuppressWarnings({
   "GuardedBy", // TODO(b/35466881): Fix or suppress.
   "nullness", // too much trouble for the payoff
@@ -295,13 +287,13 @@ class MapMakerInternalMap<
     /**
      * Returns a freshly created entry, typed at the {@code E} type, for the given {@code segment}.
      */
-    E newEntry(S segment, K key, int hash, @Nullable E next);
+    E newEntry(S segment, K key, int hash, E next);
 
     /**
      * Returns a freshly created entry, typed at the {@code E} type, for the given {@code segment},
      * that is a copy of the given {@code entry}.
      */
-    E copy(S segment, E entry, @Nullable E newNext);
+    E copy(S segment, E entry, E newNext);
 
     /**
      * Sets the value of the given {@code entry} in the given {@code segment} to be the given {@code
@@ -343,9 +335,9 @@ class MapMakerInternalMap<
       implements InternalEntry<K, V, E> {
     final K key;
     final int hash;
-    final @Nullable E next;
+    final E next;
 
-    AbstractStrongKeyEntry(K key, int hash, @Nullable E next) {
+    AbstractStrongKeyEntry(K key, int hash, E next) {
       this.key = key;
       this.hash = hash;
       this.next = next;
@@ -393,14 +385,14 @@ class MapMakerInternalMap<
   static final class StrongKeyStrongValueEntry<K, V>
       extends AbstractStrongKeyEntry<K, V, StrongKeyStrongValueEntry<K, V>>
       implements StrongValueEntry<K, V, StrongKeyStrongValueEntry<K, V>> {
-    private volatile @Nullable V value = null;
+    private volatile V value = null;
 
-    StrongKeyStrongValueEntry(K key, int hash, @Nullable StrongKeyStrongValueEntry<K, V> next) {
+    StrongKeyStrongValueEntry(K key, int hash, StrongKeyStrongValueEntry<K, V> next) {
       super(key, hash, next);
     }
 
     @Override
-    public @Nullable V getValue() {
+    public V getValue() {
       return value;
     }
 
@@ -450,7 +442,7 @@ class MapMakerInternalMap<
       public StrongKeyStrongValueEntry<K, V> copy(
           StrongKeyStrongValueSegment<K, V> segment,
           StrongKeyStrongValueEntry<K, V> entry,
-          @Nullable StrongKeyStrongValueEntry<K, V> newNext) {
+          StrongKeyStrongValueEntry<K, V> newNext) {
         return entry.copy(newNext);
       }
 
@@ -467,7 +459,7 @@ class MapMakerInternalMap<
           StrongKeyStrongValueSegment<K, V> segment,
           K key,
           int hash,
-          @Nullable StrongKeyStrongValueEntry<K, V> next) {
+          StrongKeyStrongValueEntry<K, V> next) {
         return new StrongKeyStrongValueEntry<>(key, hash, next);
       }
     }
@@ -480,7 +472,7 @@ class MapMakerInternalMap<
     private volatile WeakValueReference<K, V, StrongKeyWeakValueEntry<K, V>> valueReference =
         unsetWeakValueReference();
 
-    StrongKeyWeakValueEntry(K key, int hash, @Nullable StrongKeyWeakValueEntry<K, V> next) {
+    StrongKeyWeakValueEntry(K key, int hash, StrongKeyWeakValueEntry<K, V> next) {
       super(key, hash, next);
     }
 
@@ -546,7 +538,7 @@ class MapMakerInternalMap<
       public StrongKeyWeakValueEntry<K, V> copy(
           StrongKeyWeakValueSegment<K, V> segment,
           StrongKeyWeakValueEntry<K, V> entry,
-          @Nullable StrongKeyWeakValueEntry<K, V> newNext) {
+          StrongKeyWeakValueEntry<K, V> newNext) {
         if (Segment.isCollected(entry)) {
           return null;
         }
@@ -564,7 +556,7 @@ class MapMakerInternalMap<
           StrongKeyWeakValueSegment<K, V> segment,
           K key,
           int hash,
-          @Nullable StrongKeyWeakValueEntry<K, V> next) {
+          StrongKeyWeakValueEntry<K, V> next) {
         return new StrongKeyWeakValueEntry<>(key, hash, next);
       }
     }
@@ -574,7 +566,7 @@ class MapMakerInternalMap<
   static final class StrongKeyDummyValueEntry<K>
       extends AbstractStrongKeyEntry<K, Dummy, StrongKeyDummyValueEntry<K>>
       implements StrongValueEntry<K, Dummy, StrongKeyDummyValueEntry<K>> {
-    StrongKeyDummyValueEntry(K key, int hash, @Nullable StrongKeyDummyValueEntry<K> next) {
+    StrongKeyDummyValueEntry(K key, int hash, StrongKeyDummyValueEntry<K> next) {
       super(key, hash, next);
     }
 
@@ -626,7 +618,7 @@ class MapMakerInternalMap<
       public StrongKeyDummyValueEntry<K> copy(
           StrongKeyDummyValueSegment<K> segment,
           StrongKeyDummyValueEntry<K> entry,
-          @Nullable StrongKeyDummyValueEntry<K> newNext) {
+          StrongKeyDummyValueEntry<K> newNext) {
         return entry.copy(newNext);
       }
 
@@ -639,7 +631,7 @@ class MapMakerInternalMap<
           StrongKeyDummyValueSegment<K> segment,
           K key,
           int hash,
-          @Nullable StrongKeyDummyValueEntry<K> next) {
+          StrongKeyDummyValueEntry<K> next) {
         return new StrongKeyDummyValueEntry<K>(key, hash, next);
       }
     }
@@ -649,9 +641,9 @@ class MapMakerInternalMap<
   abstract static class AbstractWeakKeyEntry<K, V, E extends InternalEntry<K, V, E>>
       extends WeakReference<K> implements InternalEntry<K, V, E> {
     final int hash;
-    final @Nullable E next;
+    final E next;
 
-    AbstractWeakKeyEntry(ReferenceQueue<K> queue, K key, int hash, @Nullable E next) {
+    AbstractWeakKeyEntry(ReferenceQueue<K> queue, K key, int hash, E next) {
       super(key, queue);
       this.hash = hash;
       this.next = next;
@@ -678,7 +670,7 @@ class MapMakerInternalMap<
       extends AbstractWeakKeyEntry<K, Dummy, WeakKeyDummyValueEntry<K>>
       implements StrongValueEntry<K, Dummy, WeakKeyDummyValueEntry<K>> {
     WeakKeyDummyValueEntry(
-        ReferenceQueue<K> queue, K key, int hash, @Nullable WeakKeyDummyValueEntry<K> next) {
+        ReferenceQueue<K> queue, K key, int hash, WeakKeyDummyValueEntry<K> next) {
       super(queue, key, hash, next);
     }
 
@@ -730,7 +722,7 @@ class MapMakerInternalMap<
       public WeakKeyDummyValueEntry<K> copy(
           WeakKeyDummyValueSegment<K> segment,
           WeakKeyDummyValueEntry<K> entry,
-          @Nullable WeakKeyDummyValueEntry<K> newNext) {
+          WeakKeyDummyValueEntry<K> newNext) {
         if (entry.getKey() == null) {
           // key collected
           return null;
@@ -747,7 +739,7 @@ class MapMakerInternalMap<
           WeakKeyDummyValueSegment<K> segment,
           K key,
           int hash,
-          @Nullable WeakKeyDummyValueEntry<K> next) {
+          WeakKeyDummyValueEntry<K> next) {
         return new WeakKeyDummyValueEntry<K>(segment.queueForKeys, key, hash, next);
       }
     }
@@ -757,15 +749,15 @@ class MapMakerInternalMap<
   static final class WeakKeyStrongValueEntry<K, V>
       extends AbstractWeakKeyEntry<K, V, WeakKeyStrongValueEntry<K, V>>
       implements StrongValueEntry<K, V, WeakKeyStrongValueEntry<K, V>> {
-    private volatile @Nullable V value = null;
+    private volatile V value = null;
 
     WeakKeyStrongValueEntry(
-        ReferenceQueue<K> queue, K key, int hash, @Nullable WeakKeyStrongValueEntry<K, V> next) {
+        ReferenceQueue<K> queue, K key, int hash, WeakKeyStrongValueEntry<K, V> next) {
       super(queue, key, hash, next);
     }
 
     @Override
-    public @Nullable V getValue() {
+    public V getValue() {
       return value;
     }
 
@@ -815,7 +807,7 @@ class MapMakerInternalMap<
       public WeakKeyStrongValueEntry<K, V> copy(
           WeakKeyStrongValueSegment<K, V> segment,
           WeakKeyStrongValueEntry<K, V> entry,
-          @Nullable WeakKeyStrongValueEntry<K, V> newNext) {
+          WeakKeyStrongValueEntry<K, V> newNext) {
         if (entry.getKey() == null) {
           // key collected
           return null;
@@ -834,7 +826,7 @@ class MapMakerInternalMap<
           WeakKeyStrongValueSegment<K, V> segment,
           K key,
           int hash,
-          @Nullable WeakKeyStrongValueEntry<K, V> next) {
+          WeakKeyStrongValueEntry<K, V> next) {
         return new WeakKeyStrongValueEntry<>(segment.queueForKeys, key, hash, next);
       }
     }
@@ -848,7 +840,7 @@ class MapMakerInternalMap<
         unsetWeakValueReference();
 
     WeakKeyWeakValueEntry(
-        ReferenceQueue<K> queue, K key, int hash, @Nullable WeakKeyWeakValueEntry<K, V> next) {
+        ReferenceQueue<K> queue, K key, int hash, WeakKeyWeakValueEntry<K, V> next) {
       super(queue, key, hash, next);
     }
 
@@ -916,7 +908,7 @@ class MapMakerInternalMap<
       public WeakKeyWeakValueEntry<K, V> copy(
           WeakKeyWeakValueSegment<K, V> segment,
           WeakKeyWeakValueEntry<K, V> entry,
-          @Nullable WeakKeyWeakValueEntry<K, V> newNext) {
+          WeakKeyWeakValueEntry<K, V> newNext) {
         if (entry.getKey() == null) {
           // key collected
           return null;
@@ -938,7 +930,7 @@ class MapMakerInternalMap<
           WeakKeyWeakValueSegment<K, V> segment,
           K key,
           int hash,
-          @Nullable WeakKeyWeakValueEntry<K, V> next) {
+          WeakKeyWeakValueEntry<K, V> next) {
         return new WeakKeyWeakValueEntry<>(segment.queueForKeys, key, hash, next);
       }
     }
@@ -950,7 +942,6 @@ class MapMakerInternalMap<
      * Returns the current value being referenced, or {@code null} if there is none (e.g. because
      * either it got collected, or {@link #clear} was called, or it wasn't set in the first place).
      */
-    @Nullable
     V get();
 
     /** Returns the entry which contains this {@link WeakValueReference}. */
@@ -1026,7 +1017,7 @@ class MapMakerInternalMap<
   /** Concrete implementation of {@link WeakValueReference}. */
   static final class WeakValueReferenceImpl<K, V, E extends InternalEntry<K, V, E>>
       extends WeakReference<V> implements WeakValueReference<K, V, E> {
-    @Weak final E entry;
+    final E entry;
 
     WeakValueReferenceImpl(ReferenceQueue<V> queue, V referent, E entry) {
       super(referent, queue);
@@ -1068,7 +1059,6 @@ class MapMakerInternalMap<
    * This method is a convenience for testing. Code should call {@link Segment#copyEntry} directly.
    */
   // Guarded By Segment.this
-  @VisibleForTesting
   E copyEntry(E original, E newNext) {
     int hash = original.getHash();
     return segmentFor(hash).copyEntry(original, newNext);
@@ -1094,7 +1084,6 @@ class MapMakerInternalMap<
    * This method is a convenience for testing. Code should call {@link Segment#getLiveValue}
    * instead.
    */
-  @VisibleForTesting
   boolean isLiveForTesting(InternalEntry<K, V, ?> entry) {
     return segmentFor(entry.getHash()).getLiveValueForTesting(entry) != null;
   }
@@ -1169,7 +1158,7 @@ class MapMakerInternalMap<
      * comments.
      */
 
-    @Weak final MapMakerInternalMap<K, V, E, S> map;
+    final MapMakerInternalMap<K, V, E, S> map;
 
     /**
      * The number of live elements in this segment's region. This does not include unset elements
@@ -1192,7 +1181,7 @@ class MapMakerInternalMap<
     int threshold;
 
     /** The per-segment table. */
-    volatile @Nullable AtomicReferenceArray<E> table;
+    volatile AtomicReferenceArray<E> table;
 
     /** The maximum size of this map. MapMaker.UNSET_INT if there is no maximum. */
     final int maxSegmentSize;
@@ -1218,7 +1207,6 @@ class MapMakerInternalMap<
     abstract S self();
 
     /** Drains the reference queues used by this segment, if any. */
-    @GuardedBy("this")
     void maybeDrainReferenceQueues() {}
 
     /** Clears the reference queues used by this segment, if any. */
@@ -1300,7 +1288,7 @@ class MapMakerInternalMap<
     }
 
     /** Unsafely returns a copy of the given entry. */
-    E copyForTesting(InternalEntry<K, V, ?> entry, @Nullable InternalEntry<K, V, ?> newNext) {
+    E copyForTesting(InternalEntry<K, V, ?> entry, InternalEntry<K, V, ?> newNext) {
       return this.map.entryHelper.copy(self(), castForTesting(entry), castForTesting(newNext));
     }
 
@@ -1310,12 +1298,11 @@ class MapMakerInternalMap<
     }
 
     /** Unsafely returns a fresh entry. */
-    E newEntryForTesting(K key, int hash, @Nullable InternalEntry<K, V, ?> next) {
+    E newEntryForTesting(K key, int hash, InternalEntry<K, V, ?> next) {
       return this.map.entryHelper.newEntry(self(), key, hash, castForTesting(next));
     }
 
     /** Unsafely removes the given entry from this segment's hash table. */
-    @CanIgnoreReturnValue
     boolean removeTableEntryForTesting(InternalEntry<K, V, ?> entry) {
       return removeEntryForTesting(castForTesting(entry));
     }
@@ -1328,7 +1315,6 @@ class MapMakerInternalMap<
     /**
      * Unsafely returns the value of the given entry if it's still live, or {@code null} otherwise.
      */
-    @Nullable
     V getLiveValueForTesting(InternalEntry<K, V, ?> entry) {
       return getLiveValue(castForTesting(entry));
     }
@@ -1346,7 +1332,6 @@ class MapMakerInternalMap<
       }
     }
 
-    @GuardedBy("this")
     void drainKeyReferenceQueue(ReferenceQueue<K> keyReferenceQueue) {
       Reference<? extends K> ref;
       int i = 0;
@@ -1360,7 +1345,6 @@ class MapMakerInternalMap<
       }
     }
 
-    @GuardedBy("this")
     void drainValueReferenceQueue(ReferenceQueue<V> valueReferenceQueue) {
       Reference<? extends V> ref;
       int i = 0;
@@ -1447,7 +1431,6 @@ class MapMakerInternalMap<
      * This method is a convenience for testing. Code should call {@link
      * MapMakerInternalMap#containsValue} directly.
      */
-    @VisibleForTesting
     boolean containsValue(Object value) {
       try {
         if (count != 0) { // read-volatile
@@ -1530,7 +1513,6 @@ class MapMakerInternalMap<
     }
 
     /** Expands the table if possible. */
-    @GuardedBy("this")
     void expand() {
       AtomicReferenceArray<E> oldTable = table;
       int oldCapacity = oldTable.length();
@@ -1686,7 +1668,6 @@ class MapMakerInternalMap<
       }
     }
 
-    @CanIgnoreReturnValue
     V remove(Object key, int hash) {
       lock();
       try {
@@ -1799,7 +1780,6 @@ class MapMakerInternalMap<
      * @param entry the entry being removed from the table
      * @return the new first entry for the table
      */
-    @GuardedBy("this")
     E removeFromChain(E first, E entry) {
       int newCount = count;
       E newFirst = entry.getNext();
@@ -1816,7 +1796,6 @@ class MapMakerInternalMap<
     }
 
     /** Removes an entry whose key has been garbage collected. */
-    @CanIgnoreReturnValue
     boolean reclaimKey(E entry, int hash) {
       lock();
       try {
@@ -1843,7 +1822,6 @@ class MapMakerInternalMap<
     }
 
     /** Removes an entry whose value has been garbage collected. */
-    @CanIgnoreReturnValue
     boolean reclaimValue(K key, int hash, WeakValueReference<K, V, E> valueReference) {
       lock();
       try {
@@ -1877,7 +1855,6 @@ class MapMakerInternalMap<
     }
 
     /** Clears a value that has not yet been set, and thus does not require count to be modified. */
-    @CanIgnoreReturnValue
     boolean clearValueForTesting(
         K key,
         int hash,
@@ -1909,7 +1886,6 @@ class MapMakerInternalMap<
       }
     }
 
-    @GuardedBy("this")
     boolean removeEntryForTesting(E entry) {
       int hash = entry.getHash();
       int newCount = this.count - 1;
@@ -1943,7 +1919,6 @@ class MapMakerInternalMap<
      * Gets the value from an entry. Returns {@code null} if the entry is invalid or
      * partially-collected.
      */
-    @Nullable
     V getLiveValue(E entry) {
       if (entry.getKey() == null) {
         tryDrainReferenceQueues();
@@ -1973,7 +1948,6 @@ class MapMakerInternalMap<
      * Performs routine cleanup prior to executing a write. This should be called every time a write
      * thread acquires the segment lock, immediately after acquiring the lock.
      */
-    @GuardedBy("this")
     void preWriteCleanup() {
       runLockedCleanup();
     }
@@ -2276,17 +2250,14 @@ class MapMakerInternalMap<
     }
   }
 
-  @VisibleForTesting
   Strength keyStrength() {
     return entryHelper.keyStrength();
   }
 
-  @VisibleForTesting
   Strength valueStrength() {
     return entryHelper.valueStrength();
   }
 
-  @VisibleForTesting
   Equivalence<Object> valueEquivalence() {
     return entryHelper.valueStrength().defaultEquivalence();
   }
@@ -2334,7 +2305,7 @@ class MapMakerInternalMap<
   }
 
   @Override
-  public V get(@Nullable Object key) {
+  public V get(Object key) {
     if (key == null) {
       return null;
     }
@@ -2346,7 +2317,7 @@ class MapMakerInternalMap<
    * Returns the internal entry for the specified key. The entry may be computing or partially
    * collected. Does not impact recency ordering.
    */
-  E getEntry(@Nullable Object key) {
+  E getEntry(Object key) {
     if (key == null) {
       return null;
     }
@@ -2355,7 +2326,7 @@ class MapMakerInternalMap<
   }
 
   @Override
-  public boolean containsKey(@Nullable Object key) {
+  public boolean containsKey(Object key) {
     if (key == null) {
       return false;
     }
@@ -2364,7 +2335,7 @@ class MapMakerInternalMap<
   }
 
   @Override
-  public boolean containsValue(@Nullable Object value) {
+  public boolean containsValue(Object value) {
     if (value == null) {
       return false;
     }
@@ -2401,7 +2372,6 @@ class MapMakerInternalMap<
     return false;
   }
 
-  @CanIgnoreReturnValue
   @Override
   public V put(K key, V value) {
     checkNotNull(key);
@@ -2410,7 +2380,6 @@ class MapMakerInternalMap<
     return segmentFor(hash).put(key, hash, value, false);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public V putIfAbsent(K key, V value) {
     checkNotNull(key);
@@ -2426,9 +2395,8 @@ class MapMakerInternalMap<
     }
   }
 
-  @CanIgnoreReturnValue
   @Override
-  public V remove(@Nullable Object key) {
+  public V remove(Object key) {
     if (key == null) {
       return null;
     }
@@ -2436,9 +2404,8 @@ class MapMakerInternalMap<
     return segmentFor(hash).remove(key, hash);
   }
 
-  @CanIgnoreReturnValue
   @Override
-  public boolean remove(@Nullable Object key, @Nullable Object value) {
+  public boolean remove(Object key, Object value) {
     if (key == null || value == null) {
       return false;
     }
@@ -2446,9 +2413,8 @@ class MapMakerInternalMap<
     return segmentFor(hash).remove(key, hash, value);
   }
 
-  @CanIgnoreReturnValue
   @Override
-  public boolean replace(K key, @Nullable V oldValue, V newValue) {
+  public boolean replace(K key, V oldValue, V newValue) {
     checkNotNull(key);
     checkNotNull(newValue);
     if (oldValue == null) {
@@ -2458,7 +2424,6 @@ class MapMakerInternalMap<
     return segmentFor(hash).replace(key, hash, oldValue, newValue);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public V replace(K key, V value) {
     checkNotNull(key);
@@ -2474,7 +2439,7 @@ class MapMakerInternalMap<
     }
   }
 
-  transient @Nullable Set<K> keySet;
+  transient Set<K> keySet;
 
   @Override
   public Set<K> keySet() {
@@ -2482,7 +2447,7 @@ class MapMakerInternalMap<
     return (ks != null) ? ks : (keySet = new KeySet());
   }
 
-  transient @Nullable Collection<V> values;
+  transient Collection<V> values;
 
   @Override
   public Collection<V> values() {
@@ -2490,7 +2455,7 @@ class MapMakerInternalMap<
     return (vs != null) ? vs : (values = new Values());
   }
 
-  transient @Nullable Set<Entry<K, V>> entrySet;
+  transient Set<Entry<K, V>> entrySet;
 
   @Override
   public Set<Entry<K, V>> entrySet() {
@@ -2504,11 +2469,11 @@ class MapMakerInternalMap<
 
     int nextSegmentIndex;
     int nextTableIndex;
-    @Nullable Segment<K, V, E, S> currentSegment;
-    @Nullable AtomicReferenceArray<E> currentTable;
-    @Nullable E nextEntry;
-    @Nullable WriteThroughEntry nextExternal;
-    @Nullable WriteThroughEntry lastReturned;
+    Segment<K, V, E, S> currentSegment;
+    AtomicReferenceArray<E> currentTable;
+    E nextEntry;
+    WriteThroughEntry nextExternal;
+    WriteThroughEntry lastReturned;
 
     HashIterator() {
       nextSegmentIndex = segments.length - 1;
@@ -2648,7 +2613,7 @@ class MapMakerInternalMap<
     }
 
     @Override
-    public boolean equals(@Nullable Object object) {
+    public boolean equals(Object object) {
       // Cannot use key and value equivalence
       if (object instanceof Entry) {
         Entry<?, ?> that = (Entry<?, ?>) object;
@@ -2679,7 +2644,6 @@ class MapMakerInternalMap<
     }
   }
 
-  @WeakOuter
   final class KeySet extends SafeToArraySet<K> {
 
     @Override
@@ -2713,7 +2677,6 @@ class MapMakerInternalMap<
     }
   }
 
-  @WeakOuter
   final class Values extends AbstractCollection<V> {
 
     @Override
@@ -2755,7 +2718,6 @@ class MapMakerInternalMap<
     }
   }
 
-  @WeakOuter
   final class EntrySet extends SafeToArraySet<Entry<K, V>> {
 
     @Override
diff --git a/guava/src/com/google/common/collect/Maps.java b/guava/src/com/google/common/collect/Maps.java
index c892557f33..4b244892b1 100644
--- a/guava/src/com/google/common/collect/Maps.java
+++ b/guava/src/com/google/common/collect/Maps.java
@@ -24,9 +24,6 @@ import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Converter;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Function;
@@ -36,10 +33,6 @@ import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
 import com.google.common.collect.MapDifference.ValueDifference;
 import com.google.common.primitives.Ints;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.j2objc.annotations.RetainedWith;
-import com.google.j2objc.annotations.Weak;
-import com.google.j2objc.annotations.WeakOuter;
 import java.io.Serializable;
 import java.util.AbstractCollection;
 import java.util.AbstractMap;
@@ -71,7 +64,6 @@ import java.util.function.BinaryOperator;
 import java.util.function.Consumer;
 import java.util.stream.Collector;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to {@link Map} instances (including instances of {@link
@@ -87,12 +79,11 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 2.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class Maps {
   private Maps() {}
 
-  private enum EntryFunction implements Function<Entry<?, ?>, @Nullable Object> {
+  private enum EntryFunction implements Function<Entry<?, ?>, Object> {
     KEY {
       @Override
       @CheckForNull
@@ -110,16 +101,16 @@ public final class Maps {
   }
 
   @SuppressWarnings("unchecked")
-  static <K extends @Nullable Object> Function<Entry<K, ?>, K> keyFunction() {
+  static <K extends Object> Function<Entry<K, ?>, K> keyFunction() {
     return (Function) EntryFunction.KEY;
   }
 
   @SuppressWarnings("unchecked")
-  static <V extends @Nullable Object> Function<Entry<?, V>, V> valueFunction() {
+  static <V extends Object> Function<Entry<?, V>, V> valueFunction() {
     return (Function) EntryFunction.VALUE;
   }
 
-  static <K extends @Nullable Object, V extends @Nullable Object> Iterator<K> keyIterator(
+  static <K extends Object, V extends Object> Iterator<K> keyIterator(
       Iterator<Entry<K, V>> entryIterator) {
     return new TransformedIterator<Entry<K, V>, K>(entryIterator) {
       @Override
@@ -130,7 +121,7 @@ public final class Maps {
     };
   }
 
-  static <K extends @Nullable Object, V extends @Nullable Object> Iterator<V> valueIterator(
+  static <K extends Object, V extends Object> Iterator<V> valueIterator(
       Iterator<Entry<K, V>> entryIterator) {
     return new TransformedIterator<Entry<K, V>, V>(entryIterator) {
       @Override
@@ -152,7 +143,6 @@ public final class Maps {
    * @return an immutable map containing those entries
    * @since 14.0
    */
-  @GwtCompatible(serializable = true)
   public static <K extends Enum<K>, V> ImmutableMap<K, V> immutableEnumMap(
       Map<K, ? extends V> map) {
     if (map instanceof ImmutableEnumMap) {
@@ -195,7 +185,7 @@ public final class Maps {
    *
    * @since 21.0
    */
-  public static <T extends @Nullable Object, K extends Enum<K>, V>
+  public static <T extends Object, K extends Enum<K>, V>
       Collector<T, ?, ImmutableMap<K, V>> toImmutableEnumMap(
           java.util.function.Function<? super T, ? extends K> keyFunction,
           java.util.function.Function<? super T, ? extends V> valueFunction) {
@@ -213,7 +203,7 @@ public final class Maps {
    *
    * @since 21.0
    */
-  public static <T extends @Nullable Object, K extends Enum<K>, V>
+  public static <T extends Object, K extends Enum<K>, V>
       Collector<T, ?, ImmutableMap<K, V>> toImmutableEnumMap(
           java.util.function.Function<? super T, ? extends K> keyFunction,
           java.util.function.Function<? super T, ? extends V> valueFunction,
@@ -234,7 +224,7 @@ public final class Maps {
    *
    * @return a new, empty {@code HashMap}
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       HashMap<K, V> newHashMap() {
     return new HashMap<>();
   }
@@ -253,7 +243,7 @@ public final class Maps {
    * @param map the mappings to be placed in the new map
    * @return a new {@code HashMap} initialized with the mappings from {@code map}
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object> HashMap<K, V> newHashMap(
+  public static <K extends Object, V extends Object> HashMap<K, V> newHashMap(
       Map<? extends K, ? extends V> map) {
     return new HashMap<>(map);
   }
@@ -269,7 +259,7 @@ public final class Maps {
    *     without resizing
    * @throws IllegalArgumentException if {@code expectedSize} is negative
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       HashMap<K, V> newHashMapWithExpectedSize(int expectedSize) {
     return new HashMap<>(capacity(expectedSize));
   }
@@ -303,7 +293,7 @@ public final class Maps {
    *
    * @return a new, empty {@code LinkedHashMap}
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       LinkedHashMap<K, V> newLinkedHashMap() {
     return new LinkedHashMap<>();
   }
@@ -321,7 +311,7 @@ public final class Maps {
    * @param map the mappings to be placed in the new map
    * @return a new, {@code LinkedHashMap} initialized with the mappings from {@code map}
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       LinkedHashMap<K, V> newLinkedHashMap(Map<? extends K, ? extends V> map) {
     return new LinkedHashMap<>(map);
   }
@@ -338,7 +328,7 @@ public final class Maps {
    * @throws IllegalArgumentException if {@code expectedSize} is negative
    * @since 19.0
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       LinkedHashMap<K, V> newLinkedHashMapWithExpectedSize(int expectedSize) {
     return new LinkedHashMap<>(capacity(expectedSize));
   }
@@ -364,7 +354,7 @@ public final class Maps {
    *
    * @return a new, empty {@code TreeMap}
    */
-  public static <K extends Comparable, V extends @Nullable Object> TreeMap<K, V> newTreeMap() {
+  public static <K extends Comparable, V extends Object> TreeMap<K, V> newTreeMap() {
     return new TreeMap<>();
   }
 
@@ -384,7 +374,7 @@ public final class Maps {
    * @return a new {@code TreeMap} initialized with the mappings from {@code map} and using the
    *     comparator of {@code map}
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object> TreeMap<K, V> newTreeMap(
+  public static <K extends Object, V extends Object> TreeMap<K, V> newTreeMap(
       SortedMap<K, ? extends V> map) {
     return new TreeMap<>(map);
   }
@@ -402,7 +392,7 @@ public final class Maps {
    * @param comparator the comparator to sort the keys with
    * @return a new, empty {@code TreeMap}
    */
-  public static <C extends @Nullable Object, K extends C, V extends @Nullable Object>
+  public static <C extends Object, K extends C, V extends Object>
       TreeMap<K, V> newTreeMap(@CheckForNull Comparator<C> comparator) {
     // Ideally, the extra type parameter "C" shouldn't be necessary. It is a
     // work-around of a compiler type inference quirk that prevents the
@@ -418,7 +408,7 @@ public final class Maps {
    * @param type the key type for this map
    * @return a new, empty {@code EnumMap}
    */
-  public static <K extends Enum<K>, V extends @Nullable Object> EnumMap<K, V> newEnumMap(
+  public static <K extends Enum<K>, V extends Object> EnumMap<K, V> newEnumMap(
       Class<K> type) {
     return new EnumMap<>(checkNotNull(type));
   }
@@ -435,7 +425,7 @@ public final class Maps {
    * @throws IllegalArgumentException if {@code m} is not an {@code EnumMap} instance and contains
    *     no mappings
    */
-  public static <K extends Enum<K>, V extends @Nullable Object> EnumMap<K, V> newEnumMap(
+  public static <K extends Enum<K>, V extends Object> EnumMap<K, V> newEnumMap(
       Map<K, ? extends V> map) {
     return new EnumMap<>(map);
   }
@@ -449,7 +439,7 @@ public final class Maps {
    *
    * @return a new, empty {@code IdentityHashMap}
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       IdentityHashMap<K, V> newIdentityHashMap() {
     return new IdentityHashMap<>();
   }
@@ -470,7 +460,7 @@ public final class Maps {
    * @return the difference between the two maps
    */
   @SuppressWarnings("unchecked")
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       MapDifference<K, V> difference(
           Map<? extends K, ? extends V> left, Map<? extends K, ? extends V> right) {
     if (left instanceof SortedMap) {
@@ -533,7 +523,7 @@ public final class Maps {
    * (Vaguely related: Another thing we could consider is an overload that accepts a BiPredicate:
    * https://github.com/google/guava/issues/3913)
    */
-  public static <K extends @Nullable Object, V> MapDifference<K, V> difference(
+  public static <K extends Object, V> MapDifference<K, V> difference(
       Map<? extends K, ? extends V> left,
       Map<? extends K, ? extends V> right,
       Equivalence<? super V> valueEquivalence) {
@@ -564,7 +554,7 @@ public final class Maps {
    * @return the difference between the two maps
    * @since 11.0
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       SortedMapDifference<K, V> difference(
           SortedMap<K, ? extends V> left, Map<? extends K, ? extends V> right) {
     checkNotNull(left);
@@ -579,7 +569,7 @@ public final class Maps {
     return new SortedMapDifferenceImpl<>(onlyOnLeft, onlyOnRight, onBoth, differences);
   }
 
-  private static <K extends @Nullable Object, V extends @Nullable Object> void doDifference(
+  private static <K extends Object, V extends Object> void doDifference(
       Map<? extends K, ? extends V> left,
       Map<? extends K, ? extends V> right,
       Equivalence<? super V> valueEquivalence,
@@ -613,7 +603,7 @@ public final class Maps {
     }
   }
 
-  private static <K extends @Nullable Object, V extends @Nullable Object> Map<K, V> unmodifiableMap(
+  private static <K extends Object, V extends Object> Map<K, V> unmodifiableMap(
       Map<K, ? extends V> map) {
     if (map instanceof SortedMap) {
       return Collections.unmodifiableSortedMap((SortedMap<K, ? extends V>) map);
@@ -622,7 +612,7 @@ public final class Maps {
     }
   }
 
-  static class MapDifferenceImpl<K extends @Nullable Object, V extends @Nullable Object>
+  static class MapDifferenceImpl<K extends Object, V extends Object>
       implements MapDifference<K, V> {
     final Map<K, V> onlyOnLeft;
     final Map<K, V> onlyOnRight;
@@ -706,12 +696,12 @@ public final class Maps {
     }
   }
 
-  static class ValueDifferenceImpl<V extends @Nullable Object>
+  static class ValueDifferenceImpl<V extends Object>
       implements MapDifference.ValueDifference<V> {
     @ParametricNullness private final V left;
     @ParametricNullness private final V right;
 
-    static <V extends @Nullable Object> ValueDifference<V> create(
+    static <V extends Object> ValueDifference<V> create(
         @ParametricNullness V left, @ParametricNullness V right) {
       return new ValueDifferenceImpl<V>(left, right);
     }
@@ -754,7 +744,7 @@ public final class Maps {
     }
   }
 
-  static class SortedMapDifferenceImpl<K extends @Nullable Object, V extends @Nullable Object>
+  static class SortedMapDifferenceImpl<K extends Object, V extends Object>
       extends MapDifferenceImpl<K, V> implements SortedMapDifference<K, V> {
     SortedMapDifferenceImpl(
         SortedMap<K, V> onlyOnLeft,
@@ -791,7 +781,7 @@ public final class Maps {
    * ugly type-casting in one place.
    */
   @SuppressWarnings("unchecked")
-  static <E extends @Nullable Object> Comparator<? super E> orNaturalOrder(
+  static <E extends Object> Comparator<? super E> orNaturalOrder(
       @CheckForNull Comparator<? super E> comparator) {
     if (comparator != null) { // can't use ? : because of javac bug 5080917
       return comparator;
@@ -823,7 +813,7 @@ public final class Maps {
    *
    * @since 14.0
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object> Map<K, V> asMap(
+  public static <K extends Object, V extends Object> Map<K, V> asMap(
       Set<K> set, Function<? super K, V> function) {
     return new AsMapView<>(set, function);
   }
@@ -851,7 +841,7 @@ public final class Maps {
    *
    * @since 14.0
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object> SortedMap<K, V> asMap(
+  public static <K extends Object, V extends Object> SortedMap<K, V> asMap(
       SortedSet<K> set, Function<? super K, V> function) {
     return new SortedAsMapView<>(set, function);
   }
@@ -879,13 +869,13 @@ public final class Maps {
    *
    * @since 14.0
    */
-  @GwtIncompatible // NavigableMap
-  public static <K extends @Nullable Object, V extends @Nullable Object> NavigableMap<K, V> asMap(
+  // NavigableMap
+  public static <K extends Object, V extends Object> NavigableMap<K, V> asMap(
       NavigableSet<K> set, Function<? super K, V> function) {
     return new NavigableAsMapView<>(set, function);
   }
 
-  private static class AsMapView<K extends @Nullable Object, V extends @Nullable Object>
+  private static class AsMapView<K extends Object, V extends Object>
       extends ViewCachingAbstractMap<K, V> {
 
     private final Set<K> set;
@@ -957,7 +947,6 @@ public final class Maps {
 
     @Override
     protected Set<Entry<K, V>> createEntrySet() {
-      @WeakOuter
       class EntrySetImpl extends EntrySet<K, V> {
         @Override
         Map<K, V> map() {
@@ -980,7 +969,7 @@ public final class Maps {
     }
   }
 
-  static <K extends @Nullable Object, V extends @Nullable Object>
+  static <K extends Object, V extends Object>
       Iterator<Entry<K, V>> asMapEntryIterator(Set<K> set, final Function<? super K, V> function) {
     return new TransformedIterator<K, Entry<K, V>>(set.iterator()) {
       @Override
@@ -990,7 +979,7 @@ public final class Maps {
     };
   }
 
-  private static class SortedAsMapView<K extends @Nullable Object, V extends @Nullable Object>
+  private static class SortedAsMapView<K extends Object, V extends Object>
       extends AsMapView<K, V> implements SortedMap<K, V> {
 
     SortedAsMapView(SortedSet<K> set, Function<? super K, V> function) {
@@ -1041,9 +1030,9 @@ public final class Maps {
     }
   }
 
-  @GwtIncompatible // NavigableMap
+  // NavigableMap
   private static final class NavigableAsMapView<
-          K extends @Nullable Object, V extends @Nullable Object>
+          K extends Object, V extends Object>
       extends AbstractNavigableMap<K, V> {
     /*
      * Using AbstractNavigableMap is simpler than extending SortedAsMapView and rewriting all the
@@ -1142,7 +1131,7 @@ public final class Maps {
     }
   }
 
-  private static <E extends @Nullable Object> Set<E> removeOnlySet(final Set<E> set) {
+  private static <E extends Object> Set<E> removeOnlySet(final Set<E> set) {
     return new ForwardingSet<E>() {
       @Override
       protected Set<E> delegate() {
@@ -1161,7 +1150,7 @@ public final class Maps {
     };
   }
 
-  private static <E extends @Nullable Object> SortedSet<E> removeOnlySortedSet(
+  private static <E extends Object> SortedSet<E> removeOnlySortedSet(
       final SortedSet<E> set) {
     return new ForwardingSortedSet<E>() {
       @Override
@@ -1197,8 +1186,8 @@ public final class Maps {
     };
   }
 
-  @GwtIncompatible // NavigableSet
-  private static <E extends @Nullable Object> NavigableSet<E> removeOnlyNavigableSet(
+  // NavigableSet
+  private static <E extends Object> NavigableSet<E> removeOnlyNavigableSet(
       final NavigableSet<E> set) {
     return new ForwardingNavigableSet<E>() {
       @Override
@@ -1333,7 +1322,6 @@ public final class Maps {
    * @throws NullPointerException if any element of {@code values} is {@code null}, or if {@code
    *     keyFunction} produces {@code null} for any value
    */
-  @CanIgnoreReturnValue
   public static <K, V> ImmutableMap<K, V> uniqueIndex(
       Iterable<V> values, Function<? super V, K> keyFunction) {
     // TODO(lowasser): consider presizing the builder if values is a Collection
@@ -1369,7 +1357,6 @@ public final class Maps {
    *     keyFunction} produces {@code null} for any value
    * @since 10.0
    */
-  @CanIgnoreReturnValue
   public static <K, V> ImmutableMap<K, V> uniqueIndex(
       Iterator<V> values, Function<? super V, K> keyFunction) {
     checkNotNull(keyFunction);
@@ -1397,7 +1384,7 @@ public final class Maps {
    * @throws ClassCastException if any key in {@code properties} is not a {@code String}
    * @throws NullPointerException if any key or value in {@code properties} is null
    */
-  @GwtIncompatible // java.util.Properties
+  // java.util.Properties
   public static ImmutableMap<String, String> fromProperties(Properties properties) {
     ImmutableMap.Builder<String, String> builder = ImmutableMap.builder();
 
@@ -1447,8 +1434,7 @@ public final class Maps {
    * @param key the key to be associated with the returned entry
    * @param value the value to be associated with the returned entry
    */
-  @GwtCompatible(serializable = true)
-  public static <K extends @Nullable Object, V extends @Nullable Object> Entry<K, V> immutableEntry(
+  public static <K extends Object, V extends Object> Entry<K, V> immutableEntry(
       @ParametricNullness K key, @ParametricNullness V value) {
     return new ImmutableEntry<>(key, value);
   }
@@ -1461,7 +1447,7 @@ public final class Maps {
    * @param entrySet the entries for which to return an unmodifiable view
    * @return an unmodifiable view of the entries
    */
-  static <K extends @Nullable Object, V extends @Nullable Object>
+  static <K extends Object, V extends Object>
       Set<Entry<K, V>> unmodifiableEntrySet(Set<Entry<K, V>> entrySet) {
     return new UnmodifiableEntrySet<>(Collections.unmodifiableSet(entrySet));
   }
@@ -1475,7 +1461,7 @@ public final class Maps {
    * @param entry the entry for which to return an unmodifiable view
    * @return an unmodifiable view of the entry
    */
-  static <K extends @Nullable Object, V extends @Nullable Object> Entry<K, V> unmodifiableEntry(
+  static <K extends Object, V extends Object> Entry<K, V> unmodifiableEntry(
       final Entry<? extends K, ? extends V> entry) {
     checkNotNull(entry);
     return new AbstractMapEntry<K, V>() {
@@ -1493,7 +1479,7 @@ public final class Maps {
     };
   }
 
-  static <K extends @Nullable Object, V extends @Nullable Object>
+  static <K extends Object, V extends Object>
       UnmodifiableIterator<Entry<K, V>> unmodifiableEntryIterator(
           final Iterator<Entry<K, V>> entryIterator) {
     return new UnmodifiableIterator<Entry<K, V>>() {
@@ -1510,7 +1496,7 @@ public final class Maps {
   }
 
   /** @see Multimaps#unmodifiableEntries */
-  static class UnmodifiableEntries<K extends @Nullable Object, V extends @Nullable Object>
+  static class UnmodifiableEntries<K extends Object, V extends Object>
       extends ForwardingCollection<Entry<K, V>> {
     private final Collection<Entry<K, V>> entries;
 
@@ -1544,13 +1530,13 @@ public final class Maps {
 
     @Override
     @SuppressWarnings("nullness") // b/192354773 in our checker affects toArray declarations
-    public <T extends @Nullable Object> T[] toArray(T[] array) {
+    public <T extends Object> T[] toArray(T[] array) {
       return standardToArray(array);
     }
   }
 
   /** @see Maps#unmodifiableEntrySet(Set) */
-  static class UnmodifiableEntrySet<K extends @Nullable Object, V extends @Nullable Object>
+  static class UnmodifiableEntrySet<K extends Object, V extends Object>
       extends UnmodifiableEntries<K, V> implements Set<Entry<K, V>> {
     UnmodifiableEntrySet(Set<Entry<K, V>> entries) {
       super(entries);
@@ -1658,7 +1644,7 @@ public final class Maps {
    * @param bimap the bimap to be wrapped in a synchronized view
    * @return a synchronized view of the specified bimap
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       BiMap<K, V> synchronizedBiMap(BiMap<K, V> bimap) {
     return Synchronized.biMap(bimap, null);
   }
@@ -1674,17 +1660,17 @@ public final class Maps {
    * @param bimap the bimap for which an unmodifiable view is to be returned
    * @return an unmodifiable view of the specified bimap
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       BiMap<K, V> unmodifiableBiMap(BiMap<? extends K, ? extends V> bimap) {
     return new UnmodifiableBiMap<>(bimap, null);
   }
 
   /** @see Maps#unmodifiableBiMap(BiMap) */
-  private static class UnmodifiableBiMap<K extends @Nullable Object, V extends @Nullable Object>
+  private static class UnmodifiableBiMap<K extends Object, V extends Object>
       extends ForwardingMap<K, V> implements BiMap<K, V>, Serializable {
     final Map<K, V> unmodifiableMap;
     final BiMap<? extends K, ? extends V> delegate;
-    @RetainedWith @CheckForNull BiMap<V, K> inverse;
+    @CheckForNull BiMap<V, K> inverse;
     @CheckForNull transient Set<V> values;
 
     UnmodifiableBiMap(BiMap<? extends K, ? extends V> delegate, @CheckForNull BiMap<V, K> inverse) {
@@ -1755,7 +1741,7 @@ public final class Maps {
    * view, copy the returned map into a new map of your choosing.
    */
   public static <
-          K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object>
+          K extends Object, V1 extends Object, V2 extends Object>
       Map<K, V2> transformValues(Map<K, V1> fromMap, Function<? super V1, V2> function) {
     return transformEntries(fromMap, asEntryTransformer(function));
   }
@@ -1797,7 +1783,7 @@ public final class Maps {
    * @since 11.0
    */
   public static <
-          K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object>
+          K extends Object, V1 extends Object, V2 extends Object>
       SortedMap<K, V2> transformValues(
           SortedMap<K, V1> fromMap, Function<? super V1, V2> function) {
     return transformEntries(fromMap, asEntryTransformer(function));
@@ -1841,9 +1827,9 @@ public final class Maps {
    *
    * @since 13.0
    */
-  @GwtIncompatible // NavigableMap
+  // NavigableMap
   public static <
-          K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object>
+          K extends Object, V1 extends Object, V2 extends Object>
       NavigableMap<K, V2> transformValues(
           NavigableMap<K, V1> fromMap, Function<? super V1, V2> function) {
     return transformEntries(fromMap, asEntryTransformer(function));
@@ -1897,7 +1883,7 @@ public final class Maps {
    * @since 7.0
    */
   public static <
-          K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object>
+          K extends Object, V1 extends Object, V2 extends Object>
       Map<K, V2> transformEntries(
           Map<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {
     return new TransformedEntriesMap<>(fromMap, transformer);
@@ -1951,7 +1937,7 @@ public final class Maps {
    * @since 11.0
    */
   public static <
-          K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object>
+          K extends Object, V1 extends Object, V2 extends Object>
       SortedMap<K, V2> transformEntries(
           SortedMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {
     return new TransformedEntriesSortedMap<>(fromMap, transformer);
@@ -2005,9 +1991,9 @@ public final class Maps {
    *
    * @since 13.0
    */
-  @GwtIncompatible // NavigableMap
+  // NavigableMap
   public static <
-          K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object>
+          K extends Object, V1 extends Object, V2 extends Object>
       NavigableMap<K, V2> transformEntries(
           NavigableMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {
     return new TransformedEntriesNavigableMap<>(fromMap, transformer);
@@ -2024,7 +2010,7 @@ public final class Maps {
    */
   @FunctionalInterface
   public interface EntryTransformer<
-      K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object> {
+      K extends Object, V1 extends Object, V2 extends Object> {
     /**
      * Determines an output value based on a key-value pair. This method is <i>generally
      * expected</i>, but not absolutely required, to have the following properties:
@@ -2043,7 +2029,7 @@ public final class Maps {
   }
 
   /** Views a function as an entry transformer that ignores the entry key. */
-  static <K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object>
+  static <K extends Object, V1 extends Object, V2 extends Object>
       EntryTransformer<K, V1, V2> asEntryTransformer(final Function<? super V1, V2> function) {
     checkNotNull(function);
     return new EntryTransformer<K, V1, V2>() {
@@ -2055,7 +2041,7 @@ public final class Maps {
     };
   }
 
-  static <K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object>
+  static <K extends Object, V1 extends Object, V2 extends Object>
       Function<V1, V2> asValueToValueFunction(
           final EntryTransformer<? super K, V1, V2> transformer, @ParametricNullness final K key) {
     checkNotNull(transformer);
@@ -2069,7 +2055,7 @@ public final class Maps {
   }
 
   /** Views an entry transformer as a function from {@code Entry} to values. */
-  static <K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object>
+  static <K extends Object, V1 extends Object, V2 extends Object>
       Function<Entry<K, V1>, V2> asEntryToValueFunction(
           final EntryTransformer<? super K, ? super V1, V2> transformer) {
     checkNotNull(transformer);
@@ -2083,7 +2069,7 @@ public final class Maps {
   }
 
   /** Returns a view of an entry transformed by the specified transformer. */
-  static <V2 extends @Nullable Object, K extends @Nullable Object, V1 extends @Nullable Object>
+  static <V2 extends Object, K extends Object, V1 extends Object>
       Entry<K, V2> transformEntry(
           final EntryTransformer<? super K, ? super V1, V2> transformer, final Entry<K, V1> entry) {
     checkNotNull(transformer);
@@ -2104,7 +2090,7 @@ public final class Maps {
   }
 
   /** Views an entry transformer as a function from entries to entries. */
-  static <K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object>
+  static <K extends Object, V1 extends Object, V2 extends Object>
       Function<Entry<K, V1>, Entry<K, V2>> asEntryToEntryFunction(
           final EntryTransformer<? super K, ? super V1, V2> transformer) {
     checkNotNull(transformer);
@@ -2117,7 +2103,7 @@ public final class Maps {
   }
 
   static class TransformedEntriesMap<
-          K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object>
+          K extends Object, V1 extends Object, V2 extends Object>
       extends IteratorBasedAbstractMap<K, V2> {
     final Map<K, V1> fromMap;
     final EntryTransformer<? super K, ? super V1, V2> transformer;
@@ -2204,7 +2190,7 @@ public final class Maps {
   }
 
   static class TransformedEntriesSortedMap<
-          K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object>
+          K extends Object, V1 extends Object, V2 extends Object>
       extends TransformedEntriesMap<K, V1, V2> implements SortedMap<K, V2> {
 
     protected SortedMap<K, V1> fromMap() {
@@ -2250,9 +2236,9 @@ public final class Maps {
     }
   }
 
-  @GwtIncompatible // NavigableMap
+  // NavigableMap
   private static class TransformedEntriesNavigableMap<
-          K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object>
+          K extends Object, V1 extends Object, V2 extends Object>
       extends TransformedEntriesSortedMap<K, V1, V2> implements NavigableMap<K, V2> {
 
     TransformedEntriesNavigableMap(
@@ -2393,12 +2379,12 @@ public final class Maps {
     }
   }
 
-  static <K extends @Nullable Object> Predicate<Entry<K, ?>> keyPredicateOnEntries(
+  static <K extends Object> Predicate<Entry<K, ?>> keyPredicateOnEntries(
       Predicate<? super K> keyPredicate) {
     return compose(keyPredicate, Maps.<K>keyFunction());
   }
 
-  static <V extends @Nullable Object> Predicate<Entry<?, V>> valuePredicateOnEntries(
+  static <V extends Object> Predicate<Entry<?, V>> valuePredicateOnEntries(
       Predicate<? super V> valuePredicate) {
     return compose(valuePredicate, Maps.<V>valueFunction());
   }
@@ -2426,7 +2412,7 @@ public final class Maps {
    * {@link Predicate#apply}. Do not provide a predicate such as {@code
    * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object> Map<K, V> filterKeys(
+  public static <K extends Object, V extends Object> Map<K, V> filterKeys(
       Map<K, V> unfiltered, final Predicate<? super K> keyPredicate) {
     checkNotNull(keyPredicate);
     Predicate<Entry<K, ?>> entryPredicate = keyPredicateOnEntries(keyPredicate);
@@ -2461,7 +2447,7 @@ public final class Maps {
    *
    * @since 11.0
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object> SortedMap<K, V> filterKeys(
+  public static <K extends Object, V extends Object> SortedMap<K, V> filterKeys(
       SortedMap<K, V> unfiltered, final Predicate<? super K> keyPredicate) {
     // TODO(lowasser): Return a subclass of Maps.FilteredKeyMap for slightly better
     // performance.
@@ -2494,8 +2480,8 @@ public final class Maps {
    *
    * @since 14.0
    */
-  @GwtIncompatible // NavigableMap
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  // NavigableMap
+  public static <K extends Object, V extends Object>
       NavigableMap<K, V> filterKeys(
           NavigableMap<K, V> unfiltered, final Predicate<? super K> keyPredicate) {
     // TODO(lowasser): Return a subclass of Maps.FilteredKeyMap for slightly better
@@ -2527,7 +2513,7 @@ public final class Maps {
    *
    * @since 14.0
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object> BiMap<K, V> filterKeys(
+  public static <K extends Object, V extends Object> BiMap<K, V> filterKeys(
       BiMap<K, V> unfiltered, final Predicate<? super K> keyPredicate) {
     checkNotNull(keyPredicate);
     return filterEntries(unfiltered, Maps.<K>keyPredicateOnEntries(keyPredicate));
@@ -2556,7 +2542,7 @@ public final class Maps {
    * at {@link Predicate#apply}. Do not provide a predicate such as {@code
    * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object> Map<K, V> filterValues(
+  public static <K extends Object, V extends Object> Map<K, V> filterValues(
       Map<K, V> unfiltered, final Predicate<? super V> valuePredicate) {
     return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));
   }
@@ -2587,7 +2573,7 @@ public final class Maps {
    *
    * @since 11.0
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       SortedMap<K, V> filterValues(
           SortedMap<K, V> unfiltered, final Predicate<? super V> valuePredicate) {
     return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));
@@ -2619,8 +2605,8 @@ public final class Maps {
    *
    * @since 14.0
    */
-  @GwtIncompatible // NavigableMap
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  // NavigableMap
+  public static <K extends Object, V extends Object>
       NavigableMap<K, V> filterValues(
           NavigableMap<K, V> unfiltered, final Predicate<? super V> valuePredicate) {
     return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));
@@ -2653,7 +2639,7 @@ public final class Maps {
    *
    * @since 14.0
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object> BiMap<K, V> filterValues(
+  public static <K extends Object, V extends Object> BiMap<K, V> filterValues(
       BiMap<K, V> unfiltered, final Predicate<? super V> valuePredicate) {
     return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));
   }
@@ -2682,7 +2668,7 @@ public final class Maps {
    * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals</i>, as documented
    * at {@link Predicate#apply}.
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object> Map<K, V> filterEntries(
+  public static <K extends Object, V extends Object> Map<K, V> filterEntries(
       Map<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {
     checkNotNull(entryPredicate);
     return (unfiltered instanceof AbstractFilteredMap)
@@ -2716,7 +2702,7 @@ public final class Maps {
    *
    * @since 11.0
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       SortedMap<K, V> filterEntries(
           SortedMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {
     checkNotNull(entryPredicate);
@@ -2751,8 +2737,8 @@ public final class Maps {
    *
    * @since 14.0
    */
-  @GwtIncompatible // NavigableMap
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  // NavigableMap
+  public static <K extends Object, V extends Object>
       NavigableMap<K, V> filterEntries(
           NavigableMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {
     checkNotNull(entryPredicate);
@@ -2788,7 +2774,7 @@ public final class Maps {
    *
    * @since 14.0
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object> BiMap<K, V> filterEntries(
+  public static <K extends Object, V extends Object> BiMap<K, V> filterEntries(
       BiMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {
     checkNotNull(unfiltered);
     checkNotNull(entryPredicate);
@@ -2801,7 +2787,7 @@ public final class Maps {
    * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when filtering a filtered
    * map.
    */
-  private static <K extends @Nullable Object, V extends @Nullable Object> Map<K, V> filterFiltered(
+  private static <K extends Object, V extends Object> Map<K, V> filterFiltered(
       AbstractFilteredMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {
     return new FilteredEntryMap<>(
         map.unfiltered, Predicates.<Entry<K, V>>and(map.predicate, entryPredicate));
@@ -2811,7 +2797,7 @@ public final class Maps {
    * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when filtering a filtered
    * sorted map.
    */
-  private static <K extends @Nullable Object, V extends @Nullable Object>
+  private static <K extends Object, V extends Object>
       SortedMap<K, V> filterFiltered(
           FilteredEntrySortedMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {
     Predicate<Entry<K, V>> predicate = Predicates.<Entry<K, V>>and(map.predicate, entryPredicate);
@@ -2822,8 +2808,8 @@ public final class Maps {
    * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when filtering a filtered
    * navigable map.
    */
-  @GwtIncompatible // NavigableMap
-  private static <K extends @Nullable Object, V extends @Nullable Object>
+  // NavigableMap
+  private static <K extends Object, V extends Object>
       NavigableMap<K, V> filterFiltered(
           FilteredEntryNavigableMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {
     Predicate<Entry<K, V>> predicate =
@@ -2835,7 +2821,7 @@ public final class Maps {
    * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when filtering a filtered
    * map.
    */
-  private static <K extends @Nullable Object, V extends @Nullable Object>
+  private static <K extends Object, V extends Object>
       BiMap<K, V> filterFiltered(
           FilteredEntryBiMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {
     Predicate<Entry<K, V>> predicate = Predicates.<Entry<K, V>>and(map.predicate, entryPredicate);
@@ -2843,7 +2829,7 @@ public final class Maps {
   }
 
   private abstract static class AbstractFilteredMap<
-          K extends @Nullable Object, V extends @Nullable Object>
+          K extends Object, V extends Object>
       extends ViewCachingAbstractMap<K, V> {
     final Map<K, V> unfiltered;
     final Predicate<? super Entry<K, V>> predicate;
@@ -2906,7 +2892,7 @@ public final class Maps {
   }
 
   private static final class FilteredMapValues<
-          K extends @Nullable Object, V extends @Nullable Object>
+          K extends Object, V extends Object>
       extends Maps.Values<K, V> {
     final Map<K, V> unfiltered;
     final Predicate<? super Entry<K, V>> predicate;
@@ -2960,19 +2946,19 @@ public final class Maps {
     }
 
     @Override
-    public @Nullable Object[] toArray() {
+    public Object[] toArray() {
       // creating an ArrayList so filtering happens once
       return Lists.newArrayList(iterator()).toArray();
     }
 
     @Override
     @SuppressWarnings("nullness") // b/192354773 in our checker affects toArray declarations
-    public <T extends @Nullable Object> T[] toArray(T[] array) {
+    public <T extends Object> T[] toArray(T[] array) {
       return Lists.newArrayList(iterator()).toArray(array);
     }
   }
 
-  private static class FilteredKeyMap<K extends @Nullable Object, V extends @Nullable Object>
+  private static class FilteredKeyMap<K extends Object, V extends Object>
       extends AbstractFilteredMap<K, V> {
     final Predicate<? super K> keyPredicate;
 
@@ -3003,7 +2989,7 @@ public final class Maps {
     }
   }
 
-  static class FilteredEntryMap<K extends @Nullable Object, V extends @Nullable Object>
+  static class FilteredEntryMap<K extends Object, V extends Object>
       extends AbstractFilteredMap<K, V> {
     /**
      * Entries in this set satisfy the predicate, but they don't validate the input to {@code
@@ -3021,7 +3007,6 @@ public final class Maps {
       return new EntrySet();
     }
 
-    @WeakOuter
     private class EntrySet extends ForwardingSet<Entry<K, V>> {
       @Override
       protected Set<Entry<K, V>> delegate() {
@@ -3056,7 +3041,7 @@ public final class Maps {
       return new KeySet();
     }
 
-    static <K extends @Nullable Object, V extends @Nullable Object> boolean removeAllKeys(
+    static <K extends Object, V extends Object> boolean removeAllKeys(
         Map<K, V> map, Predicate<? super Entry<K, V>> entryPredicate, Collection<?> keyCollection) {
       Iterator<Entry<K, V>> entryItr = map.entrySet().iterator();
       boolean result = false;
@@ -3070,7 +3055,7 @@ public final class Maps {
       return result;
     }
 
-    static <K extends @Nullable Object, V extends @Nullable Object> boolean retainAllKeys(
+    static <K extends Object, V extends Object> boolean retainAllKeys(
         Map<K, V> map, Predicate<? super Entry<K, V>> entryPredicate, Collection<?> keyCollection) {
       Iterator<Entry<K, V>> entryItr = map.entrySet().iterator();
       boolean result = false;
@@ -3084,7 +3069,6 @@ public final class Maps {
       return result;
     }
 
-    @WeakOuter
     class KeySet extends Maps.KeySet<K, V> {
       KeySet() {
         super(FilteredEntryMap.this);
@@ -3110,21 +3094,21 @@ public final class Maps {
       }
 
       @Override
-      public @Nullable Object[] toArray() {
+      public Object[] toArray() {
         // creating an ArrayList so filtering happens once
         return Lists.newArrayList(iterator()).toArray();
       }
 
       @Override
       @SuppressWarnings("nullness") // b/192354773 in our checker affects toArray declarations
-      public <T extends @Nullable Object> T[] toArray(T[] array) {
+      public <T extends Object> T[] toArray(T[] array) {
         return Lists.newArrayList(iterator()).toArray(array);
       }
     }
   }
 
   private static class FilteredEntrySortedMap<
-          K extends @Nullable Object, V extends @Nullable Object>
+          K extends Object, V extends Object>
       extends FilteredEntryMap<K, V> implements SortedMap<K, V> {
 
     FilteredEntrySortedMap(
@@ -3146,7 +3130,6 @@ public final class Maps {
       return new SortedKeySet();
     }
 
-    @WeakOuter
     class SortedKeySet extends KeySet implements SortedSet<K> {
       @Override
       @CheckForNull
@@ -3227,9 +3210,9 @@ public final class Maps {
     }
   }
 
-  @GwtIncompatible // NavigableMap
+  // NavigableMap
   private static class FilteredEntryNavigableMap<
-          K extends @Nullable Object, V extends @Nullable Object>
+          K extends Object, V extends Object>
       extends AbstractNavigableMap<K, V> {
     /*
      * It's less code to extend AbstractNavigableMap and forward the filtering logic to
@@ -3370,11 +3353,11 @@ public final class Maps {
     }
   }
 
-  static final class FilteredEntryBiMap<K extends @Nullable Object, V extends @Nullable Object>
+  static final class FilteredEntryBiMap<K extends Object, V extends Object>
       extends FilteredEntryMap<K, V> implements BiMap<K, V> {
-    @RetainedWith private final BiMap<V, K> inverse;
+    private final BiMap<V, K> inverse;
 
-    private static <K extends @Nullable Object, V extends @Nullable Object>
+    private static <K extends Object, V extends Object>
         Predicate<Entry<V, K>> inversePredicate(
             final Predicate<? super Entry<K, V>> forwardPredicate) {
       return new Predicate<Entry<V, K>>() {
@@ -3447,8 +3430,8 @@ public final class Maps {
    * @return an unmodifiable view of the specified navigable map
    * @since 12.0
    */
-  @GwtIncompatible // NavigableMap
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  // NavigableMap
+  public static <K extends Object, V extends Object>
       NavigableMap<K, V> unmodifiableNavigableMap(NavigableMap<K, ? extends V> map) {
     checkNotNull(map);
     if (map instanceof UnmodifiableNavigableMap) {
@@ -3461,13 +3444,13 @@ public final class Maps {
   }
 
   @CheckForNull
-  private static <K extends @Nullable Object, V extends @Nullable Object>
+  private static <K extends Object, V extends Object>
       Entry<K, V> unmodifiableOrNull(@CheckForNull Entry<K, ? extends V> entry) {
     return (entry == null) ? null : Maps.unmodifiableEntry(entry);
   }
 
-  @GwtIncompatible // NavigableMap
-  static class UnmodifiableNavigableMap<K extends @Nullable Object, V extends @Nullable Object>
+  // NavigableMap
+  static class UnmodifiableNavigableMap<K extends Object, V extends Object>
       extends ForwardingSortedMap<K, V> implements NavigableMap<K, V>, Serializable {
     private final NavigableMap<K, ? extends V> delegate;
 
@@ -3668,8 +3651,8 @@ public final class Maps {
    * @return a synchronized view of the specified navigable map.
    * @since 13.0
    */
-  @GwtIncompatible // NavigableMap
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  // NavigableMap
+  public static <K extends Object, V extends Object>
       NavigableMap<K, V> synchronizedNavigableMap(NavigableMap<K, V> navigableMap) {
     return Synchronized.navigableMap(navigableMap);
   }
@@ -3678,9 +3661,8 @@ public final class Maps {
    * {@code AbstractMap} extension that makes it easy to cache customized keySet, values, and
    * entrySet views.
    */
-  @GwtCompatible
   abstract static class ViewCachingAbstractMap<
-          K extends @Nullable Object, V extends @Nullable Object>
+          K extends Object, V extends Object>
       extends AbstractMap<K, V> {
     /**
      * Creates the entry set to be returned by {@link #entrySet()}. This method is invoked at most
@@ -3722,7 +3704,7 @@ public final class Maps {
   }
 
   abstract static class IteratorBasedAbstractMap<
-          K extends @Nullable Object, V extends @Nullable Object>
+          K extends Object, V extends Object>
       extends AbstractMap<K, V> {
     @Override
     public abstract int size();
@@ -3774,7 +3756,7 @@ public final class Maps {
    * NullPointerException}.
    */
   @CheckForNull
-  static <V extends @Nullable Object> V safeGet(Map<?, V> map, @CheckForNull Object key) {
+  static <V extends Object> V safeGet(Map<?, V> map, @CheckForNull Object key) {
     checkNotNull(map);
     try {
       return map.get(key);
@@ -3801,7 +3783,7 @@ public final class Maps {
    * NullPointerException}.
    */
   @CheckForNull
-  static <V extends @Nullable Object> V safeRemove(Map<?, V> map, @CheckForNull Object key) {
+  static <V extends Object> V safeRemove(Map<?, V> map, @CheckForNull Object key) {
     checkNotNull(map);
     try {
       return map.remove(key);
@@ -3832,7 +3814,7 @@ public final class Maps {
    * @param o the object that might be contained in {@code c}
    * @return {@code true} if {@code c} contains {@code o}
    */
-  static <K extends @Nullable Object, V extends @Nullable Object> boolean containsEntryImpl(
+  static <K extends Object, V extends Object> boolean containsEntryImpl(
       Collection<Entry<K, V>> c, @CheckForNull Object o) {
     if (!(o instanceof Entry)) {
       return false;
@@ -3851,7 +3833,7 @@ public final class Maps {
    * @param o the object to remove from {@code c}
    * @return {@code true} if {@code c} was changed
    */
-  static <K extends @Nullable Object, V extends @Nullable Object> boolean removeEntryImpl(
+  static <K extends Object, V extends Object> boolean removeEntryImpl(
       Collection<Entry<K, V>> c, @CheckForNull Object o) {
     if (!(o instanceof Entry)) {
       return false;
@@ -3885,16 +3867,16 @@ public final class Maps {
   }
 
   /** An implementation of {@link Map#putAll}. */
-  static <K extends @Nullable Object, V extends @Nullable Object> void putAllImpl(
+  static <K extends Object, V extends Object> void putAllImpl(
       Map<K, V> self, Map<? extends K, ? extends V> map) {
     for (Entry<? extends K, ? extends V> entry : map.entrySet()) {
       self.put(entry.getKey(), entry.getValue());
     }
   }
 
-  static class KeySet<K extends @Nullable Object, V extends @Nullable Object>
+  static class KeySet<K extends Object, V extends Object>
       extends Sets.ImprovedAbstractSet<K> {
-    @Weak final Map<K, V> map;
+    final Map<K, V> map;
 
     KeySet(Map<K, V> map) {
       this.map = checkNotNull(map);
@@ -3947,16 +3929,16 @@ public final class Maps {
   }
 
   @CheckForNull
-  static <K extends @Nullable Object> K keyOrNull(@CheckForNull Entry<K, ?> entry) {
+  static <K extends Object> K keyOrNull(@CheckForNull Entry<K, ?> entry) {
     return (entry == null) ? null : entry.getKey();
   }
 
   @CheckForNull
-  static <V extends @Nullable Object> V valueOrNull(@CheckForNull Entry<?, V> entry) {
+  static <V extends Object> V valueOrNull(@CheckForNull Entry<?, V> entry) {
     return (entry == null) ? null : entry.getValue();
   }
 
-  static class SortedKeySet<K extends @Nullable Object, V extends @Nullable Object>
+  static class SortedKeySet<K extends Object, V extends Object>
       extends KeySet<K, V> implements SortedSet<K> {
     SortedKeySet(SortedMap<K, V> map) {
       super(map);
@@ -4001,8 +3983,8 @@ public final class Maps {
     }
   }
 
-  @GwtIncompatible // NavigableMap
-  static class NavigableKeySet<K extends @Nullable Object, V extends @Nullable Object>
+  // NavigableMap
+  static class NavigableKeySet<K extends Object, V extends Object>
       extends SortedKeySet<K, V> implements NavigableSet<K> {
     NavigableKeySet(NavigableMap<K, V> map) {
       super(map);
@@ -4094,9 +4076,9 @@ public final class Maps {
     }
   }
 
-  static class Values<K extends @Nullable Object, V extends @Nullable Object>
+  static class Values<K extends Object, V extends Object>
       extends AbstractCollection<V> {
-    @Weak final Map<K, V> map;
+    final Map<K, V> map;
 
     Values(Map<K, V> map) {
       this.map = checkNotNull(map);
@@ -4184,7 +4166,7 @@ public final class Maps {
     }
   }
 
-  abstract static class EntrySet<K extends @Nullable Object, V extends @Nullable Object>
+  abstract static class EntrySet<K extends Object, V extends Object>
       extends Sets.ImprovedAbstractSet<Entry<K, V>> {
     abstract Map<K, V> map();
 
@@ -4243,7 +4225,7 @@ public final class Maps {
         return super.retainAll(checkNotNull(c));
       } catch (UnsupportedOperationException e) {
         // if the iterators don't support remove
-        Set<@Nullable Object> keys = Sets.newHashSetWithExpectedSize(c.size());
+        Set<Object> keys = Sets.newHashSetWithExpectedSize(c.size());
         for (Object o : c) {
           /*
            * `o instanceof Entry` is guaranteed by `contains`, but we check it here to satisfy our
@@ -4259,8 +4241,8 @@ public final class Maps {
     }
   }
 
-  @GwtIncompatible // NavigableMap
-  abstract static class DescendingMap<K extends @Nullable Object, V extends @Nullable Object>
+  // NavigableMap
+  abstract static class DescendingMap<K extends Object, V extends Object>
       extends ForwardingMap<K, V> implements NavigableMap<K, V> {
 
     abstract NavigableMap<K, V> forward();
@@ -4287,7 +4269,7 @@ public final class Maps {
     }
 
     // If we inline this, we get a javac error.
-    private static <T extends @Nullable Object> Ordering<T> reverse(Comparator<T> forward) {
+    private static <T extends Object> Ordering<T> reverse(Comparator<T> forward) {
       return Ordering.from(forward).reverse();
     }
 
@@ -4391,7 +4373,6 @@ public final class Maps {
     abstract Iterator<Entry<K, V>> entryIterator();
 
     Set<Entry<K, V>> createEntrySet() {
-      @WeakOuter
       class EntrySetImpl extends EntrySet<K, V> {
         @Override
         Map<K, V> map() {
@@ -4495,9 +4476,8 @@ public final class Maps {
    *
    * @since 20.0
    */
-  @Beta
-  @GwtIncompatible // NavigableMap
-  public static <K extends Comparable<? super K>, V extends @Nullable Object>
+  // NavigableMap
+  public static <K extends Comparable<? super K>, V extends Object>
       NavigableMap<K, V> subMap(NavigableMap<K, V> map, Range<K> range) {
     if (map.comparator() != null
         && map.comparator() != Ordering.natural()
diff --git a/guava/src/com/google/common/collect/MinMaxPriorityQueue.java b/guava/src/com/google/common/collect/MinMaxPriorityQueue.java
index cd01279f4e..3c9bb84e42 100644
--- a/guava/src/com/google/common/collect/MinMaxPriorityQueue.java
+++ b/guava/src/com/google/common/collect/MinMaxPriorityQueue.java
@@ -23,13 +23,7 @@ import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.CollectPreconditions.checkRemove;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.math.IntMath;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.j2objc.annotations.Weak;
-import com.google.j2objc.annotations.WeakOuter;
 import java.util.AbstractQueue;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
@@ -43,7 +37,6 @@ import java.util.NoSuchElementException;
 import java.util.PriorityQueue;
 import java.util.Queue;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A double-ended priority queue, which provides constant-time access to both its least element and
@@ -98,8 +91,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Torbjorn Gannholm
  * @since 8.0
  */
-@Beta
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
 
@@ -162,7 +153,6 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
    *     Queue<Integer>} but not a {@code Queue<Object>}).
    * @since 8.0
    */
-  @Beta
   public static final class Builder<B> {
     /*
      * TODO(kevinb): when the dust settles, see if we still need this or can
@@ -182,7 +172,6 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
      * Configures this builder to build min-max priority queues with an initial expected size of
      * {@code expectedSize}.
      */
-    @CanIgnoreReturnValue
     public Builder<B> expectedSize(int expectedSize) {
       checkArgument(expectedSize >= 0);
       this.expectedSize = expectedSize;
@@ -195,7 +184,6 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
      * removes its greatest element (according to its comparator), which might be the element that
      * was just added.
      */
-    @CanIgnoreReturnValue
     public Builder<B> maximumSize(int maximumSize) {
       checkArgument(maximumSize > 0);
       this.maximumSize = maximumSize;
@@ -232,8 +220,8 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
 
   private final Heap minHeap;
   private final Heap maxHeap;
-  @VisibleForTesting final int maximumSize;
-  private @Nullable Object[] queue;
+  final int maximumSize;
+  private Object[] queue;
   private int size;
   private int modCount;
 
@@ -261,14 +249,12 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
    *
    * @return {@code true} always
    */
-  @CanIgnoreReturnValue
   @Override
   public boolean add(E element) {
     offer(element);
     return true;
   }
 
-  @CanIgnoreReturnValue
   @Override
   public boolean addAll(Collection<? extends E> newElements) {
     boolean modified = false;
@@ -284,7 +270,6 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
    * element} the queue will automatically evict its greatest element (according to its comparator),
    * which may be {@code element} itself.
    */
-  @CanIgnoreReturnValue
   @Override
   public boolean offer(E element) {
     checkNotNull(element);
@@ -299,7 +284,6 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
     return size <= maximumSize || pollLast() != element;
   }
 
-  @CanIgnoreReturnValue
   @Override
   @CheckForNull
   public E poll() {
@@ -339,7 +323,6 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
    * Removes and returns the least element of this queue, or returns {@code null} if the queue is
    * empty.
    */
-  @CanIgnoreReturnValue
   @CheckForNull
   public E pollFirst() {
     return poll();
@@ -350,7 +333,6 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
    *
    * @throws NoSuchElementException if the queue is empty
    */
-  @CanIgnoreReturnValue
   public E removeFirst() {
     return remove();
   }
@@ -368,7 +350,6 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
    * Removes and returns the greatest element of this queue, or returns {@code null} if the queue is
    * empty.
    */
-  @CanIgnoreReturnValue
   @CheckForNull
   public E pollLast() {
     return isEmpty() ? null : removeAndGet(getMaxElementIndex());
@@ -379,7 +360,6 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
    *
    * @throws NoSuchElementException if the queue is empty
    */
-  @CanIgnoreReturnValue
   public E removeLast() {
     if (isEmpty()) {
       throw new NoSuchElementException();
@@ -409,8 +389,6 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
    * down to replace the element at {@code index}. This fact is used by iterator.remove so as to
    * visit elements during a traversal once and only once.
    */
-  @VisibleForTesting
-  @CanIgnoreReturnValue
   @CheckForNull
   MoveDesc<E> removeAt(int index) {
     checkPositionIndex(index, size);
@@ -495,7 +473,6 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
   private static final int EVEN_POWERS_OF_TWO = 0x55555555;
   private static final int ODD_POWERS_OF_TWO = 0xaaaaaaaa;
 
-  @VisibleForTesting
   static boolean isEvenLevel(int index) {
     int oneBased = ~~(index + 1); // for GWT
     checkState(oneBased > 0, "negative index");
@@ -507,7 +484,6 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
    *
    * <p>TODO(kevinb): move to the test class?
    */
-  @VisibleForTesting
   boolean isIntact() {
     for (int i = 1; i < size; i++) {
       if (!heapForIndex(i).verifyIndex(i)) {
@@ -522,10 +498,9 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
    * max-heap. Conceptually, these might each have their own array for storage, but for efficiency's
    * sake they are stored interleaved on alternate heap levels in the same array (MMPQ.queue).
    */
-  @WeakOuter
   private class Heap {
     final Ordering<E> ordering;
-    @Weak Heap otherHeap; // always initialized immediately after construction
+    Heap otherHeap; // always initialized immediately after construction
 
     Heap(Ordering<E> ordering) {
       this.ordering = ordering;
@@ -584,7 +559,6 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
      * Bubbles a value from {@code index} up the levels of this heap, and returns the index the
      * element ended up at.
      */
-    @CanIgnoreReturnValue
     int bubbleUpAlternatingLevels(int index, E x) {
       while (index > 2) {
         int grandParentIndex = getGrandparentIndex(index);
@@ -926,7 +900,6 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
     return minHeap.ordering;
   }
 
-  @VisibleForTesting
   int capacity() {
     return queue.length;
   }
@@ -935,7 +908,6 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
 
   private static final int DEFAULT_CAPACITY = 11;
 
-  @VisibleForTesting
   static int initialQueueSize(
       int configuredExpectedSize, int maximumSize, Iterable<?> initialContents) {
     // Start with what they said, if they said it, otherwise DEFAULT_CAPACITY
diff --git a/guava/src/com/google/common/collect/MoreCollectors.java b/guava/src/com/google/common/collect/MoreCollectors.java
index 5a84a4628e..cb0b002ead 100644
--- a/guava/src/com/google/common/collect/MoreCollectors.java
+++ b/guava/src/com/google/common/collect/MoreCollectors.java
@@ -19,13 +19,11 @@ package com.google.common.collect;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static java.util.Collections.emptyList;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.Optional;
 import java.util.stream.Collector;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Collectors not present in {@code java.util.stream.Collectors} that are not otherwise associated
@@ -34,7 +32,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 21.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class MoreCollectors {
 
@@ -65,8 +62,8 @@ public final class MoreCollectors {
 
   private static final Object NULL_PLACEHOLDER = new Object();
 
-  private static final Collector<@Nullable Object, ?, @Nullable Object> ONLY_ELEMENT =
-      Collector.<@Nullable Object, ToOptionalState, @Nullable Object>of(
+  private static final Collector<Object, ?, Object> ONLY_ELEMENT =
+      Collector.<Object, ToOptionalState, Object>of(
           ToOptionalState::new,
           (state, o) -> state.add((o == null) ? NULL_PLACEHOLDER : o),
           ToOptionalState::combine,
@@ -82,7 +79,7 @@ public final class MoreCollectors {
    * more elements, and a {@code NoSuchElementException} if the stream is empty.
    */
   @SuppressWarnings("unchecked")
-  public static <T extends @Nullable Object> Collector<T, ?, T> onlyElement() {
+  public static <T extends Object> Collector<T, ?, T> onlyElement() {
     return (Collector) ONLY_ELEMENT;
   }
 
@@ -93,7 +90,7 @@ public final class MoreCollectors {
   private static final class ToOptionalState {
     static final int MAX_EXTRAS = 4;
 
-    @Nullable Object element;
+    Object element;
     List<Object> extras;
 
     ToOptionalState() {
diff --git a/guava/src/com/google/common/collect/Multimap.java b/guava/src/com/google/common/collect/Multimap.java
index e1a0a8ef67..eecdacf376 100644
--- a/guava/src/com/google/common/collect/Multimap.java
+++ b/guava/src/com/google/common/collect/Multimap.java
@@ -18,10 +18,6 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.CompatibleWith;
-import com.google.errorprone.annotations.DoNotMock;
 import java.util.Collection;
 import java.util.List;
 import java.util.Map;
@@ -29,7 +25,6 @@ import java.util.Map.Entry;
 import java.util.Set;
 import java.util.function.BiConsumer;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A collection that maps keys to values, similar to {@link Map}, but in which each key may be
@@ -160,10 +155,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Jared Levy
  * @since 2.0
  */
-@DoNotMock("Use ImmutableMultimap, HashMultimap, or another implementation")
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public interface Multimap<K extends @Nullable Object, V extends @Nullable Object> {
+public interface Multimap<K extends Object, V extends Object> {
   // Query Operations
 
   /**
@@ -185,21 +178,21 @@ public interface Multimap<K extends @Nullable Object, V extends @Nullable Object
    * Returns {@code true} if this multimap contains at least one key-value pair with the key {@code
    * key}.
    */
-  boolean containsKey(@CompatibleWith("K") @CheckForNull Object key);
+  boolean containsKey(@CheckForNull Object key);
 
   /**
    * Returns {@code true} if this multimap contains at least one key-value pair with the value
    * {@code value}.
    */
-  boolean containsValue(@CompatibleWith("V") @CheckForNull Object value);
+  boolean containsValue(@CheckForNull Object value);
 
   /**
    * Returns {@code true} if this multimap contains at least one key-value pair with the key {@code
    * key} and the value {@code value}.
    */
   boolean containsEntry(
-      @CompatibleWith("K") @CheckForNull Object key,
-      @CompatibleWith("V") @CheckForNull Object value);
+      @CheckForNull Object key,
+      @CheckForNull Object value);
 
   // Modification Operations
 
@@ -213,7 +206,6 @@ public interface Multimap<K extends @Nullable Object, V extends @Nullable Object
    * @return {@code true} if the method increased the size of the multimap, or {@code false} if the
    *     multimap already contained the key-value pair and doesn't allow duplicates
    */
-  @CanIgnoreReturnValue
   boolean put(@ParametricNullness K key, @ParametricNullness V value);
 
   /**
@@ -223,10 +215,9 @@ public interface Multimap<K extends @Nullable Object, V extends @Nullable Object
    *
    * @return {@code true} if the multimap changed
    */
-  @CanIgnoreReturnValue
   boolean remove(
-      @CompatibleWith("K") @CheckForNull Object key,
-      @CompatibleWith("V") @CheckForNull Object value);
+      @CheckForNull Object key,
+      @CheckForNull Object value);
 
   // Bulk Operations
 
@@ -244,7 +235,6 @@ public interface Multimap<K extends @Nullable Object, V extends @Nullable Object
    *
    * @return {@code true} if the multimap changed
    */
-  @CanIgnoreReturnValue
   boolean putAll(@ParametricNullness K key, Iterable<? extends V> values);
 
   /**
@@ -253,7 +243,6 @@ public interface Multimap<K extends @Nullable Object, V extends @Nullable Object
    *
    * @return {@code true} if the multimap changed
    */
-  @CanIgnoreReturnValue
   boolean putAll(Multimap<? extends K, ? extends V> multimap);
 
   /**
@@ -265,7 +254,6 @@ public interface Multimap<K extends @Nullable Object, V extends @Nullable Object
    *     associated with the key. The collection <i>may</i> be modifiable, but updating it will have
    *     no effect on the multimap.
    */
-  @CanIgnoreReturnValue
   Collection<V> replaceValues(@ParametricNullness K key, Iterable<? extends V> values);
 
   /**
@@ -277,8 +265,7 @@ public interface Multimap<K extends @Nullable Object, V extends @Nullable Object
    * @return the values that were removed (possibly empty). The returned collection <i>may</i> be
    *     modifiable, but updating it will have no effect on the multimap.
    */
-  @CanIgnoreReturnValue
-  Collection<V> removeAll(@CompatibleWith("K") @CheckForNull Object key);
+  Collection<V> removeAll(@CheckForNull Object key);
 
   /** Removes all key-value pairs from the multimap, leaving it {@linkplain #isEmpty empty}. */
   void clear();
diff --git a/guava/src/com/google/common/collect/MultimapBuilder.java b/guava/src/com/google/common/collect/MultimapBuilder.java
index dddae28643..2feebdefa3 100644
--- a/guava/src/com/google/common/collect/MultimapBuilder.java
+++ b/guava/src/com/google/common/collect/MultimapBuilder.java
@@ -19,7 +19,6 @@ package com.google.common.collect;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Supplier;
 import java.io.Serializable;
 import java.util.ArrayList;
@@ -34,7 +33,6 @@ import java.util.Set;
 import java.util.SortedSet;
 import java.util.TreeMap;
 import java.util.TreeSet;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A builder for a multimap implementation that allows customization of the backing map and value
@@ -61,9 +59,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @param <V0> An upper bound on the value type of the generated multimap.
  * @since 16.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @Nullable Object> {
+public abstract class MultimapBuilder<K0 extends Object, V0 extends Object> {
   /*
    * Leaving K and V as upper bounds rather than the actual key and value types allows type
    * parameters to be left implicit more often. CacheBuilder uses the same technique.
@@ -74,7 +71,7 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
   private static final int DEFAULT_EXPECTED_KEYS = 8;
 
   /** Uses a hash table to map keys to value collections. */
-  public static MultimapBuilderWithKeys<@Nullable Object> hashKeys() {
+  public static MultimapBuilderWithKeys<Object> hashKeys() {
     return hashKeys(DEFAULT_EXPECTED_KEYS);
   }
 
@@ -84,11 +81,11 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
    *
    * @throws IllegalArgumentException if {@code expectedKeys < 0}
    */
-  public static MultimapBuilderWithKeys<@Nullable Object> hashKeys(final int expectedKeys) {
+  public static MultimapBuilderWithKeys<Object> hashKeys(final int expectedKeys) {
     checkNonnegative(expectedKeys, "expectedKeys");
-    return new MultimapBuilderWithKeys<@Nullable Object>() {
+    return new MultimapBuilderWithKeys<Object>() {
       @Override
-      <K extends @Nullable Object, V extends @Nullable Object> Map<K, Collection<V>> createMap() {
+      <K extends Object, V extends Object> Map<K, Collection<V>> createMap() {
         return Platform.newHashMapWithExpectedSize(expectedKeys);
       }
     };
@@ -102,7 +99,7 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
    * multimap, save that if all values associated with a key are removed and then the key is added
    * back into the multimap, that key will come last in the key iteration order.
    */
-  public static MultimapBuilderWithKeys<@Nullable Object> linkedHashKeys() {
+  public static MultimapBuilderWithKeys<Object> linkedHashKeys() {
     return linkedHashKeys(DEFAULT_EXPECTED_KEYS);
   }
 
@@ -115,11 +112,11 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
    * multimap, save that if all values associated with a key are removed and then the key is added
    * back into the multimap, that key will come last in the key iteration order.
    */
-  public static MultimapBuilderWithKeys<@Nullable Object> linkedHashKeys(final int expectedKeys) {
+  public static MultimapBuilderWithKeys<Object> linkedHashKeys(final int expectedKeys) {
     checkNonnegative(expectedKeys, "expectedKeys");
-    return new MultimapBuilderWithKeys<@Nullable Object>() {
+    return new MultimapBuilderWithKeys<Object>() {
       @Override
-      <K extends @Nullable Object, V extends @Nullable Object> Map<K, Collection<V>> createMap() {
+      <K extends Object, V extends Object> Map<K, Collection<V>> createMap() {
         return Platform.newLinkedHashMapWithExpectedSize(expectedKeys);
       }
     };
@@ -153,12 +150,12 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
    * <p>Multimaps generated by the resulting builder will not be serializable if {@code comparator}
    * is not serializable.
    */
-  public static <K0 extends @Nullable Object> MultimapBuilderWithKeys<K0> treeKeys(
+  public static <K0 extends Object> MultimapBuilderWithKeys<K0> treeKeys(
       final Comparator<K0> comparator) {
     checkNotNull(comparator);
     return new MultimapBuilderWithKeys<K0>() {
       @Override
-      <K extends K0, V extends @Nullable Object> Map<K, Collection<V>> createMap() {
+      <K extends K0, V extends Object> Map<K, Collection<V>> createMap() {
         return new TreeMap<>(comparator);
       }
     };
@@ -175,7 +172,7 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
     return new MultimapBuilderWithKeys<K0>() {
       @SuppressWarnings("unchecked")
       @Override
-      <K extends K0, V extends @Nullable Object> Map<K, Collection<V>> createMap() {
+      <K extends K0, V extends Object> Map<K, Collection<V>> createMap() {
         // K must actually be K0, since enums are effectively final
         // (their subclasses are inaccessible)
         return (Map<K, Collection<V>>) new EnumMap<K0, Collection<V>>(keyClass);
@@ -183,7 +180,7 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
     };
   }
 
-  private static final class ArrayListSupplier<V extends @Nullable Object>
+  private static final class ArrayListSupplier<V extends Object>
       implements Supplier<List<V>>, Serializable {
     private final int expectedValuesPerKey;
 
@@ -200,7 +197,7 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
   private enum LinkedListSupplier implements Supplier<List<?>> {
     INSTANCE;
 
-    public static <V extends @Nullable Object> Supplier<List<V>> instance() {
+    public static <V extends Object> Supplier<List<V>> instance() {
       // Each call generates a fresh LinkedList, which can serve as a List<V> for any V.
       @SuppressWarnings({"rawtypes", "unchecked"})
       Supplier<List<V>> result = (Supplier) INSTANCE;
@@ -213,7 +210,7 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
     }
   }
 
-  private static final class HashSetSupplier<V extends @Nullable Object>
+  private static final class HashSetSupplier<V extends Object>
       implements Supplier<Set<V>>, Serializable {
     private final int expectedValuesPerKey;
 
@@ -227,7 +224,7 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
     }
   }
 
-  private static final class LinkedHashSetSupplier<V extends @Nullable Object>
+  private static final class LinkedHashSetSupplier<V extends Object>
       implements Supplier<Set<V>>, Serializable {
     private final int expectedValuesPerKey;
 
@@ -241,7 +238,7 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
     }
   }
 
-  private static final class TreeSetSupplier<V extends @Nullable Object>
+  private static final class TreeSetSupplier<V extends Object>
       implements Supplier<SortedSet<V>>, Serializable {
     private final Comparator<? super V> comparator;
 
@@ -276,16 +273,16 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
    * @param <K0> The upper bound on the key type of the generated multimap.
    * @since 16.0
    */
-  public abstract static class MultimapBuilderWithKeys<K0 extends @Nullable Object> {
+  public abstract static class MultimapBuilderWithKeys<K0 extends Object> {
 
     private static final int DEFAULT_EXPECTED_VALUES_PER_KEY = 2;
 
     MultimapBuilderWithKeys() {}
 
-    abstract <K extends K0, V extends @Nullable Object> Map<K, Collection<V>> createMap();
+    abstract <K extends K0, V extends Object> Map<K, Collection<V>> createMap();
 
     /** Uses an {@link ArrayList} to store value collections. */
-    public ListMultimapBuilder<K0, @Nullable Object> arrayListValues() {
+    public ListMultimapBuilder<K0, Object> arrayListValues() {
       return arrayListValues(DEFAULT_EXPECTED_VALUES_PER_KEY);
     }
 
@@ -295,12 +292,12 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
      *
      * @throws IllegalArgumentException if {@code expectedValuesPerKey < 0}
      */
-    public ListMultimapBuilder<K0, @Nullable Object> arrayListValues(
+    public ListMultimapBuilder<K0, Object> arrayListValues(
         final int expectedValuesPerKey) {
       checkNonnegative(expectedValuesPerKey, "expectedValuesPerKey");
-      return new ListMultimapBuilder<K0, @Nullable Object>() {
+      return new ListMultimapBuilder<K0, Object>() {
         @Override
-        public <K extends K0, V extends @Nullable Object> ListMultimap<K, V> build() {
+        public <K extends K0, V extends Object> ListMultimap<K, V> build() {
           return Multimaps.newListMultimap(
               MultimapBuilderWithKeys.this.<K, V>createMap(),
               new ArrayListSupplier<V>(expectedValuesPerKey));
@@ -309,10 +306,10 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
     }
 
     /** Uses a {@link LinkedList} to store value collections. */
-    public ListMultimapBuilder<K0, @Nullable Object> linkedListValues() {
-      return new ListMultimapBuilder<K0, @Nullable Object>() {
+    public ListMultimapBuilder<K0, Object> linkedListValues() {
+      return new ListMultimapBuilder<K0, Object>() {
         @Override
-        public <K extends K0, V extends @Nullable Object> ListMultimap<K, V> build() {
+        public <K extends K0, V extends Object> ListMultimap<K, V> build() {
           return Multimaps.newListMultimap(
               MultimapBuilderWithKeys.this.<K, V>createMap(), LinkedListSupplier.<V>instance());
         }
@@ -320,7 +317,7 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
     }
 
     /** Uses a hash-based {@code Set} to store value collections. */
-    public SetMultimapBuilder<K0, @Nullable Object> hashSetValues() {
+    public SetMultimapBuilder<K0, Object> hashSetValues() {
       return hashSetValues(DEFAULT_EXPECTED_VALUES_PER_KEY);
     }
 
@@ -330,11 +327,11 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
      *
      * @throws IllegalArgumentException if {@code expectedValuesPerKey < 0}
      */
-    public SetMultimapBuilder<K0, @Nullable Object> hashSetValues(final int expectedValuesPerKey) {
+    public SetMultimapBuilder<K0, Object> hashSetValues(final int expectedValuesPerKey) {
       checkNonnegative(expectedValuesPerKey, "expectedValuesPerKey");
-      return new SetMultimapBuilder<K0, @Nullable Object>() {
+      return new SetMultimapBuilder<K0, Object>() {
         @Override
-        public <K extends K0, V extends @Nullable Object> SetMultimap<K, V> build() {
+        public <K extends K0, V extends Object> SetMultimap<K, V> build() {
           return Multimaps.newSetMultimap(
               MultimapBuilderWithKeys.this.<K, V>createMap(),
               new HashSetSupplier<V>(expectedValuesPerKey));
@@ -343,7 +340,7 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
     }
 
     /** Uses an insertion-ordered hash-based {@code Set} to store value collections. */
-    public SetMultimapBuilder<K0, @Nullable Object> linkedHashSetValues() {
+    public SetMultimapBuilder<K0, Object> linkedHashSetValues() {
       return linkedHashSetValues(DEFAULT_EXPECTED_VALUES_PER_KEY);
     }
 
@@ -353,12 +350,12 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
      *
      * @throws IllegalArgumentException if {@code expectedValuesPerKey < 0}
      */
-    public SetMultimapBuilder<K0, @Nullable Object> linkedHashSetValues(
+    public SetMultimapBuilder<K0, Object> linkedHashSetValues(
         final int expectedValuesPerKey) {
       checkNonnegative(expectedValuesPerKey, "expectedValuesPerKey");
-      return new SetMultimapBuilder<K0, @Nullable Object>() {
+      return new SetMultimapBuilder<K0, Object>() {
         @Override
-        public <K extends K0, V extends @Nullable Object> SetMultimap<K, V> build() {
+        public <K extends K0, V extends Object> SetMultimap<K, V> build() {
           return Multimaps.newSetMultimap(
               MultimapBuilderWithKeys.this.<K, V>createMap(),
               new LinkedHashSetSupplier<V>(expectedValuesPerKey));
@@ -378,7 +375,7 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
      * <p>Multimaps generated by the resulting builder will not be serializable if {@code
      * comparator} is not serializable.
      */
-    public <V0 extends @Nullable Object> SortedSetMultimapBuilder<K0, V0> treeSetValues(
+    public <V0 extends Object> SortedSetMultimapBuilder<K0, V0> treeSetValues(
         final Comparator<V0> comparator) {
       checkNotNull(comparator, "comparator");
       return new SortedSetMultimapBuilder<K0, V0>() {
@@ -427,7 +424,7 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
    * @since 16.0
    */
   public abstract static class ListMultimapBuilder<
-          K0 extends @Nullable Object, V0 extends @Nullable Object>
+          K0 extends Object, V0 extends Object>
       extends MultimapBuilder<K0, V0> {
     ListMultimapBuilder() {}
 
@@ -447,7 +444,7 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
    * @since 16.0
    */
   public abstract static class SetMultimapBuilder<
-          K0 extends @Nullable Object, V0 extends @Nullable Object>
+          K0 extends Object, V0 extends Object>
       extends MultimapBuilder<K0, V0> {
     SetMultimapBuilder() {}
 
@@ -467,7 +464,7 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
    * @since 16.0
    */
   public abstract static class SortedSetMultimapBuilder<
-          K0 extends @Nullable Object, V0 extends @Nullable Object>
+          K0 extends Object, V0 extends Object>
       extends SetMultimapBuilder<K0, V0> {
     SortedSetMultimapBuilder() {}
 
diff --git a/guava/src/com/google/common/collect/Multimaps.java b/guava/src/com/google/common/collect/Multimaps.java
index 9bc9e98f5b..85d4e304c9 100644
--- a/guava/src/com/google/common/collect/Multimaps.java
+++ b/guava/src/com/google/common/collect/Multimaps.java
@@ -22,18 +22,11 @@ import static com.google.common.collect.CollectPreconditions.checkRemove;
 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Function;
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
 import com.google.common.base.Supplier;
 import com.google.common.collect.Maps.EntryTransformer;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.concurrent.LazyInit;
-import com.google.j2objc.annotations.Weak;
-import com.google.j2objc.annotations.WeakOuter;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
@@ -57,7 +50,6 @@ import java.util.function.Consumer;
 import java.util.stream.Collector;
 import java.util.stream.Stream;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Provides static methods acting on or generating a {@code Multimap}.
@@ -72,7 +64,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 2.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class Multimaps {
   private Multimaps() {}
@@ -114,9 +105,9 @@ public final class Multimaps {
    * @since 21.0
    */
   public static <
-          T extends @Nullable Object,
-          K extends @Nullable Object,
-          V extends @Nullable Object,
+          T extends Object,
+          K extends Object,
+          V extends Object,
           M extends Multimap<K, V>>
       Collector<T, ?, M> toMultimap(
           java.util.function.Function<? super T, ? extends K> keyFunction,
@@ -158,11 +149,10 @@ public final class Multimaps {
    *
    * @since 21.0
    */
-  @Beta
   public static <
-          T extends @Nullable Object,
-          K extends @Nullable Object,
-          V extends @Nullable Object,
+          T extends Object,
+          K extends Object,
+          V extends Object,
           M extends Multimap<K, V>>
       Collector<T, ?, M> flatteningToMultimap(
           java.util.function.Function<? super T, ? extends K> keyFunction,
@@ -207,12 +197,12 @@ public final class Multimaps {
    *     key
    * @throws IllegalArgumentException if {@code map} is not empty
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object> Multimap<K, V> newMultimap(
+  public static <K extends Object, V extends Object> Multimap<K, V> newMultimap(
       Map<K, Collection<V>> map, final Supplier<? extends Collection<V>> factory) {
     return new CustomMultimap<>(map, factory);
   }
 
-  private static class CustomMultimap<K extends @Nullable Object, V extends @Nullable Object>
+  private static class CustomMultimap<K extends Object, V extends Object>
       extends AbstractMapBasedMultimap<K, V> {
     transient Supplier<? extends Collection<V>> factory;
 
@@ -237,7 +227,7 @@ public final class Multimaps {
     }
 
     @Override
-    <E extends @Nullable Object> Collection<E> unmodifiableCollectionSubclass(
+    <E extends Object> Collection<E> unmodifiableCollectionSubclass(
         Collection<E> collection) {
       if (collection instanceof NavigableSet) {
         return Sets.unmodifiableNavigableSet((NavigableSet<E>) collection);
@@ -271,14 +261,14 @@ public final class Multimaps {
     // there's no way to generate the empty backing map.
 
     /** @serialData the factory and the backing map */
-    @GwtIncompatible // java.io.ObjectOutputStream
+    // java.io.ObjectOutputStream
     private void writeObject(ObjectOutputStream stream) throws IOException {
       stream.defaultWriteObject();
       stream.writeObject(factory);
       stream.writeObject(backingMap());
     }
 
-    @GwtIncompatible // java.io.ObjectInputStream
+    // java.io.ObjectInputStream
     @SuppressWarnings("unchecked") // reading data stored by writeObject
     private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
       stream.defaultReadObject();
@@ -287,7 +277,7 @@ public final class Multimaps {
       setMap(map);
     }
 
-    @GwtIncompatible // java serialization not supported
+    // java serialization not supported
     private static final long serialVersionUID = 0;
   }
 
@@ -321,13 +311,13 @@ public final class Multimaps {
    * @param factory supplier of new, empty lists that will each hold all values for a given key
    * @throws IllegalArgumentException if {@code map} is not empty
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       ListMultimap<K, V> newListMultimap(
           Map<K, Collection<V>> map, final Supplier<? extends List<V>> factory) {
     return new CustomListMultimap<>(map, factory);
   }
 
-  private static class CustomListMultimap<K extends @Nullable Object, V extends @Nullable Object>
+  private static class CustomListMultimap<K extends Object, V extends Object>
       extends AbstractListMultimap<K, V> {
     transient Supplier<? extends List<V>> factory;
 
@@ -352,14 +342,14 @@ public final class Multimaps {
     }
 
     /** @serialData the factory and the backing map */
-    @GwtIncompatible // java.io.ObjectOutputStream
+    // java.io.ObjectOutputStream
     private void writeObject(ObjectOutputStream stream) throws IOException {
       stream.defaultWriteObject();
       stream.writeObject(factory);
       stream.writeObject(backingMap());
     }
 
-    @GwtIncompatible // java.io.ObjectInputStream
+    // java.io.ObjectInputStream
     @SuppressWarnings("unchecked") // reading data stored by writeObject
     private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
       stream.defaultReadObject();
@@ -368,7 +358,7 @@ public final class Multimaps {
       setMap(map);
     }
 
-    @GwtIncompatible // java serialization not supported
+    // java serialization not supported
     private static final long serialVersionUID = 0;
   }
 
@@ -401,13 +391,13 @@ public final class Multimaps {
    * @param factory supplier of new, empty sets that will each hold all values for a given key
    * @throws IllegalArgumentException if {@code map} is not empty
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       SetMultimap<K, V> newSetMultimap(
           Map<K, Collection<V>> map, final Supplier<? extends Set<V>> factory) {
     return new CustomSetMultimap<>(map, factory);
   }
 
-  private static class CustomSetMultimap<K extends @Nullable Object, V extends @Nullable Object>
+  private static class CustomSetMultimap<K extends Object, V extends Object>
       extends AbstractSetMultimap<K, V> {
     transient Supplier<? extends Set<V>> factory;
 
@@ -432,7 +422,7 @@ public final class Multimaps {
     }
 
     @Override
-    <E extends @Nullable Object> Collection<E> unmodifiableCollectionSubclass(
+    <E extends Object> Collection<E> unmodifiableCollectionSubclass(
         Collection<E> collection) {
       if (collection instanceof NavigableSet) {
         return Sets.unmodifiableNavigableSet((NavigableSet<E>) collection);
@@ -455,14 +445,14 @@ public final class Multimaps {
     }
 
     /** @serialData the factory and the backing map */
-    @GwtIncompatible // java.io.ObjectOutputStream
+    // java.io.ObjectOutputStream
     private void writeObject(ObjectOutputStream stream) throws IOException {
       stream.defaultWriteObject();
       stream.writeObject(factory);
       stream.writeObject(backingMap());
     }
 
-    @GwtIncompatible // java.io.ObjectInputStream
+    // java.io.ObjectInputStream
     @SuppressWarnings("unchecked") // reading data stored by writeObject
     private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
       stream.defaultReadObject();
@@ -471,7 +461,7 @@ public final class Multimaps {
       setMap(map);
     }
 
-    @GwtIncompatible // not needed in emulated source
+    // not needed in emulated source
     private static final long serialVersionUID = 0;
   }
 
@@ -504,14 +494,14 @@ public final class Multimaps {
    *     key
    * @throws IllegalArgumentException if {@code map} is not empty
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       SortedSetMultimap<K, V> newSortedSetMultimap(
           Map<K, Collection<V>> map, final Supplier<? extends SortedSet<V>> factory) {
     return new CustomSortedSetMultimap<>(map, factory);
   }
 
   private static class CustomSortedSetMultimap<
-          K extends @Nullable Object, V extends @Nullable Object>
+          K extends Object, V extends Object>
       extends AbstractSortedSetMultimap<K, V> {
     transient Supplier<? extends SortedSet<V>> factory;
     @CheckForNull transient Comparator<? super V> valueComparator;
@@ -544,14 +534,14 @@ public final class Multimaps {
     }
 
     /** @serialData the factory and the backing map */
-    @GwtIncompatible // java.io.ObjectOutputStream
+    // java.io.ObjectOutputStream
     private void writeObject(ObjectOutputStream stream) throws IOException {
       stream.defaultWriteObject();
       stream.writeObject(factory);
       stream.writeObject(backingMap());
     }
 
-    @GwtIncompatible // java.io.ObjectInputStream
+    // java.io.ObjectInputStream
     @SuppressWarnings("unchecked") // reading data stored by writeObject
     private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
       stream.defaultReadObject();
@@ -561,7 +551,7 @@ public final class Multimaps {
       setMap(map);
     }
 
-    @GwtIncompatible // not needed in emulated source
+    // not needed in emulated source
     private static final long serialVersionUID = 0;
   }
 
@@ -576,8 +566,7 @@ public final class Multimaps {
    * @param dest the multimap to copy into; usually empty
    * @return {@code dest}
    */
-  @CanIgnoreReturnValue
-  public static <K extends @Nullable Object, V extends @Nullable Object, M extends Multimap<K, V>>
+  public static <K extends Object, V extends Object, M extends Multimap<K, V>>
       M invertFrom(Multimap<? extends V, ? extends K> source, M dest) {
     checkNotNull(dest);
     for (Map.Entry<? extends V, ? extends K> entry : source.entries()) {
@@ -618,7 +607,7 @@ public final class Multimaps {
    * @param multimap the multimap to be wrapped in a synchronized view
    * @return a synchronized view of the specified multimap
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       Multimap<K, V> synchronizedMultimap(Multimap<K, V> multimap) {
     return Synchronized.multimap(multimap, null);
   }
@@ -634,7 +623,7 @@ public final class Multimaps {
    * @param delegate the multimap for which an unmodifiable view is to be returned
    * @return an unmodifiable view of the specified multimap
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       Multimap<K, V> unmodifiableMultimap(Multimap<K, V> delegate) {
     if (delegate instanceof UnmodifiableMultimap || delegate instanceof ImmutableMultimap) {
       return delegate;
@@ -653,14 +642,14 @@ public final class Multimaps {
     return checkNotNull(delegate);
   }
 
-  private static class UnmodifiableMultimap<K extends @Nullable Object, V extends @Nullable Object>
+  private static class UnmodifiableMultimap<K extends Object, V extends Object>
       extends ForwardingMultimap<K, V> implements Serializable {
     final Multimap<K, V> delegate;
-    @LazyInit @CheckForNull transient Collection<Entry<K, V>> entries;
-    @LazyInit @CheckForNull transient Multiset<K> keys;
-    @LazyInit @CheckForNull transient Set<K> keySet;
-    @LazyInit @CheckForNull transient Collection<V> values;
-    @LazyInit @CheckForNull transient Map<K, Collection<V>> map;
+    @CheckForNull transient Collection<Entry<K, V>> entries;
+    @CheckForNull transient Multiset<K> keys;
+    @CheckForNull transient Set<K> keySet;
+    @CheckForNull transient Collection<V> values;
+    @CheckForNull transient Map<K, Collection<V>> map;
 
     UnmodifiableMultimap(final Multimap<K, V> delegate) {
       this.delegate = checkNotNull(delegate);
@@ -775,7 +764,7 @@ public final class Multimaps {
   }
 
   private static class UnmodifiableListMultimap<
-          K extends @Nullable Object, V extends @Nullable Object>
+          K extends Object, V extends Object>
       extends UnmodifiableMultimap<K, V> implements ListMultimap<K, V> {
     UnmodifiableListMultimap(ListMultimap<K, V> delegate) {
       super(delegate);
@@ -805,7 +794,7 @@ public final class Multimaps {
   }
 
   private static class UnmodifiableSetMultimap<
-          K extends @Nullable Object, V extends @Nullable Object>
+          K extends Object, V extends Object>
       extends UnmodifiableMultimap<K, V> implements SetMultimap<K, V> {
     UnmodifiableSetMultimap(SetMultimap<K, V> delegate) {
       super(delegate);
@@ -844,7 +833,7 @@ public final class Multimaps {
   }
 
   private static class UnmodifiableSortedSetMultimap<
-          K extends @Nullable Object, V extends @Nullable Object>
+          K extends Object, V extends Object>
       extends UnmodifiableSetMultimap<K, V> implements SortedSetMultimap<K, V> {
     UnmodifiableSortedSetMultimap(SortedSetMultimap<K, V> delegate) {
       super(delegate);
@@ -889,7 +878,7 @@ public final class Multimaps {
    * @param multimap the multimap to be wrapped
    * @return a synchronized view of the specified multimap
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       SetMultimap<K, V> synchronizedSetMultimap(SetMultimap<K, V> multimap) {
     return Synchronized.setMultimap(multimap, null);
   }
@@ -905,7 +894,7 @@ public final class Multimaps {
    * @param delegate the multimap for which an unmodifiable view is to be returned
    * @return an unmodifiable view of the specified multimap
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       SetMultimap<K, V> unmodifiableSetMultimap(SetMultimap<K, V> delegate) {
     if (delegate instanceof UnmodifiableSetMultimap || delegate instanceof ImmutableSetMultimap) {
       return delegate;
@@ -936,7 +925,7 @@ public final class Multimaps {
    * @param multimap the multimap to be wrapped
    * @return a synchronized view of the specified multimap
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       SortedSetMultimap<K, V> synchronizedSortedSetMultimap(SortedSetMultimap<K, V> multimap) {
     return Synchronized.sortedSetMultimap(multimap, null);
   }
@@ -952,7 +941,7 @@ public final class Multimaps {
    * @param delegate the multimap for which an unmodifiable view is to be returned
    * @return an unmodifiable view of the specified multimap
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       SortedSetMultimap<K, V> unmodifiableSortedSetMultimap(SortedSetMultimap<K, V> delegate) {
     if (delegate instanceof UnmodifiableSortedSetMultimap) {
       return delegate;
@@ -968,7 +957,7 @@ public final class Multimaps {
    * @param multimap the multimap to be wrapped
    * @return a synchronized view of the specified multimap
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       ListMultimap<K, V> synchronizedListMultimap(ListMultimap<K, V> multimap) {
     return Synchronized.listMultimap(multimap, null);
   }
@@ -984,7 +973,7 @@ public final class Multimaps {
    * @param delegate the multimap for which an unmodifiable view is to be returned
    * @return an unmodifiable view of the specified multimap
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       ListMultimap<K, V> unmodifiableListMultimap(ListMultimap<K, V> delegate) {
     if (delegate instanceof UnmodifiableListMultimap || delegate instanceof ImmutableListMultimap) {
       return delegate;
@@ -1012,7 +1001,7 @@ public final class Multimaps {
    * @param collection the collection for which to return an unmodifiable view
    * @return an unmodifiable view of the collection
    */
-  private static <V extends @Nullable Object> Collection<V> unmodifiableValueCollection(
+  private static <V extends Object> Collection<V> unmodifiableValueCollection(
       Collection<V> collection) {
     if (collection instanceof SortedSet) {
       return Collections.unmodifiableSortedSet((SortedSet<V>) collection);
@@ -1032,7 +1021,7 @@ public final class Multimaps {
    * @param entries the entries for which to return an unmodifiable view
    * @return an unmodifiable view of the entries
    */
-  private static <K extends @Nullable Object, V extends @Nullable Object>
+  private static <K extends Object, V extends Object>
       Collection<Entry<K, V>> unmodifiableEntries(Collection<Entry<K, V>> entries) {
     if (entries instanceof Set) {
       return Maps.unmodifiableEntrySet((Set<Entry<K, V>>) entries);
@@ -1046,10 +1035,9 @@ public final class Multimaps {
    *
    * @since 15.0
    */
-  @Beta
   @SuppressWarnings("unchecked")
   // safe by specification of ListMultimap.asMap()
-  public static <K extends @Nullable Object, V extends @Nullable Object> Map<K, List<V>> asMap(
+  public static <K extends Object, V extends Object> Map<K, List<V>> asMap(
       ListMultimap<K, V> multimap) {
     return (Map<K, List<V>>) (Map<K, ?>) multimap.asMap();
   }
@@ -1060,10 +1048,9 @@ public final class Multimaps {
    *
    * @since 15.0
    */
-  @Beta
   @SuppressWarnings("unchecked")
   // safe by specification of SetMultimap.asMap()
-  public static <K extends @Nullable Object, V extends @Nullable Object> Map<K, Set<V>> asMap(
+  public static <K extends Object, V extends Object> Map<K, Set<V>> asMap(
       SetMultimap<K, V> multimap) {
     return (Map<K, Set<V>>) (Map<K, ?>) multimap.asMap();
   }
@@ -1074,10 +1061,9 @@ public final class Multimaps {
    *
    * @since 15.0
    */
-  @Beta
   @SuppressWarnings("unchecked")
   // safe by specification of SortedSetMultimap.asMap()
-  public static <K extends @Nullable Object, V extends @Nullable Object> Map<K, SortedSet<V>> asMap(
+  public static <K extends Object, V extends Object> Map<K, SortedSet<V>> asMap(
       SortedSetMultimap<K, V> multimap) {
     return (Map<K, SortedSet<V>>) (Map<K, ?>) multimap.asMap();
   }
@@ -1088,8 +1074,7 @@ public final class Multimaps {
    *
    * @since 15.0
    */
-  @Beta
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       Map<K, Collection<V>> asMap(Multimap<K, V> multimap) {
     return multimap.asMap();
   }
@@ -1109,13 +1094,13 @@ public final class Multimaps {
    *
    * @param map the backing map for the returned multimap view
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object> SetMultimap<K, V> forMap(
+  public static <K extends Object, V extends Object> SetMultimap<K, V> forMap(
       Map<K, V> map) {
     return new MapMultimap<>(map);
   }
 
   /** @see Multimaps#forMap */
-  private static class MapMultimap<K extends @Nullable Object, V extends @Nullable Object>
+  private static class MapMultimap<K extends Object, V extends Object>
       extends AbstractMultimap<K, V> implements SetMultimap<K, V>, Serializable {
     final Map<K, V> map;
 
@@ -1311,7 +1296,7 @@ public final class Multimaps {
    * @since 7.0
    */
   public static <
-          K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object>
+          K extends Object, V1 extends Object, V2 extends Object>
       Multimap<K, V2> transformValues(
           Multimap<K, V1> fromMultimap, final Function<? super V1, V2> function) {
     checkNotNull(function);
@@ -1360,7 +1345,7 @@ public final class Multimaps {
    * @since 7.0
    */
   public static <
-          K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object>
+          K extends Object, V1 extends Object, V2 extends Object>
       ListMultimap<K, V2> transformValues(
           ListMultimap<K, V1> fromMultimap, final Function<? super V1, V2> function) {
     checkNotNull(function);
@@ -1420,7 +1405,7 @@ public final class Multimaps {
    * @since 7.0
    */
   public static <
-          K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object>
+          K extends Object, V1 extends Object, V2 extends Object>
       Multimap<K, V2> transformEntries(
           Multimap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {
     return new TransformedEntriesMultimap<>(fromMap, transformer);
@@ -1475,14 +1460,14 @@ public final class Multimaps {
    * @since 7.0
    */
   public static <
-          K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object>
+          K extends Object, V1 extends Object, V2 extends Object>
       ListMultimap<K, V2> transformEntries(
           ListMultimap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {
     return new TransformedEntriesListMultimap<>(fromMap, transformer);
   }
 
   private static class TransformedEntriesMultimap<
-          K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object>
+          K extends Object, V1 extends Object, V2 extends Object>
       extends AbstractMultimap<K, V2> {
     final Multimap<K, V1> fromMultimap;
     final EntryTransformer<? super K, ? super V1, V2> transformer;
@@ -1601,7 +1586,7 @@ public final class Multimaps {
   }
 
   private static final class TransformedEntriesListMultimap<
-          K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object>
+          K extends Object, V1 extends Object, V2 extends Object>
       extends TransformedEntriesMultimap<K, V1, V2> implements ListMultimap<K, V2> {
 
     TransformedEntriesListMultimap(
@@ -1719,9 +1704,9 @@ public final class Multimaps {
     return builder.build();
   }
 
-  static class Keys<K extends @Nullable Object, V extends @Nullable Object>
+  static class Keys<K extends Object, V extends Object>
       extends AbstractMultiset<K> {
-    @Weak final Multimap<K, V> multimap;
+    final Multimap<K, V> multimap;
 
     Keys(Multimap<K, V> multimap) {
       this.multimap = multimap;
@@ -1829,7 +1814,7 @@ public final class Multimaps {
   }
 
   /** A skeleton implementation of {@link Multimap#entries()}. */
-  abstract static class Entries<K extends @Nullable Object, V extends @Nullable Object>
+  abstract static class Entries<K extends Object, V extends Object>
       extends AbstractCollection<Map.Entry<K, V>> {
     abstract Multimap<K, V> multimap();
 
@@ -1863,9 +1848,9 @@ public final class Multimaps {
   }
 
   /** A skeleton implementation of {@link Multimap#asMap()}. */
-  static final class AsMap<K extends @Nullable Object, V extends @Nullable Object>
+  static final class AsMap<K extends Object, V extends Object>
       extends Maps.ViewCachingAbstractMap<K, Collection<V>> {
-    @Weak private final Multimap<K, V> multimap;
+    private final Multimap<K, V> multimap;
 
     AsMap(Multimap<K, V> multimap) {
       this.multimap = checkNotNull(multimap);
@@ -1885,7 +1870,6 @@ public final class Multimaps {
       multimap.keySet().remove(key);
     }
 
-    @WeakOuter
     class EntrySet extends Maps.EntrySet<K, Collection<V>> {
       @Override
       Map<K, Collection<V>> map() {
@@ -1977,7 +1961,7 @@ public final class Multimaps {
    *
    * @since 11.0
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object> Multimap<K, V> filterKeys(
+  public static <K extends Object, V extends Object> Multimap<K, V> filterKeys(
       Multimap<K, V> unfiltered, final Predicate<? super K> keyPredicate) {
     if (unfiltered instanceof SetMultimap) {
       return filterKeys((SetMultimap<K, V>) unfiltered, keyPredicate);
@@ -2022,7 +2006,7 @@ public final class Multimaps {
    *
    * @since 14.0
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       SetMultimap<K, V> filterKeys(
           SetMultimap<K, V> unfiltered, final Predicate<? super K> keyPredicate) {
     if (unfiltered instanceof FilteredKeySetMultimap) {
@@ -2064,7 +2048,7 @@ public final class Multimaps {
    *
    * @since 14.0
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       ListMultimap<K, V> filterKeys(
           ListMultimap<K, V> unfiltered, final Predicate<? super K> keyPredicate) {
     if (unfiltered instanceof FilteredKeyListMultimap) {
@@ -2103,7 +2087,7 @@ public final class Multimaps {
    *
    * @since 11.0
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       Multimap<K, V> filterValues(
           Multimap<K, V> unfiltered, final Predicate<? super V> valuePredicate) {
     return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));
@@ -2136,7 +2120,7 @@ public final class Multimaps {
    *
    * @since 14.0
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       SetMultimap<K, V> filterValues(
           SetMultimap<K, V> unfiltered, final Predicate<? super V> valuePredicate) {
     return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));
@@ -2167,7 +2151,7 @@ public final class Multimaps {
    *
    * @since 11.0
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       Multimap<K, V> filterEntries(
           Multimap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {
     checkNotNull(entryPredicate);
@@ -2204,7 +2188,7 @@ public final class Multimaps {
    *
    * @since 14.0
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object>
+  public static <K extends Object, V extends Object>
       SetMultimap<K, V> filterEntries(
           SetMultimap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {
     checkNotNull(entryPredicate);
@@ -2219,7 +2203,7 @@ public final class Multimaps {
    * lead to a multimap whose removal operations would fail. This method combines the predicates to
    * avoid that problem.
    */
-  private static <K extends @Nullable Object, V extends @Nullable Object>
+  private static <K extends Object, V extends Object>
       Multimap<K, V> filterFiltered(
           FilteredMultimap<K, V> multimap, Predicate<? super Entry<K, V>> entryPredicate) {
     Predicate<Entry<K, V>> predicate =
@@ -2233,7 +2217,7 @@ public final class Multimaps {
    * lead to a multimap whose removal operations would fail. This method combines the predicates to
    * avoid that problem.
    */
-  private static <K extends @Nullable Object, V extends @Nullable Object>
+  private static <K extends Object, V extends Object>
       SetMultimap<K, V> filterFiltered(
           FilteredSetMultimap<K, V> multimap, Predicate<? super Entry<K, V>> entryPredicate) {
     Predicate<Entry<K, V>> predicate =
diff --git a/guava/src/com/google/common/collect/Multiset.java b/guava/src/com/google/common/collect/Multiset.java
index e7c7d62c11..7a7ca7c58a 100644
--- a/guava/src/com/google/common/collect/Multiset.java
+++ b/guava/src/com/google/common/collect/Multiset.java
@@ -18,10 +18,6 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.CompatibleWith;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Iterator;
@@ -31,7 +27,6 @@ import java.util.Spliterator;
 import java.util.function.Consumer;
 import java.util.function.ObjIntConsumer;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A collection that supports order-independent equality, like {@link Set}, but may have duplicate
@@ -86,9 +81,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kevin Bourrillion
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public interface Multiset<E extends @Nullable Object> extends Collection<E> {
+public interface Multiset<E extends Object> extends Collection<E> {
   // Query Operations
 
   /**
@@ -113,7 +107,7 @@ public interface Multiset<E extends @Nullable Object> extends Collection<E> {
    * @return the number of occurrences of the element in this multiset; possibly zero but never
    *     negative
    */
-  int count(@CompatibleWith("E") @CheckForNull Object element);
+  int count(@CheckForNull Object element);
 
   // Bulk Operations
 
@@ -135,7 +129,6 @@ public interface Multiset<E extends @Nullable Object> extends Collection<E> {
    *     null elements. Note that if {@code occurrences} is zero, the implementation may opt to
    *     return normally.
    */
-  @CanIgnoreReturnValue
   int add(@ParametricNullness E element, int occurrences);
 
   /**
@@ -157,7 +150,6 @@ public interface Multiset<E extends @Nullable Object> extends Collection<E> {
    * @throws IllegalArgumentException if {@link Integer#MAX_VALUE} occurrences of {@code element}
    *     are already contained in this multiset
    */
-  @CanIgnoreReturnValue
   @Override
   boolean add(@ParametricNullness E element);
 
@@ -173,8 +165,7 @@ public interface Multiset<E extends @Nullable Object> extends Collection<E> {
    * @return the count of the element before the operation; possibly zero
    * @throws IllegalArgumentException if {@code occurrences} is negative
    */
-  @CanIgnoreReturnValue
-  int remove(@CompatibleWith("E") @CheckForNull Object element, int occurrences);
+  int remove(@CheckForNull Object element, int occurrences);
 
   /**
    * Removes a <i>single</i> occurrence of the specified element from this multiset, if present.
@@ -188,7 +179,6 @@ public interface Multiset<E extends @Nullable Object> extends Collection<E> {
    * @param element the element to remove one occurrence of
    * @return {@code true} if an occurrence was found and removed
    */
-  @CanIgnoreReturnValue
   @Override
   boolean remove(@CheckForNull Object element);
 
@@ -205,7 +195,6 @@ public interface Multiset<E extends @Nullable Object> extends Collection<E> {
    *     null elements. Note that if {@code count} is zero, the implementor may optionally return
    *     zero instead.
    */
-  @CanIgnoreReturnValue
   int setCount(@ParametricNullness E element, int count);
 
   /**
@@ -224,7 +213,6 @@ public interface Multiset<E extends @Nullable Object> extends Collection<E> {
    *     null elements. Note that if {@code oldCount} and {@code newCount} are both zero, the
    *     implementor may optionally return {@code true} instead.
    */
-  @CanIgnoreReturnValue
   boolean setCount(@ParametricNullness E element, int oldCount, int newCount);
 
   // Views
@@ -271,7 +259,7 @@ public interface Multiset<E extends @Nullable Object> extends Collection<E> {
    *
    * @since 2.0
    */
-  interface Entry<E extends @Nullable Object> {
+  interface Entry<E extends Object> {
 
     /**
      * Returns the multiset element corresponding to this entry. Multiple calls to this method
@@ -340,7 +328,6 @@ public interface Multiset<E extends @Nullable Object> extends Collection<E> {
    *
    * @since 21.0
    */
-  @Beta
   default void forEachEntry(ObjIntConsumer<? super E> action) {
     checkNotNull(action);
     entrySet().forEach(entry -> action.accept(entry.getElement(), entry.getCount()));
@@ -434,7 +421,6 @@ public interface Multiset<E extends @Nullable Object> extends Collection<E> {
    * <p>This method refines {@link Collection#removeAll} to further specify that it <b>may not</b>
    * throw an exception in response to any of {@code elements} being null or of the wrong type.
    */
-  @CanIgnoreReturnValue
   @Override
   boolean removeAll(Collection<?> c);
 
@@ -451,7 +437,6 @@ public interface Multiset<E extends @Nullable Object> extends Collection<E> {
    *
    * @see Multisets#retainOccurrences(Multiset, Multiset)
    */
-  @CanIgnoreReturnValue
   @Override
   boolean retainAll(Collection<?> c);
 
diff --git a/guava/src/com/google/common/collect/Multisets.java b/guava/src/com/google/common/collect/Multisets.java
index e3203d237e..bd0aa42ea8 100644
--- a/guava/src/com/google/common/collect/Multisets.java
+++ b/guava/src/com/google/common/collect/Multisets.java
@@ -22,15 +22,12 @@ import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 import static com.google.common.collect.CollectPreconditions.checkRemove;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Objects;
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
 import com.google.common.collect.Multiset.Entry;
 import com.google.common.math.IntMath;
 import com.google.common.primitives.Ints;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.Serializable;
 import java.util.Arrays;
 import java.util.Collection;
@@ -45,7 +42,6 @@ import java.util.function.Supplier;
 import java.util.function.ToIntFunction;
 import java.util.stream.Collector;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Provides static utility methods for creating and working with {@link Multiset} instances.
@@ -59,7 +55,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class Multisets {
   private Multisets() {}
@@ -81,7 +76,7 @@ public final class Multisets {
    *
    * @since 22.0
    */
-  public static <T extends @Nullable Object, E extends @Nullable Object, M extends Multiset<E>>
+  public static <T extends Object, E extends Object, M extends Multiset<E>>
       Collector<T, ?, M> toMultiset(
           Function<? super T, E> elementFunction,
           ToIntFunction<? super T> countFunction,
@@ -99,7 +94,7 @@ public final class Multisets {
    * @param multiset the multiset for which an unmodifiable view is to be generated
    * @return an unmodifiable view of the multiset
    */
-  public static <E extends @Nullable Object> Multiset<E> unmodifiableMultiset(
+  public static <E extends Object> Multiset<E> unmodifiableMultiset(
       Multiset<? extends E> multiset) {
     if (multiset instanceof UnmodifiableMultiset || multiset instanceof ImmutableMultiset) {
       @SuppressWarnings("unchecked") // Since it's unmodifiable, the covariant cast is safe
@@ -120,7 +115,7 @@ public final class Multisets {
     return checkNotNull(multiset);
   }
 
-  static class UnmodifiableMultiset<E extends @Nullable Object> extends ForwardingMultiset<E>
+  static class UnmodifiableMultiset<E extends Object> extends ForwardingMultiset<E>
       implements Serializable {
     final Multiset<? extends E> delegate;
 
@@ -229,8 +224,7 @@ public final class Multisets {
    * @return an unmodifiable view of the multiset
    * @since 11.0
    */
-  @Beta
-  public static <E extends @Nullable Object> SortedMultiset<E> unmodifiableSortedMultiset(
+  public static <E extends Object> SortedMultiset<E> unmodifiableSortedMultiset(
       SortedMultiset<E> sortedMultiset) {
     // it's in its own file so it can be emulated for GWT
     return new UnmodifiableSortedMultiset<E>(checkNotNull(sortedMultiset));
@@ -244,12 +238,12 @@ public final class Multisets {
    * @param n the count to be associated with the returned entry
    * @throws IllegalArgumentException if {@code n} is negative
    */
-  public static <E extends @Nullable Object> Multiset.Entry<E> immutableEntry(
+  public static <E extends Object> Multiset.Entry<E> immutableEntry(
       @ParametricNullness E e, int n) {
     return new ImmutableEntry<E>(e, n);
   }
 
-  static class ImmutableEntry<E extends @Nullable Object> extends AbstractEntry<E>
+  static class ImmutableEntry<E extends Object> extends AbstractEntry<E>
       implements Serializable {
     @ParametricNullness private final E element;
     private final int count;
@@ -304,8 +298,7 @@ public final class Multisets {
    *
    * @since 14.0
    */
-  @Beta
-  public static <E extends @Nullable Object> Multiset<E> filter(
+  public static <E extends Object> Multiset<E> filter(
       Multiset<E> unfiltered, Predicate<? super E> predicate) {
     if (unfiltered instanceof FilteredMultiset) {
       // Support clear(), removeAll(), and retainAll() when filtering a filtered
@@ -317,7 +310,7 @@ public final class Multisets {
     return new FilteredMultiset<E>(unfiltered, predicate);
   }
 
-  private static final class FilteredMultiset<E extends @Nullable Object> extends ViewMultiset<E> {
+  private static final class FilteredMultiset<E extends Object> extends ViewMultiset<E> {
     final Multiset<E> unfiltered;
     final Predicate<? super E> predicate;
 
@@ -411,8 +404,7 @@ public final class Multisets {
    *
    * @since 14.0
    */
-  @Beta
-  public static <E extends @Nullable Object> Multiset<E> union(
+  public static <E extends Object> Multiset<E> union(
       final Multiset<? extends E> multiset1, final Multiset<? extends E> multiset2) {
     checkNotNull(multiset1);
     checkNotNull(multiset2);
@@ -484,7 +476,7 @@ public final class Multisets {
    *
    * @since 2.0
    */
-  public static <E extends @Nullable Object> Multiset<E> intersection(
+  public static <E extends Object> Multiset<E> intersection(
       final Multiset<E> multiset1, final Multiset<?> multiset2) {
     checkNotNull(multiset1);
     checkNotNull(multiset2);
@@ -541,8 +533,7 @@ public final class Multisets {
    *
    * @since 14.0
    */
-  @Beta
-  public static <E extends @Nullable Object> Multiset<E> sum(
+  public static <E extends Object> Multiset<E> sum(
       final Multiset<? extends E> multiset1, final Multiset<? extends E> multiset2) {
     checkNotNull(multiset1);
     checkNotNull(multiset2);
@@ -619,8 +610,7 @@ public final class Multisets {
    *
    * @since 14.0
    */
-  @Beta
-  public static <E extends @Nullable Object> Multiset<E> difference(
+  public static <E extends Object> Multiset<E> difference(
       final Multiset<E> multiset1, final Multiset<?> multiset2) {
     checkNotNull(multiset1);
     checkNotNull(multiset2);
@@ -690,7 +680,6 @@ public final class Multisets {
    *
    * @since 10.0
    */
-  @CanIgnoreReturnValue
   public static boolean containsOccurrences(Multiset<?> superMultiset, Multiset<?> subMultiset) {
     checkNotNull(superMultiset);
     checkNotNull(subMultiset);
@@ -719,14 +708,13 @@ public final class Multisets {
    * @return {@code true} if {@code multisetToModify} was changed as a result of this operation
    * @since 10.0
    */
-  @CanIgnoreReturnValue
   public static boolean retainOccurrences(
       Multiset<?> multisetToModify, Multiset<?> multisetToRetain) {
     return retainOccurrencesImpl(multisetToModify, multisetToRetain);
   }
 
   /** Delegate implementation which cares about the element type. */
-  private static <E extends @Nullable Object> boolean retainOccurrencesImpl(
+  private static <E extends Object> boolean retainOccurrencesImpl(
       Multiset<E> multisetToModify, Multiset<?> occurrencesToRetain) {
     checkNotNull(multisetToModify);
     checkNotNull(occurrencesToRetain);
@@ -770,7 +758,6 @@ public final class Multisets {
    * @since 18.0 (present in 10.0 with a requirement that the second parameter be a {@code
    *     Multiset})
    */
-  @CanIgnoreReturnValue
   public static boolean removeOccurrences(
       Multiset<?> multisetToModify, Iterable<?> occurrencesToRemove) {
     if (occurrencesToRemove instanceof Multiset) {
@@ -808,7 +795,6 @@ public final class Multisets {
    * @return {@code true} if {@code multisetToModify} was changed as a result of this operation
    * @since 10.0 (missing in 18.0 when only the overload taking an {@code Iterable} was present)
    */
-  @CanIgnoreReturnValue
   public static boolean removeOccurrences(
       Multiset<?> multisetToModify, Multiset<?> occurrencesToRemove) {
     checkNotNull(multisetToModify);
@@ -834,7 +820,7 @@ public final class Multisets {
    * Implementation of the {@code equals}, {@code hashCode}, and {@code toString} methods of {@link
    * Multiset.Entry}.
    */
-  abstract static class AbstractEntry<E extends @Nullable Object> implements Multiset.Entry<E> {
+  abstract static class AbstractEntry<E extends Object> implements Multiset.Entry<E> {
     /**
      * Indicates whether an object equals this entry, following the behavior specified in {@link
      * Multiset.Entry#equals}.
@@ -900,7 +886,7 @@ public final class Multisets {
   }
 
   /** An implementation of {@link Multiset#addAll}. */
-  static <E extends @Nullable Object> boolean addAllImpl(
+  static <E extends Object> boolean addAllImpl(
       Multiset<E> self, Collection<? extends E> elements) {
     checkNotNull(self);
     checkNotNull(elements);
@@ -914,7 +900,7 @@ public final class Multisets {
   }
 
   /** A specialization of {@code addAllImpl} for when {@code elements} is itself a Multiset. */
-  private static <E extends @Nullable Object> boolean addAllImpl(
+  private static <E extends Object> boolean addAllImpl(
       Multiset<E> self, Multiset<? extends E> elements) {
     if (elements.isEmpty()) {
       return false;
@@ -945,7 +931,7 @@ public final class Multisets {
   }
 
   /** An implementation of {@link Multiset#setCount(Object, int)}. */
-  static <E extends @Nullable Object> int setCountImpl(
+  static <E extends Object> int setCountImpl(
       Multiset<E> self, @ParametricNullness E element, int count) {
     checkNonnegative(count, "count");
 
@@ -962,7 +948,7 @@ public final class Multisets {
   }
 
   /** An implementation of {@link Multiset#setCount(Object, int, int)}. */
-  static <E extends @Nullable Object> boolean setCountImpl(
+  static <E extends Object> boolean setCountImpl(
       Multiset<E> self, @ParametricNullness E element, int oldCount, int newCount) {
     checkNonnegative(oldCount, "oldCount");
     checkNonnegative(newCount, "newCount");
@@ -975,7 +961,7 @@ public final class Multisets {
     }
   }
 
-  static <E extends @Nullable Object> Iterator<E> elementIterator(
+  static <E extends Object> Iterator<E> elementIterator(
       Iterator<Entry<E>> entryIterator) {
     return new TransformedIterator<Entry<E>, E>(entryIterator) {
       @Override
@@ -986,7 +972,7 @@ public final class Multisets {
     };
   }
 
-  abstract static class ElementSet<E extends @Nullable Object> extends Sets.ImprovedAbstractSet<E> {
+  abstract static class ElementSet<E extends Object> extends Sets.ImprovedAbstractSet<E> {
     abstract Multiset<E> multiset();
 
     @Override
@@ -1023,7 +1009,7 @@ public final class Multisets {
     }
   }
 
-  abstract static class EntrySet<E extends @Nullable Object>
+  abstract static class EntrySet<E extends Object>
       extends Sets.ImprovedAbstractSet<Entry<E>> {
     abstract Multiset<E> multiset();
 
@@ -1056,7 +1042,7 @@ public final class Multisets {
           // Safe as long as we never add a new entry, which we won't.
           // (Presumably it can still throw CCE/NPE but only if the underlying Multiset does.)
           @SuppressWarnings({"unchecked", "nullness"})
-          Multiset<@Nullable Object> multiset = (Multiset<@Nullable Object>) multiset();
+          Multiset<Object> multiset = (Multiset<Object>) multiset();
           return multiset.setCount(element, entryCount, 0);
         }
       }
@@ -1070,11 +1056,11 @@ public final class Multisets {
   }
 
   /** An implementation of {@link Multiset#iterator}. */
-  static <E extends @Nullable Object> Iterator<E> iteratorImpl(Multiset<E> multiset) {
+  static <E extends Object> Iterator<E> iteratorImpl(Multiset<E> multiset) {
     return new MultisetIteratorImpl<E>(multiset, multiset.entrySet().iterator());
   }
 
-  static final class MultisetIteratorImpl<E extends @Nullable Object> implements Iterator<E> {
+  static final class MultisetIteratorImpl<E extends Object> implements Iterator<E> {
     private final Multiset<E> multiset;
     private final Iterator<Entry<E>> entryIterator;
     @CheckForNull private Entry<E> currentEntry;
@@ -1133,7 +1119,7 @@ public final class Multisets {
     }
   }
 
-  static <E extends @Nullable Object> Spliterator<E> spliteratorImpl(Multiset<E> multiset) {
+  static <E extends Object> Spliterator<E> spliteratorImpl(Multiset<E> multiset) {
     Spliterator<Entry<E>> entrySpliterator = multiset.entrySet().spliterator();
     return CollectSpliterators.flatMap(
         entrySpliterator,
@@ -1154,7 +1140,7 @@ public final class Multisets {
   }
 
   /** Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557 */
-  static <T extends @Nullable Object> Multiset<T> cast(Iterable<T> iterable) {
+  static <T extends Object> Multiset<T> cast(Iterable<T> iterable) {
     return (Multiset<T>) iterable;
   }
 
@@ -1164,7 +1150,6 @@ public final class Multisets {
    *
    * @since 11.0
    */
-  @Beta
   public static <E> ImmutableMultiset<E> copyHighestCountFirst(Multiset<E> multiset) {
     Entry<E>[] entries = (Entry<E>[]) multiset.entrySet().toArray(new Entry[0]);
     Arrays.sort(entries, DecreasingCount.INSTANCE);
@@ -1184,7 +1169,7 @@ public final class Multisets {
    * An {@link AbstractMultiset} with additional default implementations, some of them linear-time
    * implementations in terms of {@code elementSet} and {@code entrySet}.
    */
-  private abstract static class ViewMultiset<E extends @Nullable Object>
+  private abstract static class ViewMultiset<E extends Object>
       extends AbstractMultiset<E> {
     @Override
     public int size() {
diff --git a/guava/src/com/google/common/collect/MutableClassToInstanceMap.java b/guava/src/com/google/common/collect/MutableClassToInstanceMap.java
index 0990a49f09..0625f73cce 100644
--- a/guava/src/com/google/common/collect/MutableClassToInstanceMap.java
+++ b/guava/src/com/google/common/collect/MutableClassToInstanceMap.java
@@ -18,9 +18,7 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.primitives.Primitives;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.Serializable;
 import java.util.HashMap;
 import java.util.Iterator;
@@ -29,7 +27,6 @@ import java.util.Map;
 import java.util.Set;
 import java.util.Spliterator;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A mutable class-to-instance map backed by an arbitrary user-provided map. See also {@link
@@ -45,7 +42,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kevin Bourrillion
  * @since 2.0
  */
-@GwtIncompatible
 @SuppressWarnings("serial") // using writeReplace instead of standard serialization
 @ElementTypesAreNonnullByDefault
 public final class MutableClassToInstanceMap<B> extends ForwardingMap<Class<? extends B>, B>
@@ -138,14 +134,13 @@ public final class MutableClassToInstanceMap<B> extends ForwardingMap<Class<? ex
 
       @Override
       @SuppressWarnings("nullness") // b/192354773 in our checker affects toArray declarations
-      public <T extends @Nullable Object> T[] toArray(T[] array) {
+      public <T extends Object> T[] toArray(T[] array) {
         return standardToArray(array);
       }
     };
   }
 
   @Override
-  @CanIgnoreReturnValue
   @CheckForNull
   public B put(Class<? extends B> key, B value) {
     return super.put(key, cast(key, value));
@@ -160,7 +155,6 @@ public final class MutableClassToInstanceMap<B> extends ForwardingMap<Class<? ex
     super.putAll(copy);
   }
 
-  @CanIgnoreReturnValue
   @Override
   @CheckForNull
   public <T extends B> T putInstance(Class<T> type, T value) {
@@ -173,7 +167,6 @@ public final class MutableClassToInstanceMap<B> extends ForwardingMap<Class<? ex
     return cast(type, get(type));
   }
 
-  @CanIgnoreReturnValue
   @CheckForNull
   private static <B, T extends B> T cast(Class<T> type, @CheckForNull B value) {
     return Primitives.wrap(type).cast(value);
diff --git a/guava/src/com/google/common/collect/NaturalOrdering.java b/guava/src/com/google/common/collect/NaturalOrdering.java
index 8cb8aef9a0..21859a7a6c 100644
--- a/guava/src/com/google/common/collect/NaturalOrdering.java
+++ b/guava/src/com/google/common/collect/NaturalOrdering.java
@@ -18,20 +18,17 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** An ordering that uses the natural order of the values. */
-@GwtCompatible(serializable = true)
 @SuppressWarnings({"unchecked", "rawtypes"}) // TODO(kevinb): the right way to explain this??
 @ElementTypesAreNonnullByDefault
 final class NaturalOrdering extends Ordering<Comparable<?>> implements Serializable {
   static final NaturalOrdering INSTANCE = new NaturalOrdering();
 
-  @CheckForNull private transient Ordering<@Nullable Comparable<?>> nullsFirst;
-  @CheckForNull private transient Ordering<@Nullable Comparable<?>> nullsLast;
+  @CheckForNull private transient Ordering<Comparable<?>> nullsFirst;
+  @CheckForNull private transient Ordering<Comparable<?>> nullsLast;
 
   @Override
   public int compare(Comparable<?> left, Comparable<?> right) {
@@ -41,21 +38,21 @@ final class NaturalOrdering extends Ordering<Comparable<?>> implements Serializa
   }
 
   @Override
-  public <S extends Comparable<?>> Ordering<@Nullable S> nullsFirst() {
-    Ordering<@Nullable Comparable<?>> result = nullsFirst;
+  public <S extends Comparable<?>> Ordering<S> nullsFirst() {
+    Ordering<Comparable<?>> result = nullsFirst;
     if (result == null) {
       result = nullsFirst = super.<Comparable<?>>nullsFirst();
     }
-    return (Ordering<@Nullable S>) result;
+    return (Ordering<S>) result;
   }
 
   @Override
-  public <S extends Comparable<?>> Ordering<@Nullable S> nullsLast() {
-    Ordering<@Nullable Comparable<?>> result = nullsLast;
+  public <S extends Comparable<?>> Ordering<S> nullsLast() {
+    Ordering<Comparable<?>> result = nullsLast;
     if (result == null) {
       result = nullsLast = super.<Comparable<?>>nullsLast();
     }
-    return (Ordering<@Nullable S>) result;
+    return (Ordering<S>) result;
   }
 
   @Override
diff --git a/guava/src/com/google/common/collect/NullnessCasts.java b/guava/src/com/google/common/collect/NullnessCasts.java
index 6ceeda75ff..448e182147 100644
--- a/guava/src/com/google/common/collect/NullnessCasts.java
+++ b/guava/src/com/google/common/collect/NullnessCasts.java
@@ -14,12 +14,9 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** A utility method to perform unchecked casts to suppress errors produced by nullness analyses. */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 final class NullnessCasts {
   /**
@@ -52,7 +49,7 @@ final class NullnessCasts {
    */
   @ParametricNullness
   @SuppressWarnings("nullness")
-  static <T extends @Nullable Object> T uncheckedCastNullableTToT(@CheckForNull T t) {
+  static <T extends Object> T uncheckedCastNullableTToT(@CheckForNull T t) {
     return t;
   }
 
@@ -60,7 +57,7 @@ final class NullnessCasts {
   @SuppressWarnings({"nullness", "TypeParameterUnusedInFormals"})
   // The warnings are legitimate. Each time we use this method, we document why.
   @ParametricNullness
-  static <T extends @Nullable Object> T unsafeNull() {
+  static <T extends Object> T unsafeNull() {
     return null;
   }
 
diff --git a/guava/src/com/google/common/collect/NullsFirstOrdering.java b/guava/src/com/google/common/collect/NullsFirstOrdering.java
index ce8be2fa3c..c2f97e192b 100644
--- a/guava/src/com/google/common/collect/NullsFirstOrdering.java
+++ b/guava/src/com/google/common/collect/NullsFirstOrdering.java
@@ -16,15 +16,12 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** An ordering that treats {@code null} as less than all other values. */
-@GwtCompatible(serializable = true)
 @ElementTypesAreNonnullByDefault
-final class NullsFirstOrdering<T extends @Nullable Object> extends Ordering<@Nullable T>
+final class NullsFirstOrdering<T extends Object> extends Ordering<T>
     implements Serializable {
   final Ordering<? super T> ordering;
 
@@ -48,19 +45,19 @@ final class NullsFirstOrdering<T extends @Nullable Object> extends Ordering<@Nul
 
   @Override
   @SuppressWarnings("nullness") // should be safe, but not sure if we can avoid the warning
-  public <S extends @Nullable T> Ordering<S> reverse() {
+  public <S extends T> Ordering<S> reverse() {
     // ordering.reverse() might be optimized, so let it do its thing
     return ordering.reverse().nullsLast();
   }
 
   @SuppressWarnings("unchecked") // still need the right way to explain this
   @Override
-  public <S extends T> Ordering<@Nullable S> nullsFirst() {
-    return (Ordering<@Nullable S>) this;
+  public <S extends T> Ordering<S> nullsFirst() {
+    return (Ordering<S>) this;
   }
 
   @Override
-  public <S extends T> Ordering<@Nullable S> nullsLast() {
+  public <S extends T> Ordering<S> nullsLast() {
     return ordering.<S>nullsLast();
   }
 
diff --git a/guava/src/com/google/common/collect/NullsLastOrdering.java b/guava/src/com/google/common/collect/NullsLastOrdering.java
index 6f8f74cdd6..c75e320e9b 100644
--- a/guava/src/com/google/common/collect/NullsLastOrdering.java
+++ b/guava/src/com/google/common/collect/NullsLastOrdering.java
@@ -16,15 +16,12 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** An ordering that treats {@code null} as greater than all other values. */
-@GwtCompatible(serializable = true)
 @ElementTypesAreNonnullByDefault
-final class NullsLastOrdering<T extends @Nullable Object> extends Ordering<@Nullable T>
+final class NullsLastOrdering<T extends Object> extends Ordering<T>
     implements Serializable {
   final Ordering<? super T> ordering;
 
@@ -48,20 +45,20 @@ final class NullsLastOrdering<T extends @Nullable Object> extends Ordering<@Null
 
   @Override
   @SuppressWarnings("nullness") // should be safe, but not sure if we can avoid the warning
-  public <S extends @Nullable T> Ordering<S> reverse() {
+  public <S extends T> Ordering<S> reverse() {
     // ordering.reverse() might be optimized, so let it do its thing
     return ordering.reverse().nullsFirst();
   }
 
   @Override
-  public <S extends T> Ordering<@Nullable S> nullsFirst() {
+  public <S extends T> Ordering<S> nullsFirst() {
     return ordering.<S>nullsFirst();
   }
 
   @SuppressWarnings("unchecked") // still need the right way to explain this
   @Override
-  public <S extends T> Ordering<@Nullable S> nullsLast() {
-    return (Ordering<@Nullable S>) this;
+  public <S extends T> Ordering<S> nullsLast() {
+    return (Ordering<S>) this;
   }
 
   @Override
diff --git a/guava/src/com/google/common/collect/ObjectArrays.java b/guava/src/com/google/common/collect/ObjectArrays.java
index d3b048da7e..11d59308eb 100644
--- a/guava/src/com/google/common/collect/ObjectArrays.java
+++ b/guava/src/com/google/common/collect/ObjectArrays.java
@@ -18,13 +18,9 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkPositionIndexes;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.lang.reflect.Array;
 import java.util.Arrays;
 import java.util.Collection;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to object arrays.
@@ -32,7 +28,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kevin Bourrillion
  * @since 2.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class ObjectArrays {
 
@@ -44,7 +39,7 @@ public final class ObjectArrays {
    * @param type the component type
    * @param length the length of the new array
    */
-  @GwtIncompatible // Array.newInstance(Class, int)
+  // Array.newInstance(Class, int)
   @SuppressWarnings("unchecked")
   public static <T> T[] newArray(Class<T> type, int length) {
     return (T[]) Array.newInstance(type, length);
@@ -56,7 +51,7 @@ public final class ObjectArrays {
    * @param reference any array of the desired type
    * @param length the length of the new array
    */
-  public static <T extends @Nullable Object> T[] newArray(T[] reference, int length) {
+  public static <T extends Object> T[] newArray(T[] reference, int length) {
     return Platform.newArray(reference, length);
   }
 
@@ -67,7 +62,7 @@ public final class ObjectArrays {
    * @param second the second array of elements to concatenate
    * @param type the component type of the returned array
    */
-  @GwtIncompatible // Array.newInstance(Class, int)
+  // Array.newInstance(Class, int)
   public static <T> T[] concat(T[] first, T[] second, Class<T> type) {
     T[] result = newArray(type, first.length + second.length);
     System.arraycopy(first, 0, result, 0, first.length);
@@ -83,7 +78,7 @@ public final class ObjectArrays {
    * @return an array whose size is one larger than {@code array}, with {@code element} occupying
    *     the first position, and the elements of {@code array} occupying the remaining elements.
    */
-  public static <T extends @Nullable Object> T[] concat(@ParametricNullness T element, T[] array) {
+  public static <T extends Object> T[] concat(@ParametricNullness T element, T[] array) {
     T[] result = newArray(array, array.length + 1);
     result[0] = element;
     System.arraycopy(array, 0, result, 1, array.length);
@@ -98,7 +93,7 @@ public final class ObjectArrays {
    * @return an array whose size is one larger than {@code array}, with the same contents as {@code
    *     array}, plus {@code element} occupying the last position.
    */
-  public static <T extends @Nullable Object> T[] concat(T[] array, @ParametricNullness T element) {
+  public static <T extends Object> T[] concat(T[] array, @ParametricNullness T element) {
     T[] result = Arrays.copyOf(array, array.length + 1);
     result[array.length] = element;
     return result;
@@ -125,14 +120,14 @@ public final class ObjectArrays {
    * @throws ArrayStoreException if the runtime type of the specified array is not a supertype of
    *     the runtime type of every element in the specified collection
    */
-  static <T extends @Nullable Object> T[] toArrayImpl(Collection<?> c, T[] array) {
+  static <T extends Object> T[] toArrayImpl(Collection<?> c, T[] array) {
     int size = c.size();
     if (array.length < size) {
       array = newArray(array, size);
     }
     fillArray(c, array);
     if (array.length > size) {
-      @Nullable Object[] unsoundlyCovariantArray = array;
+      Object[] unsoundlyCovariantArray = array;
       unsoundlyCovariantArray[size] = null;
     }
     return array;
@@ -149,13 +144,13 @@ public final class ObjectArrays {
    * collection is set to {@code null}. This is useful in determining the length of the collection
    * <i>only</i> if the caller knows that the collection does not contain any null elements.
    */
-  static <T extends @Nullable Object> T[] toArrayImpl(
-      @Nullable Object[] src, int offset, int len, T[] dst) {
+  static <T extends Object> T[] toArrayImpl(
+      Object[] src, int offset, int len, T[] dst) {
     checkPositionIndexes(offset, offset + len, src.length);
     if (dst.length < len) {
       dst = newArray(dst, len);
     } else if (dst.length > len) {
-      @Nullable Object[] unsoundlyCovariantArray = dst;
+      Object[] unsoundlyCovariantArray = dst;
       unsoundlyCovariantArray[len] = null;
     }
     System.arraycopy(src, offset, dst, 0, len);
@@ -174,7 +169,7 @@ public final class ObjectArrays {
    *
    * @param c the collection for which to return an array of elements
    */
-  static @Nullable Object[] toArrayImpl(Collection<?> c) {
+  static Object[] toArrayImpl(Collection<?> c) {
     return fillArray(c, new Object[c.size()]);
   }
 
@@ -182,18 +177,17 @@ public final class ObjectArrays {
    * Returns a copy of the specified subrange of the specified array that is literally an Object[],
    * and not e.g. a {@code String[]}.
    */
-  static @Nullable Object[] copyAsObjectArray(@Nullable Object[] elements, int offset, int length) {
+  static Object[] copyAsObjectArray(Object[] elements, int offset, int length) {
     checkPositionIndexes(offset, offset + length, elements.length);
     if (length == 0) {
       return new Object[0];
     }
-    @Nullable Object[] result = new Object[length];
+    Object[] result = new Object[length];
     System.arraycopy(elements, offset, result, 0, length);
     return result;
   }
 
-  @CanIgnoreReturnValue
-  private static @Nullable Object[] fillArray(Iterable<?> elements, @Nullable Object[] array) {
+  private static Object[] fillArray(Iterable<?> elements, Object[] array) {
     int i = 0;
     for (Object element : elements) {
       array[i++] = element;
@@ -208,12 +202,10 @@ public final class ObjectArrays {
     array[j] = temp;
   }
 
-  @CanIgnoreReturnValue
   static Object[] checkElementsNotNull(Object... array) {
     return checkElementsNotNull(array, array.length);
   }
 
-  @CanIgnoreReturnValue
   static Object[] checkElementsNotNull(Object[] array, int length) {
     for (int i = 0; i < length; i++) {
       checkElementNotNull(array[i], i);
@@ -223,7 +215,6 @@ public final class ObjectArrays {
 
   // We do this instead of Preconditions.checkNotNull to save boxing and array
   // creation cost.
-  @CanIgnoreReturnValue
   static Object checkElementNotNull(Object element, int index) {
     if (element == null) {
       throw new NullPointerException("at index " + index);
diff --git a/guava/src/com/google/common/collect/Ordering.java b/guava/src/com/google/common/collect/Ordering.java
index 9bf180fc28..aab0ac924e 100644
--- a/guava/src/com/google/common/collect/Ordering.java
+++ b/guava/src/com/google/common/collect/Ordering.java
@@ -19,10 +19,7 @@ package com.google.common.collect;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Function;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -39,7 +36,6 @@ import java.util.TreeSet;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.atomic.AtomicInteger;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A comparator, with additional methods to support common operations. This is an "enriched" version
@@ -144,9 +140,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kevin Bourrillion
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public abstract class Ordering<T extends @Nullable Object> implements Comparator<T> {
+public abstract class Ordering<T extends Object> implements Comparator<T> {
   // Natural order
 
   /**
@@ -158,7 +153,6 @@ public abstract class Ordering<T extends @Nullable Object> implements Comparator
    *
    * <p><b>Java 8 users:</b> use {@link Comparator#naturalOrder} instead.
    */
-  @GwtCompatible(serializable = true)
   @SuppressWarnings("unchecked") // TODO(kevinb): right way to explain this??
   public static <C extends Comparable> Ordering<C> natural() {
     return (Ordering<C>) NaturalOrdering.INSTANCE;
@@ -179,8 +173,7 @@ public abstract class Ordering<T extends @Nullable Object> implements Comparator
    * @return comparator itself if it is already an {@code Ordering}; otherwise an ordering that
    *     wraps that comparator
    */
-  @GwtCompatible(serializable = true)
-  public static <T extends @Nullable Object> Ordering<T> from(Comparator<T> comparator) {
+  public static <T extends Object> Ordering<T> from(Comparator<T> comparator) {
     return (comparator instanceof Ordering)
         ? (Ordering<T>) comparator
         : new ComparatorOrdering<T>(comparator);
@@ -191,9 +184,8 @@ public abstract class Ordering<T extends @Nullable Object> implements Comparator
    *
    * @deprecated no need to use this
    */
-  @GwtCompatible(serializable = true)
   @Deprecated
-  public static <T extends @Nullable Object> Ordering<T> from(Ordering<T> ordering) {
+  public static <T extends Object> Ordering<T> from(Ordering<T> ordering) {
     return checkNotNull(ordering);
   }
 
@@ -217,7 +209,6 @@ public abstract class Ordering<T extends @Nullable Object> implements Comparator
    *     (according to {@link Object#equals})
    */
   // TODO(kevinb): provide replacement
-  @GwtCompatible(serializable = true)
   public static <T> Ordering<T> explicit(List<T> valuesInOrder) {
     return new ExplicitOrdering<T>(valuesInOrder);
   }
@@ -243,7 +234,6 @@ public abstract class Ordering<T extends @Nullable Object> implements Comparator
    *     Object#equals(Object)}) are present among the method arguments
    */
   // TODO(kevinb): provide replacement
-  @GwtCompatible(serializable = true)
   public static <T> Ordering<T> explicit(T leastValue, T... remainingValuesInOrder) {
     return explicit(Lists.asList(leastValue, remainingValuesInOrder));
   }
@@ -278,9 +268,8 @@ public abstract class Ordering<T extends @Nullable Object> implements Comparator
    *
    * @since 13.0
    */
-  @GwtCompatible(serializable = true)
   @SuppressWarnings("unchecked")
-  public static Ordering<@Nullable Object> allEqual() {
+  public static Ordering<Object> allEqual() {
     return AllEqualOrdering.INSTANCE;
   }
 
@@ -292,7 +281,6 @@ public abstract class Ordering<T extends @Nullable Object> implements Comparator
    *
    * <p><b>Java 8 users:</b> Use {@code Comparator.comparing(Object::toString)} instead.
    */
-  @GwtCompatible(serializable = true)
   public static Ordering<Object> usingToString() {
     return UsingToStringOrdering.INSTANCE;
   }
@@ -313,16 +301,15 @@ public abstract class Ordering<T extends @Nullable Object> implements Comparator
    * @since 2.0
    */
   // TODO(kevinb): copy to Comparators, etc.
-  public static Ordering<@Nullable Object> arbitrary() {
+  public static Ordering<Object> arbitrary() {
     return ArbitraryOrderingHolder.ARBITRARY_ORDERING;
   }
 
   private static class ArbitraryOrderingHolder {
-    static final Ordering<@Nullable Object> ARBITRARY_ORDERING = new ArbitraryOrdering();
+    static final Ordering<Object> ARBITRARY_ORDERING = new ArbitraryOrdering();
   }
 
-  @VisibleForTesting
-  static class ArbitraryOrdering extends Ordering<@Nullable Object> {
+  static class ArbitraryOrdering extends Ordering<Object> {
 
     private final AtomicInteger counter = new AtomicInteger(0);
     private final ConcurrentMap<Object, Integer> uids =
@@ -402,7 +389,6 @@ public abstract class Ordering<T extends @Nullable Object> implements Comparator
    */
   // type parameter <S> lets us avoid the extra <String> in statements like:
   // Ordering<String> o = Ordering.<String>natural().reverse();
-  @GwtCompatible(serializable = true)
   public <S extends T> Ordering<S> reverse() {
     return new ReverseOrdering<S>(this);
   }
@@ -415,8 +401,7 @@ public abstract class Ordering<T extends @Nullable Object> implements Comparator
    */
   // type parameter <S> lets us avoid the extra <String> in statements like:
   // Ordering<String> o = Ordering.<String>natural().nullsFirst();
-  @GwtCompatible(serializable = true)
-  public <S extends T> Ordering<@Nullable S> nullsFirst() {
+  public <S extends T> Ordering<S> nullsFirst() {
     return new NullsFirstOrdering<S>(this);
   }
 
@@ -428,8 +413,7 @@ public abstract class Ordering<T extends @Nullable Object> implements Comparator
    */
   // type parameter <S> lets us avoid the extra <String> in statements like:
   // Ordering<String> o = Ordering.<String>natural().nullsLast();
-  @GwtCompatible(serializable = true)
-  public <S extends T> Ordering<@Nullable S> nullsLast() {
+  public <S extends T> Ordering<S> nullsLast() {
     return new NullsLastOrdering<S>(this);
   }
 
@@ -446,8 +430,7 @@ public abstract class Ordering<T extends @Nullable Object> implements Comparator
    * <p><b>Java 8 users:</b> Use {@code Comparator.comparing(function, thisComparator)} instead (you
    * can omit the comparator if it is the natural order).
    */
-  @GwtCompatible(serializable = true)
-  public <F extends @Nullable Object> Ordering<F> onResultOf(Function<F, ? extends T> function) {
+  public <F extends Object> Ordering<F> onResultOf(Function<F, ? extends T> function) {
     return new ByFunctionOrdering<>(function, this);
   }
 
@@ -468,7 +451,6 @@ public abstract class Ordering<T extends @Nullable Object> implements Comparator
    * Depending on what {@code secondaryComparator} is, one of the other overloads of {@code
    * thenComparing} may be even more useful.
    */
-  @GwtCompatible(serializable = true)
   public <U extends T> Ordering<U> compound(Comparator<? super U> secondaryComparator) {
     return new CompoundOrdering<U>(this, checkNotNull(secondaryComparator));
   }
@@ -492,8 +474,7 @@ public abstract class Ordering<T extends @Nullable Object> implements Comparator
    *
    * @param comparators the comparators to try in order
    */
-  @GwtCompatible(serializable = true)
-  public static <T extends @Nullable Object> Ordering<T> compound(
+  public static <T extends Object> Ordering<T> compound(
       Iterable<? extends Comparator<? super T>> comparators) {
     return new CompoundOrdering<T>(comparators);
   }
@@ -513,7 +494,6 @@ public abstract class Ordering<T extends @Nullable Object> implements Comparator
    *
    * @since 2.0
    */
-  @GwtCompatible(serializable = true)
   // type parameter <S> lets us avoid the extra <String> in statements like:
   // Ordering<Iterable<String>> o =
   //     Ordering.<String>natural().lexicographical();
@@ -530,7 +510,7 @@ public abstract class Ordering<T extends @Nullable Object> implements Comparator
 
   // Regular instance methods
 
-  @CanIgnoreReturnValue // TODO(kak): Consider removing this
+  // TODO(kak): Consider removing this
   @Override
   public abstract int compare(@ParametricNullness T left, @ParametricNullness T right);
 
@@ -943,7 +923,6 @@ public abstract class Ordering<T extends @Nullable Object> implements Comparator
    * Object[])} comparator when comparing a value outside the set of values it can compare.
    * Extending {@link ClassCastException} may seem odd, but it is required.
    */
-  @VisibleForTesting
   static class IncomparableValueException extends ClassCastException {
     final Object value;
 
diff --git a/guava/src/com/google/common/collect/ParametricNullness.java b/guava/src/com/google/common/collect/ParametricNullness.java
index b1cda482c2..cc82d5cb56 100644
--- a/guava/src/com/google/common/collect/ParametricNullness.java
+++ b/guava/src/com/google/common/collect/ParametricNullness.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import static javax.annotation.meta.When.UNKNOWN;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -35,7 +34,6 @@ import javax.annotation.meta.TypeQualifierNickname;
  * href="https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/NullFromTypeParam.java">{@code
  * NullFromTypeParam}</a>). We use this to "undo" {@link ElementTypesAreNonnullByDefault}.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target({FIELD, METHOD, PARAMETER})
 @TypeQualifierNickname
diff --git a/guava/src/com/google/common/collect/PeekingIterator.java b/guava/src/com/google/common/collect/PeekingIterator.java
index a274fe454a..9ce5773739 100644
--- a/guava/src/com/google/common/collect/PeekingIterator.java
+++ b/guava/src/com/google/common/collect/PeekingIterator.java
@@ -16,12 +16,8 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotMock;
 import java.util.Iterator;
 import java.util.NoSuchElementException;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An iterator that supports a one-element lookahead while iterating.
@@ -33,10 +29,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Mick Killianey
  * @since 2.0
  */
-@DoNotMock("Use Iterators.peekingIterator")
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public interface PeekingIterator<E extends @Nullable Object> extends Iterator<E> {
+public interface PeekingIterator<E extends Object> extends Iterator<E> {
   /**
    * Returns the next element in the iteration, without advancing the iteration.
    *
@@ -55,7 +49,6 @@ public interface PeekingIterator<E extends @Nullable Object> extends Iterator<E>
    * <p>The objects returned by consecutive calls to {@link #peek()} then {@link #next()} are
    * guaranteed to be equal to each other.
    */
-  @CanIgnoreReturnValue
   @Override
   @ParametricNullness
   E next();
diff --git a/guava/src/com/google/common/collect/Platform.java b/guava/src/com/google/common/collect/Platform.java
index b1d6b2f438..ba3bd8bb51 100644
--- a/guava/src/com/google/common/collect/Platform.java
+++ b/guava/src/com/google/common/collect/Platform.java
@@ -16,27 +16,24 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.reflect.Array;
 import java.util.Arrays;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Methods factored out so that they can be emulated differently in GWT.
  *
  * @author Hayward Chan
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 final class Platform {
   private static final java.util.logging.Logger logger =
       java.util.logging.Logger.getLogger(Platform.class.getName());
 
   /** Returns the platform preferred implementation of a map based on a hash table. */
-  static <K extends @Nullable Object, V extends @Nullable Object>
+  static <K extends Object, V extends Object>
       Map<K, V> newHashMapWithExpectedSize(int expectedSize) {
     return Maps.newHashMapWithExpectedSize(expectedSize);
   }
@@ -45,13 +42,13 @@ final class Platform {
    * Returns the platform preferred implementation of an insertion ordered map based on a hash
    * table.
    */
-  static <K extends @Nullable Object, V extends @Nullable Object>
+  static <K extends Object, V extends Object>
       Map<K, V> newLinkedHashMapWithExpectedSize(int expectedSize) {
     return Maps.newLinkedHashMapWithExpectedSize(expectedSize);
   }
 
   /** Returns the platform preferred implementation of a set based on a hash table. */
-  static <E extends @Nullable Object> Set<E> newHashSetWithExpectedSize(int expectedSize) {
+  static <E extends Object> Set<E> newHashSetWithExpectedSize(int expectedSize) {
     return Sets.newHashSetWithExpectedSize(expectedSize);
   }
 
@@ -64,7 +61,7 @@ final class Platform {
    * Returns the platform preferred implementation of an insertion ordered set based on a hash
    * table.
    */
-  static <E extends @Nullable Object> Set<E> newLinkedHashSetWithExpectedSize(int expectedSize) {
+  static <E extends Object> Set<E> newLinkedHashSetWithExpectedSize(int expectedSize) {
     return Sets.newLinkedHashSetWithExpectedSize(expectedSize);
   }
 
@@ -72,7 +69,7 @@ final class Platform {
    * Returns the platform preferred map implementation that preserves insertion order when used only
    * for insertions.
    */
-  static <K extends @Nullable Object, V extends @Nullable Object>
+  static <K extends Object, V extends Object>
       Map<K, V> preservesInsertionOrderOnPutsMap() {
     return Maps.newLinkedHashMap();
   }
@@ -81,7 +78,7 @@ final class Platform {
    * Returns the platform preferred set implementation that preserves insertion order when used only
    * for insertions.
    */
-  static <E extends @Nullable Object> Set<E> preservesInsertionOrderOnAddsSet() {
+  static <E extends Object> Set<E> preservesInsertionOrderOnAddsSet() {
     return Sets.newLinkedHashSet();
   }
 
@@ -97,7 +94,7 @@ final class Platform {
    * about arrays for now, as they're a mess. (We previously discussed this in the review of
    * ObjectArrays, which is the main caller of this method.)
    */
-  static <T extends @Nullable Object> T[] newArray(T[] reference, int length) {
+  static <T extends Object> T[] newArray(T[] reference, int length) {
     Class<?> type = reference.getClass().getComponentType();
 
     // the cast is safe because
@@ -117,7 +114,7 @@ final class Platform {
    * - https://github.com/jspecify/jdk/commit/71d826792b8c7ef95d492c50a274deab938f2552
    */
   @SuppressWarnings("nullness")
-  static <T extends @Nullable Object> T[] copy(Object[] source, int from, int to, T[] arrayOfType) {
+  static <T extends Object> T[] copy(Object[] source, int from, int to, T[] arrayOfType) {
     return Arrays.copyOfRange(source, from, to, (Class<? extends T[]>) arrayOfType.getClass());
   }
 
diff --git a/guava/src/com/google/common/collect/Queues.java b/guava/src/com/google/common/collect/Queues.java
index a140102fd6..2e31130f38 100644
--- a/guava/src/com/google/common/collect/Queues.java
+++ b/guava/src/com/google/common/collect/Queues.java
@@ -14,11 +14,7 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Preconditions;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.ArrayDeque;
 import java.util.Collection;
 import java.util.Deque;
@@ -32,7 +28,6 @@ import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.PriorityBlockingQueue;
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.TimeUnit;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to {@link Queue} and {@link Deque} instances. Also see this
@@ -41,7 +36,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kurt Alfred Kluever
  * @since 11.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class Queues {
   private Queues() {}
@@ -52,7 +46,7 @@ public final class Queues {
    * Creates an empty {@code ArrayBlockingQueue} with the given (fixed) capacity and nonfair access
    * policy.
    */
-  @GwtIncompatible // ArrayBlockingQueue
+  // ArrayBlockingQueue
   public static <E> ArrayBlockingQueue<E> newArrayBlockingQueue(int capacity) {
     return new ArrayBlockingQueue<E>(capacity);
   }
@@ -86,7 +80,7 @@ public final class Queues {
   // ConcurrentLinkedQueue
 
   /** Creates an empty {@code ConcurrentLinkedQueue}. */
-  @GwtIncompatible // ConcurrentLinkedQueue
+  // ConcurrentLinkedQueue
   public static <E> ConcurrentLinkedQueue<E> newConcurrentLinkedQueue() {
     return new ConcurrentLinkedQueue<E>();
   }
@@ -95,7 +89,7 @@ public final class Queues {
    * Creates a {@code ConcurrentLinkedQueue} containing the elements of the specified iterable, in
    * the order they are returned by the iterable's iterator.
    */
-  @GwtIncompatible // ConcurrentLinkedQueue
+  // ConcurrentLinkedQueue
   public static <E> ConcurrentLinkedQueue<E> newConcurrentLinkedQueue(
       Iterable<? extends E> elements) {
     if (elements instanceof Collection) {
@@ -113,7 +107,7 @@ public final class Queues {
    *
    * @since 12.0
    */
-  @GwtIncompatible // LinkedBlockingDeque
+  // LinkedBlockingDeque
   public static <E> LinkedBlockingDeque<E> newLinkedBlockingDeque() {
     return new LinkedBlockingDeque<E>();
   }
@@ -124,7 +118,7 @@ public final class Queues {
    * @throws IllegalArgumentException if {@code capacity} is less than 1
    * @since 12.0
    */
-  @GwtIncompatible // LinkedBlockingDeque
+  // LinkedBlockingDeque
   public static <E> LinkedBlockingDeque<E> newLinkedBlockingDeque(int capacity) {
     return new LinkedBlockingDeque<E>(capacity);
   }
@@ -136,7 +130,7 @@ public final class Queues {
    *
    * @since 12.0
    */
-  @GwtIncompatible // LinkedBlockingDeque
+  // LinkedBlockingDeque
   public static <E> LinkedBlockingDeque<E> newLinkedBlockingDeque(Iterable<? extends E> elements) {
     if (elements instanceof Collection) {
       return new LinkedBlockingDeque<E>((Collection<? extends E>) elements);
@@ -149,7 +143,7 @@ public final class Queues {
   // LinkedBlockingQueue
 
   /** Creates an empty {@code LinkedBlockingQueue} with a capacity of {@link Integer#MAX_VALUE}. */
-  @GwtIncompatible // LinkedBlockingQueue
+  // LinkedBlockingQueue
   public static <E> LinkedBlockingQueue<E> newLinkedBlockingQueue() {
     return new LinkedBlockingQueue<E>();
   }
@@ -159,7 +153,7 @@ public final class Queues {
    *
    * @throws IllegalArgumentException if {@code capacity} is less than 1
    */
-  @GwtIncompatible // LinkedBlockingQueue
+  // LinkedBlockingQueue
   public static <E> LinkedBlockingQueue<E> newLinkedBlockingQueue(int capacity) {
     return new LinkedBlockingQueue<E>(capacity);
   }
@@ -172,7 +166,7 @@ public final class Queues {
    * @param elements the elements that the queue should contain, in order
    * @return a new {@code LinkedBlockingQueue} containing those elements
    */
-  @GwtIncompatible // LinkedBlockingQueue
+  // LinkedBlockingQueue
   public static <E> LinkedBlockingQueue<E> newLinkedBlockingQueue(Iterable<? extends E> elements) {
     if (elements instanceof Collection) {
       return new LinkedBlockingQueue<E>((Collection<? extends E>) elements);
@@ -193,7 +187,7 @@ public final class Queues {
    * @since 11.0 (but the bound of {@code E} was changed from {@code Object} to {@code Comparable}
    *     in 15.0)
    */
-  @GwtIncompatible // PriorityBlockingQueue
+  // PriorityBlockingQueue
   public static <E extends Comparable> PriorityBlockingQueue<E> newPriorityBlockingQueue() {
     return new PriorityBlockingQueue<E>();
   }
@@ -207,7 +201,7 @@ public final class Queues {
    * @since 11.0 (but the bound of {@code E} was changed from {@code Object} to {@code Comparable}
    *     in 15.0)
    */
-  @GwtIncompatible // PriorityBlockingQueue
+  // PriorityBlockingQueue
   public static <E extends Comparable> PriorityBlockingQueue<E> newPriorityBlockingQueue(
       Iterable<? extends E> elements) {
     if (elements instanceof Collection) {
@@ -253,7 +247,7 @@ public final class Queues {
   // SynchronousQueue
 
   /** Creates an empty {@code SynchronousQueue} with nonfair access policy. */
-  @GwtIncompatible // SynchronousQueue
+  // SynchronousQueue
   public static <E> SynchronousQueue<E> newSynchronousQueue() {
     return new SynchronousQueue<E>();
   }
@@ -270,9 +264,7 @@ public final class Queues {
    * @throws InterruptedException if interrupted while waiting
    * @since 28.0
    */
-  @Beta
-  @CanIgnoreReturnValue
-  @GwtIncompatible // BlockingQueue
+  // BlockingQueue
   public static <E> int drain(
       BlockingQueue<E> q, Collection<? super E> buffer, int numElements, java.time.Duration timeout)
       throws InterruptedException {
@@ -292,9 +284,7 @@ public final class Queues {
    * @return the number of elements transferred
    * @throws InterruptedException if interrupted while waiting
    */
-  @Beta
-  @CanIgnoreReturnValue
-  @GwtIncompatible // BlockingQueue
+  // BlockingQueue
   @SuppressWarnings("GoodTime") // should accept a java.time.Duration
   public static <E> int drain(
       BlockingQueue<E> q,
@@ -340,9 +330,7 @@ public final class Queues {
    * @return the number of elements transferred
    * @since 28.0
    */
-  @Beta
-  @CanIgnoreReturnValue
-  @GwtIncompatible // BlockingQueue
+  // BlockingQueue
   public static <E> int drainUninterruptibly(
       BlockingQueue<E> q,
       Collection<? super E> buffer,
@@ -365,9 +353,7 @@ public final class Queues {
    * @param unit a {@code TimeUnit} determining how to interpret the timeout parameter
    * @return the number of elements transferred
    */
-  @Beta
-  @CanIgnoreReturnValue
-  @GwtIncompatible // BlockingQueue
+  // BlockingQueue
   @SuppressWarnings("GoodTime") // should accept a java.time.Duration
   public static <E> int drainUninterruptibly(
       BlockingQueue<E> q,
@@ -438,7 +424,7 @@ public final class Queues {
    * @return a synchronized view of the specified queue
    * @since 14.0
    */
-  public static <E extends @Nullable Object> Queue<E> synchronizedQueue(Queue<E> queue) {
+  public static <E extends Object> Queue<E> synchronizedQueue(Queue<E> queue) {
     return Synchronized.queue(queue, null);
   }
 
@@ -471,7 +457,7 @@ public final class Queues {
    * @return a synchronized view of the specified deque
    * @since 15.0
    */
-  public static <E extends @Nullable Object> Deque<E> synchronizedDeque(Deque<E> deque) {
+  public static <E extends Object> Deque<E> synchronizedDeque(Deque<E> deque) {
     return Synchronized.deque(deque, null);
   }
 }
diff --git a/guava/src/com/google/common/collect/Range.java b/guava/src/com/google/common/collect/Range.java
index ab5c077937..4bab6add2b 100644
--- a/guava/src/com/google/common/collect/Range.java
+++ b/guava/src/com/google/common/collect/Range.java
@@ -18,7 +18,6 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Function;
 import com.google.common.base.Predicate;
@@ -115,7 +114,6 @@ import javax.annotation.CheckForNull;
  * @author Gregory Kick
  * @since 10.0
  */
-@GwtCompatible
 @SuppressWarnings("rawtypes")
 @ElementTypesAreNonnullByDefault
 public final class Range<C extends Comparable> extends RangeGwtSerializationDependencies
diff --git a/guava/src/com/google/common/collect/RangeGwtSerializationDependencies.java b/guava/src/com/google/common/collect/RangeGwtSerializationDependencies.java
index 222c1285fb..1b22630eea 100644
--- a/guava/src/com/google/common/collect/RangeGwtSerializationDependencies.java
+++ b/guava/src/com/google/common/collect/RangeGwtSerializationDependencies.java
@@ -16,7 +16,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 
 /**
@@ -28,5 +27,4 @@ import java.io.Serializable;
  *
  * <p>TODO(cpovirk): Consider applying this subclass approach to our other types.
  */
-@GwtCompatible(emulated = true)
 abstract class RangeGwtSerializationDependencies<C extends Comparable> implements Serializable {}
diff --git a/guava/src/com/google/common/collect/RangeMap.java b/guava/src/com/google/common/collect/RangeMap.java
index 99e7b97d5e..a5488cb635 100644
--- a/guava/src/com/google/common/collect/RangeMap.java
+++ b/guava/src/com/google/common/collect/RangeMap.java
@@ -16,16 +16,12 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.DoNotMock;
 import java.util.Collection;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.NoSuchElementException;
 import java.util.function.BiFunction;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A mapping from disjoint nonempty ranges to non-null values. Queries look up the value associated
@@ -37,9 +33,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 14.0
  */
-@Beta
-@DoNotMock("Use ImmutableRangeMap or TreeRangeMap")
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public interface RangeMap<K extends Comparable, V> {
   /*
@@ -138,7 +131,7 @@ public interface RangeMap<K extends Comparable, V> {
   void merge(
       Range<K> range,
       @CheckForNull V value,
-      BiFunction<? super V, ? super @Nullable V, ? extends @Nullable V> remappingFunction);
+      BiFunction<? super V, ? super V, ? extends V> remappingFunction);
 
   /**
    * Returns a view of this range map as an unmodifiable {@code Map<Range<K>, V>}. Modifications to
diff --git a/guava/src/com/google/common/collect/RangeSet.java b/guava/src/com/google/common/collect/RangeSet.java
index 1fb7b10fcb..401d3f6632 100644
--- a/guava/src/com/google/common/collect/RangeSet.java
+++ b/guava/src/com/google/common/collect/RangeSet.java
@@ -14,9 +14,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.DoNotMock;
 import java.util.NoSuchElementException;
 import java.util.Set;
 import javax.annotation.CheckForNull;
@@ -49,9 +46,6 @@ import javax.annotation.CheckForNull;
  * @author Louis Wasserman
  * @since 14.0
  */
-@Beta
-@DoNotMock("Use ImmutableRangeSet or TreeRangeSet")
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public interface RangeSet<C extends Comparable> {
   // TODO(lowasser): consider adding default implementations of some of these methods
diff --git a/guava/src/com/google/common/collect/RegularContiguousSet.java b/guava/src/com/google/common/collect/RegularContiguousSet.java
index 913e2d7d3f..903a4ac97a 100644
--- a/guava/src/com/google/common/collect/RegularContiguousSet.java
+++ b/guava/src/com/google/common/collect/RegularContiguousSet.java
@@ -20,8 +20,6 @@ import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.BoundType.CLOSED;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import java.io.Serializable;
 import java.util.Collection;
 import javax.annotation.CheckForNull;
@@ -31,7 +29,6 @@ import javax.annotation.CheckForNull;
  *
  * @author Gregory Kick
  */
-@GwtCompatible(emulated = true)
 @SuppressWarnings("unchecked") // allow ungenerified Comparable types
 @ElementTypesAreNonnullByDefault
 final class RegularContiguousSet<C extends Comparable> extends ContiguousSet<C> {
@@ -71,7 +68,7 @@ final class RegularContiguousSet<C extends Comparable> extends ContiguousSet<C>
     return intersectionInCurrentDomain(Range.downTo(fromElement, BoundType.forBoolean(inclusive)));
   }
 
-  @GwtIncompatible // not used by GWT emulation
+  // not used by GWT emulation
   @Override
   int indexOf(@CheckForNull Object target) {
     // requireNonNull is safe because of the contains check.
@@ -91,7 +88,7 @@ final class RegularContiguousSet<C extends Comparable> extends ContiguousSet<C>
     };
   }
 
-  @GwtIncompatible // NavigableSet
+  // NavigableSet
   @Override
   public UnmodifiableIterator<C> descendingIterator() {
     return new AbstractSequentialIterator<C>(last()) {
@@ -220,7 +217,7 @@ final class RegularContiguousSet<C extends Comparable> extends ContiguousSet<C>
     return Sets.hashCodeImpl(this);
   }
 
-  @GwtIncompatible // serialization
+  // serialization
   private static final class SerializedForm<C extends Comparable> implements Serializable {
     final Range<C> range;
     final DiscreteDomain<C> domain;
@@ -235,7 +232,7 @@ final class RegularContiguousSet<C extends Comparable> extends ContiguousSet<C>
     }
   }
 
-  @GwtIncompatible // serialization
+  // serialization
   @Override
   Object writeReplace() {
     return new SerializedForm<C>(range, domain);
diff --git a/guava/src/com/google/common/collect/RegularImmutableAsList.java b/guava/src/com/google/common/collect/RegularImmutableAsList.java
index 0e3fe4ec8f..eaead6b03f 100644
--- a/guava/src/com/google/common/collect/RegularImmutableAsList.java
+++ b/guava/src/com/google/common/collect/RegularImmutableAsList.java
@@ -16,11 +16,8 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import java.util.function.Consumer;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An {@link ImmutableAsList} implementation specialized for when the delegate collection is already
@@ -28,7 +25,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @author Louis Wasserman
  */
-@GwtCompatible(emulated = true)
 @SuppressWarnings("serial") // uses writeReplace, not default serialization
 @ElementTypesAreNonnullByDefault
 class RegularImmutableAsList<E> extends ImmutableAsList<E> {
@@ -59,15 +55,15 @@ class RegularImmutableAsList<E> extends ImmutableAsList<E> {
     return (UnmodifiableListIterator<E>) delegateList.listIterator(index);
   }
 
-  @GwtIncompatible // not present in emulated superclass
+  // not present in emulated superclass
   @Override
   public void forEach(Consumer<? super E> action) {
     delegateList.forEach(action);
   }
 
-  @GwtIncompatible // not present in emulated superclass
+  // not present in emulated superclass
   @Override
-  int copyIntoArray(@Nullable Object[] dst, int offset) {
+  int copyIntoArray(Object[] dst, int offset) {
     return delegateList.copyIntoArray(dst, offset);
   }
 
diff --git a/guava/src/com/google/common/collect/RegularImmutableBiMap.java b/guava/src/com/google/common/collect/RegularImmutableBiMap.java
index 60d22e2b8f..483092dc96 100644
--- a/guava/src/com/google/common/collect/RegularImmutableBiMap.java
+++ b/guava/src/com/google/common/collect/RegularImmutableBiMap.java
@@ -23,24 +23,17 @@ import static com.google.common.collect.ImmutableMapEntry.createEntryArray;
 import static com.google.common.collect.RegularImmutableMap.checkNoConflictInKeyBucket;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableMapEntry.NonTerminalImmutableBiMapEntry;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.concurrent.LazyInit;
-import com.google.j2objc.annotations.RetainedWith;
 import java.io.Serializable;
 import java.util.function.BiConsumer;
 import java.util.function.Consumer;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Bimap with zero or more mappings.
  *
  * @author Louis Wasserman
  */
-@GwtCompatible(serializable = true, emulated = true)
 @SuppressWarnings("serial") // uses writeReplace(), not default serialization
 @ElementTypesAreNonnullByDefault
 class RegularImmutableBiMap<K, V> extends ImmutableBiMap<K, V> {
@@ -50,9 +43,9 @@ class RegularImmutableBiMap<K, V> extends ImmutableBiMap<K, V> {
 
   static final double MAX_LOAD_FACTOR = 1.2;
 
-  @CheckForNull private final transient @Nullable ImmutableMapEntry<K, V>[] keyTable;
-  @CheckForNull private final transient @Nullable ImmutableMapEntry<K, V>[] valueTable;
-  @VisibleForTesting final transient Entry<K, V>[] entries;
+  @CheckForNull private final transient ImmutableMapEntry<K, V>[] keyTable;
+  @CheckForNull private final transient ImmutableMapEntry<K, V>[] valueTable;
+  final transient Entry<K, V>[] entries;
   private final transient int mask;
   private final transient int hashCode;
 
@@ -60,12 +53,12 @@ class RegularImmutableBiMap<K, V> extends ImmutableBiMap<K, V> {
     return fromEntryArray(entries.length, entries);
   }
 
-  static <K, V> ImmutableBiMap<K, V> fromEntryArray(int n, @Nullable Entry<K, V>[] entryArray) {
+  static <K, V> ImmutableBiMap<K, V> fromEntryArray(int n, Entry<K, V>[] entryArray) {
     checkPositionIndex(n, entryArray.length);
     int tableSize = Hashing.closedTableSize(n, MAX_LOAD_FACTOR);
     int mask = tableSize - 1;
-    @Nullable ImmutableMapEntry<K, V>[] keyTable = createEntryArray(tableSize);
-    @Nullable ImmutableMapEntry<K, V>[] valueTable = createEntryArray(tableSize);
+    ImmutableMapEntry<K, V>[] keyTable = createEntryArray(tableSize);
+    ImmutableMapEntry<K, V>[] valueTable = createEntryArray(tableSize);
     /*
      * The cast is safe: n==entryArray.length means that we have filled the whole array with Entry
      * instances, in which case it is safe to cast it from an array of nullable entries to an array
@@ -109,8 +102,8 @@ class RegularImmutableBiMap<K, V> extends ImmutableBiMap<K, V> {
   }
 
   private RegularImmutableBiMap(
-      @CheckForNull @Nullable ImmutableMapEntry<K, V>[] keyTable,
-      @CheckForNull @Nullable ImmutableMapEntry<K, V>[] valueTable,
+      @CheckForNull ImmutableMapEntry<K, V>[] keyTable,
+      @CheckForNull ImmutableMapEntry<K, V>[] valueTable,
       Entry<K, V>[] entries,
       int mask,
       int hashCode) {
@@ -127,7 +120,6 @@ class RegularImmutableBiMap<K, V> extends ImmutableBiMap<K, V> {
    * @return number of entries in this bucket
    * @throws IllegalArgumentException if another entry in the bucket has the same key
    */
-  @CanIgnoreReturnValue
   private static int checkNoConflictInValueBucket(
       Object value, Entry<?, ?> entry, @CheckForNull ImmutableMapEntry<?, ?> valueBucketHead) {
     int bucketSize = 0;
@@ -184,7 +176,7 @@ class RegularImmutableBiMap<K, V> extends ImmutableBiMap<K, V> {
     return entries.length;
   }
 
-  @LazyInit @RetainedWith @CheckForNull private transient ImmutableBiMap<V, K> inverse;
+  @CheckForNull private transient ImmutableBiMap<V, K> inverse;
 
   @Override
   public ImmutableBiMap<V, K> inverse() {
diff --git a/guava/src/com/google/common/collect/RegularImmutableList.java b/guava/src/com/google/common/collect/RegularImmutableList.java
index 397147d70d..62b8e3824a 100644
--- a/guava/src/com/google/common/collect/RegularImmutableList.java
+++ b/guava/src/com/google/common/collect/RegularImmutableList.java
@@ -16,24 +16,20 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.VisibleForTesting;
 import java.util.Spliterator;
 import java.util.Spliterators;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@link ImmutableList} backed by a simple array.
  *
  * @author Kevin Bourrillion
  */
-@GwtCompatible(serializable = true, emulated = true)
 @SuppressWarnings("serial") // uses writeReplace(), not default serialization
 @ElementTypesAreNonnullByDefault
 class RegularImmutableList<E> extends ImmutableList<E> {
   static final ImmutableList<Object> EMPTY = new RegularImmutableList<>(new Object[0]);
 
-  @VisibleForTesting final transient Object[] array;
+  final transient Object[] array;
 
   RegularImmutableList(Object[] array) {
     this.array = array;
@@ -65,7 +61,7 @@ class RegularImmutableList<E> extends ImmutableList<E> {
   }
 
   @Override
-  int copyIntoArray(@Nullable Object[] dst, int dstOff) {
+  int copyIntoArray(Object[] dst, int dstOff) {
     System.arraycopy(array, 0, dst, dstOff, array.length);
     return dstOff + array.length;
   }
diff --git a/guava/src/com/google/common/collect/RegularImmutableMap.java b/guava/src/com/google/common/collect/RegularImmutableMap.java
index 43425b2ecb..40280d3f8f 100644
--- a/guava/src/com/google/common/collect/RegularImmutableMap.java
+++ b/guava/src/com/google/common/collect/RegularImmutableMap.java
@@ -22,15 +22,10 @@ import static com.google.common.collect.CollectPreconditions.checkEntryNotNull;
 import static com.google.common.collect.ImmutableMapEntry.createEntryArray;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableMapEntry.NonTerminalImmutableMapEntry;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.Serializable;
 import java.util.function.BiConsumer;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@link ImmutableMap} with two or more entries.
@@ -39,7 +34,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kevin Bourrillion
  * @author Gregory Kick
  */
-@GwtCompatible(serializable = true, emulated = true)
 @ElementTypesAreNonnullByDefault
 final class RegularImmutableMap<K, V> extends ImmutableMap<K, V> {
   @SuppressWarnings("unchecked")
@@ -51,24 +45,24 @@ final class RegularImmutableMap<K, V> extends ImmutableMap<K, V> {
    * ensures that the table is still likely to be relatively sparse (hence it misses fast) while
    * saving space.
    */
-  @VisibleForTesting static final double MAX_LOAD_FACTOR = 1.2;
+  static final double MAX_LOAD_FACTOR = 1.2;
 
   /**
    * Maximum allowed false positive probability of detecting a hash flooding attack given random
    * input.
    */
-  @VisibleForTesting static final double HASH_FLOODING_FPP = 0.001;
+  static final double HASH_FLOODING_FPP = 0.001;
 
   /**
    * Maximum allowed length of a hash table bucket before falling back to a j.u.HashMap based
    * implementation. Experimentally determined.
    */
-  @VisibleForTesting static final int MAX_HASH_BUCKET_LENGTH = 8;
+  static final int MAX_HASH_BUCKET_LENGTH = 8;
 
   // entries in insertion order
-  @VisibleForTesting final transient Entry<K, V>[] entries;
+  final transient Entry<K, V>[] entries;
   // array of linked lists of entries
-  @CheckForNull private final transient @Nullable ImmutableMapEntry<K, V>[] table;
+  @CheckForNull private final transient ImmutableMapEntry<K, V>[] table;
   // 'and' with an int to get a table index
   private final transient int mask;
 
@@ -81,7 +75,7 @@ final class RegularImmutableMap<K, V> extends ImmutableMap<K, V> {
    * the entries in entryArray with its own entry objects (though they will have the same key/value
    * contents), and may take ownership of entryArray.
    */
-  static <K, V> ImmutableMap<K, V> fromEntryArray(int n, @Nullable Entry<K, V>[] entryArray) {
+  static <K, V> ImmutableMap<K, V> fromEntryArray(int n, Entry<K, V>[] entryArray) {
     checkPositionIndex(n, entryArray.length);
     if (n == 0) {
       return (RegularImmutableMap<K, V>) EMPTY;
@@ -95,7 +89,7 @@ final class RegularImmutableMap<K, V> extends ImmutableMap<K, V> {
     Entry<K, V>[] entries =
         (n == entryArray.length) ? (Entry<K, V>[]) entryArray : createEntryArray(n);
     int tableSize = Hashing.closedTableSize(n, MAX_LOAD_FACTOR);
-    @Nullable ImmutableMapEntry<K, V>[] table = createEntryArray(tableSize);
+    ImmutableMapEntry<K, V>[] table = createEntryArray(tableSize);
     int mask = tableSize - 1;
     for (int entryIndex = 0; entryIndex < n; entryIndex++) {
       // requireNonNull is safe because the first `n` elements have been filled in.
@@ -135,7 +129,7 @@ final class RegularImmutableMap<K, V> extends ImmutableMap<K, V> {
   }
 
   private RegularImmutableMap(
-      Entry<K, V>[] entries, @CheckForNull @Nullable ImmutableMapEntry<K, V>[] table, int mask) {
+      Entry<K, V>[] entries, @CheckForNull ImmutableMapEntry<K, V>[] table, int mask) {
     this.entries = entries;
     this.table = table;
     this.mask = mask;
@@ -145,7 +139,6 @@ final class RegularImmutableMap<K, V> extends ImmutableMap<K, V> {
    * @return number of entries in this bucket
    * @throws IllegalArgumentException if another entry in the bucket has the same key
    */
-  @CanIgnoreReturnValue
   static int checkNoConflictInKeyBucket(
       Object key, Entry<?, ?> entry, @CheckForNull ImmutableMapEntry<?, ?> keyBucketHead) {
     int bucketSize = 0;
@@ -165,7 +158,7 @@ final class RegularImmutableMap<K, V> extends ImmutableMap<K, V> {
   @CheckForNull
   static <V> V get(
       @CheckForNull Object key,
-      @CheckForNull @Nullable ImmutableMapEntry<?, V>[] keyTable,
+      @CheckForNull ImmutableMapEntry<?, V>[] keyTable,
       int mask) {
     if (key == null || keyTable == null) {
       return null;
@@ -217,7 +210,6 @@ final class RegularImmutableMap<K, V> extends ImmutableMap<K, V> {
     return new KeySet<>(this);
   }
 
-  @GwtCompatible(emulated = true)
   private static final class KeySet<K> extends IndexedImmutableSet<K> {
     private final RegularImmutableMap<K, ?> map;
 
@@ -246,7 +238,7 @@ final class RegularImmutableMap<K, V> extends ImmutableMap<K, V> {
     }
 
     // No longer used for new writes, but kept so that old data can still be read.
-    @GwtIncompatible // serialization
+    // serialization
     @SuppressWarnings("unused")
     private static class SerializedForm<K> implements Serializable {
       final ImmutableMap<K, ?> map;
@@ -268,7 +260,6 @@ final class RegularImmutableMap<K, V> extends ImmutableMap<K, V> {
     return new Values<>(this);
   }
 
-  @GwtCompatible(emulated = true)
   private static final class Values<K, V> extends ImmutableList<V> {
     final RegularImmutableMap<K, V> map;
 
@@ -292,7 +283,7 @@ final class RegularImmutableMap<K, V> extends ImmutableMap<K, V> {
     }
 
     // No longer used for new writes, but kept so that old data can still be read.
-    @GwtIncompatible // serialization
+    // serialization
     @SuppressWarnings("unused")
     private static class SerializedForm<V> implements Serializable {
       final ImmutableMap<?, V> map;
diff --git a/guava/src/com/google/common/collect/RegularImmutableMultiset.java b/guava/src/com/google/common/collect/RegularImmutableMultiset.java
index 026919e0d5..d6a1608383 100644
--- a/guava/src/com/google/common/collect/RegularImmutableMultiset.java
+++ b/guava/src/com/google/common/collect/RegularImmutableMultiset.java
@@ -16,16 +16,12 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Objects;
 import com.google.common.collect.Multisets.ImmutableEntry;
 import com.google.common.primitives.Ints;
-import com.google.errorprone.annotations.concurrent.LazyInit;
 import java.util.Arrays;
 import java.util.Collection;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@link ImmutableMultiset} with zero or more elements.
@@ -33,7 +29,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Jared Levy
  * @author Louis Wasserman
  */
-@GwtCompatible(emulated = true, serializable = true)
 @SuppressWarnings("serial") // uses writeReplace(), not default serialization
 @ElementTypesAreNonnullByDefault
 class RegularImmutableMultiset<E> extends ImmutableMultiset<E> {
@@ -50,8 +45,7 @@ class RegularImmutableMultiset<E> extends ImmutableMultiset<E> {
     int tableSize = Hashing.closedTableSize(distinct, MAX_LOAD_FACTOR);
     int mask = tableSize - 1;
     @SuppressWarnings({"unchecked", "rawtypes"})
-    @Nullable
-    ImmutableEntry<E>[] hashTable = new @Nullable ImmutableEntry[tableSize];
+    ImmutableEntry<E>[] hashTable = new ImmutableEntry[tableSize];
 
     int index = 0;
     int hashCode = 0;
@@ -85,7 +79,7 @@ class RegularImmutableMultiset<E> extends ImmutableMultiset<E> {
             entryArray, hashTable, Ints.saturatedCast(size), hashCode, null);
   }
 
-  private static boolean hashFloodingDetected(@Nullable ImmutableEntry<?>[] hashTable) {
+  private static boolean hashFloodingDetected(ImmutableEntry<?>[] hashTable) {
     for (int i = 0; i < hashTable.length; i++) {
       int bucketLength = 0;
       for (ImmutableEntry<?> entry = hashTable[i]; entry != null; entry = entry.nextInBucket()) {
@@ -103,30 +97,30 @@ class RegularImmutableMultiset<E> extends ImmutableMultiset<E> {
    * ensures that the table is still likely to be relatively sparse (hence it misses fast) while
    * saving space.
    */
-  @VisibleForTesting static final double MAX_LOAD_FACTOR = 1.0;
+  static final double MAX_LOAD_FACTOR = 1.0;
 
   /**
    * Maximum allowed false positive probability of detecting a hash flooding attack given random
    * input.
    */
-  @VisibleForTesting static final double HASH_FLOODING_FPP = 0.001;
+  static final double HASH_FLOODING_FPP = 0.001;
 
   /**
    * Maximum allowed length of a hash table bucket before falling back to a j.u.HashMap based
    * implementation. Experimentally determined.
    */
-  @VisibleForTesting static final int MAX_HASH_BUCKET_LENGTH = 9;
+  static final int MAX_HASH_BUCKET_LENGTH = 9;
 
   private final transient ImmutableEntry<E>[] entries;
-  private final transient @Nullable ImmutableEntry<?>[] hashTable;
+  private final transient ImmutableEntry<?>[] hashTable;
   private final transient int size;
   private final transient int hashCode;
 
-  @LazyInit @CheckForNull private transient ImmutableSet<E> elementSet;
+  @CheckForNull private transient ImmutableSet<E> elementSet;
 
   private RegularImmutableMultiset(
       ImmutableEntry<E>[] entries,
-      @Nullable ImmutableEntry<?>[] hashTable,
+      ImmutableEntry<?>[] hashTable,
       int size,
       int hashCode,
       @CheckForNull ImmutableSet<E> elementSet) {
@@ -158,7 +152,7 @@ class RegularImmutableMultiset<E> extends ImmutableMultiset<E> {
 
   @Override
   public int count(@CheckForNull Object element) {
-    @Nullable ImmutableEntry<?>[] hashTable = this.hashTable;
+    ImmutableEntry<?>[] hashTable = this.hashTable;
     if (element == null || hashTable.length == 0) {
       return 0;
     }
diff --git a/guava/src/com/google/common/collect/RegularImmutableSet.java b/guava/src/com/google/common/collect/RegularImmutableSet.java
index 211c89304c..aedf78500e 100644
--- a/guava/src/com/google/common/collect/RegularImmutableSet.java
+++ b/guava/src/com/google/common/collect/RegularImmutableSet.java
@@ -16,19 +16,15 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.VisibleForTesting;
 import java.util.Spliterator;
 import java.util.Spliterators;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@link ImmutableSet} with two or more elements.
  *
  * @author Kevin Bourrillion
  */
-@GwtCompatible(serializable = true, emulated = true)
 @SuppressWarnings("serial") // uses writeReplace(), not default serialization
 @ElementTypesAreNonnullByDefault
 final class RegularImmutableSet<E> extends ImmutableSet.CachingAsList<E> {
@@ -39,11 +35,11 @@ final class RegularImmutableSet<E> extends ImmutableSet.CachingAsList<E> {
   private final transient Object[] elements;
   private final transient int hashCode;
   // the same values as `elements` in hashed positions (plus nulls)
-  @VisibleForTesting final transient @Nullable Object[] table;
+  final transient Object[] table;
   // 'and' with an int to get a valid table index.
   private final transient int mask;
 
-  RegularImmutableSet(Object[] elements, int hashCode, @Nullable Object[] table, int mask) {
+  RegularImmutableSet(Object[] elements, int hashCode, Object[] table, int mask) {
     this.elements = elements;
     this.hashCode = hashCode;
     this.table = table;
@@ -52,7 +48,7 @@ final class RegularImmutableSet<E> extends ImmutableSet.CachingAsList<E> {
 
   @Override
   public boolean contains(@CheckForNull Object target) {
-    @Nullable Object[] table = this.table;
+    Object[] table = this.table;
     if (target == null || table.length == 0) {
       return false;
     }
@@ -98,7 +94,7 @@ final class RegularImmutableSet<E> extends ImmutableSet.CachingAsList<E> {
   }
 
   @Override
-  int copyIntoArray(@Nullable Object[] dst, int offset) {
+  int copyIntoArray(Object[] dst, int offset) {
     System.arraycopy(elements, 0, dst, offset, elements.length);
     return offset + elements.length;
   }
diff --git a/guava/src/com/google/common/collect/RegularImmutableSortedMultiset.java b/guava/src/com/google/common/collect/RegularImmutableSortedMultiset.java
index 4b7ba87427..46ca6449e2 100644
--- a/guava/src/com/google/common/collect/RegularImmutableSortedMultiset.java
+++ b/guava/src/com/google/common/collect/RegularImmutableSortedMultiset.java
@@ -18,8 +18,6 @@ import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
 import static com.google.common.collect.BoundType.CLOSED;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.primitives.Ints;
 import java.util.Comparator;
 import java.util.function.ObjIntConsumer;
@@ -31,7 +29,6 @@ import javax.annotation.CheckForNull;
  * @author Louis Wasserman
  */
 @SuppressWarnings("serial") // uses writeReplace, not default serialization
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 final class RegularImmutableSortedMultiset<E> extends ImmutableSortedMultiset<E> {
   private static final long[] ZERO_CUMULATIVE_COUNTS = {0};
@@ -39,7 +36,7 @@ final class RegularImmutableSortedMultiset<E> extends ImmutableSortedMultiset<E>
   static final ImmutableSortedMultiset<Comparable> NATURAL_EMPTY_MULTISET =
       new RegularImmutableSortedMultiset<>(Ordering.natural());
 
-  @VisibleForTesting final transient RegularImmutableSortedSet<E> elementSet;
+  final transient RegularImmutableSortedSet<E> elementSet;
   private final transient long[] cumulativeCounts;
   private final transient int offset;
   private final transient int length;
diff --git a/guava/src/com/google/common/collect/RegularImmutableSortedSet.java b/guava/src/com/google/common/collect/RegularImmutableSortedSet.java
index fcb683f562..fe53cda2e7 100644
--- a/guava/src/com/google/common/collect/RegularImmutableSortedSet.java
+++ b/guava/src/com/google/common/collect/RegularImmutableSortedSet.java
@@ -18,8 +18,6 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Comparator;
@@ -37,7 +35,6 @@ import javax.annotation.CheckForNull;
  * @author Jared Levy
  * @author Louis Wasserman
  */
-@GwtCompatible(serializable = true, emulated = true)
 @SuppressWarnings({"serial", "rawtypes"})
 @ElementTypesAreNonnullByDefault
 final class RegularImmutableSortedSet<E> extends ImmutableSortedSet<E> {
@@ -72,7 +69,7 @@ final class RegularImmutableSortedSet<E> extends ImmutableSortedSet<E> {
     return elements.iterator();
   }
 
-  @GwtIncompatible // NavigableSet
+  // NavigableSet
   @Override
   public UnmodifiableIterator<E> descendingIterator() {
     return elements.reverse().iterator();
diff --git a/guava/src/com/google/common/collect/RegularImmutableTable.java b/guava/src/com/google/common/collect/RegularImmutableTable.java
index 24434c5a19..500c7cff45 100644
--- a/guava/src/com/google/common/collect/RegularImmutableTable.java
+++ b/guava/src/com/google/common/collect/RegularImmutableTable.java
@@ -17,8 +17,6 @@ package com.google.common.collect;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.j2objc.annotations.WeakOuter;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.LinkedHashSet;
@@ -31,7 +29,6 @@ import javax.annotation.CheckForNull;
  *
  * @author Gregory Kick
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 abstract class RegularImmutableTable<R, C, V> extends ImmutableTable<R, C, V> {
   RegularImmutableTable() {}
@@ -43,7 +40,6 @@ abstract class RegularImmutableTable<R, C, V> extends ImmutableTable<R, C, V> {
     return isEmpty() ? ImmutableSet.<Cell<R, C, V>>of() : new CellSet();
   }
 
-  @WeakOuter
   private final class CellSet extends IndexedImmutableSet<Cell<R, C, V>> {
     @Override
     public int size() {
@@ -78,7 +74,6 @@ abstract class RegularImmutableTable<R, C, V> extends ImmutableTable<R, C, V> {
     return isEmpty() ? ImmutableList.<V>of() : new Values();
   }
 
-  @WeakOuter
   private final class Values extends ImmutableList<V> {
     @Override
     public int size() {
diff --git a/guava/src/com/google/common/collect/ReverseNaturalOrdering.java b/guava/src/com/google/common/collect/ReverseNaturalOrdering.java
index f0c40cb612..1b90432ee6 100644
--- a/guava/src/com/google/common/collect/ReverseNaturalOrdering.java
+++ b/guava/src/com/google/common/collect/ReverseNaturalOrdering.java
@@ -18,12 +18,10 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 import java.util.Iterator;
 
 /** An ordering that uses the reverse of the natural order of the values. */
-@GwtCompatible(serializable = true)
 @SuppressWarnings({"unchecked", "rawtypes"}) // TODO(kevinb): the right way to explain this??
 @ElementTypesAreNonnullByDefault
 final class ReverseNaturalOrdering extends Ordering<Comparable<?>> implements Serializable {
diff --git a/guava/src/com/google/common/collect/ReverseOrdering.java b/guava/src/com/google/common/collect/ReverseOrdering.java
index 6c1e74dd73..c9772b013c 100644
--- a/guava/src/com/google/common/collect/ReverseOrdering.java
+++ b/guava/src/com/google/common/collect/ReverseOrdering.java
@@ -18,16 +18,13 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 import java.util.Iterator;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** An ordering that uses the reverse of a given order. */
-@GwtCompatible(serializable = true)
 @ElementTypesAreNonnullByDefault
-final class ReverseOrdering<T extends @Nullable Object> extends Ordering<T>
+final class ReverseOrdering<T extends Object> extends Ordering<T>
     implements Serializable {
   final Ordering<? super T> forwardOrder;
 
diff --git a/guava/src/com/google/common/collect/RowSortedTable.java b/guava/src/com/google/common/collect/RowSortedTable.java
index 2c2d773f78..cef6ba5f50 100644
--- a/guava/src/com/google/common/collect/RowSortedTable.java
+++ b/guava/src/com/google/common/collect/RowSortedTable.java
@@ -16,12 +16,10 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.Map;
 import java.util.Set;
 import java.util.SortedMap;
 import java.util.SortedSet;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Interface that extends {@code Table} and whose rows are sorted.
@@ -33,10 +31,9 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Warren Dukes
  * @since 8.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public interface RowSortedTable<
-        R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object>
+        R extends Object, C extends Object, V extends Object>
     extends Table<R, C, V> {
   /**
    * {@inheritDoc}
diff --git a/guava/src/com/google/common/collect/Serialization.java b/guava/src/com/google/common/collect/Serialization.java
index 5e8806764e..8b25839dde 100644
--- a/guava/src/com/google/common/collect/Serialization.java
+++ b/guava/src/com/google/common/collect/Serialization.java
@@ -16,14 +16,12 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtIncompatible;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.lang.reflect.Field;
 import java.util.Collection;
 import java.util.Map;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Provides static methods for serializing collection classes.
@@ -33,7 +31,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @author Jared Levy
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 final class Serialization {
   private Serialization() {}
@@ -56,7 +53,7 @@ final class Serialization {
    * <p>The serialized output consists of the number of entries, first key, first value, second key,
    * second value, and so on.
    */
-  static <K extends @Nullable Object, V extends @Nullable Object> void writeMap(
+  static <K extends Object, V extends Object> void writeMap(
       Map<K, V> map, ObjectOutputStream stream) throws IOException {
     stream.writeInt(map.size());
     for (Map.Entry<K, V> entry : map.entrySet()) {
@@ -69,7 +66,7 @@ final class Serialization {
    * Populates a map by reading an input stream, as part of deserialization. See {@link #writeMap}
    * for the data format.
    */
-  static <K extends @Nullable Object, V extends @Nullable Object> void populateMap(
+  static <K extends Object, V extends Object> void populateMap(
       Map<K, V> map, ObjectInputStream stream) throws IOException, ClassNotFoundException {
     int size = stream.readInt();
     populateMap(map, stream, size);
@@ -79,7 +76,7 @@ final class Serialization {
    * Populates a map by reading an input stream, as part of deserialization. See {@link #writeMap}
    * for the data format. The size is determined by a prior call to {@link #readCount}.
    */
-  static <K extends @Nullable Object, V extends @Nullable Object> void populateMap(
+  static <K extends Object, V extends Object> void populateMap(
       Map<K, V> map, ObjectInputStream stream, int size)
       throws IOException, ClassNotFoundException {
     for (int i = 0; i < size; i++) {
@@ -98,7 +95,7 @@ final class Serialization {
    * <p>The serialized output consists of the number of distinct elements, the first element, its
    * count, the second element, its count, and so on.
    */
-  static <E extends @Nullable Object> void writeMultiset(
+  static <E extends Object> void writeMultiset(
       Multiset<E> multiset, ObjectOutputStream stream) throws IOException {
     int entryCount = multiset.entrySet().size();
     stream.writeInt(entryCount);
@@ -112,7 +109,7 @@ final class Serialization {
    * Populates a multiset by reading an input stream, as part of deserialization. See {@link
    * #writeMultiset} for the data format.
    */
-  static <E extends @Nullable Object> void populateMultiset(
+  static <E extends Object> void populateMultiset(
       Multiset<E> multiset, ObjectInputStream stream) throws IOException, ClassNotFoundException {
     int distinctElements = stream.readInt();
     populateMultiset(multiset, stream, distinctElements);
@@ -123,7 +120,7 @@ final class Serialization {
    * #writeMultiset} for the data format. The number of distinct elements is determined by a prior
    * call to {@link #readCount}.
    */
-  static <E extends @Nullable Object> void populateMultiset(
+  static <E extends Object> void populateMultiset(
       Multiset<E> multiset, ObjectInputStream stream, int distinctElements)
       throws IOException, ClassNotFoundException {
     for (int i = 0; i < distinctElements; i++) {
@@ -142,7 +139,7 @@ final class Serialization {
    * <p>The serialized output consists of the number of distinct keys, and then for each distinct
    * key: the key, the number of values for that key, and the key's values.
    */
-  static <K extends @Nullable Object, V extends @Nullable Object> void writeMultimap(
+  static <K extends Object, V extends Object> void writeMultimap(
       Multimap<K, V> multimap, ObjectOutputStream stream) throws IOException {
     stream.writeInt(multimap.asMap().size());
     for (Map.Entry<K, Collection<V>> entry : multimap.asMap().entrySet()) {
@@ -158,7 +155,7 @@ final class Serialization {
    * Populates a multimap by reading an input stream, as part of deserialization. See {@link
    * #writeMultimap} for the data format.
    */
-  static <K extends @Nullable Object, V extends @Nullable Object> void populateMultimap(
+  static <K extends Object, V extends Object> void populateMultimap(
       Multimap<K, V> multimap, ObjectInputStream stream)
       throws IOException, ClassNotFoundException {
     int distinctKeys = stream.readInt();
@@ -170,7 +167,7 @@ final class Serialization {
    * #writeMultimap} for the data format. The number of distinct keys is determined by a prior call
    * to {@link #readCount}.
    */
-  static <K extends @Nullable Object, V extends @Nullable Object> void populateMultimap(
+  static <K extends Object, V extends Object> void populateMultimap(
       Multimap<K, V> multimap, ObjectInputStream stream, int distinctKeys)
       throws IOException, ClassNotFoundException {
     for (int i = 0; i < distinctKeys; i++) {
diff --git a/guava/src/com/google/common/collect/SetMultimap.java b/guava/src/com/google/common/collect/SetMultimap.java
index 216533ea23..99ddf7a0f3 100644
--- a/guava/src/com/google/common/collect/SetMultimap.java
+++ b/guava/src/com/google/common/collect/SetMultimap.java
@@ -16,14 +16,11 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Collection;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@code Multimap} that cannot hold duplicate key-value pairs. Adding a key-value pair that's
@@ -52,9 +49,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Jared Levy
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public interface SetMultimap<K extends @Nullable Object, V extends @Nullable Object>
+public interface SetMultimap<K extends Object, V extends Object>
     extends Multimap<K, V> {
   /**
    * {@inheritDoc}
@@ -73,7 +69,6 @@ public interface SetMultimap<K extends @Nullable Object, V extends @Nullable Obj
    * {@link Set}, instead of the {@link java.util.Collection} specified in the {@link Multimap}
    * interface.
    */
-  @CanIgnoreReturnValue
   @Override
   Set<V> removeAll(@CheckForNull Object key);
 
@@ -86,7 +81,6 @@ public interface SetMultimap<K extends @Nullable Object, V extends @Nullable Obj
    *
    * <p>Any duplicates in {@code values} will be stored in the multimap once.
    */
-  @CanIgnoreReturnValue
   @Override
   Set<V> replaceValues(@ParametricNullness K key, Iterable<? extends V> values);
 
diff --git a/guava/src/com/google/common/collect/Sets.java b/guava/src/com/google/common/collect/Sets.java
index 5338bd244b..8f2bed417f 100644
--- a/guava/src/com/google/common/collect/Sets.java
+++ b/guava/src/com/google/common/collect/Sets.java
@@ -20,15 +20,10 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
 import com.google.common.collect.Collections2.FilteredCollection;
 import com.google.common.math.IntMath;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotCall;
 import java.io.Serializable;
 import java.util.AbstractSet;
 import java.util.Arrays;
@@ -53,7 +48,6 @@ import java.util.function.Consumer;
 import java.util.stream.Collector;
 import java.util.stream.Stream;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to {@link Set} instances. Also see this class's counterparts
@@ -67,7 +61,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Chris Povirk
  * @since 2.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class Sets {
   private Sets() {}
@@ -76,7 +69,7 @@ public final class Sets {
    * {@link AbstractSet} substitute without the potentially-quadratic {@code removeAll}
    * implementation.
    */
-  abstract static class ImprovedAbstractSet<E extends @Nullable Object> extends AbstractSet<E> {
+  abstract static class ImprovedAbstractSet<E extends Object> extends AbstractSet<E> {
     @Override
     public boolean removeAll(Collection<?> c) {
       return removeAllImpl(this, c);
@@ -100,7 +93,6 @@ public final class Sets {
    * @return an immutable set containing those elements, minus duplicates
    */
   // http://code.google.com/p/google-web-toolkit/issues/detail?id=3028
-  @GwtCompatible(serializable = true)
   public static <E extends Enum<E>> ImmutableSet<E> immutableEnumSet(
       E anElement, E... otherElements) {
     return ImmutableEnumSet.asImmutable(EnumSet.of(anElement, otherElements));
@@ -117,7 +109,6 @@ public final class Sets {
    * @return an immutable set containing those elements, minus duplicates
    */
   // http://code.google.com/p/google-web-toolkit/issues/detail?id=3028
-  @GwtCompatible(serializable = true)
   public static <E extends Enum<E>> ImmutableSet<E> immutableEnumSet(Iterable<E> elements) {
     if (elements instanceof ImmutableEnumSet) {
       return (ImmutableEnumSet<E>) elements;
@@ -177,7 +168,7 @@ public final class Sets {
    * deprecated. Instead, use the {@code HashSet} constructor directly, taking advantage of the new
    * <a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.
    */
-  public static <E extends @Nullable Object> HashSet<E> newHashSet() {
+  public static <E extends Object> HashSet<E> newHashSet() {
     return new HashSet<E>();
   }
 
@@ -194,7 +185,7 @@ public final class Sets {
    * asList}{@code (...))}, or for creating an empty set then calling {@link Collections#addAll}.
    * This method is not actually very useful and will likely be deprecated in the future.
    */
-  public static <E extends @Nullable Object> HashSet<E> newHashSet(E... elements) {
+  public static <E extends Object> HashSet<E> newHashSet(E... elements) {
     HashSet<E> set = newHashSetWithExpectedSize(elements.length);
     Collections.addAll(set, elements);
     return set;
@@ -218,7 +209,7 @@ public final class Sets {
    *
    * <p>Overall, this method is not very useful and will likely be deprecated in the future.
    */
-  public static <E extends @Nullable Object> HashSet<E> newHashSet(Iterable<? extends E> elements) {
+  public static <E extends Object> HashSet<E> newHashSet(Iterable<? extends E> elements) {
     return (elements instanceof Collection)
         ? new HashSet<E>((Collection<? extends E>) elements)
         : newHashSet(elements.iterator());
@@ -236,7 +227,7 @@ public final class Sets {
    *
    * <p>Overall, this method is not very useful and will likely be deprecated in the future.
    */
-  public static <E extends @Nullable Object> HashSet<E> newHashSet(Iterator<? extends E> elements) {
+  public static <E extends Object> HashSet<E> newHashSet(Iterator<? extends E> elements) {
     HashSet<E> set = newHashSet();
     Iterators.addAll(set, elements);
     return set;
@@ -254,7 +245,7 @@ public final class Sets {
    *     without resizing
    * @throws IllegalArgumentException if {@code expectedSize} is negative
    */
-  public static <E extends @Nullable Object> HashSet<E> newHashSetWithExpectedSize(
+  public static <E extends Object> HashSet<E> newHashSetWithExpectedSize(
       int expectedSize) {
     return new HashSet<E>(Maps.capacity(expectedSize));
   }
@@ -305,7 +296,7 @@ public final class Sets {
    *
    * @return a new, empty {@code LinkedHashSet}
    */
-  public static <E extends @Nullable Object> LinkedHashSet<E> newLinkedHashSet() {
+  public static <E extends Object> LinkedHashSet<E> newLinkedHashSet() {
     return new LinkedHashSet<E>();
   }
 
@@ -324,7 +315,7 @@ public final class Sets {
    * @param elements the elements that the set should contain, in order
    * @return a new {@code LinkedHashSet} containing those elements (minus duplicates)
    */
-  public static <E extends @Nullable Object> LinkedHashSet<E> newLinkedHashSet(
+  public static <E extends Object> LinkedHashSet<E> newLinkedHashSet(
       Iterable<? extends E> elements) {
     if (elements instanceof Collection) {
       return new LinkedHashSet<E>((Collection<? extends E>) elements);
@@ -346,7 +337,7 @@ public final class Sets {
    * @throws IllegalArgumentException if {@code expectedSize} is negative
    * @since 11.0
    */
-  public static <E extends @Nullable Object> LinkedHashSet<E> newLinkedHashSetWithExpectedSize(
+  public static <E extends Object> LinkedHashSet<E> newLinkedHashSetWithExpectedSize(
       int expectedSize) {
     return new LinkedHashSet<E>(Maps.capacity(expectedSize));
   }
@@ -412,7 +403,7 @@ public final class Sets {
    * @return a new, empty {@code TreeSet}
    * @throws NullPointerException if {@code comparator} is null
    */
-  public static <E extends @Nullable Object> TreeSet<E> newTreeSet(
+  public static <E extends Object> TreeSet<E> newTreeSet(
       Comparator<? super E> comparator) {
     return new TreeSet<E>(checkNotNull(comparator));
   }
@@ -426,7 +417,7 @@ public final class Sets {
    *
    * @since 8.0
    */
-  public static <E extends @Nullable Object> Set<E> newIdentityHashSet() {
+  public static <E extends Object> Set<E> newIdentityHashSet() {
     return Collections.newSetFromMap(Maps.<E, Boolean>newIdentityHashMap());
   }
 
@@ -439,8 +430,8 @@ public final class Sets {
    * @return a new, empty {@code CopyOnWriteArraySet}
    * @since 12.0
    */
-  @GwtIncompatible // CopyOnWriteArraySet
-  public static <E extends @Nullable Object> CopyOnWriteArraySet<E> newCopyOnWriteArraySet() {
+  // CopyOnWriteArraySet
+  public static <E extends Object> CopyOnWriteArraySet<E> newCopyOnWriteArraySet() {
     return new CopyOnWriteArraySet<E>();
   }
 
@@ -451,8 +442,8 @@ public final class Sets {
    * @return a new {@code CopyOnWriteArraySet} containing those elements
    * @since 12.0
    */
-  @GwtIncompatible // CopyOnWriteArraySet
-  public static <E extends @Nullable Object> CopyOnWriteArraySet<E> newCopyOnWriteArraySet(
+  // CopyOnWriteArraySet
+  public static <E extends Object> CopyOnWriteArraySet<E> newCopyOnWriteArraySet(
       Iterable<? extends E> elements) {
     // We copy elements to an ArrayList first, rather than incurring the
     // quadratic cost of adding them to the COWAS directly.
@@ -541,7 +532,7 @@ public final class Sets {
    * @deprecated Use {@link Collections#newSetFromMap} instead.
    */
   @Deprecated
-  public static <E extends @Nullable Object> Set<E> newSetFromMap(
+  public static <E extends Object> Set<E> newSetFromMap(
       Map<E, Boolean> map) {
     return Collections.newSetFromMap(map);
   }
@@ -555,7 +546,7 @@ public final class Sets {
    *
    * @since 2.0
    */
-  public abstract static class SetView<E extends @Nullable Object> extends AbstractSet<E> {
+  public abstract static class SetView<E extends Object> extends AbstractSet<E> {
     private SetView() {} // no subclasses but our own
 
     /**
@@ -580,7 +571,6 @@ public final class Sets {
      */
     // Note: S should logically extend Set<? super E> but can't due to either
     // some javac bug or some weirdness in the spec, not sure which.
-    @CanIgnoreReturnValue
     public <S extends Set<E>> S copyInto(S set) {
       set.addAll(this);
       return set;
@@ -592,10 +582,8 @@ public final class Sets {
      * @throws UnsupportedOperationException always
      * @deprecated Unsupported operation.
      */
-    @CanIgnoreReturnValue
     @Deprecated
     @Override
-    @DoNotCall("Always throws UnsupportedOperationException")
     public final boolean add(@ParametricNullness E e) {
       throw new UnsupportedOperationException();
     }
@@ -606,10 +594,8 @@ public final class Sets {
      * @throws UnsupportedOperationException always
      * @deprecated Unsupported operation.
      */
-    @CanIgnoreReturnValue
     @Deprecated
     @Override
-    @DoNotCall("Always throws UnsupportedOperationException")
     public final boolean remove(@CheckForNull Object object) {
       throw new UnsupportedOperationException();
     }
@@ -620,10 +606,8 @@ public final class Sets {
      * @throws UnsupportedOperationException always
      * @deprecated Unsupported operation.
      */
-    @CanIgnoreReturnValue
     @Deprecated
     @Override
-    @DoNotCall("Always throws UnsupportedOperationException")
     public final boolean addAll(Collection<? extends E> newElements) {
       throw new UnsupportedOperationException();
     }
@@ -634,10 +618,8 @@ public final class Sets {
      * @throws UnsupportedOperationException always
      * @deprecated Unsupported operation.
      */
-    @CanIgnoreReturnValue
     @Deprecated
     @Override
-    @DoNotCall("Always throws UnsupportedOperationException")
     public final boolean removeAll(Collection<?> oldElements) {
       throw new UnsupportedOperationException();
     }
@@ -648,10 +630,8 @@ public final class Sets {
      * @throws UnsupportedOperationException always
      * @deprecated Unsupported operation.
      */
-    @CanIgnoreReturnValue
     @Deprecated
     @Override
-    @DoNotCall("Always throws UnsupportedOperationException")
     public final boolean removeIf(java.util.function.Predicate<? super E> filter) {
       throw new UnsupportedOperationException();
     }
@@ -662,10 +642,8 @@ public final class Sets {
      * @throws UnsupportedOperationException always
      * @deprecated Unsupported operation.
      */
-    @CanIgnoreReturnValue
     @Deprecated
     @Override
-    @DoNotCall("Always throws UnsupportedOperationException")
     public final boolean retainAll(Collection<?> elementsToKeep) {
       throw new UnsupportedOperationException();
     }
@@ -678,7 +656,6 @@ public final class Sets {
      */
     @Deprecated
     @Override
-    @DoNotCall("Always throws UnsupportedOperationException")
     public final void clear() {
       throw new UnsupportedOperationException();
     }
@@ -702,7 +679,7 @@ public final class Sets {
    * equivalence relations, for example if {@code set1} is a {@link HashSet} and {@code set2} is a
    * {@link TreeSet} or the {@link Map#keySet} of an {@code IdentityHashMap}.
    */
-  public static <E extends @Nullable Object> SetView<E> union(
+  public static <E extends Object> SetView<E> union(
       final Set<? extends E> set1, final Set<? extends E> set2) {
     checkNotNull(set1, "set1");
     checkNotNull(set2, "set2");
@@ -804,7 +781,7 @@ public final class Sets {
    *
    * <p>This is unfortunate, but should come up only very rarely.
    */
-  public static <E extends @Nullable Object> SetView<E> intersection(
+  public static <E extends Object> SetView<E> intersection(
       final Set<E> set1, final Set<?> set2) {
     checkNotNull(set1, "set1");
     checkNotNull(set2, "set2");
@@ -877,7 +854,7 @@ public final class Sets {
    * equivalence relations, for example if {@code set1} is a {@link HashSet} and {@code set2} is a
    * {@link TreeSet} or the {@link Map#keySet} of an {@code IdentityHashMap}.
    */
-  public static <E extends @Nullable Object> SetView<E> difference(
+  public static <E extends Object> SetView<E> difference(
       final Set<E> set1, final Set<?> set2) {
     checkNotNull(set1, "set1");
     checkNotNull(set2, "set2");
@@ -946,7 +923,7 @@ public final class Sets {
    *
    * @since 3.0
    */
-  public static <E extends @Nullable Object> SetView<E> symmetricDifference(
+  public static <E extends Object> SetView<E> symmetricDifference(
       final Set<? extends E> set1, final Set<? extends E> set2) {
     checkNotNull(set1, "set1");
     checkNotNull(set2, "set2");
@@ -1032,7 +1009,7 @@ public final class Sets {
    * you to migrate to streams.
    */
   // TODO(kevinb): how to omit that last sentence when building GWT javadoc?
-  public static <E extends @Nullable Object> Set<E> filter(
+  public static <E extends Object> Set<E> filter(
       Set<E> unfiltered, Predicate<? super E> predicate) {
     if (unfiltered instanceof SortedSet) {
       return filter((SortedSet<E>) unfiltered, predicate);
@@ -1072,7 +1049,7 @@ public final class Sets {
    *
    * @since 11.0
    */
-  public static <E extends @Nullable Object> SortedSet<E> filter(
+  public static <E extends Object> SortedSet<E> filter(
       SortedSet<E> unfiltered, Predicate<? super E> predicate) {
     if (unfiltered instanceof FilteredSet) {
       // Support clear(), removeAll(), and retainAll() when filtering a filtered
@@ -1109,9 +1086,9 @@ public final class Sets {
    *
    * @since 14.0
    */
-  @GwtIncompatible // NavigableSet
+  // NavigableSet
   @SuppressWarnings("unchecked")
-  public static <E extends @Nullable Object> NavigableSet<E> filter(
+  public static <E extends Object> NavigableSet<E> filter(
       NavigableSet<E> unfiltered, Predicate<? super E> predicate) {
     if (unfiltered instanceof FilteredSet) {
       // Support clear(), removeAll(), and retainAll() when filtering a filtered
@@ -1124,7 +1101,7 @@ public final class Sets {
     return new FilteredNavigableSet<E>(checkNotNull(unfiltered), checkNotNull(predicate));
   }
 
-  private static class FilteredSet<E extends @Nullable Object> extends FilteredCollection<E>
+  private static class FilteredSet<E extends Object> extends FilteredCollection<E>
       implements Set<E> {
     FilteredSet(Set<E> unfiltered, Predicate<? super E> predicate) {
       super(unfiltered, predicate);
@@ -1141,7 +1118,7 @@ public final class Sets {
     }
   }
 
-  private static class FilteredSortedSet<E extends @Nullable Object> extends FilteredSet<E>
+  private static class FilteredSortedSet<E extends Object> extends FilteredSet<E>
       implements SortedSet<E> {
 
     FilteredSortedSet(SortedSet<E> unfiltered, Predicate<? super E> predicate) {
@@ -1190,8 +1167,8 @@ public final class Sets {
     }
   }
 
-  @GwtIncompatible // NavigableSet
-  private static class FilteredNavigableSet<E extends @Nullable Object> extends FilteredSortedSet<E>
+  // NavigableSet
+  private static class FilteredNavigableSet<E extends Object> extends FilteredSortedSet<E>
       implements NavigableSet<E> {
     FilteredNavigableSet(NavigableSet<E> unfiltered, Predicate<? super E> predicate) {
       super(unfiltered, predicate);
@@ -1511,7 +1488,6 @@ public final class Sets {
    * @see <a href="http://en.wikipedia.org/wiki/Power_set">Power set article at Wikipedia</a>
    * @since 4.0
    */
-  @GwtCompatible(serializable = false)
   public static <E> Set<Set<E>> powerSet(Set<E> set) {
     return new PowerSet<E>(set);
   }
@@ -1647,7 +1623,6 @@ public final class Sets {
    * @throws NullPointerException if {@code set} is or contains {@code null}
    * @since 23.0
    */
-  @Beta
   public static <E> Set<Set<E>> combinations(Set<E> set, final int size) {
     final ImmutableMap<E, Integer> index = Maps.indexMap(set);
     checkNonnegative(size, "size");
@@ -1790,7 +1765,7 @@ public final class Sets {
    * @return an unmodifiable view of the specified navigable set
    * @since 12.0
    */
-  public static <E extends @Nullable Object> NavigableSet<E> unmodifiableNavigableSet(
+  public static <E extends Object> NavigableSet<E> unmodifiableNavigableSet(
       NavigableSet<E> set) {
     if (set instanceof ImmutableCollection || set instanceof UnmodifiableNavigableSet) {
       return set;
@@ -1798,7 +1773,7 @@ public final class Sets {
     return new UnmodifiableNavigableSet<E>(set);
   }
 
-  static final class UnmodifiableNavigableSet<E extends @Nullable Object>
+  static final class UnmodifiableNavigableSet<E extends Object>
       extends ForwardingSortedSet<E> implements NavigableSet<E>, Serializable {
     private final NavigableSet<E> delegate;
     private final SortedSet<E> unmodifiableDelegate;
@@ -1956,8 +1931,8 @@ public final class Sets {
    * @return a synchronized view of the specified navigable set.
    * @since 13.0
    */
-  @GwtIncompatible // NavigableSet
-  public static <E extends @Nullable Object> NavigableSet<E> synchronizedNavigableSet(
+  // NavigableSet
+  public static <E extends Object> NavigableSet<E> synchronizedNavigableSet(
       NavigableSet<E> navigableSet) {
     return Synchronized.navigableSet(navigableSet);
   }
@@ -1990,8 +1965,8 @@ public final class Sets {
     }
   }
 
-  @GwtIncompatible // NavigableSet
-  static class DescendingSet<E extends @Nullable Object> extends ForwardingNavigableSet<E> {
+  // NavigableSet
+  static class DescendingSet<E extends Object> extends ForwardingNavigableSet<E> {
     private final NavigableSet<E> forward;
 
     DescendingSet(NavigableSet<E> forward) {
@@ -2095,7 +2070,7 @@ public final class Sets {
     }
 
     // If we inline this, we get a javac error.
-    private static <T extends @Nullable Object> Ordering<T> reverse(Comparator<T> forward) {
+    private static <T extends Object> Ordering<T> reverse(Comparator<T> forward) {
       return Ordering.from(forward).reverse();
     }
 
@@ -2117,13 +2092,13 @@ public final class Sets {
     }
 
     @Override
-    public @Nullable Object[] toArray() {
+    public Object[] toArray() {
       return standardToArray();
     }
 
     @Override
     @SuppressWarnings("nullness") // b/192354773 in our checker affects toArray declarations
-    public <T extends @Nullable Object> T[] toArray(T[] array) {
+    public <T extends Object> T[] toArray(T[] array) {
       return standardToArray(array);
     }
 
@@ -2149,8 +2124,7 @@ public final class Sets {
    *
    * @since 20.0
    */
-  @Beta
-  @GwtIncompatible // NavigableSet
+  // NavigableSet
   public static <K extends Comparable<? super K>> NavigableSet<K> subSet(
       NavigableSet<K> set, Range<K> range) {
     if (set.comparator() != null
diff --git a/guava/src/com/google/common/collect/SingletonImmutableBiMap.java b/guava/src/com/google/common/collect/SingletonImmutableBiMap.java
index c5fb2b2989..39e56340fa 100644
--- a/guava/src/com/google/common/collect/SingletonImmutableBiMap.java
+++ b/guava/src/com/google/common/collect/SingletonImmutableBiMap.java
@@ -19,9 +19,6 @@ package com.google.common.collect;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkEntryNotNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.concurrent.LazyInit;
-import com.google.j2objc.annotations.RetainedWith;
 import java.util.function.BiConsumer;
 import javax.annotation.CheckForNull;
 
@@ -31,7 +28,6 @@ import javax.annotation.CheckForNull;
  * @author Jesse Wilson
  * @author Kevin Bourrillion
  */
-@GwtCompatible(serializable = true, emulated = true)
 @SuppressWarnings("serial") // uses writeReplace(), not default serialization
 @ElementTypesAreNonnullByDefault
 final class SingletonImmutableBiMap<K, V> extends ImmutableBiMap<K, V> {
@@ -94,7 +90,7 @@ final class SingletonImmutableBiMap<K, V> extends ImmutableBiMap<K, V> {
   }
 
   @CheckForNull private final transient ImmutableBiMap<V, K> inverse;
-  @LazyInit @RetainedWith @CheckForNull private transient ImmutableBiMap<V, K> lazyInverse;
+  @CheckForNull private transient ImmutableBiMap<V, K> lazyInverse;
 
   @Override
   public ImmutableBiMap<V, K> inverse() {
diff --git a/guava/src/com/google/common/collect/SingletonImmutableList.java b/guava/src/com/google/common/collect/SingletonImmutableList.java
index a7ac8b30e2..5b0ffff2af 100644
--- a/guava/src/com/google/common/collect/SingletonImmutableList.java
+++ b/guava/src/com/google/common/collect/SingletonImmutableList.java
@@ -18,7 +18,6 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Preconditions;
 import java.util.Collections;
 import java.util.Spliterator;
@@ -28,7 +27,6 @@ import java.util.Spliterator;
  *
  * @author Hayward Chan
  */
-@GwtCompatible(serializable = true, emulated = true)
 @SuppressWarnings("serial") // uses writeReplace(), not default serialization
 @ElementTypesAreNonnullByDefault
 final class SingletonImmutableList<E> extends ImmutableList<E> {
diff --git a/guava/src/com/google/common/collect/SingletonImmutableSet.java b/guava/src/com/google/common/collect/SingletonImmutableSet.java
index 088cb802f2..41a344b703 100644
--- a/guava/src/com/google/common/collect/SingletonImmutableSet.java
+++ b/guava/src/com/google/common/collect/SingletonImmutableSet.java
@@ -16,10 +16,8 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Preconditions;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@link ImmutableSet} with exactly one element.
@@ -27,7 +25,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kevin Bourrillion
  * @author Nick Kralevich
  */
-@GwtCompatible(serializable = true, emulated = true)
 @SuppressWarnings("serial") // uses writeReplace(), not default serialization
 @ElementTypesAreNonnullByDefault
 final class SingletonImmutableSet<E> extends ImmutableSet<E> {
@@ -66,7 +63,7 @@ final class SingletonImmutableSet<E> extends ImmutableSet<E> {
   }
 
   @Override
-  int copyIntoArray(@Nullable Object[] dst, int offset) {
+  int copyIntoArray(Object[] dst, int offset) {
     dst[offset] = element;
     return offset + 1;
   }
diff --git a/guava/src/com/google/common/collect/SingletonImmutableTable.java b/guava/src/com/google/common/collect/SingletonImmutableTable.java
index cfaeadb41d..565a4b489e 100644
--- a/guava/src/com/google/common/collect/SingletonImmutableTable.java
+++ b/guava/src/com/google/common/collect/SingletonImmutableTable.java
@@ -18,7 +18,6 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.Map;
 
 /**
@@ -26,7 +25,6 @@ import java.util.Map;
  *
  * @author Gregory Kick
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 class SingletonImmutableTable<R, C, V> extends ImmutableTable<R, C, V> {
   final R singleRowKey;
diff --git a/guava/src/com/google/common/collect/SortedIterable.java b/guava/src/com/google/common/collect/SortedIterable.java
index 64ec08ef31..4ed3e60521 100644
--- a/guava/src/com/google/common/collect/SortedIterable.java
+++ b/guava/src/com/google/common/collect/SortedIterable.java
@@ -14,10 +14,8 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.Comparator;
 import java.util.Iterator;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An {@code Iterable} whose elements are sorted relative to a {@code Comparator}, typically
@@ -25,9 +23,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @author Louis Wasserman
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-interface SortedIterable<T extends @Nullable Object> extends Iterable<T> {
+interface SortedIterable<T extends Object> extends Iterable<T> {
   /**
    * Returns the {@code Comparator} by which the elements of this iterable are ordered, or {@code
    * Ordering.natural()} if the elements are ordered by their natural ordering.
diff --git a/guava/src/com/google/common/collect/SortedIterables.java b/guava/src/com/google/common/collect/SortedIterables.java
index 68b231a381..184b3c206d 100644
--- a/guava/src/com/google/common/collect/SortedIterables.java
+++ b/guava/src/com/google/common/collect/SortedIterables.java
@@ -16,17 +16,14 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.Comparator;
 import java.util.SortedSet;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Utilities for dealing with sorted collections of all types.
  *
  * @author Louis Wasserman
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 final class SortedIterables {
   private SortedIterables() {}
@@ -51,7 +48,7 @@ final class SortedIterables {
 
   @SuppressWarnings("unchecked")
   // if sortedSet.comparator() is null, the set must be naturally ordered
-  public static <E extends @Nullable Object> Comparator<? super E> comparator(
+  public static <E extends Object> Comparator<? super E> comparator(
       SortedSet<E> sortedSet) {
     Comparator<? super E> result = sortedSet.comparator();
     if (result == null) {
diff --git a/guava/src/com/google/common/collect/SortedLists.java b/guava/src/com/google/common/collect/SortedLists.java
index 0ebaab20f9..9c6dbbdff6 100644
--- a/guava/src/com/google/common/collect/SortedLists.java
+++ b/guava/src/com/google/common/collect/SortedLists.java
@@ -16,14 +16,11 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Function;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
 import java.util.RandomAccess;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static methods pertaining to sorted {@link List} instances.
@@ -34,8 +31,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @author Louis Wasserman
  */
-@GwtCompatible
-@Beta
 @ElementTypesAreNonnullByDefault
 final class SortedLists {
   private SortedLists() {}
@@ -51,7 +46,7 @@ final class SortedLists {
      */
     ANY_PRESENT {
       @Override
-      <E extends @Nullable Object> int resultIndex(
+      <E extends Object> int resultIndex(
           Comparator<? super E> comparator,
           @ParametricNullness E key,
           List<? extends E> list,
@@ -62,7 +57,7 @@ final class SortedLists {
     /** Return the index of the last list element that compares as equal to the key. */
     LAST_PRESENT {
       @Override
-      <E extends @Nullable Object> int resultIndex(
+      <E extends Object> int resultIndex(
           Comparator<? super E> comparator,
           @ParametricNullness E key,
           List<? extends E> list,
@@ -87,7 +82,7 @@ final class SortedLists {
     /** Return the index of the first list element that compares as equal to the key. */
     FIRST_PRESENT {
       @Override
-      <E extends @Nullable Object> int resultIndex(
+      <E extends Object> int resultIndex(
           Comparator<? super E> comparator,
           @ParametricNullness E key,
           List<? extends E> list,
@@ -116,7 +111,7 @@ final class SortedLists {
      */
     FIRST_AFTER {
       @Override
-      public <E extends @Nullable Object> int resultIndex(
+      public <E extends Object> int resultIndex(
           Comparator<? super E> comparator,
           @ParametricNullness E key,
           List<? extends E> list,
@@ -130,7 +125,7 @@ final class SortedLists {
      */
     LAST_BEFORE {
       @Override
-      public <E extends @Nullable Object> int resultIndex(
+      public <E extends Object> int resultIndex(
           Comparator<? super E> comparator,
           @ParametricNullness E key,
           List<? extends E> list,
@@ -139,7 +134,7 @@ final class SortedLists {
       }
     };
 
-    abstract <E extends @Nullable Object> int resultIndex(
+    abstract <E extends Object> int resultIndex(
         Comparator<? super E> comparator,
         @ParametricNullness E key,
         List<? extends E> list,
@@ -215,7 +210,7 @@ final class SortedLists {
    * <p>Equivalent to {@link #binarySearch(List, Function, Object, Comparator, KeyPresentBehavior,
    * KeyAbsentBehavior)} using {@link Ordering#natural}.
    */
-  public static <E extends @Nullable Object, K extends Comparable> int binarySearch(
+  public static <E extends Object, K extends Comparable> int binarySearch(
       List<E> list,
       Function<? super E, K> keyFunction,
       K key,
@@ -233,7 +228,7 @@ final class SortedLists {
    * KeyAbsentBehavior)} using {@link Lists#transform(List, Function) Lists.transform(list,
    * keyFunction)}.
    */
-  public static <E extends @Nullable Object, K extends @Nullable Object> int binarySearch(
+  public static <E extends Object, K extends Object> int binarySearch(
       List<E> list,
       Function<? super E, K> keyFunction,
       @ParametricNullness K key,
@@ -267,7 +262,7 @@ final class SortedLists {
    * @return the index determined by the {@code KeyPresentBehavior}, if the key is in the list;
    *     otherwise the index determined by the {@code KeyAbsentBehavior}.
    */
-  public static <E extends @Nullable Object> int binarySearch(
+  public static <E extends Object> int binarySearch(
       List<? extends E> list,
       @ParametricNullness E key,
       Comparator<? super E> comparator,
diff --git a/guava/src/com/google/common/collect/SortedMapDifference.java b/guava/src/com/google/common/collect/SortedMapDifference.java
index 46cac8a3da..caf8c772a0 100644
--- a/guava/src/com/google/common/collect/SortedMapDifference.java
+++ b/guava/src/com/google/common/collect/SortedMapDifference.java
@@ -16,9 +16,7 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.SortedMap;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An object representing the differences between two sorted maps.
@@ -26,9 +24,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 8.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public interface SortedMapDifference<K extends @Nullable Object, V extends @Nullable Object>
+public interface SortedMapDifference<K extends Object, V extends Object>
     extends MapDifference<K, V> {
 
   @Override
diff --git a/guava/src/com/google/common/collect/SortedMultiset.java b/guava/src/com/google/common/collect/SortedMultiset.java
index 68932f5859..babea9a4f5 100644
--- a/guava/src/com/google/common/collect/SortedMultiset.java
+++ b/guava/src/com/google/common/collect/SortedMultiset.java
@@ -16,14 +16,12 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.Collection;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.NavigableSet;
 import java.util.Set;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link Multiset} which maintains the ordering of its elements, according to either their
@@ -43,9 +41,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 11.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
-public interface SortedMultiset<E extends @Nullable Object>
+public interface SortedMultiset<E extends Object>
     extends SortedMultisetBridge<E>, SortedIterable<E> {
   /**
    * Returns the comparator that orders this multiset, or {@link Ordering#natural()} if the natural
diff --git a/guava/src/com/google/common/collect/SortedMultisetBridge.java b/guava/src/com/google/common/collect/SortedMultisetBridge.java
index 72d50beb69..fdd2b556e8 100644
--- a/guava/src/com/google/common/collect/SortedMultisetBridge.java
+++ b/guava/src/com/google/common/collect/SortedMultisetBridge.java
@@ -16,9 +16,7 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtIncompatible;
 import java.util.SortedSet;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Superinterface of {@link SortedMultiset} to introduce a bridge method for {@code elementSet()},
@@ -27,9 +25,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @author Louis Wasserman
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
-interface SortedMultisetBridge<E extends @Nullable Object> extends Multiset<E> {
+interface SortedMultisetBridge<E extends Object> extends Multiset<E> {
   @Override
   SortedSet<E> elementSet();
 }
diff --git a/guava/src/com/google/common/collect/SortedMultisets.java b/guava/src/com/google/common/collect/SortedMultisets.java
index 1d1940c9a9..803e71345f 100644
--- a/guava/src/com/google/common/collect/SortedMultisets.java
+++ b/guava/src/com/google/common/collect/SortedMultisets.java
@@ -19,33 +19,28 @@ package com.google.common.collect;
 import static com.google.common.collect.BoundType.CLOSED;
 import static com.google.common.collect.BoundType.OPEN;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.Multiset.Entry;
-import com.google.j2objc.annotations.Weak;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.NavigableSet;
 import java.util.NoSuchElementException;
 import java.util.SortedSet;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Provides static utility methods for creating and working with {@link SortedMultiset} instances.
  *
  * @author Louis Wasserman
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 final class SortedMultisets {
   private SortedMultisets() {}
 
   /** A skeleton implementation for {@link SortedMultiset#elementSet}. */
   @SuppressWarnings("JdkObsolete") // TODO(b/6160855): Switch GWT emulations to NavigableSet.
-  static class ElementSet<E extends @Nullable Object> extends Multisets.ElementSet<E>
+  static class ElementSet<E extends Object> extends Multisets.ElementSet<E>
       implements SortedSet<E> {
-    @Weak private final SortedMultiset<E> multiset;
+    private final SortedMultiset<E> multiset;
 
     ElementSet(SortedMultiset<E> multiset) {
       this.multiset = multiset;
@@ -95,8 +90,8 @@ final class SortedMultisets {
   }
 
   /** A skeleton navigable implementation for {@link SortedMultiset#elementSet}. */
-  @GwtIncompatible // Navigable
-  static class NavigableElementSet<E extends @Nullable Object> extends ElementSet<E>
+  // Navigable
+  static class NavigableElementSet<E extends Object> extends ElementSet<E>
       implements NavigableSet<E> {
     NavigableElementSet(SortedMultiset<E> multiset) {
       super(multiset);
@@ -174,7 +169,7 @@ final class SortedMultisets {
     }
   }
 
-  private static <E extends @Nullable Object> E getElementOrThrow(@CheckForNull Entry<E> entry) {
+  private static <E extends Object> E getElementOrThrow(@CheckForNull Entry<E> entry) {
     if (entry == null) {
       throw new NoSuchElementException();
     }
@@ -182,7 +177,7 @@ final class SortedMultisets {
   }
 
   @CheckForNull
-  private static <E extends @Nullable Object> E getElementOrNull(@CheckForNull Entry<E> entry) {
+  private static <E extends Object> E getElementOrNull(@CheckForNull Entry<E> entry) {
     return (entry == null) ? null : entry.getElement();
   }
 }
diff --git a/guava/src/com/google/common/collect/SortedSetMultimap.java b/guava/src/com/google/common/collect/SortedSetMultimap.java
index 8449014674..6ed311661f 100644
--- a/guava/src/com/google/common/collect/SortedSetMultimap.java
+++ b/guava/src/com/google/common/collect/SortedSetMultimap.java
@@ -16,8 +16,6 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Collection;
 import java.util.Comparator;
 import java.util.Map;
@@ -25,7 +23,6 @@ import java.util.Set;
 import java.util.SortedMap;
 import java.util.SortedSet;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@code SetMultimap} whose set of values for a given key are kept sorted; that is, they comprise
@@ -49,9 +46,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Jared Levy
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public interface SortedSetMultimap<K extends @Nullable Object, V extends @Nullable Object>
+public interface SortedSetMultimap<K extends Object, V extends Object>
     extends SetMultimap<K, V> {
   // Following Javadoc copied from Multimap.
 
@@ -75,7 +71,6 @@ public interface SortedSetMultimap<K extends @Nullable Object, V extends @Nullab
    * returns a {@link SortedSet}, instead of the {@link java.util.Collection} specified in the
    * {@link Multimap} interface.
    */
-  @CanIgnoreReturnValue
   @Override
   SortedSet<V> removeAll(@CheckForNull Object key);
 
@@ -88,7 +83,6 @@ public interface SortedSetMultimap<K extends @Nullable Object, V extends @Nullab
    *
    * <p>Any duplicates in {@code values} will be stored in the multimap once.
    */
-  @CanIgnoreReturnValue
   @Override
   SortedSet<V> replaceValues(@ParametricNullness K key, Iterable<? extends V> values);
 
diff --git a/guava/src/com/google/common/collect/SparseImmutableTable.java b/guava/src/com/google/common/collect/SparseImmutableTable.java
index b314f7bb33..7058fae4c8 100644
--- a/guava/src/com/google/common/collect/SparseImmutableTable.java
+++ b/guava/src/com/google/common/collect/SparseImmutableTable.java
@@ -16,15 +16,11 @@ package com.google.common.collect;
 
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.Immutable;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Map.Entry;
 
 /** A {@code RegularImmutableTable} optimized for sparse data. */
-@GwtCompatible
-@Immutable(containerOf = {"R", "C", "V"})
 @ElementTypesAreNonnullByDefault
 final class SparseImmutableTable<R, C, V> extends RegularImmutableTable<R, C, V> {
   static final ImmutableTable<Object, Object, Object> EMPTY =
diff --git a/guava/src/com/google/common/collect/StandardRowSortedTable.java b/guava/src/com/google/common/collect/StandardRowSortedTable.java
index bea5b7bb3a..2be8d58682 100644
--- a/guava/src/com/google/common/collect/StandardRowSortedTable.java
+++ b/guava/src/com/google/common/collect/StandardRowSortedTable.java
@@ -18,9 +18,7 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Supplier;
-import com.google.j2objc.annotations.WeakOuter;
 import java.util.Comparator;
 import java.util.Map;
 import java.util.Set;
@@ -45,7 +43,6 @@ import javax.annotation.CheckForNull;
  *
  * @author Jared Levy
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 class StandardRowSortedTable<R, C, V> extends StandardTable<R, C, V>
     implements RowSortedTable<R, C, V> {
@@ -91,7 +88,6 @@ class StandardRowSortedTable<R, C, V> extends StandardTable<R, C, V>
     return new RowSortedMap();
   }
 
-  @WeakOuter
   private class RowSortedMap extends RowMap implements SortedMap<R, Map<C, V>> {
     @Override
     public SortedSet<R> keySet() {
diff --git a/guava/src/com/google/common/collect/StandardTable.java b/guava/src/com/google/common/collect/StandardTable.java
index 06defb0eb8..4755376f22 100644
--- a/guava/src/com/google/common/collect/StandardTable.java
+++ b/guava/src/com/google/common/collect/StandardTable.java
@@ -26,15 +26,12 @@ import static com.google.common.collect.Maps.safeGet;
 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Function;
 import com.google.common.base.Predicate;
 import com.google.common.base.Supplier;
 import com.google.common.collect.Maps.IteratorBasedAbstractMap;
 import com.google.common.collect.Maps.ViewCachingAbstractMap;
 import com.google.common.collect.Sets.ImprovedAbstractSet;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.j2objc.annotations.WeakOuter;
 import java.io.Serializable;
 import java.util.Collection;
 import java.util.Iterator;
@@ -65,7 +62,6 @@ import javax.annotation.CheckForNull;
  *
  * @author Jared Levy
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializable {
   @GwtTransient final Map<R, Map<C, V>> backingMap;
@@ -142,7 +138,6 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
     return map;
   }
 
-  @CanIgnoreReturnValue
   @Override
   @CheckForNull
   public V put(R rowKey, C columnKey, V value) {
@@ -152,7 +147,6 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
     return getOrCreate(rowKey).put(columnKey, value);
   }
 
-  @CanIgnoreReturnValue
   @Override
   @CheckForNull
   public V remove(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
@@ -170,7 +164,6 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
     return value;
   }
 
-  @CanIgnoreReturnValue
   private Map<R, V> removeColumn(@CheckForNull Object column) {
     Map<R, V> output = new LinkedHashMap<>();
     Iterator<Entry<R, Map<C, V>>> iterator = backingMap.entrySet().iterator();
@@ -208,7 +201,6 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
    * Abstract set whose {@code isEmpty()} returns whether the table is empty and whose {@code
    * clear()} clears all table mappings.
    */
-  @WeakOuter
   private abstract class TableSet<T> extends ImprovedAbstractSet<T> {
     @Override
     public boolean isEmpty() {
@@ -490,7 +482,6 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
     }
 
     /** Removes all {@code Column} mappings whose row key and value satisfy the given predicate. */
-    @CanIgnoreReturnValue
     boolean removeFromColumnIf(Predicate<? super Entry<R, V>> predicate) {
       boolean changed = false;
       Iterator<Entry<R, Map<C, V>>> iterator = backingMap.entrySet().iterator();
@@ -514,7 +505,6 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
       return new EntrySet();
     }
 
-    @WeakOuter
     private class EntrySet extends ImprovedAbstractSet<Entry<R, V>> {
       @Override
       public Iterator<Entry<R, V>> iterator() {
@@ -575,7 +565,6 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
         while (iterator.hasNext()) {
           final Entry<R, Map<C, V>> entry = iterator.next();
           if (entry.getValue().containsKey(columnKey)) {
-            @WeakOuter
             class EntryImpl extends AbstractMapEntry<R, V> {
               @Override
               public R getKey() {
@@ -619,7 +608,6 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
       return new KeySet();
     }
 
-    @WeakOuter
     private class KeySet extends Maps.KeySet<R, V> {
       KeySet() {
         super(Column.this);
@@ -646,7 +634,6 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
       return new Values();
     }
 
-    @WeakOuter
     private class Values extends Maps.Values<R, V> {
       Values() {
         super(Column.this);
@@ -690,7 +677,6 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
     return (result == null) ? columnKeySet = new ColumnKeySet() : result;
   }
 
-  @WeakOuter
   private class ColumnKeySet extends TableSet<C> {
     @Override
     public Iterator<C> iterator() {
@@ -817,7 +803,6 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
     return new RowMap();
   }
 
-  @WeakOuter
   class RowMap extends ViewCachingAbstractMap<R, Map<C, V>> {
     @Override
     public boolean containsKey(@CheckForNull Object key) {
@@ -844,7 +829,6 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
       return new EntrySet();
     }
 
-    @WeakOuter
     class EntrySet extends TableSet<Entry<R, Map<C, V>>> {
       @Override
       public Iterator<Entry<R, Map<C, V>>> iterator() {
@@ -895,7 +879,6 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
     return (result == null) ? columnMap = new ColumnMap() : result;
   }
 
-  @WeakOuter
   private class ColumnMap extends ViewCachingAbstractMap<C, Map<R, V>> {
     // The cast to C occurs only when the key is in the map, implying that it
     // has the correct type.
@@ -933,7 +916,6 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
       return new ColumnMapValues();
     }
 
-    @WeakOuter
     class ColumnMapEntrySet extends TableSet<Entry<C, Map<R, V>>> {
       @Override
       public Iterator<Entry<C, Map<R, V>>> iterator() {
@@ -1004,7 +986,6 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
       }
     }
 
-    @WeakOuter
     private class ColumnMapValues extends Maps.Values<C, Map<R, V>> {
       ColumnMapValues() {
         super(ColumnMap.this);
diff --git a/guava/src/com/google/common/collect/Streams.java b/guava/src/com/google/common/collect/Streams.java
index 3bf8382023..b500ffdfc3 100644
--- a/guava/src/com/google/common/collect/Streams.java
+++ b/guava/src/com/google/common/collect/Streams.java
@@ -20,11 +20,7 @@ import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.math.LongMath;
-import com.google.errorprone.annotations.InlineMe;
-import com.google.errorprone.annotations.InlineMeValidationDisabled;
 import java.util.ArrayDeque;
 import java.util.Collection;
 import java.util.Deque;
@@ -49,21 +45,19 @@ import java.util.stream.LongStream;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods related to {@code Stream} instances.
  *
  * @since 21.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class Streams {
   /**
    * Returns a sequential {@link Stream} of the contents of {@code iterable}, delegating to {@link
    * Collection#stream} if possible.
    */
-  public static <T extends @Nullable Object> Stream<T> stream(Iterable<T> iterable) {
+  public static <T extends Object> Stream<T> stream(Iterable<T> iterable) {
     return (iterable instanceof Collection)
         ? ((Collection<T>) iterable).stream()
         : StreamSupport.stream(iterable.spliterator(), false);
@@ -74,10 +68,8 @@ public final class Streams {
    *
    * @deprecated There is no reason to use this; just invoke {@code collection.stream()} directly.
    */
-  @Beta
   @Deprecated
-  @InlineMe(replacement = "collection.stream()")
-  public static <T extends @Nullable Object> Stream<T> stream(Collection<T> collection) {
+  public static <T extends Object> Stream<T> stream(Collection<T> collection) {
     return collection.stream();
   }
 
@@ -85,8 +77,7 @@ public final class Streams {
    * Returns a sequential {@link Stream} of the remaining contents of {@code iterator}. Do not use
    * {@code iterator} directly after passing it to this method.
    */
-  @Beta
-  public static <T extends @Nullable Object> Stream<T> stream(Iterator<T> iterator) {
+  public static <T extends Object> Stream<T> stream(Iterator<T> iterator) {
     return StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator, 0), false);
   }
 
@@ -94,7 +85,6 @@ public final class Streams {
    * If a value is present in {@code optional}, returns a stream containing only that element,
    * otherwise returns an empty stream.
    */
-  @Beta
   public static <T> Stream<T> stream(com.google.common.base.Optional<T> optional) {
     return optional.isPresent() ? Stream.of(optional.get()) : Stream.empty();
   }
@@ -105,9 +95,6 @@ public final class Streams {
    *
    * <p><b>Java 9 users:</b> use {@code optional.stream()} instead.
    */
-  @Beta
-  @InlineMe(replacement = "optional.stream()")
-  @InlineMeValidationDisabled("Java 9+ API only")
   public static <T> Stream<T> stream(java.util.Optional<T> optional) {
     return optional.isPresent() ? Stream.of(optional.get()) : Stream.empty();
   }
@@ -118,9 +105,6 @@ public final class Streams {
    *
    * <p><b>Java 9 users:</b> use {@code optional.stream()} instead.
    */
-  @Beta
-  @InlineMe(replacement = "optional.stream()")
-  @InlineMeValidationDisabled("Java 9+ API only")
   public static IntStream stream(OptionalInt optional) {
     return optional.isPresent() ? IntStream.of(optional.getAsInt()) : IntStream.empty();
   }
@@ -131,9 +115,6 @@ public final class Streams {
    *
    * <p><b>Java 9 users:</b> use {@code optional.stream()} instead.
    */
-  @Beta
-  @InlineMe(replacement = "optional.stream()")
-  @InlineMeValidationDisabled("Java 9+ API only")
   public static LongStream stream(OptionalLong optional) {
     return optional.isPresent() ? LongStream.of(optional.getAsLong()) : LongStream.empty();
   }
@@ -144,9 +125,6 @@ public final class Streams {
    *
    * <p><b>Java 9 users:</b> use {@code optional.stream()} instead.
    */
-  @Beta
-  @InlineMe(replacement = "optional.stream()")
-  @InlineMeValidationDisabled("Java 9+ API only")
   public static DoubleStream stream(OptionalDouble optional) {
     return optional.isPresent() ? DoubleStream.of(optional.getAsDouble()) : DoubleStream.empty();
   }
@@ -168,7 +146,7 @@ public final class Streams {
    * @see Stream#concat(Stream, Stream)
    */
   @SafeVarargs
-  public static <T extends @Nullable Object> Stream<T> concat(Stream<? extends T>... streams) {
+  public static <T extends Object> Stream<T> concat(Stream<? extends T>... streams) {
     // TODO(lowasser): consider an implementation that can support SUBSIZED
     boolean isParallel = false;
     int characteristics = Spliterator.ORDERED | Spliterator.SIZED | Spliterator.NONNULL;
@@ -313,8 +291,7 @@ public final class Streams {
    * href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">efficiently splittable</a>.
    * This may harm parallel performance.
    */
-  @Beta
-  public static <A extends @Nullable Object, B extends @Nullable Object, R extends @Nullable Object>
+  public static <A extends Object, B extends Object, R extends Object>
       Stream<R> zip(
           Stream<A> streamA, Stream<B> streamB, BiFunction<? super A, ? super B, R> function) {
     checkNotNull(streamA);
@@ -376,8 +353,7 @@ public final class Streams {
    *
    * @since 22.0
    */
-  @Beta
-  public static <A extends @Nullable Object, B extends @Nullable Object> void forEachPair(
+  public static <A extends Object, B extends Object> void forEachPair(
       Stream<A> streamA, Stream<B> streamB, BiConsumer<? super A, ? super B> consumer) {
     checkNotNull(consumer);
 
@@ -393,7 +369,7 @@ public final class Streams {
   }
 
   // Use this carefully - it doesn't implement value semantics
-  private static class TemporaryPair<A extends @Nullable Object, B extends @Nullable Object> {
+  private static class TemporaryPair<A extends Object, B extends Object> {
     @ParametricNullness final A a;
     @ParametricNullness final B b;
 
@@ -425,8 +401,7 @@ public final class Streams {
    * <p>The order of the resulting stream is defined if and only if the order of the original stream
    * was defined.
    */
-  @Beta
-  public static <T extends @Nullable Object, R extends @Nullable Object> Stream<R> mapWithIndex(
+  public static <T extends Object, R extends Object> Stream<R> mapWithIndex(
       Stream<T> stream, FunctionWithIndex<? super T, ? extends R> function) {
     checkNotNull(stream);
     checkNotNull(function);
@@ -509,8 +484,7 @@ public final class Streams {
    * <p>The order of the resulting stream is defined if and only if the order of the original stream
    * was defined.
    */
-  @Beta
-  public static <R extends @Nullable Object> Stream<R> mapWithIndex(
+  public static <R extends Object> Stream<R> mapWithIndex(
       IntStream stream, IntFunctionWithIndex<R> function) {
     checkNotNull(stream);
     checkNotNull(function);
@@ -589,8 +563,7 @@ public final class Streams {
    * <p>The order of the resulting stream is defined if and only if the order of the original stream
    * was defined.
    */
-  @Beta
-  public static <R extends @Nullable Object> Stream<R> mapWithIndex(
+  public static <R extends Object> Stream<R> mapWithIndex(
       LongStream stream, LongFunctionWithIndex<R> function) {
     checkNotNull(stream);
     checkNotNull(function);
@@ -669,8 +642,7 @@ public final class Streams {
    * <p>The order of the resulting stream is defined if and only if the order of the original stream
    * was defined.
    */
-  @Beta
-  public static <R extends @Nullable Object> Stream<R> mapWithIndex(
+  public static <R extends Object> Stream<R> mapWithIndex(
       DoubleStream stream, DoubleFunctionWithIndex<R> function) {
     checkNotNull(stream);
     checkNotNull(function);
@@ -735,8 +707,7 @@ public final class Streams {
    *
    * @since 21.0
    */
-  @Beta
-  public interface FunctionWithIndex<T extends @Nullable Object, R extends @Nullable Object> {
+  public interface FunctionWithIndex<T extends Object, R extends Object> {
     /** Applies this function to the given argument and its index within a stream. */
     @ParametricNullness
     R apply(@ParametricNullness T from, long index);
@@ -744,7 +715,7 @@ public final class Streams {
 
   private abstract static class MapWithIndexSpliterator<
           F extends Spliterator<?>,
-          R extends @Nullable Object,
+          R extends Object,
           S extends MapWithIndexSpliterator<F, R, S>>
       implements Spliterator<R> {
     final F fromSpliterator;
@@ -791,8 +762,7 @@ public final class Streams {
    *
    * @since 21.0
    */
-  @Beta
-  public interface IntFunctionWithIndex<R extends @Nullable Object> {
+  public interface IntFunctionWithIndex<R extends Object> {
     /** Applies this function to the given argument and its index within a stream. */
     @ParametricNullness
     R apply(int from, long index);
@@ -806,8 +776,7 @@ public final class Streams {
    *
    * @since 21.0
    */
-  @Beta
-  public interface LongFunctionWithIndex<R extends @Nullable Object> {
+  public interface LongFunctionWithIndex<R extends Object> {
     /** Applies this function to the given argument and its index within a stream. */
     @ParametricNullness
     R apply(long from, long index);
@@ -821,8 +790,7 @@ public final class Streams {
    *
    * @since 21.0
    */
-  @Beta
-  public interface DoubleFunctionWithIndex<R extends @Nullable Object> {
+  public interface DoubleFunctionWithIndex<R extends Object> {
     /** Applies this function to the given argument and its index within a stream. */
     @ParametricNullness
     R apply(double from, long index);
@@ -853,7 +821,6 @@ public final class Streams {
    * split has a last element of null, so throw NPE" from "the final split was empty, so look for an
    * element in the prior one.")
    */
-  @Beta
   public static <T> java.util.Optional<T> findLast(Stream<T> stream) {
     class OptionalState {
       boolean set = false;
@@ -932,7 +899,6 @@ public final class Streams {
    * @see IntStream#findFirst()
    * @throws NullPointerException if the last element of the stream is null
    */
-  @Beta
   public static OptionalInt findLast(IntStream stream) {
     // findLast(Stream) does some allocation, so we might as well box some more
     java.util.Optional<Integer> boxedLast = findLast(stream.boxed());
@@ -951,7 +917,6 @@ public final class Streams {
    * @see LongStream#findFirst()
    * @throws NullPointerException if the last element of the stream is null
    */
-  @Beta
   public static OptionalLong findLast(LongStream stream) {
     // findLast(Stream) does some allocation, so we might as well box some more
     java.util.Optional<Long> boxedLast = findLast(stream.boxed());
@@ -970,7 +935,6 @@ public final class Streams {
    * @see DoubleStream#findFirst()
    * @throws NullPointerException if the last element of the stream is null
    */
-  @Beta
   public static OptionalDouble findLast(DoubleStream stream) {
     // findLast(Stream) does some allocation, so we might as well box some more
     java.util.Optional<Double> boxedLast = findLast(stream.boxed());
diff --git a/guava/src/com/google/common/collect/Synchronized.java b/guava/src/com/google/common/collect/Synchronized.java
index 25e28709db..8125ebc15b 100644
--- a/guava/src/com/google/common/collect/Synchronized.java
+++ b/guava/src/com/google/common/collect/Synchronized.java
@@ -18,10 +18,6 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
-import com.google.j2objc.annotations.RetainedWith;
 import java.io.IOException;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
@@ -48,7 +44,6 @@ import java.util.function.Predicate;
 import java.util.function.UnaryOperator;
 import java.util.stream.Stream;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Synchronized collection views. The returned synchronized collection views are serializable if the
@@ -62,7 +57,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Mike Bostock
  * @author Jared Levy
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 /*
  * I have decided not to bother adding @ParametricNullness annotations in this class. Adding them is
@@ -103,24 +97,23 @@ final class Synchronized {
     // they don't contain any non-transient member variables, while the
     // following writeObject() handles the SynchronizedObject members.
 
-    @GwtIncompatible // java.io.ObjectOutputStream
+    // java.io.ObjectOutputStream
     private void writeObject(ObjectOutputStream stream) throws IOException {
       synchronized (mutex) {
         stream.defaultWriteObject();
       }
     }
 
-    @GwtIncompatible // not needed in emulated source
+    // not needed in emulated source
     private static final long serialVersionUID = 0;
   }
 
-  private static <E extends @Nullable Object> Collection<E> collection(
+  private static <E extends Object> Collection<E> collection(
       Collection<E> collection, @CheckForNull Object mutex) {
     return new SynchronizedCollection<E>(collection, mutex);
   }
 
-  @VisibleForTesting
-  static class SynchronizedCollection<E extends @Nullable Object> extends SynchronizedObject
+  static class SynchronizedCollection<E extends Object> extends SynchronizedObject
       implements Collection<E> {
     private SynchronizedCollection(Collection<E> delegate, @CheckForNull Object mutex) {
       super(delegate, mutex);
@@ -243,7 +236,7 @@ final class Synchronized {
     }
 
     @Override
-    public @Nullable Object[] toArray() {
+    public Object[] toArray() {
       synchronized (mutex) {
         return delegate().toArray();
       }
@@ -251,7 +244,7 @@ final class Synchronized {
 
     @Override
     @SuppressWarnings("nullness") // b/192354773 in our checker affects toArray declarations
-    public <T extends @Nullable Object> T[] toArray(T[] a) {
+    public <T extends Object> T[] toArray(T[] a) {
       synchronized (mutex) {
         return delegate().toArray(a);
       }
@@ -260,12 +253,11 @@ final class Synchronized {
     private static final long serialVersionUID = 0;
   }
 
-  @VisibleForTesting
-  static <E extends @Nullable Object> Set<E> set(Set<E> set, @CheckForNull Object mutex) {
+  static <E extends Object> Set<E> set(Set<E> set, @CheckForNull Object mutex) {
     return new SynchronizedSet<E>(set, mutex);
   }
 
-  static class SynchronizedSet<E extends @Nullable Object> extends SynchronizedCollection<E>
+  static class SynchronizedSet<E extends Object> extends SynchronizedCollection<E>
       implements Set<E> {
 
     SynchronizedSet(Set<E> delegate, @CheckForNull Object mutex) {
@@ -297,12 +289,12 @@ final class Synchronized {
     private static final long serialVersionUID = 0;
   }
 
-  private static <E extends @Nullable Object> SortedSet<E> sortedSet(
+  private static <E extends Object> SortedSet<E> sortedSet(
       SortedSet<E> set, @CheckForNull Object mutex) {
     return new SynchronizedSortedSet<E>(set, mutex);
   }
 
-  static class SynchronizedSortedSet<E extends @Nullable Object> extends SynchronizedSet<E>
+  static class SynchronizedSortedSet<E extends Object> extends SynchronizedSet<E>
       implements SortedSet<E> {
     SynchronizedSortedSet(SortedSet<E> delegate, @CheckForNull Object mutex) {
       super(delegate, mutex);
@@ -359,14 +351,14 @@ final class Synchronized {
     private static final long serialVersionUID = 0;
   }
 
-  private static <E extends @Nullable Object> List<E> list(
+  private static <E extends Object> List<E> list(
       List<E> list, @CheckForNull Object mutex) {
     return (list instanceof RandomAccess)
         ? new SynchronizedRandomAccessList<E>(list, mutex)
         : new SynchronizedList<E>(list, mutex);
   }
 
-  private static class SynchronizedList<E extends @Nullable Object>
+  private static class SynchronizedList<E extends Object>
       extends SynchronizedCollection<E> implements List<E> {
     SynchronizedList(List<E> delegate, @CheckForNull Object mutex) {
       super(delegate, mutex);
@@ -477,7 +469,7 @@ final class Synchronized {
     private static final long serialVersionUID = 0;
   }
 
-  private static class SynchronizedRandomAccessList<E extends @Nullable Object>
+  private static class SynchronizedRandomAccessList<E extends Object>
       extends SynchronizedList<E> implements RandomAccess {
     SynchronizedRandomAccessList(List<E> list, @CheckForNull Object mutex) {
       super(list, mutex);
@@ -486,7 +478,7 @@ final class Synchronized {
     private static final long serialVersionUID = 0;
   }
 
-  static <E extends @Nullable Object> Multiset<E> multiset(
+  static <E extends Object> Multiset<E> multiset(
       Multiset<E> multiset, @CheckForNull Object mutex) {
     if (multiset instanceof SynchronizedMultiset || multiset instanceof ImmutableMultiset) {
       return multiset;
@@ -494,7 +486,7 @@ final class Synchronized {
     return new SynchronizedMultiset<E>(multiset, mutex);
   }
 
-  private static class SynchronizedMultiset<E extends @Nullable Object>
+  private static class SynchronizedMultiset<E extends Object>
       extends SynchronizedCollection<E> implements Multiset<E> {
     @CheckForNull transient Set<E> elementSet;
     @CheckForNull transient Set<Multiset.Entry<E>> entrySet;
@@ -583,7 +575,7 @@ final class Synchronized {
     private static final long serialVersionUID = 0;
   }
 
-  static <K extends @Nullable Object, V extends @Nullable Object> Multimap<K, V> multimap(
+  static <K extends Object, V extends Object> Multimap<K, V> multimap(
       Multimap<K, V> multimap, @CheckForNull Object mutex) {
     if (multimap instanceof SynchronizedMultimap || multimap instanceof BaseImmutableMultimap) {
       return multimap;
@@ -591,7 +583,7 @@ final class Synchronized {
     return new SynchronizedMultimap<>(multimap, mutex);
   }
 
-  private static class SynchronizedMultimap<K extends @Nullable Object, V extends @Nullable Object>
+  private static class SynchronizedMultimap<K extends Object, V extends Object>
       extends SynchronizedObject implements Multimap<K, V> {
     @CheckForNull transient Set<K> keySet;
     @CheckForNull transient Collection<V> valuesCollection;
@@ -777,7 +769,7 @@ final class Synchronized {
     private static final long serialVersionUID = 0;
   }
 
-  static <K extends @Nullable Object, V extends @Nullable Object> ListMultimap<K, V> listMultimap(
+  static <K extends Object, V extends Object> ListMultimap<K, V> listMultimap(
       ListMultimap<K, V> multimap, @CheckForNull Object mutex) {
     if (multimap instanceof SynchronizedListMultimap || multimap instanceof BaseImmutableMultimap) {
       return multimap;
@@ -786,7 +778,7 @@ final class Synchronized {
   }
 
   private static class SynchronizedListMultimap<
-          K extends @Nullable Object, V extends @Nullable Object>
+          K extends Object, V extends Object>
       extends SynchronizedMultimap<K, V> implements ListMultimap<K, V> {
     SynchronizedListMultimap(ListMultimap<K, V> delegate, @CheckForNull Object mutex) {
       super(delegate, mutex);
@@ -821,7 +813,7 @@ final class Synchronized {
     private static final long serialVersionUID = 0;
   }
 
-  static <K extends @Nullable Object, V extends @Nullable Object> SetMultimap<K, V> setMultimap(
+  static <K extends Object, V extends Object> SetMultimap<K, V> setMultimap(
       SetMultimap<K, V> multimap, @CheckForNull Object mutex) {
     if (multimap instanceof SynchronizedSetMultimap || multimap instanceof BaseImmutableMultimap) {
       return multimap;
@@ -830,7 +822,7 @@ final class Synchronized {
   }
 
   private static class SynchronizedSetMultimap<
-          K extends @Nullable Object, V extends @Nullable Object>
+          K extends Object, V extends Object>
       extends SynchronizedMultimap<K, V> implements SetMultimap<K, V> {
     @CheckForNull transient Set<Map.Entry<K, V>> entrySet;
 
@@ -877,7 +869,7 @@ final class Synchronized {
     private static final long serialVersionUID = 0;
   }
 
-  static <K extends @Nullable Object, V extends @Nullable Object>
+  static <K extends Object, V extends Object>
       SortedSetMultimap<K, V> sortedSetMultimap(
           SortedSetMultimap<K, V> multimap, @CheckForNull Object mutex) {
     if (multimap instanceof SynchronizedSortedSetMultimap) {
@@ -887,7 +879,7 @@ final class Synchronized {
   }
 
   private static class SynchronizedSortedSetMultimap<
-          K extends @Nullable Object, V extends @Nullable Object>
+          K extends Object, V extends Object>
       extends SynchronizedSetMultimap<K, V> implements SortedSetMultimap<K, V> {
     SynchronizedSortedSetMultimap(SortedSetMultimap<K, V> delegate, @CheckForNull Object mutex) {
       super(delegate, mutex);
@@ -930,7 +922,7 @@ final class Synchronized {
     private static final long serialVersionUID = 0;
   }
 
-  private static <E extends @Nullable Object> Collection<E> typePreservingCollection(
+  private static <E extends Object> Collection<E> typePreservingCollection(
       Collection<E> collection, @CheckForNull Object mutex) {
     if (collection instanceof SortedSet) {
       return sortedSet((SortedSet<E>) collection, mutex);
@@ -944,7 +936,7 @@ final class Synchronized {
     return collection(collection, mutex);
   }
 
-  private static <E extends @Nullable Object> Set<E> typePreservingSet(
+  private static <E extends Object> Set<E> typePreservingSet(
       Set<E> set, @CheckForNull Object mutex) {
     if (set instanceof SortedSet) {
       return sortedSet((SortedSet<E>) set, mutex);
@@ -954,7 +946,7 @@ final class Synchronized {
   }
 
   private static class SynchronizedAsMapEntries<
-          K extends @Nullable Object, V extends @Nullable Object>
+          K extends Object, V extends Object>
       extends SynchronizedSet<Map.Entry<K, Collection<V>>> {
     SynchronizedAsMapEntries(
         Set<Map.Entry<K, Collection<V>>> delegate, @CheckForNull Object mutex) {
@@ -1001,7 +993,7 @@ final class Synchronized {
 
     @Override
     @SuppressWarnings("nullness") // b/192354773 in our checker affects toArray declarations
-    public <T extends @Nullable Object> T[] toArray(T[] array) {
+    public <T extends Object> T[] toArray(T[] array) {
       synchronized (mutex) {
         return ObjectArrays.toArrayImpl(delegate(), array);
       }
@@ -1055,13 +1047,12 @@ final class Synchronized {
     private static final long serialVersionUID = 0;
   }
 
-  @VisibleForTesting
-  static <K extends @Nullable Object, V extends @Nullable Object> Map<K, V> map(
+  static <K extends Object, V extends Object> Map<K, V> map(
       Map<K, V> map, @CheckForNull Object mutex) {
     return new SynchronizedMap<>(map, mutex);
   }
 
-  private static class SynchronizedMap<K extends @Nullable Object, V extends @Nullable Object>
+  private static class SynchronizedMap<K extends Object, V extends Object>
       extends SynchronizedObject implements Map<K, V> {
     @CheckForNull transient Set<K> keySet;
     @CheckForNull transient Collection<V> values;
@@ -1275,12 +1266,12 @@ final class Synchronized {
     private static final long serialVersionUID = 0;
   }
 
-  static <K extends @Nullable Object, V extends @Nullable Object> SortedMap<K, V> sortedMap(
+  static <K extends Object, V extends Object> SortedMap<K, V> sortedMap(
       SortedMap<K, V> sortedMap, @CheckForNull Object mutex) {
     return new SynchronizedSortedMap<>(sortedMap, mutex);
   }
 
-  static class SynchronizedSortedMap<K extends @Nullable Object, V extends @Nullable Object>
+  static class SynchronizedSortedMap<K extends Object, V extends Object>
       extends SynchronizedMap<K, V> implements SortedMap<K, V> {
 
     SynchronizedSortedMap(SortedMap<K, V> delegate, @CheckForNull Object mutex) {
@@ -1338,7 +1329,7 @@ final class Synchronized {
     private static final long serialVersionUID = 0;
   }
 
-  static <K extends @Nullable Object, V extends @Nullable Object> BiMap<K, V> biMap(
+  static <K extends Object, V extends Object> BiMap<K, V> biMap(
       BiMap<K, V> bimap, @CheckForNull Object mutex) {
     if (bimap instanceof SynchronizedBiMap || bimap instanceof ImmutableBiMap) {
       return bimap;
@@ -1346,11 +1337,10 @@ final class Synchronized {
     return new SynchronizedBiMap<>(bimap, mutex, null);
   }
 
-  @VisibleForTesting
-  static class SynchronizedBiMap<K extends @Nullable Object, V extends @Nullable Object>
+  static class SynchronizedBiMap<K extends Object, V extends Object>
       extends SynchronizedMap<K, V> implements BiMap<K, V>, Serializable {
     @CheckForNull private transient Set<V> valueSet;
-    @RetainedWith @CheckForNull private transient BiMap<V, K> inverse;
+    @CheckForNull private transient BiMap<V, K> inverse;
 
     private SynchronizedBiMap(
         BiMap<K, V> delegate, @CheckForNull Object mutex, @CheckForNull BiMap<V, K> inverse) {
@@ -1394,7 +1384,7 @@ final class Synchronized {
     private static final long serialVersionUID = 0;
   }
 
-  private static class SynchronizedAsMap<K extends @Nullable Object, V extends @Nullable Object>
+  private static class SynchronizedAsMap<K extends Object, V extends Object>
       extends SynchronizedMap<K, Collection<V>> {
     @CheckForNull transient Set<Map.Entry<K, Collection<V>>> asMapEntrySet;
     @CheckForNull transient Collection<Collection<V>> asMapValues;
@@ -1441,7 +1431,7 @@ final class Synchronized {
     private static final long serialVersionUID = 0;
   }
 
-  private static class SynchronizedAsMapValues<V extends @Nullable Object>
+  private static class SynchronizedAsMapValues<V extends Object>
       extends SynchronizedCollection<Collection<V>> {
     SynchronizedAsMapValues(Collection<Collection<V>> delegate, @CheckForNull Object mutex) {
       super(delegate, mutex);
@@ -1461,9 +1451,8 @@ final class Synchronized {
     private static final long serialVersionUID = 0;
   }
 
-  @GwtIncompatible // NavigableSet
-  @VisibleForTesting
-  static class SynchronizedNavigableSet<E extends @Nullable Object> extends SynchronizedSortedSet<E>
+  // NavigableSet
+  static class SynchronizedNavigableSet<E extends Object> extends SynchronizedSortedSet<E>
       implements NavigableSet<E> {
     SynchronizedNavigableSet(NavigableSet<E> delegate, @CheckForNull Object mutex) {
       super(delegate, mutex);
@@ -1582,32 +1571,31 @@ final class Synchronized {
     private static final long serialVersionUID = 0;
   }
 
-  @GwtIncompatible // NavigableSet
-  static <E extends @Nullable Object> NavigableSet<E> navigableSet(
+  // NavigableSet
+  static <E extends Object> NavigableSet<E> navigableSet(
       NavigableSet<E> navigableSet, @CheckForNull Object mutex) {
     return new SynchronizedNavigableSet<E>(navigableSet, mutex);
   }
 
-  @GwtIncompatible // NavigableSet
-  static <E extends @Nullable Object> NavigableSet<E> navigableSet(NavigableSet<E> navigableSet) {
+  // NavigableSet
+  static <E extends Object> NavigableSet<E> navigableSet(NavigableSet<E> navigableSet) {
     return navigableSet(navigableSet, null);
   }
 
-  @GwtIncompatible // NavigableMap
-  static <K extends @Nullable Object, V extends @Nullable Object> NavigableMap<K, V> navigableMap(
+  // NavigableMap
+  static <K extends Object, V extends Object> NavigableMap<K, V> navigableMap(
       NavigableMap<K, V> navigableMap) {
     return navigableMap(navigableMap, null);
   }
 
-  @GwtIncompatible // NavigableMap
-  static <K extends @Nullable Object, V extends @Nullable Object> NavigableMap<K, V> navigableMap(
+  // NavigableMap
+  static <K extends Object, V extends Object> NavigableMap<K, V> navigableMap(
       NavigableMap<K, V> navigableMap, @CheckForNull Object mutex) {
     return new SynchronizedNavigableMap<>(navigableMap, mutex);
   }
 
-  @GwtIncompatible // NavigableMap
-  @VisibleForTesting
-  static class SynchronizedNavigableMap<K extends @Nullable Object, V extends @Nullable Object>
+  // NavigableMap
+  static class SynchronizedNavigableMap<K extends Object, V extends Object>
       extends SynchronizedSortedMap<K, V> implements NavigableMap<K, V> {
 
     SynchronizedNavigableMap(NavigableMap<K, V> delegate, @CheckForNull Object mutex) {
@@ -1796,9 +1784,9 @@ final class Synchronized {
     private static final long serialVersionUID = 0;
   }
 
-  @GwtIncompatible // works but is needed only for NavigableMap
+  // works but is needed only for NavigableMap
   @CheckForNull
-  private static <K extends @Nullable Object, V extends @Nullable Object>
+  private static <K extends Object, V extends Object>
       Map.Entry<K, V> nullableSynchronizedEntry(
           @CheckForNull Map.Entry<K, V> entry, @CheckForNull Object mutex) {
     if (entry == null) {
@@ -1807,8 +1795,8 @@ final class Synchronized {
     return new SynchronizedEntry<>(entry, mutex);
   }
 
-  @GwtIncompatible // works but is needed only for NavigableMap
-  private static class SynchronizedEntry<K extends @Nullable Object, V extends @Nullable Object>
+  // works but is needed only for NavigableMap
+  private static class SynchronizedEntry<K extends Object, V extends Object>
       extends SynchronizedObject implements Map.Entry<K, V> {
 
     SynchronizedEntry(Map.Entry<K, V> delegate, @CheckForNull Object mutex) {
@@ -1859,11 +1847,11 @@ final class Synchronized {
     private static final long serialVersionUID = 0;
   }
 
-  static <E extends @Nullable Object> Queue<E> queue(Queue<E> queue, @CheckForNull Object mutex) {
+  static <E extends Object> Queue<E> queue(Queue<E> queue, @CheckForNull Object mutex) {
     return (queue instanceof SynchronizedQueue) ? queue : new SynchronizedQueue<E>(queue, mutex);
   }
 
-  private static class SynchronizedQueue<E extends @Nullable Object>
+  private static class SynchronizedQueue<E extends Object>
       extends SynchronizedCollection<E> implements Queue<E> {
 
     SynchronizedQueue(Queue<E> delegate, @CheckForNull Object mutex) {
@@ -1915,11 +1903,11 @@ final class Synchronized {
     private static final long serialVersionUID = 0;
   }
 
-  static <E extends @Nullable Object> Deque<E> deque(Deque<E> deque, @CheckForNull Object mutex) {
+  static <E extends Object> Deque<E> deque(Deque<E> deque, @CheckForNull Object mutex) {
     return new SynchronizedDeque<E>(deque, mutex);
   }
 
-  private static final class SynchronizedDeque<E extends @Nullable Object>
+  private static final class SynchronizedDeque<E extends Object>
       extends SynchronizedQueue<E> implements Deque<E> {
 
     SynchronizedDeque(Deque<E> delegate, @CheckForNull Object mutex) {
@@ -2057,13 +2045,13 @@ final class Synchronized {
     private static final long serialVersionUID = 0;
   }
 
-  static <R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object>
+  static <R extends Object, C extends Object, V extends Object>
       Table<R, C, V> table(Table<R, C, V> table, @CheckForNull Object mutex) {
     return new SynchronizedTable<>(table, mutex);
   }
 
   private static final class SynchronizedTable<
-          R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object>
+          R extends Object, C extends Object, V extends Object>
       extends SynchronizedObject implements Table<R, C, V> {
 
     SynchronizedTable(Table<R, C, V> delegate, @CheckForNull Object mutex) {
diff --git a/guava/src/com/google/common/collect/Table.java b/guava/src/com/google/common/collect/Table.java
index 97d3f70277..fb7f787f42 100644
--- a/guava/src/com/google/common/collect/Table.java
+++ b/guava/src/com/google/common/collect/Table.java
@@ -16,16 +16,11 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Objects;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.CompatibleWith;
-import com.google.errorprone.annotations.DoNotMock;
 import java.util.Collection;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A collection that associates an ordered pair of keys, called a row key and a column key, with a
@@ -54,11 +49,9 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @param <V> the type of the mapped values
  * @since 7.0
  */
-@DoNotMock("Use ImmutableTable, HashBasedTable, or another implementation")
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public interface Table<
-    R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object> {
+    R extends Object, C extends Object, V extends Object> {
   // TODO(jlevy): Consider adding methods similar to ConcurrentMap methods.
 
   // Accessors
@@ -70,29 +63,29 @@ public interface Table<
    * @param columnKey key of column to search for
    */
   boolean contains(
-      @CompatibleWith("R") @CheckForNull Object rowKey,
-      @CompatibleWith("C") @CheckForNull Object columnKey);
+      @CheckForNull Object rowKey,
+      @CheckForNull Object columnKey);
 
   /**
    * Returns {@code true} if the table contains a mapping with the specified row key.
    *
    * @param rowKey key of row to search for
    */
-  boolean containsRow(@CompatibleWith("R") @CheckForNull Object rowKey);
+  boolean containsRow(@CheckForNull Object rowKey);
 
   /**
    * Returns {@code true} if the table contains a mapping with the specified column.
    *
    * @param columnKey key of column to search for
    */
-  boolean containsColumn(@CompatibleWith("C") @CheckForNull Object columnKey);
+  boolean containsColumn(@CheckForNull Object columnKey);
 
   /**
    * Returns {@code true} if the table contains a mapping with the specified value.
    *
    * @param value value to search for
    */
-  boolean containsValue(@CompatibleWith("V") @CheckForNull Object value);
+  boolean containsValue(@CheckForNull Object value);
 
   /**
    * Returns the value corresponding to the given row and column keys, or {@code null} if no such
@@ -103,8 +96,8 @@ public interface Table<
    */
   @CheckForNull
   V get(
-      @CompatibleWith("R") @CheckForNull Object rowKey,
-      @CompatibleWith("C") @CheckForNull Object columnKey);
+      @CheckForNull Object rowKey,
+      @CheckForNull Object columnKey);
 
   /** Returns {@code true} if the table contains no mappings. */
   boolean isEmpty();
@@ -141,7 +134,6 @@ public interface Table<
    * @return the value previously associated with the keys, or {@code null} if no mapping existed
    *     for the keys
    */
-  @CanIgnoreReturnValue
   @CheckForNull
   V put(@ParametricNullness R rowKey, @ParametricNullness C columnKey, @ParametricNullness V value);
 
@@ -160,11 +152,10 @@ public interface Table<
    * @param columnKey column key of mapping to be removed
    * @return the value previously associated with the keys, or {@code null} if no such value existed
    */
-  @CanIgnoreReturnValue
   @CheckForNull
   V remove(
-      @CompatibleWith("R") @CheckForNull Object rowKey,
-      @CompatibleWith("C") @CheckForNull Object columnKey);
+      @CheckForNull Object rowKey,
+      @CheckForNull Object columnKey);
 
   // Views
 
@@ -257,7 +248,7 @@ public interface Table<
    * @since 7.0
    */
   interface Cell<
-      R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object> {
+      R extends Object, C extends Object, V extends Object> {
     /** Returns the row key of this cell. */
     @ParametricNullness
     R getRowKey();
diff --git a/guava/src/com/google/common/collect/TableCollectors.java b/guava/src/com/google/common/collect/TableCollectors.java
index 99ab810683..d7a497012a 100644
--- a/guava/src/com/google/common/collect/TableCollectors.java
+++ b/guava/src/com/google/common/collect/TableCollectors.java
@@ -18,7 +18,6 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.Tables.AbstractCell;
 import java.util.ArrayList;
 import java.util.List;
@@ -26,14 +25,12 @@ import java.util.function.BinaryOperator;
 import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.stream.Collector;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** Collectors utilities for {@code common.collect.Table} internals. */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 final class TableCollectors {
 
-  static <T extends @Nullable Object, R, C, V>
+  static <T extends Object, R, C, V>
       Collector<T, ?, ImmutableTable<R, C, V>> toImmutableTable(
           Function<? super T, ? extends R> rowFunction,
           Function<? super T, ? extends C> columnFunction,
@@ -49,7 +46,7 @@ final class TableCollectors {
         ImmutableTable.Builder::build);
   }
 
-  static <T extends @Nullable Object, R, C, V>
+  static <T extends Object, R, C, V>
       Collector<T, ?, ImmutableTable<R, C, V>> toImmutableTable(
           Function<? super T, ? extends R> rowFunction,
           Function<? super T, ? extends C> columnFunction,
@@ -81,10 +78,10 @@ final class TableCollectors {
   }
 
   static <
-          T extends @Nullable Object,
-          R extends @Nullable Object,
-          C extends @Nullable Object,
-          V extends @Nullable Object,
+          T extends Object,
+          R extends Object,
+          C extends Object,
+          V extends Object,
           I extends Table<R, C, V>>
       Collector<T, ?, I> toTable(
           java.util.function.Function<? super T, ? extends R> rowFunction,
@@ -102,10 +99,10 @@ final class TableCollectors {
   }
 
   static <
-          T extends @Nullable Object,
-          R extends @Nullable Object,
-          C extends @Nullable Object,
-          V extends @Nullable Object,
+          T extends Object,
+          R extends Object,
+          C extends Object,
+          V extends Object,
           I extends Table<R, C, V>>
       Collector<T, ?, I> toTable(
           java.util.function.Function<? super T, ? extends R> rowFunction,
@@ -197,7 +194,7 @@ final class TableCollectors {
   }
 
   private static <
-          R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object>
+          R extends Object, C extends Object, V extends Object>
       void mergeTables(
           Table<R, C, V> table,
           @ParametricNullness R row,
diff --git a/guava/src/com/google/common/collect/Tables.java b/guava/src/com/google/common/collect/Tables.java
index 2d743f07ea..97b119ba0a 100644
--- a/guava/src/com/google/common/collect/Tables.java
+++ b/guava/src/com/google/common/collect/Tables.java
@@ -20,8 +20,6 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Function;
 import com.google.common.base.Objects;
 import com.google.common.base.Supplier;
@@ -38,7 +36,6 @@ import java.util.Spliterator;
 import java.util.function.BinaryOperator;
 import java.util.stream.Collector;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Provides static methods that involve a {@code Table}.
@@ -50,7 +47,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 7.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class Tables {
   private Tables() {}
@@ -67,12 +63,11 @@ public final class Tables {
    *
    * @since 21.0
    */
-  @Beta
   public static <
-          T extends @Nullable Object,
-          R extends @Nullable Object,
-          C extends @Nullable Object,
-          V extends @Nullable Object,
+          T extends Object,
+          R extends Object,
+          C extends Object,
+          V extends Object,
           I extends Table<R, C, V>>
       Collector<T, ?, I> toTable(
           java.util.function.Function<? super T, ? extends R> rowFunction,
@@ -97,10 +92,10 @@ public final class Tables {
    * @since 21.0
    */
   public static <
-          T extends @Nullable Object,
-          R extends @Nullable Object,
-          C extends @Nullable Object,
-          V extends @Nullable Object,
+          T extends Object,
+          R extends Object,
+          C extends Object,
+          V extends Object,
           I extends Table<R, C, V>>
       Collector<T, ?, I> toTable(
           java.util.function.Function<? super T, ? extends R> rowFunction,
@@ -121,7 +116,7 @@ public final class Tables {
    * @param columnKey the column key to be associated with the returned cell
    * @param value the value to be associated with the returned cell
    */
-  public static <R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object>
+  public static <R extends Object, C extends Object, V extends Object>
       Cell<R, C, V> immutableCell(
           @ParametricNullness R rowKey,
           @ParametricNullness C columnKey,
@@ -130,7 +125,7 @@ public final class Tables {
   }
 
   static final class ImmutableCell<
-          R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object>
+          R extends Object, C extends Object, V extends Object>
       extends AbstractCell<R, C, V> implements Serializable {
     @ParametricNullness private final R rowKey;
     @ParametricNullness private final C columnKey;
@@ -167,7 +162,7 @@ public final class Tables {
   }
 
   abstract static class AbstractCell<
-          R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object>
+          R extends Object, C extends Object, V extends Object>
       implements Cell<R, C, V> {
     // needed for serialization
     AbstractCell() {}
@@ -209,7 +204,7 @@ public final class Tables {
    * columnKeySet().iterator()} doesn't. With a transposed {@link HashBasedTable}, it's the other
    * way around.
    */
-  public static <R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object>
+  public static <R extends Object, C extends Object, V extends Object>
       Table<C, R, V> transpose(Table<R, C, V> table) {
     return (table instanceof TransposeTable)
         ? ((TransposeTable<R, C, V>) table).original
@@ -217,7 +212,7 @@ public final class Tables {
   }
 
   private static class TransposeTable<
-          C extends @Nullable Object, R extends @Nullable Object, V extends @Nullable Object>
+          C extends Object, R extends Object, V extends Object>
       extends AbstractTable<C, R, V> {
     final Table<R, C, V> original;
 
@@ -376,7 +371,6 @@ public final class Tables {
    * @throws IllegalArgumentException if {@code backingMap} is not empty
    * @since 10.0
    */
-  @Beta
   public static <R, C, V> Table<R, C, V> newCustomTable(
       Map<R, Map<C, V>> backingMap, Supplier<? extends Map<C, V>> factory) {
     checkArgument(backingMap.isEmpty());
@@ -406,22 +400,21 @@ public final class Tables {
    *
    * @since 10.0
    */
-  @Beta
   public static <
-          R extends @Nullable Object,
-          C extends @Nullable Object,
-          V1 extends @Nullable Object,
-          V2 extends @Nullable Object>
+          R extends Object,
+          C extends Object,
+          V1 extends Object,
+          V2 extends Object>
       Table<R, C, V2> transformValues(
           Table<R, C, V1> fromTable, Function<? super V1, V2> function) {
     return new TransformedTable<>(fromTable, function);
   }
 
   private static class TransformedTable<
-          R extends @Nullable Object,
-          C extends @Nullable Object,
-          V1 extends @Nullable Object,
-          V2 extends @Nullable Object>
+          R extends Object,
+          C extends Object,
+          V1 extends Object,
+          V2 extends Object>
       extends AbstractTable<R, C, V2> {
     final Table<R, C, V1> fromTable;
     final Function<? super V1, V2> function;
@@ -562,13 +555,13 @@ public final class Tables {
    *
    * @since 11.0
    */
-  public static <R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object>
+  public static <R extends Object, C extends Object, V extends Object>
       Table<R, C, V> unmodifiableTable(Table<? extends R, ? extends C, ? extends V> table) {
     return new UnmodifiableTable<>(table);
   }
 
   private static class UnmodifiableTable<
-          R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object>
+          R extends Object, C extends Object, V extends Object>
       extends ForwardingTable<R, C, V> implements Serializable {
     final Table<? extends R, ? extends C, ? extends V> delegate;
 
@@ -664,8 +657,7 @@ public final class Tables {
    * @return an unmodifiable view of the specified table
    * @since 11.0
    */
-  @Beta
-  public static <R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object>
+  public static <R extends Object, C extends Object, V extends Object>
       RowSortedTable<R, C, V> unmodifiableRowSortedTable(
           RowSortedTable<R, ? extends C, ? extends V> table) {
     /*
@@ -677,7 +669,7 @@ public final class Tables {
   }
 
   static final class UnmodifiableRowSortedMap<
-          R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object>
+          R extends Object, C extends Object, V extends Object>
       extends UnmodifiableTable<R, C, V> implements RowSortedTable<R, C, V> {
 
     public UnmodifiableRowSortedMap(RowSortedTable<R, ? extends C, ? extends V> delegate) {
@@ -704,7 +696,7 @@ public final class Tables {
   }
 
   @SuppressWarnings("unchecked")
-  private static <K extends @Nullable Object, V extends @Nullable Object>
+  private static <K extends Object, V extends Object>
       Function<Map<K, V>, Map<K, V>> unmodifiableWrapper() {
     return (Function) UNMODIFIABLE_WRAPPER;
   }
@@ -746,7 +738,7 @@ public final class Tables {
    * @return a synchronized view of the specified table
    * @since 22.0
    */
-  public static <R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object>
+  public static <R extends Object, C extends Object, V extends Object>
       Table<R, C, V> synchronizedTable(Table<R, C, V> table) {
     return Synchronized.table(table, null);
   }
diff --git a/guava/src/com/google/common/collect/TopKSelector.java b/guava/src/com/google/common/collect/TopKSelector.java
index 8411fcdea0..b650f17d15 100644
--- a/guava/src/com/google/common/collect/TopKSelector.java
+++ b/guava/src/com/google/common/collect/TopKSelector.java
@@ -20,7 +20,6 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.math.IntMath;
 import java.math.RoundingMode;
 import java.util.Arrays;
@@ -30,7 +29,6 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.stream.Stream;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An accumulator that selects the "top" {@code k} elements added to it, relative to a provided
@@ -53,10 +51,9 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @author Louis Wasserman
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 final class TopKSelector<
-    T extends @Nullable Object> {
+    T extends Object> {
 
   /**
    * Returns a {@code TopKSelector} that collects the lowest {@code k} elements added to it,
@@ -75,7 +72,7 @@ final class TopKSelector<
    *
    * @throws IllegalArgumentException if {@code k < 0} or {@code k > Integer.MAX_VALUE / 2}
    */
-  public static <T extends @Nullable Object> TopKSelector<T> least(
+  public static <T extends Object> TopKSelector<T> least(
       int k, Comparator<? super T> comparator) {
     return new TopKSelector<T>(comparator, k);
   }
@@ -97,7 +94,7 @@ final class TopKSelector<
    *
    * @throws IllegalArgumentException if {@code k < 0} or {@code k > Integer.MAX_VALUE / 2}
    */
-  public static <T extends @Nullable Object> TopKSelector<T> greatest(
+  public static <T extends Object> TopKSelector<T> greatest(
       int k, Comparator<? super T> comparator) {
     return new TopKSelector<T>(Ordering.from(comparator).reverse(), k);
   }
@@ -110,7 +107,7 @@ final class TopKSelector<
    * for the top k elements. Whenever the buffer is filled, we quickselect the top k elements to the
    * range [0, k) and ignore the remaining elements.
    */
-  private final @Nullable T[] buffer;
+  private final T[] buffer;
   private int bufferSize;
 
   /**
diff --git a/guava/src/com/google/common/collect/TransformedIterator.java b/guava/src/com/google/common/collect/TransformedIterator.java
index 2456cecde9..8d6afda001 100644
--- a/guava/src/com/google/common/collect/TransformedIterator.java
+++ b/guava/src/com/google/common/collect/TransformedIterator.java
@@ -18,9 +18,7 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.Iterator;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An iterator that transforms a backing iterator; for internal use. This avoids the object overhead
@@ -28,9 +26,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @author Louis Wasserman
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-abstract class TransformedIterator<F extends @Nullable Object, T extends @Nullable Object>
+abstract class TransformedIterator<F extends Object, T extends Object>
     implements Iterator<T> {
   final Iterator<? extends F> backingIterator;
 
diff --git a/guava/src/com/google/common/collect/TransformedListIterator.java b/guava/src/com/google/common/collect/TransformedListIterator.java
index 66b42e4c60..46110b413b 100644
--- a/guava/src/com/google/common/collect/TransformedListIterator.java
+++ b/guava/src/com/google/common/collect/TransformedListIterator.java
@@ -16,10 +16,8 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Function;
 import java.util.ListIterator;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An iterator that transforms a backing list iterator; for internal use. This avoids the object
@@ -27,9 +25,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @author Louis Wasserman
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-abstract class TransformedListIterator<F extends @Nullable Object, T extends @Nullable Object>
+abstract class TransformedListIterator<F extends Object, T extends Object>
     extends TransformedIterator<F, T> implements ListIterator<T> {
   TransformedListIterator(ListIterator<? extends F> backingIterator) {
     super(backingIterator);
diff --git a/guava/src/com/google/common/collect/TreeBasedTable.java b/guava/src/com/google/common/collect/TreeBasedTable.java
index 315404aafe..083f1239eb 100644
--- a/guava/src/com/google/common/collect/TreeBasedTable.java
+++ b/guava/src/com/google/common/collect/TreeBasedTable.java
@@ -20,7 +20,6 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Function;
 import com.google.common.base.Supplier;
 import java.io.Serializable;
@@ -66,7 +65,6 @@ import javax.annotation.CheckForNull;
  * @author Louis Wasserman
  * @since 7.0
  */
-@GwtCompatible(serializable = true)
 @ElementTypesAreNonnullByDefault
 public class TreeBasedTable<R, C, V> extends StandardRowSortedTable<R, C, V> {
   private final Comparator<? super C> columnComparator;
diff --git a/guava/src/com/google/common/collect/TreeMultimap.java b/guava/src/com/google/common/collect/TreeMultimap.java
index 04ae2074ac..8080a04493 100644
--- a/guava/src/com/google/common/collect/TreeMultimap.java
+++ b/guava/src/com/google/common/collect/TreeMultimap.java
@@ -18,8 +18,6 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
@@ -31,7 +29,6 @@ import java.util.NavigableSet;
 import java.util.SortedSet;
 import java.util.TreeMap;
 import java.util.TreeSet;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@code Multimap} whose keys and values are ordered by their natural ordering or
@@ -71,9 +68,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 2.0
  */
-@GwtCompatible(serializable = true, emulated = true)
 @ElementTypesAreNonnullByDefault
-public class TreeMultimap<K extends @Nullable Object, V extends @Nullable Object>
+public class TreeMultimap<K extends Object, V extends Object>
     extends AbstractSortedKeySortedSetMultimap<K, V> {
   private transient Comparator<? super K> keyComparator;
   private transient Comparator<? super V> valueComparator;
@@ -92,7 +88,7 @@ public class TreeMultimap<K extends @Nullable Object, V extends @Nullable Object
    * @param keyComparator the comparator that determines the key ordering
    * @param valueComparator the comparator that determines the value ordering
    */
-  public static <K extends @Nullable Object, V extends @Nullable Object> TreeMultimap<K, V> create(
+  public static <K extends Object, V extends Object> TreeMultimap<K, V> create(
       Comparator<? super K> keyComparator, Comparator<? super V> valueComparator) {
     return new TreeMultimap<>(checkNotNull(keyComparator), checkNotNull(valueComparator));
   }
@@ -164,7 +160,7 @@ public class TreeMultimap<K extends @Nullable Object, V extends @Nullable Object
 
   /** @since 14.0 (present with return type {@code SortedSet} since 2.0) */
   @Override
-  @GwtIncompatible // NavigableSet
+  // NavigableSet
   public NavigableSet<V> get(@ParametricNullness K key) {
     return (NavigableSet<V>) super.get(key);
   }
@@ -201,7 +197,7 @@ public class TreeMultimap<K extends @Nullable Object, V extends @Nullable Object
    * @serialData key comparator, value comparator, number of distinct keys, and then for each
    *     distinct key: the key, number of values for that key, and key values
    */
-  @GwtIncompatible // java.io.ObjectOutputStream
+  // java.io.ObjectOutputStream
   private void writeObject(ObjectOutputStream stream) throws IOException {
     stream.defaultWriteObject();
     stream.writeObject(keyComparator());
@@ -209,7 +205,7 @@ public class TreeMultimap<K extends @Nullable Object, V extends @Nullable Object
     Serialization.writeMultimap(this, stream);
   }
 
-  @GwtIncompatible // java.io.ObjectInputStream
+  // java.io.ObjectInputStream
   @SuppressWarnings("unchecked") // reading data stored by writeObject
   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
     stream.defaultReadObject();
@@ -219,6 +215,6 @@ public class TreeMultimap<K extends @Nullable Object, V extends @Nullable Object
     Serialization.populateMultimap(this, stream);
   }
 
-  @GwtIncompatible // not needed in emulated source
+  // not needed in emulated source
   private static final long serialVersionUID = 0;
 }
diff --git a/guava/src/com/google/common/collect/TreeMultiset.java b/guava/src/com/google/common/collect/TreeMultiset.java
index dcc3f681fb..2ba7cf6f26 100644
--- a/guava/src/com/google/common/collect/TreeMultiset.java
+++ b/guava/src/com/google/common/collect/TreeMultiset.java
@@ -23,11 +23,8 @@ import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.MoreObjects;
 import com.google.common.primitives.Ints;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
@@ -38,7 +35,6 @@ import java.util.Iterator;
 import java.util.NoSuchElementException;
 import java.util.function.ObjIntConsumer;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A multiset which maintains the ordering of its elements, according to either their natural order
@@ -58,9 +54,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Jared Levy
  * @since 2.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
-public final class TreeMultiset<E extends @Nullable Object> extends AbstractSortedMultiset<E>
+public final class TreeMultiset<E extends Object> extends AbstractSortedMultiset<E>
     implements Serializable {
 
   /**
@@ -91,7 +86,7 @@ public final class TreeMultiset<E extends @Nullable Object> extends AbstractSort
    *     indicates that the elements' <i>natural ordering</i> should be used.
    */
   @SuppressWarnings("unchecked")
-  public static <E extends @Nullable Object> TreeMultiset<E> create(
+  public static <E extends Object> TreeMultiset<E> create(
       @CheckForNull Comparator<? super E> comparator) {
     return (comparator == null)
         ? new TreeMultiset<E>((Comparator) Ordering.natural())
@@ -255,7 +250,6 @@ public final class TreeMultiset<E extends @Nullable Object> extends AbstractSort
     }
   }
 
-  @CanIgnoreReturnValue
   @Override
   public int add(@ParametricNullness E element, int occurrences) {
     checkNonnegative(occurrences, "occurrences");
@@ -277,7 +271,6 @@ public final class TreeMultiset<E extends @Nullable Object> extends AbstractSort
     return result[0];
   }
 
-  @CanIgnoreReturnValue
   @Override
   public int remove(@CheckForNull Object element, int occurrences) {
     checkNonnegative(occurrences, "occurrences");
@@ -301,7 +294,6 @@ public final class TreeMultiset<E extends @Nullable Object> extends AbstractSort
     return result[0];
   }
 
-  @CanIgnoreReturnValue
   @Override
   public int setCount(@ParametricNullness E element, int count) {
     checkNonnegative(count, "count");
@@ -323,7 +315,6 @@ public final class TreeMultiset<E extends @Nullable Object> extends AbstractSort
     return result[0];
   }
 
-  @CanIgnoreReturnValue
   @Override
   public boolean setCount(@ParametricNullness E element, int oldCount, int newCount) {
     checkNonnegative(newCount, "newCount");
@@ -583,7 +574,7 @@ public final class TreeMultiset<E extends @Nullable Object> extends AbstractSort
     }
   }
 
-  private static final class AvlNode<E extends @Nullable Object> {
+  private static final class AvlNode<E extends Object> {
     /*
      * For "normal" nodes, the type of this field is `E`, not `@Nullable E` (though note that E is a
      * type that can include null, as in a TreeMultiset<@Nullable String>).
@@ -1053,12 +1044,12 @@ public final class TreeMultiset<E extends @Nullable Object> extends AbstractSort
     }
   }
 
-  private static <T extends @Nullable Object> void successor(AvlNode<T> a, AvlNode<T> b) {
+  private static <T extends Object> void successor(AvlNode<T> a, AvlNode<T> b) {
     a.succ = b;
     b.pred = a;
   }
 
-  private static <T extends @Nullable Object> void successor(
+  private static <T extends Object> void successor(
       AvlNode<T> a, AvlNode<T> b, AvlNode<T> c) {
     successor(a, b);
     successor(b, c);
@@ -1074,14 +1065,14 @@ public final class TreeMultiset<E extends @Nullable Object> extends AbstractSort
    * @serialData the comparator, the number of distinct elements, the first element, its count, the
    *     second element, its count, and so on
    */
-  @GwtIncompatible // java.io.ObjectOutputStream
+  // java.io.ObjectOutputStream
   private void writeObject(ObjectOutputStream stream) throws IOException {
     stream.defaultWriteObject();
     stream.writeObject(elementSet().comparator());
     Serialization.writeMultiset(this, stream);
   }
 
-  @GwtIncompatible // java.io.ObjectInputStream
+  // java.io.ObjectInputStream
   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
     stream.defaultReadObject();
     @SuppressWarnings("unchecked")
@@ -1098,6 +1089,6 @@ public final class TreeMultiset<E extends @Nullable Object> extends AbstractSort
     Serialization.populateMultiset(this, stream);
   }
 
-  @GwtIncompatible // not needed in emulated source
+  // not needed in emulated source
   private static final long serialVersionUID = 1;
 }
diff --git a/guava/src/com/google/common/collect/TreeRangeMap.java b/guava/src/com/google/common/collect/TreeRangeMap.java
index a9200896b3..11a5943c1c 100644
--- a/guava/src/com/google/common/collect/TreeRangeMap.java
+++ b/guava/src/com/google/common/collect/TreeRangeMap.java
@@ -23,8 +23,6 @@ import static com.google.common.base.Predicates.in;
 import static com.google.common.base.Predicates.not;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Predicate;
 import com.google.common.collect.Maps.IteratorBasedAbstractMap;
@@ -40,7 +38,6 @@ import java.util.NoSuchElementException;
 import java.util.Set;
 import java.util.function.BiFunction;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An implementation of {@code RangeMap} based on a {@code TreeMap}, supporting all optional
@@ -51,8 +48,7 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  * @since 14.0
  */
-@Beta
-@GwtIncompatible // NavigableMap
+// NavigableMap
 @ElementTypesAreNonnullByDefault
 public final class TreeRangeMap<K extends Comparable, V> implements RangeMap<K, V> {
 
@@ -269,7 +265,7 @@ public final class TreeRangeMap<K extends Comparable, V> implements RangeMap<K,
   public void merge(
       Range<K> range,
       @CheckForNull V value,
-      BiFunction<? super V, ? super @Nullable V, ? extends @Nullable V> remappingFunction) {
+      BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
     checkNotNull(range);
     checkNotNull(remappingFunction);
 
@@ -562,7 +558,7 @@ public final class TreeRangeMap<K extends Comparable, V> implements RangeMap<K,
     public void merge(
         Range<K> range,
         @CheckForNull V value,
-        BiFunction<? super V, ? super @Nullable V, ? extends @Nullable V> remappingFunction) {
+        BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
       checkArgument(
           subRange.encloses(range),
           "Cannot merge range %s into a subRangeMap(%s)",
diff --git a/guava/src/com/google/common/collect/TreeRangeSet.java b/guava/src/com/google/common/collect/TreeRangeSet.java
index 8308880a56..b87bf81985 100644
--- a/guava/src/com/google/common/collect/TreeRangeSet.java
+++ b/guava/src/com/google/common/collect/TreeRangeSet.java
@@ -17,9 +17,6 @@ package com.google.common.collect;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.MoreObjects;
 import java.io.Serializable;
 import java.util.Collection;
@@ -38,13 +35,12 @@ import javax.annotation.CheckForNull;
  * @author Louis Wasserman
  * @since 14.0
  */
-@Beta
-@GwtIncompatible // uses NavigableMap
+// uses NavigableMap
 @ElementTypesAreNonnullByDefault
 public class TreeRangeSet<C extends Comparable<?>> extends AbstractRangeSet<C>
     implements Serializable {
 
-  @VisibleForTesting final NavigableMap<Cut<C>, Range<C>> rangesByLowerBound;
+  final NavigableMap<Cut<C>, Range<C>> rangesByLowerBound;
 
   /** Creates an empty {@code TreeRangeSet} instance. */
   public static <C extends Comparable<?>> TreeRangeSet<C> create() {
@@ -282,7 +278,6 @@ public class TreeRangeSet<C extends Comparable<?>> extends AbstractRangeSet<C>
     return (result == null) ? complement = new Complement() : result;
   }
 
-  @VisibleForTesting
   static final class RangesByUpperBound<C extends Comparable<?>>
       extends AbstractNavigableMap<Cut<C>, Range<C>> {
     private final NavigableMap<Cut<C>, Range<C>> rangesByLowerBound;
diff --git a/guava/src/com/google/common/collect/TreeTraverser.java b/guava/src/com/google/common/collect/TreeTraverser.java
index b5d2a4293f..ab04f87f08 100644
--- a/guava/src/com/google/common/collect/TreeTraverser.java
+++ b/guava/src/com/google/common/collect/TreeTraverser.java
@@ -18,8 +18,6 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Function;
 import java.util.ArrayDeque;
 import java.util.Deque;
@@ -73,8 +71,6 @@ import javax.annotation.CheckForNull;
  */
 // TODO(b/68134636): Remove by 2019-10
 @Deprecated
-@Beta
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public abstract class TreeTraverser<T> {
 
diff --git a/guava/src/com/google/common/collect/UnmodifiableIterator.java b/guava/src/com/google/common/collect/UnmodifiableIterator.java
index 03e52aa203..02d022f358 100644
--- a/guava/src/com/google/common/collect/UnmodifiableIterator.java
+++ b/guava/src/com/google/common/collect/UnmodifiableIterator.java
@@ -16,10 +16,7 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.DoNotCall;
 import java.util.Iterator;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An iterator that does not support {@link #remove}.
@@ -31,9 +28,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Jared Levy
  * @since 2.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public abstract class UnmodifiableIterator<E extends @Nullable Object> implements Iterator<E> {
+public abstract class UnmodifiableIterator<E extends Object> implements Iterator<E> {
   /** Constructor for use by subclasses. */
   protected UnmodifiableIterator() {}
 
@@ -45,7 +41,6 @@ public abstract class UnmodifiableIterator<E extends @Nullable Object> implement
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final void remove() {
     throw new UnsupportedOperationException();
   }
diff --git a/guava/src/com/google/common/collect/UnmodifiableListIterator.java b/guava/src/com/google/common/collect/UnmodifiableListIterator.java
index f3d3b921b7..8b79d2aaa9 100644
--- a/guava/src/com/google/common/collect/UnmodifiableListIterator.java
+++ b/guava/src/com/google/common/collect/UnmodifiableListIterator.java
@@ -16,10 +16,7 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.DoNotCall;
 import java.util.ListIterator;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A list iterator that does not support {@link #remove}, {@link #add}, or {@link #set}.
@@ -27,9 +24,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @since 7.0
  * @author Louis Wasserman
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public abstract class UnmodifiableListIterator<E extends @Nullable Object>
+public abstract class UnmodifiableListIterator<E extends Object>
     extends UnmodifiableIterator<E> implements ListIterator<E> {
   /** Constructor for use by subclasses. */
   protected UnmodifiableListIterator() {}
@@ -42,7 +38,6 @@ public abstract class UnmodifiableListIterator<E extends @Nullable Object>
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final void add(@ParametricNullness E e) {
     throw new UnsupportedOperationException();
   }
@@ -55,7 +50,6 @@ public abstract class UnmodifiableListIterator<E extends @Nullable Object>
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public final void set(@ParametricNullness E e) {
     throw new UnsupportedOperationException();
   }
diff --git a/guava/src/com/google/common/collect/UnmodifiableSortedMultiset.java b/guava/src/com/google/common/collect/UnmodifiableSortedMultiset.java
index 59bd2ce317..a95f11db19 100644
--- a/guava/src/com/google/common/collect/UnmodifiableSortedMultiset.java
+++ b/guava/src/com/google/common/collect/UnmodifiableSortedMultiset.java
@@ -16,12 +16,10 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.Multisets.UnmodifiableMultiset;
 import java.util.Comparator;
 import java.util.NavigableSet;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@link Multisets#unmodifiableSortedMultiset(SortedMultiset)}, split out into
@@ -30,9 +28,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @author Louis Wasserman
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
-final class UnmodifiableSortedMultiset<E extends @Nullable Object> extends UnmodifiableMultiset<E>
+final class UnmodifiableSortedMultiset<E extends Object> extends UnmodifiableMultiset<E>
     implements SortedMultiset<E> {
   UnmodifiableSortedMultiset(SortedMultiset<E> delegate) {
     super(delegate);
diff --git a/guava/src/com/google/common/collect/UsingToStringOrdering.java b/guava/src/com/google/common/collect/UsingToStringOrdering.java
index 3443b43e72..8393ecc3f2 100644
--- a/guava/src/com/google/common/collect/UsingToStringOrdering.java
+++ b/guava/src/com/google/common/collect/UsingToStringOrdering.java
@@ -16,11 +16,9 @@
 
 package com.google.common.collect;
 
-import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 
 /** An ordering that uses the natural order of the string representation of the values. */
-@GwtCompatible(serializable = true)
 @ElementTypesAreNonnullByDefault
 final class UsingToStringOrdering extends Ordering<Object> implements Serializable {
   static final UsingToStringOrdering INSTANCE = new UsingToStringOrdering();
diff --git a/guava/src/com/google/common/collect/package-info.java b/guava/src/com/google/common/collect/package-info.java
index d46e65fd3a..41aa6ada4e 100644
--- a/guava/src/com/google/common/collect/package-info.java
+++ b/guava/src/com/google/common/collect/package-info.java
@@ -212,9 +212,7 @@
  *   <li>{@link com.google.common.collect.ForwardingTable}
  * </ul>
  */
-@CheckReturnValue
 @ParametersAreNonnullByDefault
 package com.google.common.collect;
 
-import com.google.errorprone.annotations.CheckReturnValue;
 import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/guava/src/com/google/common/escape/ArrayBasedCharEscaper.java b/guava/src/com/google/common/escape/ArrayBasedCharEscaper.java
index 20e8563484..22907cee86 100644
--- a/guava/src/com/google/common/escape/ArrayBasedCharEscaper.java
+++ b/guava/src/com/google/common/escape/ArrayBasedCharEscaper.java
@@ -16,8 +16,6 @@ package com.google.common.escape;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import java.util.Map;
 import javax.annotation.CheckForNull;
 
@@ -41,8 +39,6 @@ import javax.annotation.CheckForNull;
  * @author David Beaumont
  * @since 15.0
  */
-@Beta
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public abstract class ArrayBasedCharEscaper extends CharEscaper {
   // The replacement array (see ArrayBasedEscaperMap).
diff --git a/guava/src/com/google/common/escape/ArrayBasedEscaperMap.java b/guava/src/com/google/common/escape/ArrayBasedEscaperMap.java
index a0883fea2d..2de9626391 100644
--- a/guava/src/com/google/common/escape/ArrayBasedEscaperMap.java
+++ b/guava/src/com/google/common/escape/ArrayBasedEscaperMap.java
@@ -16,9 +16,6 @@ package com.google.common.escape;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.VisibleForTesting;
 import java.util.Collections;
 import java.util.Map;
 
@@ -36,8 +33,6 @@ import java.util.Map;
  * @author David Beaumont
  * @since 15.0
  */
-@Beta
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class ArrayBasedEscaperMap {
   /**
@@ -66,7 +61,6 @@ public final class ArrayBasedEscaperMap {
   // Creates a replacement array from the given map. The returned array is a
   // linear lookup table of replacement character sequences indexed by the
   // original character value.
-  @VisibleForTesting
   static char[][] createReplacementArray(Map<Character, String> map) {
     checkNotNull(map); // GWT specific check (do not optimize)
     if (map.isEmpty()) {
diff --git a/guava/src/com/google/common/escape/ArrayBasedUnicodeEscaper.java b/guava/src/com/google/common/escape/ArrayBasedUnicodeEscaper.java
index 5ea780712a..e31f707836 100644
--- a/guava/src/com/google/common/escape/ArrayBasedUnicodeEscaper.java
+++ b/guava/src/com/google/common/escape/ArrayBasedUnicodeEscaper.java
@@ -16,11 +16,8 @@ package com.google.common.escape;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import java.util.Map;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link UnicodeEscaper} that uses an array to quickly look up replacement characters for a given
@@ -41,8 +38,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author David Beaumont
  * @since 15.0
  */
-@Beta
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public abstract class ArrayBasedUnicodeEscaper extends UnicodeEscaper {
   // The replacement array (see ArrayBasedEscaperMap).
@@ -75,7 +70,7 @@ public abstract class ArrayBasedUnicodeEscaper extends UnicodeEscaper {
       Map<Character, String> replacementMap,
       int safeMin,
       int safeMax,
-      @Nullable String unsafeReplacement) {
+      String unsafeReplacement) {
     this(ArrayBasedEscaperMap.create(replacementMap), safeMin, safeMax, unsafeReplacement);
   }
 
@@ -98,7 +93,7 @@ public abstract class ArrayBasedUnicodeEscaper extends UnicodeEscaper {
       ArrayBasedEscaperMap escaperMap,
       int safeMin,
       int safeMax,
-      @Nullable String unsafeReplacement) {
+      String unsafeReplacement) {
     checkNotNull(escaperMap); // GWT specific check (do not optimize)
     this.replacements = escaperMap.getReplacementArray();
     this.replacementsLength = replacements.length;
diff --git a/guava/src/com/google/common/escape/CharEscaper.java b/guava/src/com/google/common/escape/CharEscaper.java
index 55090f6980..b0727a6422 100644
--- a/guava/src/com/google/common/escape/CharEscaper.java
+++ b/guava/src/com/google/common/escape/CharEscaper.java
@@ -16,8 +16,6 @@ package com.google.common.escape;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import javax.annotation.CheckForNull;
 
 /**
@@ -40,8 +38,6 @@ import javax.annotation.CheckForNull;
  * @author Sven Mawson
  * @since 15.0
  */
-@Beta
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public abstract class CharEscaper extends Escaper {
   /** Constructor for use by subclasses. */
diff --git a/guava/src/com/google/common/escape/CharEscaperBuilder.java b/guava/src/com/google/common/escape/CharEscaperBuilder.java
index cbe6958f3b..4ec32224fe 100644
--- a/guava/src/com/google/common/escape/CharEscaperBuilder.java
+++ b/guava/src/com/google/common/escape/CharEscaperBuilder.java
@@ -16,14 +16,10 @@ package com.google.common.escape;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Map.Entry;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Simple helper class to build a "sparse" array of objects based on the indexes that were added to
@@ -34,8 +30,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Sven Mawson
  * @since 15.0
  */
-@Beta
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class CharEscaperBuilder {
   /**
@@ -43,10 +37,10 @@ public final class CharEscaperBuilder {
    * a very fast escape method.
    */
   private static class CharArrayDecorator extends CharEscaper {
-    private final char[] @Nullable [] replacements;
+    private final char[] [] replacements;
     private final int replaceLength;
 
-    CharArrayDecorator(char[] @Nullable [] replacements) {
+    CharArrayDecorator(char[] [] replacements) {
       this.replacements = replacements;
       this.replaceLength = replacements.length;
     }
@@ -86,7 +80,6 @@ public final class CharEscaperBuilder {
   }
 
   /** Add a new mapping from an index to an object to the escaping. */
-  @CanIgnoreReturnValue
   public CharEscaperBuilder addEscape(char c, String r) {
     map.put(c, checkNotNull(r));
     if (c > max) {
@@ -96,7 +89,6 @@ public final class CharEscaperBuilder {
   }
 
   /** Add multiple mappings at once for a particular index. */
-  @CanIgnoreReturnValue
   public CharEscaperBuilder addEscapes(char[] cs, String r) {
     checkNotNull(r);
     for (char c : cs) {
@@ -112,7 +104,7 @@ public final class CharEscaperBuilder {
    *
    * @return a "sparse" array that holds the replacement mappings.
    */
-  public char[] @Nullable [] toArray() {
+  public char[] [] toArray() {
     char[][] result = new char[max + 1][];
     for (Entry<Character, String> entry : map.entrySet()) {
       result[entry.getKey()] = entry.getValue().toCharArray();
diff --git a/guava/src/com/google/common/escape/ElementTypesAreNonnullByDefault.java b/guava/src/com/google/common/escape/ElementTypesAreNonnullByDefault.java
index 992c9a3e4d..2b187ed2a5 100644
--- a/guava/src/com/google/common/escape/ElementTypesAreNonnullByDefault.java
+++ b/guava/src/com/google/common/escape/ElementTypesAreNonnullByDefault.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.ElementType.TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -33,7 +32,6 @@ import javax.annotation.meta.TypeQualifierDefault;
  * unfortunately includes type-variable usages, so we also provide {@link ParametricNullness} to
  * "undo" it as best we can.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target(TYPE)
 @TypeQualifierDefault({FIELD, METHOD, PARAMETER})
diff --git a/guava/src/com/google/common/escape/Escaper.java b/guava/src/com/google/common/escape/Escaper.java
index cdfe4e92a6..944b3c4f1b 100644
--- a/guava/src/com/google/common/escape/Escaper.java
+++ b/guava/src/com/google/common/escape/Escaper.java
@@ -14,9 +14,7 @@
 
 package com.google.common.escape;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Function;
-import com.google.errorprone.annotations.DoNotMock;
 
 /**
  * An object that converts literal text into a format safe for inclusion in a particular context
@@ -54,8 +52,6 @@ import com.google.errorprone.annotations.DoNotMock;
  * @author David Beaumont
  * @since 15.0
  */
-@DoNotMock("Use Escapers.nullEscaper() or another methods from the *Escapers classes")
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public abstract class Escaper {
   // TODO(dbeaumont): evaluate custom implementations, considering package private constructor.
diff --git a/guava/src/com/google/common/escape/Escapers.java b/guava/src/com/google/common/escape/Escapers.java
index 41af6688e9..2b2095be04 100644
--- a/guava/src/com/google/common/escape/Escapers.java
+++ b/guava/src/com/google/common/escape/Escapers.java
@@ -16,13 +16,9 @@ package com.google.common.escape;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.HashMap;
 import java.util.Map;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to {@link Escaper} instances.
@@ -31,8 +27,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author David Beaumont
  * @since 15.0
  */
-@Beta
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class Escapers {
   private Escapers() {}
@@ -93,7 +87,6 @@ public final class Escapers {
    * @author David Beaumont
    * @since 15.0
    */
-  @Beta
   public static final class Builder {
     private final Map<Character, String> replacementMap = new HashMap<>();
     private char safeMin = Character.MIN_VALUE;
@@ -112,7 +105,6 @@ public final class Escapers {
      * @param safeMax the highest 'safe' character
      * @return the builder instance
      */
-    @CanIgnoreReturnValue
     public Builder setSafeRange(char safeMin, char safeMax) {
       this.safeMin = safeMin;
       this.safeMax = safeMax;
@@ -127,8 +119,7 @@ public final class Escapers {
      * @param unsafeReplacement the string to replace unsafe characters
      * @return the builder instance
      */
-    @CanIgnoreReturnValue
-    public Builder setUnsafeReplacement(@Nullable String unsafeReplacement) {
+    public Builder setUnsafeReplacement(String unsafeReplacement) {
       this.unsafeReplacement = unsafeReplacement;
       return this;
     }
@@ -143,7 +134,6 @@ public final class Escapers {
      * @return the builder instance
      * @throws NullPointerException if {@code replacement} is null
      */
-    @CanIgnoreReturnValue
     public Builder addEscape(char c, String replacement) {
       checkNotNull(replacement);
       // This can replace an existing character (the builder is re-usable).
diff --git a/guava/src/com/google/common/escape/ParametricNullness.java b/guava/src/com/google/common/escape/ParametricNullness.java
index 2f03d59f30..4db3ffad84 100644
--- a/guava/src/com/google/common/escape/ParametricNullness.java
+++ b/guava/src/com/google/common/escape/ParametricNullness.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import static javax.annotation.meta.When.UNKNOWN;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -35,7 +34,6 @@ import javax.annotation.meta.TypeQualifierNickname;
  * href="https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/NullFromTypeParam.java">{@code
  * NullFromTypeParam}</a>). We use this to "undo" {@link ElementTypesAreNonnullByDefault}.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target({FIELD, METHOD, PARAMETER})
 @TypeQualifierNickname
diff --git a/guava/src/com/google/common/escape/Platform.java b/guava/src/com/google/common/escape/Platform.java
index dc6610c041..9ad1799b42 100644
--- a/guava/src/com/google/common/escape/Platform.java
+++ b/guava/src/com/google/common/escape/Platform.java
@@ -14,14 +14,12 @@
 
 package com.google.common.escape;
 
-import com.google.common.annotations.GwtCompatible;
 
 /**
  * Methods factored out so that they can be emulated differently in GWT.
  *
  * @author Jesse Wilson
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 final class Platform {
   private Platform() {}
diff --git a/guava/src/com/google/common/escape/UnicodeEscaper.java b/guava/src/com/google/common/escape/UnicodeEscaper.java
index c10ae34cd3..f908cfbca3 100644
--- a/guava/src/com/google/common/escape/UnicodeEscaper.java
+++ b/guava/src/com/google/common/escape/UnicodeEscaper.java
@@ -16,8 +16,6 @@ package com.google.common.escape;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import javax.annotation.CheckForNull;
 
 /**
@@ -50,8 +48,6 @@ import javax.annotation.CheckForNull;
  * @author David Beaumont
  * @since 15.0
  */
-@Beta
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public abstract class UnicodeEscaper extends Escaper {
   /** The amount of padding (chars) to use when growing the escape buffer. */
diff --git a/guava/src/com/google/common/escape/package-info.java b/guava/src/com/google/common/escape/package-info.java
index 8cd29e6f85..fa290a0c74 100644
--- a/guava/src/com/google/common/escape/package-info.java
+++ b/guava/src/com/google/common/escape/package-info.java
@@ -24,9 +24,7 @@
  * <p>This package is a part of the open-source <a href="http://github.com/google/guava">Guava</a>
  * library.
  */
-@CheckReturnValue
 @ParametersAreNonnullByDefault
 package com.google.common.escape;
 
-import com.google.errorprone.annotations.CheckReturnValue;
 import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/guava/src/com/google/common/eventbus/ElementTypesAreNonnullByDefault.java b/guava/src/com/google/common/eventbus/ElementTypesAreNonnullByDefault.java
index e8542bba63..896651ed6b 100644
--- a/guava/src/com/google/common/eventbus/ElementTypesAreNonnullByDefault.java
+++ b/guava/src/com/google/common/eventbus/ElementTypesAreNonnullByDefault.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.ElementType.TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -33,7 +32,6 @@ import javax.annotation.meta.TypeQualifierDefault;
  * unfortunately includes type-variable usages, so we also provide {@link ParametricNullness} to
  * "undo" it as best we can.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target(TYPE)
 @TypeQualifierDefault({FIELD, METHOD, PARAMETER})
diff --git a/guava/src/com/google/common/eventbus/ParametricNullness.java b/guava/src/com/google/common/eventbus/ParametricNullness.java
index fc5bb175f6..37e0e51b65 100644
--- a/guava/src/com/google/common/eventbus/ParametricNullness.java
+++ b/guava/src/com/google/common/eventbus/ParametricNullness.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import static javax.annotation.meta.When.UNKNOWN;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -35,7 +34,6 @@ import javax.annotation.meta.TypeQualifierNickname;
  * href="https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/NullFromTypeParam.java">{@code
  * NullFromTypeParam}</a>). We use this to "undo" {@link ElementTypesAreNonnullByDefault}.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target({FIELD, METHOD, PARAMETER})
 @TypeQualifierNickname
diff --git a/guava/src/com/google/common/eventbus/Subscriber.java b/guava/src/com/google/common/eventbus/Subscriber.java
index 73e7f420ac..a94b98a772 100644
--- a/guava/src/com/google/common/eventbus/Subscriber.java
+++ b/guava/src/com/google/common/eventbus/Subscriber.java
@@ -16,8 +16,6 @@ package com.google.common.eventbus;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.VisibleForTesting;
-import com.google.j2objc.annotations.Weak;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.concurrent.Executor;
@@ -43,10 +41,10 @@ class Subscriber {
   }
 
   /** The event bus this subscriber belongs to. */
-  @Weak private EventBus bus;
+  private EventBus bus;
 
   /** The object with the subscriber method. */
-  @VisibleForTesting final Object target;
+  final Object target;
 
   /** Subscriber method. */
   private final Method method;
@@ -82,7 +80,6 @@ class Subscriber {
    * Invokes the subscriber method. This method can be overridden to make the invocation
    * synchronized.
    */
-  @VisibleForTesting
   void invokeSubscriberMethod(Object event) throws InvocationTargetException {
     try {
       method.invoke(target, checkNotNull(event));
@@ -132,7 +129,6 @@ class Subscriber {
    * Subscriber that synchronizes invocations of a method to ensure that only one thread may enter
    * the method at a time.
    */
-  @VisibleForTesting
   static final class SynchronizedSubscriber extends Subscriber {
 
     private SynchronizedSubscriber(EventBus bus, Object target, Method method) {
diff --git a/guava/src/com/google/common/eventbus/SubscriberRegistry.java b/guava/src/com/google/common/eventbus/SubscriberRegistry.java
index 46e982016c..d5f67a15a4 100644
--- a/guava/src/com/google/common/eventbus/SubscriberRegistry.java
+++ b/guava/src/com/google/common/eventbus/SubscriberRegistry.java
@@ -18,7 +18,6 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Throwables.throwIfUnchecked;
 
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Objects;
 import com.google.common.base.Throwables;
@@ -35,7 +34,6 @@ import com.google.common.collect.Multimap;
 import com.google.common.primitives.Primitives;
 import com.google.common.reflect.TypeToken;
 import com.google.common.util.concurrent.UncheckedExecutionException;
-import com.google.j2objc.annotations.Weak;
 import java.lang.reflect.Method;
 import java.util.Arrays;
 import java.util.Collection;
@@ -66,7 +64,7 @@ final class SubscriberRegistry {
       Maps.newConcurrentMap();
 
   /** The event bus this registry belongs to. */
-  @Weak private final EventBus bus;
+  private final EventBus bus;
 
   SubscriberRegistry(EventBus bus) {
     this.bus = checkNotNull(bus);
@@ -115,7 +113,6 @@ final class SubscriberRegistry {
     }
   }
 
-  @VisibleForTesting
   Set<Subscriber> getSubscribersForTesting(Class<?> eventType) {
     return MoreObjects.firstNonNull(subscribers.get(eventType), ImmutableSet.<Subscriber>of());
   }
@@ -234,7 +231,6 @@ final class SubscriberRegistry {
    * Flattens a class's type hierarchy into a set of {@code Class} objects including all
    * superclasses (transitively) and all interfaces implemented by these superclasses.
    */
-  @VisibleForTesting
   static ImmutableSet<Class<?>> flattenHierarchy(Class<?> concreteClass) {
     try {
       return flattenHierarchyCache.getUnchecked(concreteClass);
diff --git a/guava/src/com/google/common/eventbus/package-info.java b/guava/src/com/google/common/eventbus/package-info.java
index fa7faa4ab4..b5a538c663 100644
--- a/guava/src/com/google/common/eventbus/package-info.java
+++ b/guava/src/com/google/common/eventbus/package-info.java
@@ -249,9 +249,7 @@
  * <p>Because subscriber methods on your listener classes are normal methods, you can simply call
  * them from your test code to simulate the EventBus.
  */
-@CheckReturnValue
 @ParametersAreNonnullByDefault
 package com.google.common.eventbus;
 
-import com.google.errorprone.annotations.CheckReturnValue;
 import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/guava/src/com/google/common/graph/AbstractGraph.java b/guava/src/com/google/common/graph/AbstractGraph.java
index 9402be5d93..56d1e6241d 100644
--- a/guava/src/com/google/common/graph/AbstractGraph.java
+++ b/guava/src/com/google/common/graph/AbstractGraph.java
@@ -16,7 +16,6 @@
 
 package com.google.common.graph;
 
-import com.google.common.annotations.Beta;
 import javax.annotation.CheckForNull;
 
 /**
@@ -27,7 +26,6 @@ import javax.annotation.CheckForNull;
  * @param <N> Node parameter type
  * @since 20.0
  */
-@Beta
 @ElementTypesAreNonnullByDefault
 public abstract class AbstractGraph<N> extends AbstractBaseGraph<N> implements Graph<N> {
 
diff --git a/guava/src/com/google/common/graph/AbstractNetwork.java b/guava/src/com/google/common/graph/AbstractNetwork.java
index d6bf4c36c6..7883d5ba63 100644
--- a/guava/src/com/google/common/graph/AbstractNetwork.java
+++ b/guava/src/com/google/common/graph/AbstractNetwork.java
@@ -22,7 +22,6 @@ import static com.google.common.graph.GraphConstants.ENDPOINTS_MISMATCH;
 import static com.google.common.graph.GraphConstants.MULTIPLE_EDGES_CONNECTING;
 import static java.util.Collections.unmodifiableSet;
 
-import com.google.common.annotations.Beta;
 import com.google.common.base.Function;
 import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableSet;
@@ -49,7 +48,6 @@ import javax.annotation.CheckForNull;
  * @param <E> Edge parameter type
  * @since 20.0
  */
-@Beta
 @ElementTypesAreNonnullByDefault
 public abstract class AbstractNetwork<N, E> implements Network<N, E> {
 
diff --git a/guava/src/com/google/common/graph/AbstractValueGraph.java b/guava/src/com/google/common/graph/AbstractValueGraph.java
index 5b8e520c35..772f2595a8 100644
--- a/guava/src/com/google/common/graph/AbstractValueGraph.java
+++ b/guava/src/com/google/common/graph/AbstractValueGraph.java
@@ -18,7 +18,6 @@ package com.google.common.graph;
 
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
 import com.google.common.base.Function;
 import com.google.common.collect.Maps;
 import java.util.Map;
@@ -38,7 +37,6 @@ import javax.annotation.CheckForNull;
  * @param <V> Value parameter type
  * @since 20.0
  */
-@Beta
 @ElementTypesAreNonnullByDefault
 public abstract class AbstractValueGraph<N, V> extends AbstractBaseGraph<N>
     implements ValueGraph<N, V> {
diff --git a/guava/src/com/google/common/graph/DirectedMultiNetworkConnections.java b/guava/src/com/google/common/graph/DirectedMultiNetworkConnections.java
index 05f40c2906..cd0a3a4226 100644
--- a/guava/src/com/google/common/graph/DirectedMultiNetworkConnections.java
+++ b/guava/src/com/google/common/graph/DirectedMultiNetworkConnections.java
@@ -23,7 +23,6 @@ import static com.google.common.graph.GraphConstants.INNER_LOAD_FACTOR;
 import com.google.common.collect.HashMultiset;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Multiset;
-import com.google.errorprone.annotations.concurrent.LazyInit;
 import java.lang.ref.Reference;
 import java.lang.ref.SoftReference;
 import java.util.Collections;
@@ -60,7 +59,7 @@ final class DirectedMultiNetworkConnections<N, E> extends AbstractDirectedNetwor
         ImmutableMap.copyOf(inEdges), ImmutableMap.copyOf(outEdges), selfLoopCount);
   }
 
-  @CheckForNull @LazyInit private transient Reference<Multiset<N>> predecessorsReference;
+  @CheckForNull private transient Reference<Multiset<N>> predecessorsReference;
 
   @Override
   public Set<N> predecessors() {
@@ -76,7 +75,7 @@ final class DirectedMultiNetworkConnections<N, E> extends AbstractDirectedNetwor
     return predecessors;
   }
 
-  @CheckForNull @LazyInit private transient Reference<Multiset<N>> successorsReference;
+  @CheckForNull private transient Reference<Multiset<N>> successorsReference;
 
   @Override
   public Set<N> successors() {
diff --git a/guava/src/com/google/common/graph/ElementOrder.java b/guava/src/com/google/common/graph/ElementOrder.java
index ea13674c68..7b1da6ce87 100644
--- a/guava/src/com/google/common/graph/ElementOrder.java
+++ b/guava/src/com/google/common/graph/ElementOrder.java
@@ -19,13 +19,11 @@ package com.google.common.graph;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 
-import com.google.common.annotations.Beta;
 import com.google.common.base.MoreObjects;
 import com.google.common.base.MoreObjects.ToStringHelper;
 import com.google.common.base.Objects;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Ordering;
-import com.google.errorprone.annotations.Immutable;
 import java.util.Comparator;
 import java.util.Map;
 import javax.annotation.CheckForNull;
@@ -44,8 +42,6 @@ import javax.annotation.CheckForNull;
  * @author Joshua O'Madadhain
  * @since 20.0
  */
-@Beta
-@Immutable
 @ElementTypesAreNonnullByDefault
 public final class ElementOrder<T> {
   private final Type type;
diff --git a/guava/src/com/google/common/graph/ElementTypesAreNonnullByDefault.java b/guava/src/com/google/common/graph/ElementTypesAreNonnullByDefault.java
index 0798de0c98..f4af581f53 100644
--- a/guava/src/com/google/common/graph/ElementTypesAreNonnullByDefault.java
+++ b/guava/src/com/google/common/graph/ElementTypesAreNonnullByDefault.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.ElementType.TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -33,7 +32,6 @@ import javax.annotation.meta.TypeQualifierDefault;
  * unfortunately includes type-variable usages, so we also provide {@link ParametricNullness} to
  * "undo" it as best we can.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target(TYPE)
 @TypeQualifierDefault({FIELD, METHOD, PARAMETER})
diff --git a/guava/src/com/google/common/graph/EndpointPair.java b/guava/src/com/google/common/graph/EndpointPair.java
index 7aa38606d5..967a5765cc 100644
--- a/guava/src/com/google/common/graph/EndpointPair.java
+++ b/guava/src/com/google/common/graph/EndpointPair.java
@@ -19,11 +19,9 @@ package com.google.common.graph;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.graph.GraphConstants.NOT_AVAILABLE_ON_UNDIRECTED;
 
-import com.google.common.annotations.Beta;
 import com.google.common.base.Objects;
 import com.google.common.collect.Iterators;
 import com.google.common.collect.UnmodifiableIterator;
-import com.google.errorprone.annotations.Immutable;
 import javax.annotation.CheckForNull;
 
 /**
@@ -37,8 +35,6 @@ import javax.annotation.CheckForNull;
  * @author James Sexton
  * @since 20.0
  */
-@Beta
-@Immutable(containerOf = {"N"})
 @ElementTypesAreNonnullByDefault
 public abstract class EndpointPair<N> implements Iterable<N> {
   private final N nodeU;
diff --git a/guava/src/com/google/common/graph/EndpointPairIterator.java b/guava/src/com/google/common/graph/EndpointPairIterator.java
index 7096dbe3da..8a488e70a7 100644
--- a/guava/src/com/google/common/graph/EndpointPairIterator.java
+++ b/guava/src/com/google/common/graph/EndpointPairIterator.java
@@ -25,7 +25,6 @@ import com.google.common.collect.Sets;
 import java.util.Iterator;
 import java.util.Set;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A class to facilitate the set returned by {@link Graph#edges()}.
@@ -117,7 +116,7 @@ abstract class EndpointPairIterator<N> extends AbstractIterator<EndpointPair<N>>
    */
   private static final class Undirected<N> extends EndpointPairIterator<N> {
     // It's a little weird that we add `null` to this set, but it makes for slightly simpler code.
-    @CheckForNull private Set<@Nullable N> visitedNodes;
+    @CheckForNull private Set<N> visitedNodes;
 
     private Undirected(BaseGraph<N> graph) {
       super(graph);
diff --git a/guava/src/com/google/common/graph/Graph.java b/guava/src/com/google/common/graph/Graph.java
index 5dc0e71faf..3099b13893 100644
--- a/guava/src/com/google/common/graph/Graph.java
+++ b/guava/src/com/google/common/graph/Graph.java
@@ -16,8 +16,6 @@
 
 package com.google.common.graph;
 
-import com.google.common.annotations.Beta;
-import com.google.errorprone.annotations.DoNotMock;
 import java.util.Collection;
 import java.util.Set;
 import javax.annotation.CheckForNull;
@@ -101,8 +99,6 @@ import javax.annotation.CheckForNull;
  * @param <N> Node parameter type
  * @since 20.0
  */
-@Beta
-@DoNotMock("Use GraphBuilder to create a real instance")
 @ElementTypesAreNonnullByDefault
 public interface Graph<N> extends BaseGraph<N> {
   //
diff --git a/guava/src/com/google/common/graph/GraphBuilder.java b/guava/src/com/google/common/graph/GraphBuilder.java
index d57ed37717..2b473fb817 100644
--- a/guava/src/com/google/common/graph/GraphBuilder.java
+++ b/guava/src/com/google/common/graph/GraphBuilder.java
@@ -20,9 +20,7 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.graph.Graphs.checkNonNegative;
 
-import com.google.common.annotations.Beta;
 import com.google.common.base.Optional;
-import com.google.errorprone.annotations.DoNotMock;
 
 /**
  * A builder for constructing instances of {@link MutableGraph} or {@link ImmutableGraph} with
@@ -62,8 +60,6 @@ import com.google.errorprone.annotations.DoNotMock;
  *     constructed based on an existing {@code Graph} using {@link #from(Graph)}.
  * @since 20.0
  */
-@Beta
-@DoNotMock
 @ElementTypesAreNonnullByDefault
 public final class GraphBuilder<N> extends AbstractGraphBuilder<N> {
 
diff --git a/guava/src/com/google/common/graph/GraphConnections.java b/guava/src/com/google/common/graph/GraphConnections.java
index 7d4f8f0cf0..be31de22ec 100644
--- a/guava/src/com/google/common/graph/GraphConnections.java
+++ b/guava/src/com/google/common/graph/GraphConnections.java
@@ -16,7 +16,6 @@
 
 package com.google.common.graph;
 
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Iterator;
 import java.util.Set;
 import javax.annotation.CheckForNull;
@@ -59,7 +58,6 @@ interface GraphConnections<N, V> {
    * Remove {@code node} from the set of successors. Returns the value previously associated with
    * the edge connecting the two nodes.
    */
-  @CanIgnoreReturnValue
   @CheckForNull
   V removeSuccessor(N node);
 
@@ -74,7 +72,6 @@ interface GraphConnections<N, V> {
    * becomes a predecessor. Associates {@code value} with the edge connecting the two nodes. Returns
    * the value previously associated with the edge connecting the two nodes.
    */
-  @CanIgnoreReturnValue
   @CheckForNull
   V addSuccessor(N node, V value);
 }
diff --git a/guava/src/com/google/common/graph/Graphs.java b/guava/src/com/google/common/graph/Graphs.java
index 6ab9f56615..a25f7d5167 100644
--- a/guava/src/com/google/common/graph/Graphs.java
+++ b/guava/src/com/google/common/graph/Graphs.java
@@ -20,14 +20,12 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.graph.GraphConstants.NODE_NOT_IN_GRAPH;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
 import com.google.common.base.Function;
 import com.google.common.base.Objects;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Iterators;
 import com.google.common.collect.Maps;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -43,7 +41,6 @@ import javax.annotation.CheckForNull;
  * @author Joshua O'Madadhain
  * @since 20.0
  */
-@Beta
 @ElementTypesAreNonnullByDefault
 public final class Graphs {
 
@@ -610,25 +607,21 @@ public final class Graphs {
     return copy;
   }
 
-  @CanIgnoreReturnValue
   static int checkNonNegative(int value) {
     checkArgument(value >= 0, "Not true that %s is non-negative.", value);
     return value;
   }
 
-  @CanIgnoreReturnValue
   static long checkNonNegative(long value) {
     checkArgument(value >= 0, "Not true that %s is non-negative.", value);
     return value;
   }
 
-  @CanIgnoreReturnValue
   static int checkPositive(int value) {
     checkArgument(value > 0, "Not true that %s is positive.", value);
     return value;
   }
 
-  @CanIgnoreReturnValue
   static long checkPositive(long value) {
     checkArgument(value > 0, "Not true that %s is positive.", value);
     return value;
diff --git a/guava/src/com/google/common/graph/ImmutableGraph.java b/guava/src/com/google/common/graph/ImmutableGraph.java
index afad211a10..9c3f1184de 100644
--- a/guava/src/com/google/common/graph/ImmutableGraph.java
+++ b/guava/src/com/google/common/graph/ImmutableGraph.java
@@ -18,14 +18,11 @@ package com.google.common.graph;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
 import com.google.common.base.Function;
 import com.google.common.base.Functions;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Maps;
 import com.google.common.graph.GraphConstants.Presence;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.Immutable;
 
 /**
  * A {@link Graph} whose elements and structural relationships will never change. Instances of this
@@ -43,8 +40,6 @@ import com.google.errorprone.annotations.Immutable;
  * @param <N> Node parameter type
  * @since 20.0
  */
-@Beta
-@Immutable(containerOf = {"N"})
 @ElementTypesAreNonnullByDefault
 public class ImmutableGraph<N> extends ForwardingGraph<N> {
   @SuppressWarnings("Immutable") // The backing graph must be immutable.
@@ -143,7 +138,6 @@ public class ImmutableGraph<N> extends ForwardingGraph<N> {
      *
      * @return this {@code Builder} object
      */
-    @CanIgnoreReturnValue
     public Builder<N> addNode(N node) {
       mutableGraph.addNode(node);
       return this;
@@ -162,7 +156,6 @@ public class ImmutableGraph<N> extends ForwardingGraph<N> {
      * @throws IllegalArgumentException if the introduction of the edge would violate {@link
      *     #allowsSelfLoops()}
      */
-    @CanIgnoreReturnValue
     public Builder<N> putEdge(N nodeU, N nodeV) {
       mutableGraph.putEdge(nodeU, nodeV);
       return this;
@@ -185,7 +178,6 @@ public class ImmutableGraph<N> extends ForwardingGraph<N> {
      *     #allowsSelfLoops()}
      * @throws IllegalArgumentException if the endpoints are unordered and the graph is directed
      */
-    @CanIgnoreReturnValue
     public Builder<N> putEdge(EndpointPair<N> endpoints) {
       mutableGraph.putEdge(endpoints);
       return this;
diff --git a/guava/src/com/google/common/graph/ImmutableNetwork.java b/guava/src/com/google/common/graph/ImmutableNetwork.java
index cb636aa289..8d80a1f891 100644
--- a/guava/src/com/google/common/graph/ImmutableNetwork.java
+++ b/guava/src/com/google/common/graph/ImmutableNetwork.java
@@ -18,12 +18,9 @@ package com.google.common.graph;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Maps;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.Immutable;
 import java.util.Map;
 
 /**
@@ -43,8 +40,6 @@ import java.util.Map;
  * @param <E> Edge parameter type
  * @since 20.0
  */
-@Beta
-@Immutable(containerOf = {"N", "E"})
 @SuppressWarnings("Immutable") // Extends StandardNetwork but uses ImmutableMaps.
 @ElementTypesAreNonnullByDefault
 public final class ImmutableNetwork<N, E> extends StandardNetwork<N, E> {
@@ -180,7 +175,6 @@ public final class ImmutableNetwork<N, E> extends StandardNetwork<N, E> {
      *
      * @return this {@code Builder} object
      */
-    @CanIgnoreReturnValue
     public ImmutableNetwork.Builder<N, E> addNode(N node) {
       mutableNetwork.addNode(node);
       return this;
@@ -207,7 +201,6 @@ public final class ImmutableNetwork<N, E> extends StandardNetwork<N, E> {
      * @throws IllegalArgumentException if the introduction of the edge would violate {@link
      *     #allowsParallelEdges()} or {@link #allowsSelfLoops()}
      */
-    @CanIgnoreReturnValue
     public ImmutableNetwork.Builder<N, E> addEdge(N nodeU, N nodeV, E edge) {
       mutableNetwork.addEdge(nodeU, nodeV, edge);
       return this;
@@ -238,7 +231,6 @@ public final class ImmutableNetwork<N, E> extends StandardNetwork<N, E> {
      *     #allowsParallelEdges()} or {@link #allowsSelfLoops()}
      * @throws IllegalArgumentException if the endpoints are unordered and the network is directed
      */
-    @CanIgnoreReturnValue
     public ImmutableNetwork.Builder<N, E> addEdge(EndpointPair<N> endpoints, E edge) {
       mutableNetwork.addEdge(endpoints, edge);
       return this;
diff --git a/guava/src/com/google/common/graph/ImmutableValueGraph.java b/guava/src/com/google/common/graph/ImmutableValueGraph.java
index a1567dacb7..4d70ba317b 100644
--- a/guava/src/com/google/common/graph/ImmutableValueGraph.java
+++ b/guava/src/com/google/common/graph/ImmutableValueGraph.java
@@ -19,12 +19,9 @@ package com.google.common.graph;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Maps;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.Immutable;
 
 /**
  * A {@link ValueGraph} whose elements and structural relationships will never change. Instances of
@@ -41,8 +38,6 @@ import com.google.errorprone.annotations.Immutable;
  * @param <V> Value parameter type
  * @since 20.0
  */
-@Beta
-@Immutable(containerOf = {"N", "V"})
 @SuppressWarnings("Immutable") // Extends StandardValueGraph but uses ImmutableMaps.
 @ElementTypesAreNonnullByDefault
 public final class ImmutableValueGraph<N, V> extends StandardValueGraph<N, V> {
@@ -146,7 +141,6 @@ public final class ImmutableValueGraph<N, V> extends StandardValueGraph<N, V> {
      *
      * @return this {@code Builder} object
      */
-    @CanIgnoreReturnValue
     public ImmutableValueGraph.Builder<N, V> addNode(N node) {
       mutableValueGraph.addNode(node);
       return this;
@@ -168,7 +162,6 @@ public final class ImmutableValueGraph<N, V> extends StandardValueGraph<N, V> {
      * @throws IllegalArgumentException if the introduction of the edge would violate {@link
      *     #allowsSelfLoops()}
      */
-    @CanIgnoreReturnValue
     public ImmutableValueGraph.Builder<N, V> putEdgeValue(N nodeU, N nodeV, V value) {
       mutableValueGraph.putEdgeValue(nodeU, nodeV, value);
       return this;
@@ -193,7 +186,6 @@ public final class ImmutableValueGraph<N, V> extends StandardValueGraph<N, V> {
      *     #allowsSelfLoops()}
      * @throws IllegalArgumentException if the endpoints are unordered and the graph is directed
      */
-    @CanIgnoreReturnValue
     public ImmutableValueGraph.Builder<N, V> putEdgeValue(EndpointPair<N> endpoints, V value) {
       mutableValueGraph.putEdgeValue(endpoints, value);
       return this;
diff --git a/guava/src/com/google/common/graph/MapIteratorCache.java b/guava/src/com/google/common/graph/MapIteratorCache.java
index aae91874ce..8681876dca 100644
--- a/guava/src/com/google/common/graph/MapIteratorCache.java
+++ b/guava/src/com/google/common/graph/MapIteratorCache.java
@@ -19,7 +19,6 @@ package com.google.common.graph;
 import static com.google.common.base.Preconditions.checkNotNull;
 
 import com.google.common.collect.UnmodifiableIterator;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.AbstractSet;
 import java.util.Iterator;
 import java.util.Map;
@@ -60,7 +59,6 @@ class MapIteratorCache<K, V> {
     this.backingMap = checkNotNull(backingMap);
   }
 
-  @CanIgnoreReturnValue
   @CheckForNull
   final V put(K key, V value) {
     checkNotNull(key);
@@ -69,7 +67,6 @@ class MapIteratorCache<K, V> {
     return backingMap.put(key, value);
   }
 
-  @CanIgnoreReturnValue
   @CheckForNull
   final V remove(Object key) {
     checkNotNull(key);
diff --git a/guava/src/com/google/common/graph/MutableGraph.java b/guava/src/com/google/common/graph/MutableGraph.java
index b1f3359cab..d0a5454916 100644
--- a/guava/src/com/google/common/graph/MutableGraph.java
+++ b/guava/src/com/google/common/graph/MutableGraph.java
@@ -16,8 +16,6 @@
 
 package com.google.common.graph;
 
-import com.google.common.annotations.Beta;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 
 /**
  * A subinterface of {@link Graph} which adds mutation methods. When mutation is not required, users
@@ -28,7 +26,6 @@ import com.google.errorprone.annotations.CanIgnoreReturnValue;
  * @param <N> Node parameter type
  * @since 20.0
  */
-@Beta
 @ElementTypesAreNonnullByDefault
 public interface MutableGraph<N> extends Graph<N> {
 
@@ -39,7 +36,6 @@ public interface MutableGraph<N> extends Graph<N> {
    *
    * @return {@code true} if the graph was modified as a result of this call
    */
-  @CanIgnoreReturnValue
   boolean addNode(N node);
 
   /**
@@ -55,7 +51,6 @@ public interface MutableGraph<N> extends Graph<N> {
    * @throws IllegalArgumentException if the introduction of the edge would violate {@link
    *     #allowsSelfLoops()}
    */
-  @CanIgnoreReturnValue
   boolean putEdge(N nodeU, N nodeV);
 
   /**
@@ -76,7 +71,6 @@ public interface MutableGraph<N> extends Graph<N> {
    * @throws IllegalArgumentException if the endpoints are unordered and the graph is directed
    * @since 27.1
    */
-  @CanIgnoreReturnValue
   boolean putEdge(EndpointPair<N> endpoints);
 
   /**
@@ -84,7 +78,6 @@ public interface MutableGraph<N> extends Graph<N> {
    *
    * @return {@code true} if the graph was modified as a result of this call
    */
-  @CanIgnoreReturnValue
   boolean removeNode(N node);
 
   /**
@@ -92,7 +85,6 @@ public interface MutableGraph<N> extends Graph<N> {
    *
    * @return {@code true} if the graph was modified as a result of this call
    */
-  @CanIgnoreReturnValue
   boolean removeEdge(N nodeU, N nodeV);
 
   /**
@@ -104,6 +96,5 @@ public interface MutableGraph<N> extends Graph<N> {
    * @return {@code true} if the graph was modified as a result of this call
    * @since 27.1
    */
-  @CanIgnoreReturnValue
   boolean removeEdge(EndpointPair<N> endpoints);
 }
diff --git a/guava/src/com/google/common/graph/MutableNetwork.java b/guava/src/com/google/common/graph/MutableNetwork.java
index 64acb13162..4c31c209f5 100644
--- a/guava/src/com/google/common/graph/MutableNetwork.java
+++ b/guava/src/com/google/common/graph/MutableNetwork.java
@@ -16,8 +16,6 @@
 
 package com.google.common.graph;
 
-import com.google.common.annotations.Beta;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 
 /**
  * A subinterface of {@link Network} which adds mutation methods. When mutation is not required,
@@ -29,7 +27,6 @@ import com.google.errorprone.annotations.CanIgnoreReturnValue;
  * @param <E> Edge parameter type
  * @since 20.0
  */
-@Beta
 @ElementTypesAreNonnullByDefault
 public interface MutableNetwork<N, E> extends Network<N, E> {
 
@@ -40,7 +37,6 @@ public interface MutableNetwork<N, E> extends Network<N, E> {
    *
    * @return {@code true} if the network was modified as a result of this call
    */
-  @CanIgnoreReturnValue
   boolean addNode(N node);
 
   /**
@@ -64,7 +60,6 @@ public interface MutableNetwork<N, E> extends Network<N, E> {
    * @throws IllegalArgumentException if the introduction of the edge would violate {@link
    *     #allowsParallelEdges()} or {@link #allowsSelfLoops()}
    */
-  @CanIgnoreReturnValue
   boolean addEdge(N nodeU, N nodeV, E edge);
 
   /**
@@ -93,7 +88,6 @@ public interface MutableNetwork<N, E> extends Network<N, E> {
    * @throws IllegalArgumentException if the endpoints are unordered and the graph is directed
    * @since 27.1
    */
-  @CanIgnoreReturnValue
   boolean addEdge(EndpointPair<N> endpoints, E edge);
 
   /**
@@ -101,7 +95,6 @@ public interface MutableNetwork<N, E> extends Network<N, E> {
    *
    * @return {@code true} if the network was modified as a result of this call
    */
-  @CanIgnoreReturnValue
   boolean removeNode(N node);
 
   /**
@@ -109,6 +102,5 @@ public interface MutableNetwork<N, E> extends Network<N, E> {
    *
    * @return {@code true} if the network was modified as a result of this call
    */
-  @CanIgnoreReturnValue
   boolean removeEdge(E edge);
 }
diff --git a/guava/src/com/google/common/graph/MutableValueGraph.java b/guava/src/com/google/common/graph/MutableValueGraph.java
index f32d2ee7a3..32f01ff2ad 100644
--- a/guava/src/com/google/common/graph/MutableValueGraph.java
+++ b/guava/src/com/google/common/graph/MutableValueGraph.java
@@ -16,8 +16,6 @@
 
 package com.google.common.graph;
 
-import com.google.common.annotations.Beta;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import javax.annotation.CheckForNull;
 
 /**
@@ -29,7 +27,6 @@ import javax.annotation.CheckForNull;
  * @param <V> Value parameter type
  * @since 20.0
  */
-@Beta
 @ElementTypesAreNonnullByDefault
 public interface MutableValueGraph<N, V> extends ValueGraph<N, V> {
 
@@ -40,7 +37,6 @@ public interface MutableValueGraph<N, V> extends ValueGraph<N, V> {
    *
    * @return {@code true} if the graph was modified as a result of this call
    */
-  @CanIgnoreReturnValue
   boolean addNode(N node);
 
   /**
@@ -60,7 +56,6 @@ public interface MutableValueGraph<N, V> extends ValueGraph<N, V> {
    * @throws IllegalArgumentException if the introduction of the edge would violate {@link
    *     #allowsSelfLoops()}
    */
-  @CanIgnoreReturnValue
   @CheckForNull
   V putEdgeValue(N nodeU, N nodeV, V value);
 
@@ -85,7 +80,6 @@ public interface MutableValueGraph<N, V> extends ValueGraph<N, V> {
    * @throws IllegalArgumentException if the endpoints are unordered and the graph is directed
    * @since 27.1
    */
-  @CanIgnoreReturnValue
   @CheckForNull
   V putEdgeValue(EndpointPair<N> endpoints, V value);
 
@@ -94,7 +88,6 @@ public interface MutableValueGraph<N, V> extends ValueGraph<N, V> {
    *
    * @return {@code true} if the graph was modified as a result of this call
    */
-  @CanIgnoreReturnValue
   boolean removeNode(N node);
 
   /**
@@ -103,7 +96,6 @@ public interface MutableValueGraph<N, V> extends ValueGraph<N, V> {
    * @return the value previously associated with the edge connecting {@code nodeU} to {@code
    *     nodeV}, or null if there was no such edge.
    */
-  @CanIgnoreReturnValue
   @CheckForNull
   V removeEdge(N nodeU, N nodeV);
 
@@ -116,7 +108,6 @@ public interface MutableValueGraph<N, V> extends ValueGraph<N, V> {
    *     there was no such edge.
    * @since 27.1
    */
-  @CanIgnoreReturnValue
   @CheckForNull
   V removeEdge(EndpointPair<N> endpoints);
 }
diff --git a/guava/src/com/google/common/graph/Network.java b/guava/src/com/google/common/graph/Network.java
index c700d3378d..a0f2267f0e 100644
--- a/guava/src/com/google/common/graph/Network.java
+++ b/guava/src/com/google/common/graph/Network.java
@@ -16,8 +16,6 @@
 
 package com.google.common.graph;
 
-import com.google.common.annotations.Beta;
-import com.google.errorprone.annotations.DoNotMock;
 import java.util.Optional;
 import java.util.Set;
 import javax.annotation.CheckForNull;
@@ -102,8 +100,6 @@ import javax.annotation.CheckForNull;
  * @param <E> Edge parameter type
  * @since 20.0
  */
-@Beta
-@DoNotMock("Use NetworkBuilder to create a real instance")
 @ElementTypesAreNonnullByDefault
 public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFunction<N> {
   //
diff --git a/guava/src/com/google/common/graph/NetworkBuilder.java b/guava/src/com/google/common/graph/NetworkBuilder.java
index 968944493c..2962c55f53 100644
--- a/guava/src/com/google/common/graph/NetworkBuilder.java
+++ b/guava/src/com/google/common/graph/NetworkBuilder.java
@@ -19,7 +19,6 @@ package com.google.common.graph;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.graph.Graphs.checkNonNegative;
 
-import com.google.common.annotations.Beta;
 import com.google.common.base.Optional;
 
 /**
@@ -66,7 +65,6 @@ import com.google.common.base.Optional;
  *     constructed based on an existing {@code Network} using {@link #from(Network)}.
  * @since 20.0
  */
-@Beta
 @ElementTypesAreNonnullByDefault
 public final class NetworkBuilder<N, E> extends AbstractGraphBuilder<N> {
   boolean allowsParallelEdges = false;
diff --git a/guava/src/com/google/common/graph/NetworkConnections.java b/guava/src/com/google/common/graph/NetworkConnections.java
index 94d1780d31..2d2833f1c8 100644
--- a/guava/src/com/google/common/graph/NetworkConnections.java
+++ b/guava/src/com/google/common/graph/NetworkConnections.java
@@ -16,7 +16,6 @@
 
 package com.google.common.graph;
 
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Set;
 import javax.annotation.CheckForNull;
 
@@ -61,12 +60,10 @@ interface NetworkConnections<N, E> {
    *
    * <p>In the undirected case, returns {@code null} if {@code isSelfLoop} is true.
    */
-  @CanIgnoreReturnValue
   @CheckForNull
   N removeInEdge(E edge, boolean isSelfLoop);
 
   /** Remove {@code edge} from the set of outgoing edges. Returns the former successor node. */
-  @CanIgnoreReturnValue
   N removeOutEdge(E edge);
 
   /**
diff --git a/guava/src/com/google/common/graph/ParametricNullness.java b/guava/src/com/google/common/graph/ParametricNullness.java
index 62534eb4cd..3cb5a25d30 100644
--- a/guava/src/com/google/common/graph/ParametricNullness.java
+++ b/guava/src/com/google/common/graph/ParametricNullness.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import static javax.annotation.meta.When.UNKNOWN;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -35,7 +34,6 @@ import javax.annotation.meta.TypeQualifierNickname;
  * href="https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/NullFromTypeParam.java">{@code
  * NullFromTypeParam}</a>). We use this to "undo" {@link ElementTypesAreNonnullByDefault}.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target({FIELD, METHOD, PARAMETER})
 @TypeQualifierNickname
diff --git a/guava/src/com/google/common/graph/PredecessorsFunction.java b/guava/src/com/google/common/graph/PredecessorsFunction.java
index 750a8acd60..52a10363b1 100644
--- a/guava/src/com/google/common/graph/PredecessorsFunction.java
+++ b/guava/src/com/google/common/graph/PredecessorsFunction.java
@@ -16,8 +16,6 @@
 
 package com.google.common.graph;
 
-import com.google.common.annotations.Beta;
-import com.google.errorprone.annotations.DoNotMock;
 
 /**
  * A functional interface for <a
@@ -78,8 +76,6 @@ import com.google.errorprone.annotations.DoNotMock;
  * @param <N> Node parameter type
  * @since 23.0
  */
-@Beta
-@DoNotMock("Implement with a lambda, or use GraphBuilder to build a Graph with the desired edges")
 @ElementTypesAreNonnullByDefault
 public interface PredecessorsFunction<N> {
 
diff --git a/guava/src/com/google/common/graph/StandardMutableNetwork.java b/guava/src/com/google/common/graph/StandardMutableNetwork.java
index c58b6d3909..856839500c 100644
--- a/guava/src/com/google/common/graph/StandardMutableNetwork.java
+++ b/guava/src/com/google/common/graph/StandardMutableNetwork.java
@@ -25,7 +25,6 @@ import static com.google.common.graph.GraphConstants.SELF_LOOPS_NOT_ALLOWED;
 import static java.util.Objects.requireNonNull;
 
 import com.google.common.collect.ImmutableList;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 
 /**
  * Standard implementation of {@link MutableNetwork} that supports both directed and undirected
@@ -50,7 +49,6 @@ final class StandardMutableNetwork<N, E> extends StandardNetwork<N, E>
   }
 
   @Override
-  @CanIgnoreReturnValue
   public boolean addNode(N node) {
     checkNotNull(node, "node");
 
@@ -67,7 +65,6 @@ final class StandardMutableNetwork<N, E> extends StandardNetwork<N, E>
    *
    * @throws IllegalStateException if {@code node} is already present
    */
-  @CanIgnoreReturnValue
   private NetworkConnections<N, E> addNodeInternal(N node) {
     NetworkConnections<N, E> connections = newConnections();
     checkState(nodeConnections.put(node, connections) == null);
@@ -75,7 +72,6 @@ final class StandardMutableNetwork<N, E> extends StandardNetwork<N, E>
   }
 
   @Override
-  @CanIgnoreReturnValue
   public boolean addEdge(N nodeU, N nodeV, E edge) {
     checkNotNull(nodeU, "nodeU");
     checkNotNull(nodeV, "nodeV");
@@ -119,14 +115,12 @@ final class StandardMutableNetwork<N, E> extends StandardNetwork<N, E>
   }
 
   @Override
-  @CanIgnoreReturnValue
   public boolean addEdge(EndpointPair<N> endpoints, E edge) {
     validateEndpoints(endpoints);
     return addEdge(endpoints.nodeU(), endpoints.nodeV(), edge);
   }
 
   @Override
-  @CanIgnoreReturnValue
   public boolean removeNode(N node) {
     checkNotNull(node, "node");
 
@@ -145,7 +139,6 @@ final class StandardMutableNetwork<N, E> extends StandardNetwork<N, E>
   }
 
   @Override
-  @CanIgnoreReturnValue
   public boolean removeEdge(E edge) {
     checkNotNull(edge, "edge");
 
diff --git a/guava/src/com/google/common/graph/StandardMutableValueGraph.java b/guava/src/com/google/common/graph/StandardMutableValueGraph.java
index 0ea641a5b1..175ff38f17 100644
--- a/guava/src/com/google/common/graph/StandardMutableValueGraph.java
+++ b/guava/src/com/google/common/graph/StandardMutableValueGraph.java
@@ -24,7 +24,6 @@ import static com.google.common.graph.Graphs.checkNonNegative;
 import static com.google.common.graph.Graphs.checkPositive;
 import static java.util.Objects.requireNonNull;
 
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import javax.annotation.CheckForNull;
 
 /**
@@ -58,7 +57,6 @@ final class StandardMutableValueGraph<N, V> extends StandardValueGraph<N, V>
   }
 
   @Override
-  @CanIgnoreReturnValue
   public boolean addNode(N node) {
     checkNotNull(node, "node");
 
@@ -75,7 +73,6 @@ final class StandardMutableValueGraph<N, V> extends StandardValueGraph<N, V>
    *
    * @throws IllegalStateException if {@code node} is already present
    */
-  @CanIgnoreReturnValue
   private GraphConnections<N, V> addNodeInternal(N node) {
     GraphConnections<N, V> connections = newConnections();
     checkState(nodeConnections.put(node, connections) == null);
@@ -83,7 +80,6 @@ final class StandardMutableValueGraph<N, V> extends StandardValueGraph<N, V>
   }
 
   @Override
-  @CanIgnoreReturnValue
   @CheckForNull
   public V putEdgeValue(N nodeU, N nodeV, V value) {
     checkNotNull(nodeU, "nodeU");
@@ -111,7 +107,6 @@ final class StandardMutableValueGraph<N, V> extends StandardValueGraph<N, V>
   }
 
   @Override
-  @CanIgnoreReturnValue
   @CheckForNull
   public V putEdgeValue(EndpointPair<N> endpoints, V value) {
     validateEndpoints(endpoints);
@@ -119,7 +114,6 @@ final class StandardMutableValueGraph<N, V> extends StandardValueGraph<N, V>
   }
 
   @Override
-  @CanIgnoreReturnValue
   public boolean removeNode(N node) {
     checkNotNull(node, "node");
 
@@ -156,7 +150,6 @@ final class StandardMutableValueGraph<N, V> extends StandardValueGraph<N, V>
   }
 
   @Override
-  @CanIgnoreReturnValue
   @CheckForNull
   public V removeEdge(N nodeU, N nodeV) {
     checkNotNull(nodeU, "nodeU");
@@ -177,7 +170,6 @@ final class StandardMutableValueGraph<N, V> extends StandardValueGraph<N, V>
   }
 
   @Override
-  @CanIgnoreReturnValue
   @CheckForNull
   public V removeEdge(EndpointPair<N> endpoints) {
     validateEndpoints(endpoints);
diff --git a/guava/src/com/google/common/graph/SuccessorsFunction.java b/guava/src/com/google/common/graph/SuccessorsFunction.java
index c29bb4b943..2725649920 100644
--- a/guava/src/com/google/common/graph/SuccessorsFunction.java
+++ b/guava/src/com/google/common/graph/SuccessorsFunction.java
@@ -16,8 +16,6 @@
 
 package com.google.common.graph;
 
-import com.google.common.annotations.Beta;
-import com.google.errorprone.annotations.DoNotMock;
 
 /**
  * A functional interface for <a
@@ -78,8 +76,6 @@ import com.google.errorprone.annotations.DoNotMock;
  * @param <N> Node parameter type
  * @since 23.0
  */
-@Beta
-@DoNotMock("Implement with a lambda, or use GraphBuilder to build a Graph with the desired edges")
 @ElementTypesAreNonnullByDefault
 public interface SuccessorsFunction<N> {
 
diff --git a/guava/src/com/google/common/graph/Traverser.java b/guava/src/com/google/common/graph/Traverser.java
index 5a36f9f894..6286f1293f 100644
--- a/guava/src/com/google/common/graph/Traverser.java
+++ b/guava/src/com/google/common/graph/Traverser.java
@@ -20,10 +20,8 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
 import com.google.common.collect.AbstractIterator;
 import com.google.common.collect.ImmutableSet;
-import com.google.errorprone.annotations.DoNotMock;
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.HashSet;
@@ -60,10 +58,6 @@ import javax.annotation.CheckForNull;
  * @param <N> Node parameter type
  * @since 23.1
  */
-@Beta
-@DoNotMock(
-    "Call forGraph or forTree, passing a lambda or a Graph with the desired edges (built with"
-        + " GraphBuilder)")
 @ElementTypesAreNonnullByDefault
 public abstract class Traverser<N> {
   private final SuccessorsFunction<N> successorFunction;
diff --git a/guava/src/com/google/common/graph/UndirectedMultiNetworkConnections.java b/guava/src/com/google/common/graph/UndirectedMultiNetworkConnections.java
index a5c45ca11d..dca3662fc4 100644
--- a/guava/src/com/google/common/graph/UndirectedMultiNetworkConnections.java
+++ b/guava/src/com/google/common/graph/UndirectedMultiNetworkConnections.java
@@ -23,7 +23,6 @@ import static com.google.common.graph.GraphConstants.INNER_LOAD_FACTOR;
 import com.google.common.collect.HashMultiset;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Multiset;
-import com.google.errorprone.annotations.concurrent.LazyInit;
 import java.lang.ref.Reference;
 import java.lang.ref.SoftReference;
 import java.util.Collections;
@@ -56,7 +55,7 @@ final class UndirectedMultiNetworkConnections<N, E>
     return new UndirectedMultiNetworkConnections<>(ImmutableMap.copyOf(incidentEdges));
   }
 
-  @CheckForNull @LazyInit private transient Reference<Multiset<N>> adjacentNodesReference;
+  @CheckForNull private transient Reference<Multiset<N>> adjacentNodesReference;
 
   @Override
   public Set<N> adjacentNodes() {
diff --git a/guava/src/com/google/common/graph/ValueGraph.java b/guava/src/com/google/common/graph/ValueGraph.java
index a13e87eb98..0696b27815 100644
--- a/guava/src/com/google/common/graph/ValueGraph.java
+++ b/guava/src/com/google/common/graph/ValueGraph.java
@@ -16,7 +16,6 @@
 
 package com.google.common.graph;
 
-import com.google.common.annotations.Beta;
 import java.util.Collection;
 import java.util.Optional;
 import java.util.Set;
@@ -107,7 +106,6 @@ import javax.annotation.CheckForNull;
  * @param <V> Value parameter type
  * @since 20.0
  */
-@Beta
 @ElementTypesAreNonnullByDefault
 public interface ValueGraph<N, V> extends BaseGraph<N> {
   //
diff --git a/guava/src/com/google/common/graph/ValueGraphBuilder.java b/guava/src/com/google/common/graph/ValueGraphBuilder.java
index ce146c3255..b0f33732a7 100644
--- a/guava/src/com/google/common/graph/ValueGraphBuilder.java
+++ b/guava/src/com/google/common/graph/ValueGraphBuilder.java
@@ -20,7 +20,6 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.graph.Graphs.checkNonNegative;
 
-import com.google.common.annotations.Beta;
 import com.google.common.base.Optional;
 
 /**
@@ -65,7 +64,6 @@ import com.google.common.base.Optional;
  *     #from(ValueGraph)}.
  * @since 20.0
  */
-@Beta
 @ElementTypesAreNonnullByDefault
 public final class ValueGraphBuilder<N, V> extends AbstractGraphBuilder<N> {
 
diff --git a/guava/src/com/google/common/graph/package-info.java b/guava/src/com/google/common/graph/package-info.java
index 32d8b0157b..b3ccd2f009 100644
--- a/guava/src/com/google/common/graph/package-info.java
+++ b/guava/src/com/google/common/graph/package-info.java
@@ -21,9 +21,7 @@
  * <p>This package is a part of the open-source <a href="https://github.com/google/guava">Guava</a>
  * library.
  */
-@CheckReturnValue
 @ParametersAreNonnullByDefault
 package com.google.common.graph;
 
-import com.google.errorprone.annotations.CheckReturnValue;
 import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/guava/src/com/google/common/hash/AbstractByteHasher.java b/guava/src/com/google/common/hash/AbstractByteHasher.java
index 9f7e041909..75be6da90a 100644
--- a/guava/src/com/google/common/hash/AbstractByteHasher.java
+++ b/guava/src/com/google/common/hash/AbstractByteHasher.java
@@ -21,7 +21,6 @@ import com.google.common.primitives.Chars;
 import com.google.common.primitives.Ints;
 import com.google.common.primitives.Longs;
 import com.google.common.primitives.Shorts;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 
@@ -31,7 +30,6 @@ import java.nio.ByteOrder;
  *
  * @author Colin Decker
  */
-@CanIgnoreReturnValue
 @ElementTypesAreNonnullByDefault
 abstract class AbstractByteHasher extends AbstractHasher {
   private final ByteBuffer scratch = ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN);
diff --git a/guava/src/com/google/common/hash/AbstractCompositeHashFunction.java b/guava/src/com/google/common/hash/AbstractCompositeHashFunction.java
index 4b69bb721c..855b492b81 100644
--- a/guava/src/com/google/common/hash/AbstractCompositeHashFunction.java
+++ b/guava/src/com/google/common/hash/AbstractCompositeHashFunction.java
@@ -17,10 +17,8 @@ package com.google.common.hash;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.errorprone.annotations.Immutable;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An abstract composition of multiple hash functions. {@linkplain #newHasher()} delegates to the
@@ -29,7 +27,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @author Dimitris Andreou
  */
-@Immutable
 @ElementTypesAreNonnullByDefault
 abstract class AbstractCompositeHashFunction extends AbstractHashFunction {
 
@@ -179,7 +176,7 @@ abstract class AbstractCompositeHashFunction extends AbstractHashFunction {
       }
 
       @Override
-      public <T extends @Nullable Object> Hasher putObject(
+      public <T extends Object> Hasher putObject(
           @ParametricNullness T instance, Funnel<? super T> funnel) {
         for (Hasher hasher : hashers) {
           hasher.putObject(instance, funnel);
diff --git a/guava/src/com/google/common/hash/AbstractHashFunction.java b/guava/src/com/google/common/hash/AbstractHashFunction.java
index 7308556002..d797358f50 100644
--- a/guava/src/com/google/common/hash/AbstractHashFunction.java
+++ b/guava/src/com/google/common/hash/AbstractHashFunction.java
@@ -17,21 +17,18 @@ package com.google.common.hash;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
 
-import com.google.errorprone.annotations.Immutable;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Skeleton implementation of {@link HashFunction} in terms of {@link #newHasher()}.
  *
  * <p>TODO(lowasser): make public
  */
-@Immutable
 @ElementTypesAreNonnullByDefault
 abstract class AbstractHashFunction implements HashFunction {
   @Override
-  public <T extends @Nullable Object> HashCode hashObject(
+  public <T extends Object> HashCode hashObject(
       @ParametricNullness T instance, Funnel<? super T> funnel) {
     return newHasher().putObject(instance, funnel).hash();
   }
diff --git a/guava/src/com/google/common/hash/AbstractHasher.java b/guava/src/com/google/common/hash/AbstractHasher.java
index c72e05be05..981efc21fe 100644
--- a/guava/src/com/google/common/hash/AbstractHasher.java
+++ b/guava/src/com/google/common/hash/AbstractHasher.java
@@ -15,10 +15,8 @@
 package com.google.common.hash;
 
 import com.google.common.base.Preconditions;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An abstract implementation of {@link Hasher}, which only requires subtypes to implement {@link
@@ -26,7 +24,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @author Dimitris Andreou
  */
-@CanIgnoreReturnValue
 @ElementTypesAreNonnullByDefault
 abstract class AbstractHasher implements Hasher {
   @Override
@@ -116,7 +113,7 @@ abstract class AbstractHasher implements Hasher {
   }
 
   @Override
-  public <T extends @Nullable Object> Hasher putObject(
+  public <T extends Object> Hasher putObject(
       @ParametricNullness T instance, Funnel<? super T> funnel) {
     funnel.funnel(instance, this);
     return this;
diff --git a/guava/src/com/google/common/hash/AbstractNonStreamingHashFunction.java b/guava/src/com/google/common/hash/AbstractNonStreamingHashFunction.java
index 4969e35b22..e606ddc12a 100644
--- a/guava/src/com/google/common/hash/AbstractNonStreamingHashFunction.java
+++ b/guava/src/com/google/common/hash/AbstractNonStreamingHashFunction.java
@@ -15,7 +15,6 @@
 package com.google.common.hash;
 
 import com.google.common.base.Preconditions;
-import com.google.errorprone.annotations.Immutable;
 import java.io.ByteArrayOutputStream;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
@@ -29,7 +28,6 @@ import java.util.Arrays;
  *
  * @author Dimitris Andreou
  */
-@Immutable
 @ElementTypesAreNonnullByDefault
 abstract class AbstractNonStreamingHashFunction extends AbstractHashFunction {
   @Override
diff --git a/guava/src/com/google/common/hash/AbstractStreamingHasher.java b/guava/src/com/google/common/hash/AbstractStreamingHasher.java
index a987b48c35..f927adf95a 100644
--- a/guava/src/com/google/common/hash/AbstractStreamingHasher.java
+++ b/guava/src/com/google/common/hash/AbstractStreamingHasher.java
@@ -16,7 +16,6 @@ package com.google.common.hash;
 
 import static com.google.common.base.Preconditions.checkArgument;
 
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 
@@ -28,7 +27,6 @@ import java.nio.ByteOrder;
  * @author Dimitris Andreou
  */
 // TODO(kevinb): this class still needs some design-and-document-for-inheritance love
-@CanIgnoreReturnValue
 @ElementTypesAreNonnullByDefault
 abstract class AbstractStreamingHasher extends AbstractHasher {
   /** Buffer via which we pass data to the hash algorithm (the implementor) */
diff --git a/guava/src/com/google/common/hash/BloomFilter.java b/guava/src/com/google/common/hash/BloomFilter.java
index e0affaad4e..8507082eaf 100644
--- a/guava/src/com/google/common/hash/BloomFilter.java
+++ b/guava/src/com/google/common/hash/BloomFilter.java
@@ -17,15 +17,12 @@ package com.google.common.hash;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Objects;
 import com.google.common.base.Predicate;
 import com.google.common.hash.BloomFilterStrategies.LockFreeBitArray;
 import com.google.common.math.DoubleMath;
 import com.google.common.primitives.SignedBytes;
 import com.google.common.primitives.UnsignedBytes;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
@@ -35,7 +32,6 @@ import java.io.Serializable;
 import java.math.RoundingMode;
 import java.util.stream.Collector;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A Bloom filter for instances of {@code T}. A Bloom filter offers an approximate containment test
@@ -64,9 +60,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kevin Bourrillion
  * @since 11.0 (thread-safe since 23.0)
  */
-@Beta
 @ElementTypesAreNonnullByDefault
-public final class BloomFilter<T extends @Nullable Object> implements Predicate<T>, Serializable {
+public final class BloomFilter<T extends Object> implements Predicate<T>, Serializable {
   /**
    * A strategy to translate T instances, to {@code numHashFunctions} bit indexes.
    *
@@ -79,7 +74,7 @@ public final class BloomFilter<T extends @Nullable Object> implements Predicate<
      *
      * <p>Returns whether any bits changed as a result of this operation.
      */
-    <T extends @Nullable Object> boolean put(
+    <T extends Object> boolean put(
         @ParametricNullness T object,
         Funnel<? super T> funnel,
         int numHashFunctions,
@@ -89,7 +84,7 @@ public final class BloomFilter<T extends @Nullable Object> implements Predicate<
      * Queries {@code numHashFunctions} bits of the given bit array, by hashing a user element;
      * returns {@code true} if and only if all selected bits are set.
      */
-    <T extends @Nullable Object> boolean mightContain(
+    <T extends Object> boolean mightContain(
         @ParametricNullness T object,
         Funnel<? super T> funnel,
         int numHashFunctions,
@@ -168,7 +163,6 @@ public final class BloomFilter<T extends @Nullable Object> implements Predicate<
    *     result to what {@code mightContain(t)} would have returned at the time it is called.
    * @since 12.0 (present in 11.0 with {@code void} return type})
    */
-  @CanIgnoreReturnValue
   public boolean put(@ParametricNullness T object) {
     return strategy.put(object, funnel, numHashFunctions, bits);
   }
@@ -211,7 +205,6 @@ public final class BloomFilter<T extends @Nullable Object> implements Predicate<
   }
 
   /** Returns the number of bits in the underlying bit array. */
-  @VisibleForTesting
   long bitSize() {
     return bits.bitSize();
   }
@@ -316,7 +309,7 @@ public final class BloomFilter<T extends @Nullable Object> implements Predicate<
    * @return a {@code Collector} generating a {@code BloomFilter} of the received elements
    * @since 23.0
    */
-  public static <T extends @Nullable Object> Collector<T, ?, BloomFilter<T>> toBloomFilter(
+  public static <T extends Object> Collector<T, ?, BloomFilter<T>> toBloomFilter(
       Funnel<? super T> funnel, long expectedInsertions) {
     return toBloomFilter(funnel, expectedInsertions, 0.03);
   }
@@ -343,7 +336,7 @@ public final class BloomFilter<T extends @Nullable Object> implements Predicate<
    * @return a {@code Collector} generating a {@code BloomFilter} of the received elements
    * @since 23.0
    */
-  public static <T extends @Nullable Object> Collector<T, ?, BloomFilter<T>> toBloomFilter(
+  public static <T extends Object> Collector<T, ?, BloomFilter<T>> toBloomFilter(
       Funnel<? super T> funnel, long expectedInsertions, double fpp) {
     checkNotNull(funnel);
     checkArgument(
@@ -381,7 +374,7 @@ public final class BloomFilter<T extends @Nullable Object> implements Predicate<
    * @param fpp the desired false positive probability (must be positive and less than 1.0)
    * @return a {@code BloomFilter}
    */
-  public static <T extends @Nullable Object> BloomFilter<T> create(
+  public static <T extends Object> BloomFilter<T> create(
       Funnel<? super T> funnel, int expectedInsertions, double fpp) {
     return create(funnel, (long) expectedInsertions, fpp);
   }
@@ -407,13 +400,12 @@ public final class BloomFilter<T extends @Nullable Object> implements Predicate<
    * @return a {@code BloomFilter}
    * @since 19.0
    */
-  public static <T extends @Nullable Object> BloomFilter<T> create(
+  public static <T extends Object> BloomFilter<T> create(
       Funnel<? super T> funnel, long expectedInsertions, double fpp) {
     return create(funnel, expectedInsertions, fpp, BloomFilterStrategies.MURMUR128_MITZ_64);
   }
 
-  @VisibleForTesting
-  static <T extends @Nullable Object> BloomFilter<T> create(
+  static <T extends Object> BloomFilter<T> create(
       Funnel<? super T> funnel, long expectedInsertions, double fpp, Strategy strategy) {
     checkNotNull(funnel);
     checkArgument(
@@ -458,7 +450,7 @@ public final class BloomFilter<T extends @Nullable Object> implements Predicate<
    *     BloomFilter}; must be positive
    * @return a {@code BloomFilter}
    */
-  public static <T extends @Nullable Object> BloomFilter<T> create(
+  public static <T extends Object> BloomFilter<T> create(
       Funnel<? super T> funnel, int expectedInsertions) {
     return create(funnel, (long) expectedInsertions);
   }
@@ -483,7 +475,7 @@ public final class BloomFilter<T extends @Nullable Object> implements Predicate<
    * @return a {@code BloomFilter}
    * @since 19.0
    */
-  public static <T extends @Nullable Object> BloomFilter<T> create(
+  public static <T extends Object> BloomFilter<T> create(
       Funnel<? super T> funnel, long expectedInsertions) {
     return create(funnel, expectedInsertions, 0.03); // FYI, for 3%, we always get 5 hash functions
   }
@@ -509,7 +501,6 @@ public final class BloomFilter<T extends @Nullable Object> implements Predicate<
    * @param n expected insertions (must be positive)
    * @param m total number of bits in Bloom filter (must be positive)
    */
-  @VisibleForTesting
   static int optimalNumOfHashFunctions(long n, long m) {
     // (m / n) * log(2), but avoid truncation due to division!
     return Math.max(1, (int) Math.round((double) m / n * Math.log(2)));
@@ -525,7 +516,6 @@ public final class BloomFilter<T extends @Nullable Object> implements Predicate<
    * @param n expected insertions (must be positive)
    * @param p false positive rate (must be 0 < p < 1)
    */
-  @VisibleForTesting
   static long optimalNumOfBits(long n, double p) {
     if (p == 0) {
       p = Double.MIN_VALUE;
@@ -537,7 +527,7 @@ public final class BloomFilter<T extends @Nullable Object> implements Predicate<
     return new SerialForm<T>(this);
   }
 
-  private static class SerialForm<T extends @Nullable Object> implements Serializable {
+  private static class SerialForm<T extends Object> implements Serializable {
     final long[] data;
     final int numHashFunctions;
     final Funnel<? super T> funnel;
@@ -590,7 +580,7 @@ public final class BloomFilter<T extends @Nullable Object> implements Predicate<
    * @throws IOException if the InputStream throws an {@code IOException}, or if its data does not
    *     appear to be a BloomFilter serialized using the {@linkplain #writeTo(OutputStream)} method.
    */
-  public static <T extends @Nullable Object> BloomFilter<T> readFrom(
+  public static <T extends Object> BloomFilter<T> readFrom(
       InputStream in, Funnel<? super T> funnel) throws IOException {
     checkNotNull(in, "InputStream");
     checkNotNull(funnel, "Funnel");
diff --git a/guava/src/com/google/common/hash/BloomFilterStrategies.java b/guava/src/com/google/common/hash/BloomFilterStrategies.java
index 3a012f3588..e9799e1027 100644
--- a/guava/src/com/google/common/hash/BloomFilterStrategies.java
+++ b/guava/src/com/google/common/hash/BloomFilterStrategies.java
@@ -23,7 +23,6 @@ import java.math.RoundingMode;
 import java.util.Arrays;
 import java.util.concurrent.atomic.AtomicLongArray;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Collections of strategies of generating the k * log(M) bits required for an element to be mapped
@@ -46,7 +45,7 @@ enum BloomFilterStrategies implements BloomFilter.Strategy {
    */
   MURMUR128_MITZ_32() {
     @Override
-    public <T extends @Nullable Object> boolean put(
+    public <T extends Object> boolean put(
         @ParametricNullness T object,
         Funnel<? super T> funnel,
         int numHashFunctions,
@@ -69,7 +68,7 @@ enum BloomFilterStrategies implements BloomFilter.Strategy {
     }
 
     @Override
-    public <T extends @Nullable Object> boolean mightContain(
+    public <T extends Object> boolean mightContain(
         @ParametricNullness T object,
         Funnel<? super T> funnel,
         int numHashFunctions,
@@ -100,7 +99,7 @@ enum BloomFilterStrategies implements BloomFilter.Strategy {
    */
   MURMUR128_MITZ_64() {
     @Override
-    public <T extends @Nullable Object> boolean put(
+    public <T extends Object> boolean put(
         @ParametricNullness T object,
         Funnel<? super T> funnel,
         int numHashFunctions,
@@ -121,7 +120,7 @@ enum BloomFilterStrategies implements BloomFilter.Strategy {
     }
 
     @Override
-    public <T extends @Nullable Object> boolean mightContain(
+    public <T extends Object> boolean mightContain(
         @ParametricNullness T object,
         Funnel<? super T> funnel,
         int numHashFunctions,
diff --git a/guava/src/com/google/common/hash/ChecksumHashFunction.java b/guava/src/com/google/common/hash/ChecksumHashFunction.java
index 159adbb819..2456b88f00 100644
--- a/guava/src/com/google/common/hash/ChecksumHashFunction.java
+++ b/guava/src/com/google/common/hash/ChecksumHashFunction.java
@@ -17,7 +17,6 @@ package com.google.common.hash;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.errorprone.annotations.Immutable;
 import java.io.Serializable;
 import java.util.zip.Checksum;
 
@@ -26,7 +25,6 @@ import java.util.zip.Checksum;
  *
  * @author Colin Decker
  */
-@Immutable
 @ElementTypesAreNonnullByDefault
 final class ChecksumHashFunction extends AbstractHashFunction implements Serializable {
   private final ImmutableSupplier<? extends Checksum> checksumSupplier;
diff --git a/guava/src/com/google/common/hash/Crc32cHashFunction.java b/guava/src/com/google/common/hash/Crc32cHashFunction.java
index 8e17e6538c..5599f858cd 100644
--- a/guava/src/com/google/common/hash/Crc32cHashFunction.java
+++ b/guava/src/com/google/common/hash/Crc32cHashFunction.java
@@ -14,7 +14,6 @@
 
 package com.google.common.hash;
 
-import com.google.errorprone.annotations.Immutable;
 import java.nio.ByteBuffer;
 
 /**
@@ -23,7 +22,6 @@ import java.nio.ByteBuffer;
  *
  * @author Kurt Alfred Kluever
  */
-@Immutable
 @ElementTypesAreNonnullByDefault
 final class Crc32cHashFunction extends AbstractHashFunction {
   static final HashFunction CRC_32_C = new Crc32cHashFunction();
diff --git a/guava/src/com/google/common/hash/ElementTypesAreNonnullByDefault.java b/guava/src/com/google/common/hash/ElementTypesAreNonnullByDefault.java
index a2382b3514..030fd4f998 100644
--- a/guava/src/com/google/common/hash/ElementTypesAreNonnullByDefault.java
+++ b/guava/src/com/google/common/hash/ElementTypesAreNonnullByDefault.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.ElementType.TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -33,7 +32,6 @@ import javax.annotation.meta.TypeQualifierDefault;
  * unfortunately includes type-variable usages, so we also provide {@link ParametricNullness} to
  * "undo" it as best we can.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target(TYPE)
 @TypeQualifierDefault({FIELD, METHOD, PARAMETER})
diff --git a/guava/src/com/google/common/hash/FarmHashFingerprint64.java b/guava/src/com/google/common/hash/FarmHashFingerprint64.java
index 7d6a3981d7..923bf2f456 100644
--- a/guava/src/com/google/common/hash/FarmHashFingerprint64.java
+++ b/guava/src/com/google/common/hash/FarmHashFingerprint64.java
@@ -19,7 +19,6 @@ import static com.google.common.hash.LittleEndianByteArray.load32;
 import static com.google.common.hash.LittleEndianByteArray.load64;
 import static java.lang.Long.rotateRight;
 
-import com.google.common.annotations.VisibleForTesting;
 
 /**
  * Implementation of FarmHash Fingerprint64, an open-source fingerprinting algorithm for strings.
@@ -65,7 +64,6 @@ final class FarmHashFingerprint64 extends AbstractNonStreamingHashFunction {
 
   // End of public functions.
 
-  @VisibleForTesting
   static long fingerprint(byte[] bytes, int offset, int length) {
     if (length <= 32) {
       if (length <= 16) {
diff --git a/guava/src/com/google/common/hash/Funnel.java b/guava/src/com/google/common/hash/Funnel.java
index 9d80dabcf6..3fb86d288a 100644
--- a/guava/src/com/google/common/hash/Funnel.java
+++ b/guava/src/com/google/common/hash/Funnel.java
@@ -14,10 +14,7 @@
 
 package com.google.common.hash;
 
-import com.google.common.annotations.Beta;
-import com.google.errorprone.annotations.DoNotMock;
 import java.io.Serializable;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An object which can send data from an object of type {@code T} into a {@code PrimitiveSink}.
@@ -42,10 +39,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Dimitris Andreou
  * @since 11.0
  */
-@Beta
-@DoNotMock("Implement with a lambda")
 @ElementTypesAreNonnullByDefault
-public interface Funnel<T extends @Nullable Object> extends Serializable {
+public interface Funnel<T extends Object> extends Serializable {
 
   /**
    * Sends a stream of data from the {@code from} object into the sink {@code into}. There is no
diff --git a/guava/src/com/google/common/hash/Funnels.java b/guava/src/com/google/common/hash/Funnels.java
index 66738361cd..9ed9dcaa5a 100644
--- a/guava/src/com/google/common/hash/Funnels.java
+++ b/guava/src/com/google/common/hash/Funnels.java
@@ -14,13 +14,11 @@
 
 package com.google.common.hash;
 
-import com.google.common.annotations.Beta;
 import com.google.common.base.Preconditions;
 import java.io.OutputStream;
 import java.io.Serializable;
 import java.nio.charset.Charset;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Funnels for common types. All implementations are serializable.
@@ -28,7 +26,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Dimitris Andreou
  * @since 11.0
  */
-@Beta
 @ElementTypesAreNonnullByDefault
 public final class Funnels {
   private Funnels() {}
@@ -166,12 +163,12 @@ public final class Funnels {
    *
    * @since 15.0
    */
-  public static <E extends @Nullable Object> Funnel<Iterable<? extends E>> sequentialFunnel(
+  public static <E extends Object> Funnel<Iterable<? extends E>> sequentialFunnel(
       Funnel<E> elementFunnel) {
     return new SequentialFunnel<E>(elementFunnel);
   }
 
-  private static class SequentialFunnel<E extends @Nullable Object>
+  private static class SequentialFunnel<E extends Object>
       implements Funnel<Iterable<? extends E>>, Serializable {
     private final Funnel<E> elementFunnel;
 
diff --git a/guava/src/com/google/common/hash/HashCode.java b/guava/src/com/google/common/hash/HashCode.java
index fde2a86d64..2f2615e103 100644
--- a/guava/src/com/google/common/hash/HashCode.java
+++ b/guava/src/com/google/common/hash/HashCode.java
@@ -21,7 +21,6 @@ import static com.google.common.base.Preconditions.checkState;
 import com.google.common.base.Preconditions;
 import com.google.common.primitives.Ints;
 import com.google.common.primitives.UnsignedInts;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.Serializable;
 import javax.annotation.CheckForNull;
 
@@ -81,7 +80,6 @@ public abstract class HashCode {
    * @return the number of bytes written to {@code dest}
    * @throws IndexOutOfBoundsException if there is not enough room in {@code dest}
    */
-  @CanIgnoreReturnValue
   public int writeBytesTo(byte[] dest, int offset, int maxLength) {
     maxLength = Ints.min(maxLength, bits() / 8);
     Preconditions.checkPositionIndexes(offset, offset + maxLength, dest.length);
diff --git a/guava/src/com/google/common/hash/HashFunction.java b/guava/src/com/google/common/hash/HashFunction.java
index d4b7f8a01f..897777e395 100644
--- a/guava/src/com/google/common/hash/HashFunction.java
+++ b/guava/src/com/google/common/hash/HashFunction.java
@@ -15,10 +15,8 @@
 package com.google.common.hash;
 
 import com.google.common.primitives.Ints;
-import com.google.errorprone.annotations.Immutable;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A hash function is a collision-averse pure function that maps an arbitrary block of data to a
@@ -115,7 +113,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kevin Bourrillion
  * @since 11.0
  */
-@Immutable
 @ElementTypesAreNonnullByDefault
 public interface HashFunction {
   /**
@@ -211,7 +208,7 @@ public interface HashFunction {
    *
    * @since 14.0
    */
-  <T extends @Nullable Object> HashCode hashObject(
+  <T extends Object> HashCode hashObject(
       @ParametricNullness T instance, Funnel<? super T> funnel);
 
   /**
diff --git a/guava/src/com/google/common/hash/Hasher.java b/guava/src/com/google/common/hash/Hasher.java
index b3f24fa282..59ede64ee7 100644
--- a/guava/src/com/google/common/hash/Hasher.java
+++ b/guava/src/com/google/common/hash/Hasher.java
@@ -14,11 +14,8 @@
 
 package com.google.common.hash;
 
-import com.google.common.annotations.Beta;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link PrimitiveSink} that can compute a hash code after reading the input. Each hasher should
@@ -53,8 +50,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kevin Bourrillion
  * @since 11.0
  */
-@Beta
-@CanIgnoreReturnValue
 @ElementTypesAreNonnullByDefault
 public interface Hasher extends PrimitiveSink {
   @Override
@@ -121,7 +116,7 @@ public interface Hasher extends PrimitiveSink {
   Hasher putString(CharSequence charSequence, Charset charset);
 
   /** A simple convenience for {@code funnel.funnel(object, this)}. */
-  <T extends @Nullable Object> Hasher putObject(
+  <T extends Object> Hasher putObject(
       @ParametricNullness T instance, Funnel<? super T> funnel);
 
   /**
diff --git a/guava/src/com/google/common/hash/Hashing.java b/guava/src/com/google/common/hash/Hashing.java
index dd6536773a..17a273f10d 100644
--- a/guava/src/com/google/common/hash/Hashing.java
+++ b/guava/src/com/google/common/hash/Hashing.java
@@ -17,8 +17,6 @@ package com.google.common.hash;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.errorprone.annotations.Immutable;
 import java.security.Key;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -42,7 +40,6 @@ import javax.crypto.spec.SecretKeySpec;
  * @author Kurt Alfred Kluever
  * @since 11.0
  */
-@Beta
 @ElementTypesAreNonnullByDefault
 public final class Hashing {
   /**
@@ -425,7 +422,6 @@ public final class Hashing {
     return ChecksumType.ADLER_32.hashFunction;
   }
 
-  @Immutable
   enum ChecksumType implements ImmutableSupplier<Checksum> {
     CRC_32("Hashing.crc32()") {
       @Override
diff --git a/guava/src/com/google/common/hash/HashingInputStream.java b/guava/src/com/google/common/hash/HashingInputStream.java
index bf9464ce55..b1a305fa1f 100644
--- a/guava/src/com/google/common/hash/HashingInputStream.java
+++ b/guava/src/com/google/common/hash/HashingInputStream.java
@@ -16,8 +16,6 @@ package com.google.common.hash;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -28,7 +26,6 @@ import java.io.InputStream;
  * @author Qian Huang
  * @since 16.0
  */
-@Beta
 @ElementTypesAreNonnullByDefault
 public final class HashingInputStream extends FilterInputStream {
   private final Hasher hasher;
@@ -49,7 +46,6 @@ public final class HashingInputStream extends FilterInputStream {
    * byte read.
    */
   @Override
-  @CanIgnoreReturnValue
   public int read() throws IOException {
     int b = in.read();
     if (b != -1) {
@@ -63,7 +59,6 @@ public final class HashingInputStream extends FilterInputStream {
    * the bytes read.
    */
   @Override
-  @CanIgnoreReturnValue
   public int read(byte[] bytes, int off, int len) throws IOException {
     int numOfBytesRead = in.read(bytes, off, len);
     if (numOfBytesRead != -1) {
diff --git a/guava/src/com/google/common/hash/HashingOutputStream.java b/guava/src/com/google/common/hash/HashingOutputStream.java
index f138bba150..14dd66f66d 100644
--- a/guava/src/com/google/common/hash/HashingOutputStream.java
+++ b/guava/src/com/google/common/hash/HashingOutputStream.java
@@ -16,7 +16,6 @@ package com.google.common.hash;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
 import java.io.FilterOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
@@ -27,7 +26,6 @@ import java.io.OutputStream;
  * @author Nick Piepmeier
  * @since 16.0
  */
-@Beta
 @ElementTypesAreNonnullByDefault
 public final class HashingOutputStream extends FilterOutputStream {
   private final Hasher hasher;
diff --git a/guava/src/com/google/common/hash/ImmutableSupplier.java b/guava/src/com/google/common/hash/ImmutableSupplier.java
index 24f711a313..76041ad375 100644
--- a/guava/src/com/google/common/hash/ImmutableSupplier.java
+++ b/guava/src/com/google/common/hash/ImmutableSupplier.java
@@ -15,13 +15,11 @@
 package com.google.common.hash;
 
 import com.google.common.base.Supplier;
-import com.google.errorprone.annotations.Immutable;
 
 /**
  * Explicitly named subinterface of {@link Supplier} that can be marked {@literal @}{@link
  * Immutable}.
  */
 // TODO(cpovirk): Should we just use ChecksumType directly instead of defining this type?
-@Immutable
 @ElementTypesAreNonnullByDefault
 interface ImmutableSupplier<T> extends Supplier<T> {}
diff --git a/guava/src/com/google/common/hash/Java8Compatibility.java b/guava/src/com/google/common/hash/Java8Compatibility.java
index c15f2b3cc5..24cb72da07 100644
--- a/guava/src/com/google/common/hash/Java8Compatibility.java
+++ b/guava/src/com/google/common/hash/Java8Compatibility.java
@@ -14,14 +14,12 @@
 
 package com.google.common.hash;
 
-import com.google.common.annotations.GwtIncompatible;
 import java.nio.Buffer;
 
 /**
  * Wrappers around {@link Buffer} methods that are covariantly overridden in Java 9+. See
  * https://github.com/google/guava/issues/3990
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 final class Java8Compatibility {
   static void clear(Buffer b) {
diff --git a/guava/src/com/google/common/hash/MacHashFunction.java b/guava/src/com/google/common/hash/MacHashFunction.java
index 031b1c017b..11e9f67b72 100644
--- a/guava/src/com/google/common/hash/MacHashFunction.java
+++ b/guava/src/com/google/common/hash/MacHashFunction.java
@@ -17,7 +17,6 @@ package com.google.common.hash;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 
-import com.google.errorprone.annotations.Immutable;
 import java.nio.ByteBuffer;
 import java.security.InvalidKeyException;
 import java.security.Key;
@@ -29,7 +28,6 @@ import javax.crypto.Mac;
  *
  * @author Kurt Alfred Kluever
  */
-@Immutable
 @ElementTypesAreNonnullByDefault
 final class MacHashFunction extends AbstractHashFunction {
 
diff --git a/guava/src/com/google/common/hash/MessageDigestHashFunction.java b/guava/src/com/google/common/hash/MessageDigestHashFunction.java
index 48b47b0f0b..bb39a4b50d 100644
--- a/guava/src/com/google/common/hash/MessageDigestHashFunction.java
+++ b/guava/src/com/google/common/hash/MessageDigestHashFunction.java
@@ -18,7 +18,6 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 
-import com.google.errorprone.annotations.Immutable;
 import java.io.Serializable;
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
@@ -31,7 +30,6 @@ import java.util.Arrays;
  * @author Kevin Bourrillion
  * @author Dimitris Andreou
  */
-@Immutable
 @ElementTypesAreNonnullByDefault
 final class MessageDigestHashFunction extends AbstractHashFunction implements Serializable {
 
diff --git a/guava/src/com/google/common/hash/Murmur3_128HashFunction.java b/guava/src/com/google/common/hash/Murmur3_128HashFunction.java
index d1304f8273..d0538a69ad 100644
--- a/guava/src/com/google/common/hash/Murmur3_128HashFunction.java
+++ b/guava/src/com/google/common/hash/Murmur3_128HashFunction.java
@@ -27,7 +27,6 @@ package com.google.common.hash;
 
 import static com.google.common.primitives.UnsignedBytes.toInt;
 
-import com.google.errorprone.annotations.Immutable;
 import java.io.Serializable;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
@@ -40,7 +39,6 @@ import javax.annotation.CheckForNull;
  * @author Austin Appleby
  * @author Dimitris Andreou
  */
-@Immutable
 @ElementTypesAreNonnullByDefault
 final class Murmur3_128HashFunction extends AbstractHashFunction implements Serializable {
   static final HashFunction MURMUR3_128 = new Murmur3_128HashFunction(0);
diff --git a/guava/src/com/google/common/hash/Murmur3_32HashFunction.java b/guava/src/com/google/common/hash/Murmur3_32HashFunction.java
index a47184be58..f241e0c128 100644
--- a/guava/src/com/google/common/hash/Murmur3_32HashFunction.java
+++ b/guava/src/com/google/common/hash/Murmur3_32HashFunction.java
@@ -33,8 +33,6 @@ import com.google.common.base.Charsets;
 import com.google.common.primitives.Chars;
 import com.google.common.primitives.Ints;
 import com.google.common.primitives.Longs;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.Immutable;
 import java.io.Serializable;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
@@ -50,7 +48,6 @@ import javax.annotation.CheckForNull;
  * @author Dimitris Andreou
  * @author Kurt Alfred Kluever
  */
-@Immutable
 @ElementTypesAreNonnullByDefault
 final class Murmur3_32HashFunction extends AbstractHashFunction implements Serializable {
   static final HashFunction MURMUR3_32 =
@@ -267,7 +264,6 @@ final class Murmur3_32HashFunction extends AbstractHashFunction implements Seria
     return HashCode.fromInt(h1);
   }
 
-  @CanIgnoreReturnValue
   private static final class Murmur3_32Hasher extends AbstractHasher {
     private int h1;
     private long buffer;
diff --git a/guava/src/com/google/common/hash/ParametricNullness.java b/guava/src/com/google/common/hash/ParametricNullness.java
index 2ae8d4200e..5eb043f306 100644
--- a/guava/src/com/google/common/hash/ParametricNullness.java
+++ b/guava/src/com/google/common/hash/ParametricNullness.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import static javax.annotation.meta.When.UNKNOWN;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -35,7 +34,6 @@ import javax.annotation.meta.TypeQualifierNickname;
  * href="https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/NullFromTypeParam.java">{@code
  * NullFromTypeParam}</a>). We use this to "undo" {@link ElementTypesAreNonnullByDefault}.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target({FIELD, METHOD, PARAMETER})
 @TypeQualifierNickname
diff --git a/guava/src/com/google/common/hash/PrimitiveSink.java b/guava/src/com/google/common/hash/PrimitiveSink.java
index a29ba4e136..c6fe0b779d 100644
--- a/guava/src/com/google/common/hash/PrimitiveSink.java
+++ b/guava/src/com/google/common/hash/PrimitiveSink.java
@@ -14,8 +14,6 @@
 
 package com.google.common.hash;
 
-import com.google.common.annotations.Beta;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
 
@@ -25,8 +23,6 @@ import java.nio.charset.Charset;
  * @author Kevin Bourrillion
  * @since 12.0 (in 11.0 as {@code Sink})
  */
-@Beta
-@CanIgnoreReturnValue
 @ElementTypesAreNonnullByDefault
 public interface PrimitiveSink {
   /**
diff --git a/guava/src/com/google/common/hash/SipHashFunction.java b/guava/src/com/google/common/hash/SipHashFunction.java
index a226b61a50..0e67e979eb 100644
--- a/guava/src/com/google/common/hash/SipHashFunction.java
+++ b/guava/src/com/google/common/hash/SipHashFunction.java
@@ -21,7 +21,6 @@ package com.google.common.hash;
 
 import static com.google.common.base.Preconditions.checkArgument;
 
-import com.google.errorprone.annotations.Immutable;
 import java.io.Serializable;
 import java.nio.ByteBuffer;
 import javax.annotation.CheckForNull;
@@ -33,7 +32,6 @@ import javax.annotation.CheckForNull;
  * @author Jean-Philippe Aumasson
  * @author Daniel J. Bernstein
  */
-@Immutable
 @ElementTypesAreNonnullByDefault
 final class SipHashFunction extends AbstractHashFunction implements Serializable {
   static final HashFunction SIP_HASH_24 =
diff --git a/guava/src/com/google/common/hash/Striped64.java b/guava/src/com/google/common/hash/Striped64.java
index 1a0671c9d7..0433fa140f 100644
--- a/guava/src/com/google/common/hash/Striped64.java
+++ b/guava/src/com/google/common/hash/Striped64.java
@@ -11,17 +11,14 @@
 
 package com.google.common.hash;
 
-import com.google.common.annotations.GwtIncompatible;
 import java.util.Random;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A package-local class holding common representation and mechanics for classes supporting dynamic
  * striping on 64bit values. The class extends Number so that concrete subclasses must publicly do
  * so.
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 abstract class Striped64 extends Number {
   /*
@@ -127,7 +124,7 @@ abstract class Striped64 extends Number {
    * class, we use a suboptimal int[] representation to avoid introducing a new type that can impede
    * class-unloading when ThreadLocals are not removed.
    */
-  static final ThreadLocal<int @Nullable []> threadHashCode = new ThreadLocal<>();
+  static final ThreadLocal<int []> threadHashCode = new ThreadLocal<>();
 
   /** Generator of new random hash codes */
   static final Random rng = new Random();
diff --git a/guava/src/com/google/common/hash/package-info.java b/guava/src/com/google/common/hash/package-info.java
index d210f7ef7b..310d297a2c 100644
--- a/guava/src/com/google/common/hash/package-info.java
+++ b/guava/src/com/google/common/hash/package-info.java
@@ -19,9 +19,7 @@
  * <p>See the Guava User Guide article on <a
  * href="https://github.com/google/guava/wiki/HashingExplained">hashing</a>.
  */
-@CheckReturnValue
 @ParametersAreNonnullByDefault
 package com.google.common.hash;
 
-import com.google.errorprone.annotations.CheckReturnValue;
 import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/guava/src/com/google/common/html/ElementTypesAreNonnullByDefault.java b/guava/src/com/google/common/html/ElementTypesAreNonnullByDefault.java
index a28b716632..bd1d1c089f 100644
--- a/guava/src/com/google/common/html/ElementTypesAreNonnullByDefault.java
+++ b/guava/src/com/google/common/html/ElementTypesAreNonnullByDefault.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.ElementType.TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -33,7 +32,6 @@ import javax.annotation.meta.TypeQualifierDefault;
  * unfortunately includes type-variable usages, so we also provide {@link ParametricNullness} to
  * "undo" it as best we can.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target(TYPE)
 @TypeQualifierDefault({FIELD, METHOD, PARAMETER})
diff --git a/guava/src/com/google/common/html/HtmlEscapers.java b/guava/src/com/google/common/html/HtmlEscapers.java
index c426388715..adb4ea20b2 100644
--- a/guava/src/com/google/common/html/HtmlEscapers.java
+++ b/guava/src/com/google/common/html/HtmlEscapers.java
@@ -14,7 +14,6 @@
 
 package com.google.common.html;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.escape.Escaper;
 import com.google.common.escape.Escapers;
 
@@ -34,7 +33,6 @@ import com.google.common.escape.Escapers;
  * @author David Beaumont
  * @since 15.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class HtmlEscapers {
   /**
diff --git a/guava/src/com/google/common/html/ParametricNullness.java b/guava/src/com/google/common/html/ParametricNullness.java
index 9a62c35bac..db63beb1ce 100644
--- a/guava/src/com/google/common/html/ParametricNullness.java
+++ b/guava/src/com/google/common/html/ParametricNullness.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import static javax.annotation.meta.When.UNKNOWN;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -35,7 +34,6 @@ import javax.annotation.meta.TypeQualifierNickname;
  * href="https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/NullFromTypeParam.java">{@code
  * NullFromTypeParam}</a>). We use this to "undo" {@link ElementTypesAreNonnullByDefault}.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target({FIELD, METHOD, PARAMETER})
 @TypeQualifierNickname
diff --git a/guava/src/com/google/common/html/package-info.java b/guava/src/com/google/common/html/package-info.java
index f84d7f23d0..da133f216d 100644
--- a/guava/src/com/google/common/html/package-info.java
+++ b/guava/src/com/google/common/html/package-info.java
@@ -20,9 +20,7 @@
  * <p>This package is a part of the open-source <a href="http://github.com/google/guava">Guava</a>
  * library.
  */
-@CheckReturnValue
 @ParametersAreNonnullByDefault
 package com.google.common.html;
 
-import com.google.errorprone.annotations.CheckReturnValue;
 import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/guava/src/com/google/common/io/AppendableWriter.java b/guava/src/com/google/common/io/AppendableWriter.java
index d9aab342f2..906d8e6249 100644
--- a/guava/src/com/google/common/io/AppendableWriter.java
+++ b/guava/src/com/google/common/io/AppendableWriter.java
@@ -16,7 +16,6 @@ package com.google.common.io;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtIncompatible;
 import java.io.Closeable;
 import java.io.Flushable;
 import java.io.IOException;
@@ -31,7 +30,6 @@ import javax.annotation.CheckForNull;
  * @author Sebastian Kanthak
  * @since 1.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 class AppendableWriter extends Writer {
   private final Appendable target;
diff --git a/guava/src/com/google/common/io/BaseEncoding.java b/guava/src/com/google/common/io/BaseEncoding.java
index f42857c355..bfffbc285c 100644
--- a/guava/src/com/google/common/io/BaseEncoding.java
+++ b/guava/src/com/google/common/io/BaseEncoding.java
@@ -24,11 +24,8 @@ import static java.math.RoundingMode.CEILING;
 import static java.math.RoundingMode.FLOOR;
 import static java.math.RoundingMode.UNNECESSARY;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Ascii;
 import com.google.common.base.Objects;
-import com.google.errorprone.annotations.concurrent.LazyInit;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -121,7 +118,6 @@ import javax.annotation.CheckForNull;
  * @author Louis Wasserman
  * @since 14.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public abstract class BaseEncoding {
   // TODO(lowasser): consider making encodeTo(Appendable, byte[], int, int) public.
@@ -169,13 +165,13 @@ public abstract class BaseEncoding {
    * {@code Writer}. When the returned {@code OutputStream} is closed, so is the backing {@code
    * Writer}.
    */
-  @GwtIncompatible // Writer,OutputStream
+  // Writer,OutputStream
   public abstract OutputStream encodingStream(Writer writer);
 
   /**
    * Returns a {@code ByteSink} that writes base-encoded bytes to the specified {@code CharSink}.
    */
-  @GwtIncompatible // ByteSink,CharSink
+  // ByteSink,CharSink
   public final ByteSink encodingSink(final CharSink encodedSink) {
     checkNotNull(encodedSink);
     return new ByteSink() {
@@ -239,14 +235,14 @@ public abstract class BaseEncoding {
    * Returns an {@code InputStream} that decodes base-encoded input from the specified {@code
    * Reader}. The returned stream throws a {@link DecodingException} upon decoding-specific errors.
    */
-  @GwtIncompatible // Reader,InputStream
+  // Reader,InputStream
   public abstract InputStream decodingStream(Reader reader);
 
   /**
    * Returns a {@code ByteSource} that reads base-encoded bytes from the specified {@code
    * CharSource}.
    */
-  @GwtIncompatible // ByteSource,CharSource
+  // ByteSource,CharSource
   public final ByteSource decodingSource(final CharSource encodedSource) {
     checkNotNull(encodedSource);
     return new ByteSource() {
@@ -586,7 +582,7 @@ public abstract class BaseEncoding {
       return alphabet.charsPerChunk * divide(bytes, alphabet.bytesPerChunk, CEILING);
     }
 
-    @GwtIncompatible // Writer,OutputStream
+    // Writer,OutputStream
     @Override
     public OutputStream encodingStream(final Writer out) {
       checkNotNull(out);
@@ -727,7 +723,7 @@ public abstract class BaseEncoding {
     }
 
     @Override
-    @GwtIncompatible // Reader,InputStream
+    // Reader,InputStream
     public InputStream decodingStream(final Reader reader) {
       checkNotNull(reader);
       return new InputStream() {
@@ -830,8 +826,8 @@ public abstract class BaseEncoding {
       return new SeparatedBaseEncoding(this, separator, afterEveryChars);
     }
 
-    @LazyInit @CheckForNull private transient BaseEncoding upperCase;
-    @LazyInit @CheckForNull private transient BaseEncoding lowerCase;
+    @CheckForNull private transient BaseEncoding upperCase;
+    @CheckForNull private transient BaseEncoding lowerCase;
 
     @Override
     public BaseEncoding upperCase() {
@@ -991,7 +987,6 @@ public abstract class BaseEncoding {
     }
   }
 
-  @GwtIncompatible
   static Reader ignoringReader(final Reader delegate, final String toIgnore) {
     checkNotNull(delegate);
     checkNotNull(toIgnore);
@@ -1048,7 +1043,7 @@ public abstract class BaseEncoding {
     };
   }
 
-  @GwtIncompatible // Writer
+  // Writer
   static Writer separatingWriter(
       final Writer delegate, final String separator, final int afterEveryChars) {
     final Appendable separatingAppendable =
@@ -1101,7 +1096,7 @@ public abstract class BaseEncoding {
           + separator.length() * divide(Math.max(0, unseparatedSize - 1), afterEveryChars, FLOOR);
     }
 
-    @GwtIncompatible // Writer,OutputStream
+    // Writer,OutputStream
     @Override
     public OutputStream encodingStream(final Writer output) {
       return delegate.encodingStream(separatingWriter(output, separator, afterEveryChars));
@@ -1142,7 +1137,7 @@ public abstract class BaseEncoding {
     }
 
     @Override
-    @GwtIncompatible // Reader,InputStream
+    // Reader,InputStream
     public InputStream decodingStream(final Reader reader) {
       return delegate.decodingStream(ignoringReader(reader, separator));
     }
diff --git a/guava/src/com/google/common/io/ByteArrayDataInput.java b/guava/src/com/google/common/io/ByteArrayDataInput.java
index cf84fcc136..8d48c24787 100644
--- a/guava/src/com/google/common/io/ByteArrayDataInput.java
+++ b/guava/src/com/google/common/io/ByteArrayDataInput.java
@@ -14,8 +14,6 @@
 
 package com.google.common.io;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.DataInput;
 import java.io.IOException;
 import javax.annotation.CheckForNull;
@@ -32,7 +30,6 @@ import javax.annotation.CheckForNull;
  * @author Kevin Bourrillion
  * @since 1.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public interface ByteArrayDataInput extends DataInput {
   @Override
@@ -46,52 +43,52 @@ public interface ByteArrayDataInput extends DataInput {
   @Override
   int skipBytes(int n);
 
-  @CanIgnoreReturnValue // to skip a byte
+  // to skip a byte
   @Override
   boolean readBoolean();
 
-  @CanIgnoreReturnValue // to skip a byte
+  // to skip a byte
   @Override
   byte readByte();
 
-  @CanIgnoreReturnValue // to skip a byte
+  // to skip a byte
   @Override
   int readUnsignedByte();
 
-  @CanIgnoreReturnValue // to skip some bytes
+  // to skip some bytes
   @Override
   short readShort();
 
-  @CanIgnoreReturnValue // to skip some bytes
+  // to skip some bytes
   @Override
   int readUnsignedShort();
 
-  @CanIgnoreReturnValue // to skip some bytes
+  // to skip some bytes
   @Override
   char readChar();
 
-  @CanIgnoreReturnValue // to skip some bytes
+  // to skip some bytes
   @Override
   int readInt();
 
-  @CanIgnoreReturnValue // to skip some bytes
+  // to skip some bytes
   @Override
   long readLong();
 
-  @CanIgnoreReturnValue // to skip some bytes
+  // to skip some bytes
   @Override
   float readFloat();
 
-  @CanIgnoreReturnValue // to skip some bytes
+  // to skip some bytes
   @Override
   double readDouble();
 
-  @CanIgnoreReturnValue // to skip a line
+  // to skip a line
   @Override
   @CheckForNull
   String readLine();
 
-  @CanIgnoreReturnValue // to skip a field
+  // to skip a field
   @Override
   String readUTF();
 }
diff --git a/guava/src/com/google/common/io/ByteArrayDataOutput.java b/guava/src/com/google/common/io/ByteArrayDataOutput.java
index 373907361d..b6ae62be4a 100644
--- a/guava/src/com/google/common/io/ByteArrayDataOutput.java
+++ b/guava/src/com/google/common/io/ByteArrayDataOutput.java
@@ -14,7 +14,6 @@
 
 package com.google.common.io;
 
-import com.google.common.annotations.GwtIncompatible;
 import java.io.DataOutput;
 import java.io.IOException;
 
@@ -25,7 +24,6 @@ import java.io.IOException;
  * @author Jayaprabhakar Kadarkarai
  * @since 1.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public interface ByteArrayDataOutput extends DataOutput {
   @Override
diff --git a/guava/src/com/google/common/io/ByteProcessor.java b/guava/src/com/google/common/io/ByteProcessor.java
index 98ea3ffbb2..bad1da6134 100644
--- a/guava/src/com/google/common/io/ByteProcessor.java
+++ b/guava/src/com/google/common/io/ByteProcessor.java
@@ -14,12 +14,7 @@
 
 package com.google.common.io;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotMock;
 import java.io.IOException;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A callback interface to process bytes from a stream.
@@ -30,11 +25,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Chris Nokleberg
  * @since 1.0
  */
-@Beta
-@DoNotMock("Implement it normally")
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
-public interface ByteProcessor<T extends @Nullable Object> {
+public interface ByteProcessor<T extends Object> {
   /**
    * This method will be called for each chunk of bytes in an input stream. The implementation
    * should process the bytes from {@code buf[off]} through {@code buf[off + len - 1]} (inclusive).
@@ -44,7 +36,7 @@ public interface ByteProcessor<T extends @Nullable Object> {
    * @param len the length of data to be processed
    * @return true to continue processing, false to stop
    */
-  @CanIgnoreReturnValue // some uses know that their processor never returns false
+  // some uses know that their processor never returns false
   boolean processBytes(byte[] buf, int off, int len) throws IOException;
 
   /** Return the result of processing all the bytes. */
diff --git a/guava/src/com/google/common/io/ByteSink.java b/guava/src/com/google/common/io/ByteSink.java
index 7a6af6fc58..d54408d6cb 100644
--- a/guava/src/com/google/common/io/ByteSink.java
+++ b/guava/src/com/google/common/io/ByteSink.java
@@ -16,8 +16,6 @@ package com.google.common.io;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.BufferedOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -45,7 +43,6 @@ import java.nio.charset.Charset;
  * @since 14.0
  * @author Colin Decker
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public abstract class ByteSink {
 
@@ -116,7 +113,6 @@ public abstract class ByteSink {
    * @return the number of bytes written
    * @throws IOException if an I/O occurs while reading from {@code input} or writing to this sink
    */
-  @CanIgnoreReturnValue
   public long writeFrom(InputStream input) throws IOException {
     checkNotNull(input);
 
diff --git a/guava/src/com/google/common/io/ByteSource.java b/guava/src/com/google/common/io/ByteSource.java
index c8da9678b8..4c5bd6223d 100644
--- a/guava/src/com/google/common/io/ByteSource.java
+++ b/guava/src/com/google/common/io/ByteSource.java
@@ -19,8 +19,6 @@ import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.io.ByteStreams.createBuffer;
 import static com.google.common.io.ByteStreams.skipUpTo;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Ascii;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
@@ -28,7 +26,6 @@ import com.google.common.hash.Funnels;
 import com.google.common.hash.HashCode;
 import com.google.common.hash.HashFunction;
 import com.google.common.hash.Hasher;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.BufferedInputStream;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
@@ -40,7 +37,6 @@ import java.nio.charset.Charset;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Iterator;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A readable source of bytes, such as a file. Unlike an {@link InputStream}, a {@code ByteSource}
@@ -73,7 +69,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @since 14.0
  * @author Colin Decker
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public abstract class ByteSource {
 
@@ -178,7 +173,6 @@ public abstract class ByteSource {
    *
    * @since 19.0
    */
-  @Beta
   public Optional<Long> sizeIfKnown() {
     return Optional.absent();
   }
@@ -247,7 +241,6 @@ public abstract class ByteSource {
    * @throws IOException if an I/O error occurs while reading from this source or writing to {@code
    *     output}
    */
-  @CanIgnoreReturnValue
   public long copyTo(OutputStream output) throws IOException {
     checkNotNull(output);
 
@@ -269,7 +262,6 @@ public abstract class ByteSource {
    * @throws IOException if an I/O error occurs while reading from this source or writing to {@code
    *     sink}
    */
-  @CanIgnoreReturnValue
   public long copyTo(ByteSink sink) throws IOException {
     checkNotNull(sink);
 
@@ -314,9 +306,8 @@ public abstract class ByteSource {
    *     processor} throws an {@code IOException}
    * @since 16.0
    */
-  @Beta
-  @CanIgnoreReturnValue // some processors won't return a useful result
-  public <T extends @Nullable Object> T read(ByteProcessor<T> processor) throws IOException {
+  // some processors won't return a useful result
+  public <T extends Object> T read(ByteProcessor<T> processor) throws IOException {
     checkNotNull(processor);
 
     Closer closer = Closer.create();
@@ -621,7 +612,7 @@ public abstract class ByteSource {
     @SuppressWarnings("CheckReturnValue") // it doesn't matter what processBytes returns here
     @Override
     @ParametricNullness
-    public <T extends @Nullable Object> T read(ByteProcessor<T> processor) throws IOException {
+    public <T extends Object> T read(ByteProcessor<T> processor) throws IOException {
       processor.processBytes(bytes, offset, length);
       return processor.getResult();
     }
diff --git a/guava/src/com/google/common/io/ByteStreams.java b/guava/src/com/google/common/io/ByteStreams.java
index 2f1f6690ee..5cf933d3aa 100644
--- a/guava/src/com/google/common/io/ByteStreams.java
+++ b/guava/src/com/google/common/io/ByteStreams.java
@@ -19,10 +19,7 @@ import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndex;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.math.IntMath;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.DataInput;
@@ -42,7 +39,6 @@ import java.util.ArrayDeque;
 import java.util.Arrays;
 import java.util.Queue;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Provides utility methods for working with byte arrays and I/O streams.
@@ -51,7 +47,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Colin Decker
  * @since 1.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class ByteStreams {
 
@@ -102,7 +97,6 @@ public final class ByteStreams {
    * @return the number of bytes copied
    * @throws IOException if an I/O error occurs
    */
-  @CanIgnoreReturnValue
   public static long copy(InputStream from, OutputStream to) throws IOException {
     checkNotNull(from);
     checkNotNull(to);
@@ -128,7 +122,6 @@ public final class ByteStreams {
    * @return the number of bytes copied
    * @throws IOException if an I/O error occurs
    */
-  @CanIgnoreReturnValue
   public static long copy(ReadableByteChannel from, WritableByteChannel to) throws IOException {
     checkNotNull(from);
     checkNotNull(to);
@@ -268,8 +261,6 @@ public final class ByteStreams {
    *
    * @since 20.0
    */
-  @CanIgnoreReturnValue
-  @Beta
   public static long exhaust(InputStream in) throws IOException {
     long total = 0;
     long read;
@@ -284,7 +275,6 @@ public final class ByteStreams {
    * Returns a new {@link ByteArrayDataInput} instance to read from the {@code bytes} array from the
    * beginning.
    */
-  @Beta
   public static ByteArrayDataInput newDataInput(byte[] bytes) {
     return newDataInput(new ByteArrayInputStream(bytes));
   }
@@ -296,7 +286,6 @@ public final class ByteStreams {
    * @throws IndexOutOfBoundsException if {@code start} is negative or greater than the length of
    *     the array
    */
-  @Beta
   public static ByteArrayDataInput newDataInput(byte[] bytes, int start) {
     checkPositionIndex(start, bytes.length);
     return newDataInput(new ByteArrayInputStream(bytes, start, bytes.length - start));
@@ -309,7 +298,6 @@ public final class ByteStreams {
    *
    * @since 17.0
    */
-  @Beta
   public static ByteArrayDataInput newDataInput(ByteArrayInputStream byteArrayInputStream) {
     return new ByteArrayDataInputStream(checkNotNull(byteArrayInputStream));
   }
@@ -461,7 +449,6 @@ public final class ByteStreams {
   }
 
   /** Returns a new {@link ByteArrayDataOutput} instance with a default size. */
-  @Beta
   public static ByteArrayDataOutput newDataOutput() {
     return newDataOutput(new ByteArrayOutputStream());
   }
@@ -472,7 +459,6 @@ public final class ByteStreams {
    *
    * @throws IllegalArgumentException if {@code size} is negative
    */
-  @Beta
   public static ByteArrayDataOutput newDataOutput(int size) {
     // When called at high frequency, boxing size generates too much garbage,
     // so avoid doing that if we can.
@@ -494,7 +480,6 @@ public final class ByteStreams {
    *
    * @since 17.0
    */
-  @Beta
   public static ByteArrayDataOutput newDataOutput(ByteArrayOutputStream byteArrayOutputStream) {
     return new ByteArrayDataOutputStream(checkNotNull(byteArrayOutputStream));
   }
@@ -670,7 +655,6 @@ public final class ByteStreams {
    *
    * @since 14.0 (since 1.0 as com.google.common.io.NullOutputStream)
    */
-  @Beta
   public static OutputStream nullOutputStream() {
     return NULL_OUTPUT_STREAM;
   }
@@ -683,7 +667,6 @@ public final class ByteStreams {
    * @return a length-limited {@link InputStream}
    * @since 14.0 (since 1.0 as com.google.common.io.LimitInputStream)
    */
-  @Beta
   public static InputStream limit(InputStream in, long limit) {
     return new LimitedInputStream(in, limit);
   }
@@ -770,7 +753,6 @@ public final class ByteStreams {
    * @throws EOFException if this stream reaches the end before reading all the bytes.
    * @throws IOException if an I/O error occurs.
    */
-  @Beta
   public static void readFully(InputStream in, byte[] b) throws IOException {
     readFully(in, b, 0, b.length);
   }
@@ -787,7 +769,6 @@ public final class ByteStreams {
    * @throws EOFException if this stream reaches the end before reading all the bytes.
    * @throws IOException if an I/O error occurs.
    */
-  @Beta
   public static void readFully(InputStream in, byte[] b, int off, int len) throws IOException {
     int read = read(in, b, off, len);
     if (read != len) {
@@ -805,7 +786,6 @@ public final class ByteStreams {
    * @throws EOFException if this stream reaches the end before skipping all the bytes
    * @throws IOException if an I/O error occurs, or the stream does not support skipping
    */
-  @Beta
   public static void skipFully(InputStream in, long n) throws IOException {
     long skipped = skipUpTo(in, n);
     if (skipped < n) {
@@ -871,10 +851,9 @@ public final class ByteStreams {
    * @throws IOException if an I/O error occurs
    * @since 14.0
    */
-  @Beta
-  @CanIgnoreReturnValue // some processors won't return a useful result
+  // some processors won't return a useful result
   @ParametricNullness
-  public static <T extends @Nullable Object> T readBytes(
+  public static <T extends Object> T readBytes(
       InputStream input, ByteProcessor<T> processor) throws IOException {
     checkNotNull(input);
     checkNotNull(processor);
@@ -911,8 +890,6 @@ public final class ByteStreams {
    * @throws IndexOutOfBoundsException if {@code off} is negative, if {@code len} is negative, or if
    *     {@code off + len} is greater than {@code b.length}
    */
-  @Beta
-  @CanIgnoreReturnValue
   // Sometimes you don't care how many bytes you actually read, I guess.
   // (You know that it's either going to read len bytes or stop at EOF.)
   public static int read(InputStream in, byte[] b, int off, int len) throws IOException {
diff --git a/guava/src/com/google/common/io/CharSequenceReader.java b/guava/src/com/google/common/io/CharSequenceReader.java
index 790e266236..47cfbc83df 100644
--- a/guava/src/com/google/common/io/CharSequenceReader.java
+++ b/guava/src/com/google/common/io/CharSequenceReader.java
@@ -19,7 +19,6 @@ import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.GwtIncompatible;
 import java.io.IOException;
 import java.io.Reader;
 import java.nio.CharBuffer;
@@ -32,7 +31,6 @@ import javax.annotation.CheckForNull;
  * @author Colin Decker
  */
 // TODO(cgdecker): make this public? as a type, or a method in CharStreams?
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 final class CharSequenceReader extends Reader {
 
diff --git a/guava/src/com/google/common/io/CharSink.java b/guava/src/com/google/common/io/CharSink.java
index f804daeb7a..e50b7f2c6f 100644
--- a/guava/src/com/google/common/io/CharSink.java
+++ b/guava/src/com/google/common/io/CharSink.java
@@ -16,9 +16,6 @@ package com.google.common.io;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.BufferedWriter;
 import java.io.IOException;
 import java.io.Reader;
@@ -50,7 +47,6 @@ import java.util.stream.Stream;
  * @since 14.0
  * @author Colin Decker
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public abstract class CharSink {
 
@@ -135,7 +131,6 @@ public abstract class CharSink {
    * @throws IOException if an I/O error occurs while writing to this sink
    * @since 22.0
    */
-  @Beta
   public void writeLines(Stream<? extends CharSequence> lines) throws IOException {
     writeLines(lines, System.getProperty("line.separator"));
   }
@@ -147,7 +142,6 @@ public abstract class CharSink {
    * @throws IOException if an I/O error occurs while writing to this sink
    * @since 22.0
    */
-  @Beta
   public void writeLines(Stream<? extends CharSequence> lines, String lineSeparator)
       throws IOException {
     writeLines(lines.iterator(), lineSeparator);
@@ -172,7 +166,6 @@ public abstract class CharSink {
    * @throws IOException if an I/O error occurs while reading from {@code readable} or writing to
    *     this sink
    */
-  @CanIgnoreReturnValue
   public long writeFrom(Readable readable) throws IOException {
     checkNotNull(readable);
 
diff --git a/guava/src/com/google/common/io/CharSource.java b/guava/src/com/google/common/io/CharSource.java
index 24a67af5c6..432ee70c5f 100644
--- a/guava/src/com/google/common/io/CharSource.java
+++ b/guava/src/com/google/common/io/CharSource.java
@@ -16,8 +16,6 @@ package com.google.common.io;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Ascii;
 import com.google.common.base.Optional;
 import com.google.common.base.Splitter;
@@ -25,8 +23,6 @@ import com.google.common.collect.AbstractIterator;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Streams;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.MustBeClosed;
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStream;
@@ -40,7 +36,6 @@ import java.util.List;
 import java.util.function.Consumer;
 import java.util.stream.Stream;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A readable source of characters, such as a text file. Unlike a {@link Reader}, a {@code
@@ -81,7 +76,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @since 14.0
  * @author Colin Decker
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public abstract class CharSource {
 
@@ -99,7 +93,6 @@ public abstract class CharSource {
    *
    * @since 20.0
    */
-  @Beta
   public ByteSource asByteSource(Charset charset) {
     return new AsByteSource(charset);
   }
@@ -155,8 +148,6 @@ public abstract class CharSource {
    * @throws IOException if an I/O error occurs while opening the stream
    * @since 22.0
    */
-  @Beta
-  @MustBeClosed
   public Stream<String> lines() throws IOException {
     BufferedReader reader = openBufferedStream();
     return reader
@@ -185,7 +176,6 @@ public abstract class CharSource {
    *
    * @since 19.0
    */
-  @Beta
   public Optional<Long> lengthIfKnown() {
     return Optional.absent();
   }
@@ -209,7 +199,6 @@ public abstract class CharSource {
    * @throws IOException if an I/O error occurs while reading the length of this source
    * @since 19.0
    */
-  @Beta
   public long length() throws IOException {
     Optional<Long> lengthIfKnown = lengthIfKnown();
     if (lengthIfKnown.isPresent()) {
@@ -244,7 +233,6 @@ public abstract class CharSource {
    * @throws IOException if an I/O error occurs while reading from this source or writing to {@code
    *     appendable}
    */
-  @CanIgnoreReturnValue
   public long copyTo(Appendable appendable) throws IOException {
     checkNotNull(appendable);
 
@@ -266,7 +254,6 @@ public abstract class CharSource {
    * @throws IOException if an I/O error occurs while reading from this source or writing to {@code
    *     sink}
    */
-  @CanIgnoreReturnValue
   public long copyTo(CharSink sink) throws IOException {
     checkNotNull(sink);
 
@@ -364,10 +351,9 @@ public abstract class CharSource {
    *     processor} throws an {@code IOException}
    * @since 16.0
    */
-  @Beta
-  @CanIgnoreReturnValue // some processors won't return a useful result
+  // some processors won't return a useful result
   @ParametricNullness
-  public <T extends @Nullable Object> T readLines(LineProcessor<T> processor) throws IOException {
+  public <T extends Object> T readLines(LineProcessor<T> processor) throws IOException {
     checkNotNull(processor);
 
     Closer closer = Closer.create();
@@ -394,7 +380,6 @@ public abstract class CharSource {
    *     throws an {@code UncheckedIOException}
    * @since 22.0
    */
-  @Beta
   public void forEachLine(Consumer<? super String> action) throws IOException {
     try (Stream<String> lines = lines()) {
       // The lines should be ordered regardless in most cases, but use forEachOrdered to be sure
@@ -612,7 +597,7 @@ public abstract class CharSource {
 
     @Override
     @ParametricNullness
-    public <T extends @Nullable Object> T readLines(LineProcessor<T> processor) throws IOException {
+    public <T extends Object> T readLines(LineProcessor<T> processor) throws IOException {
       Iterator<String> lines = linesIterator();
       while (lines.hasNext()) {
         if (!processor.processLine(lines.next())) {
diff --git a/guava/src/com/google/common/io/CharStreams.java b/guava/src/com/google/common/io/CharStreams.java
index c414194236..15bcab9133 100644
--- a/guava/src/com/google/common/io/CharStreams.java
+++ b/guava/src/com/google/common/io/CharStreams.java
@@ -17,9 +17,6 @@ package com.google.common.io;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.Closeable;
 import java.io.EOFException;
 import java.io.IOException;
@@ -29,7 +26,6 @@ import java.nio.CharBuffer;
 import java.util.ArrayList;
 import java.util.List;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Provides utility methods for working with character streams.
@@ -45,7 +41,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Colin Decker
  * @since 1.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class CharStreams {
 
@@ -68,7 +63,6 @@ public final class CharStreams {
    * @return the number of characters copied
    * @throws IOException if an I/O error occurs
    */
-  @CanIgnoreReturnValue
   public static long copy(Readable from, Appendable to) throws IOException {
     // The most common case is that from is a Reader (like InputStreamReader or StringReader) so
     // take advantage of that.
@@ -112,7 +106,6 @@ public final class CharStreams {
    * @return the number of characters copied
    * @throws IOException if an I/O error occurs
    */
-  @CanIgnoreReturnValue
   static long copyReaderToBuilder(Reader from, StringBuilder to) throws IOException {
     checkNotNull(from);
     checkNotNull(to);
@@ -140,7 +133,6 @@ public final class CharStreams {
    * @return the number of characters copied
    * @throws IOException if an I/O error occurs
    */
-  @CanIgnoreReturnValue
   static long copyReaderToWriter(Reader from, Writer to) throws IOException {
     checkNotNull(from);
     checkNotNull(to);
@@ -195,7 +187,6 @@ public final class CharStreams {
    * @return a mutable {@link List} containing all the lines
    * @throws IOException if an I/O error occurs
    */
-  @Beta
   public static List<String> readLines(Readable r) throws IOException {
     List<String> result = new ArrayList<>();
     LineReader lineReader = new LineReader(r);
@@ -215,10 +206,9 @@ public final class CharStreams {
    * @throws IOException if an I/O error occurs
    * @since 14.0
    */
-  @Beta
-  @CanIgnoreReturnValue // some processors won't return a useful result
+  // some processors won't return a useful result
   @ParametricNullness
-  public static <T extends @Nullable Object> T readLines(
+  public static <T extends Object> T readLines(
       Readable readable, LineProcessor<T> processor) throws IOException {
     checkNotNull(readable);
     checkNotNull(processor);
@@ -239,8 +229,6 @@ public final class CharStreams {
    *
    * @since 20.0
    */
-  @Beta
-  @CanIgnoreReturnValue
   public static long exhaust(Readable readable) throws IOException {
     long total = 0;
     long read;
@@ -261,7 +249,6 @@ public final class CharStreams {
    * @throws EOFException if this stream reaches the end before skipping all the characters
    * @throws IOException if an I/O error occurs
    */
-  @Beta
   public static void skipFully(Reader reader, long n) throws IOException {
     checkNotNull(reader);
     while (n > 0) {
@@ -278,7 +265,6 @@ public final class CharStreams {
    *
    * @since 15.0
    */
-  @Beta
   public static Writer nullWriter() {
     return NullWriter.INSTANCE;
   }
@@ -346,7 +332,6 @@ public final class CharStreams {
    * @param target the object to which output will be sent
    * @return a new Writer object, unless target is a Writer, in which case the target is returned
    */
-  @Beta
   public static Writer asWriter(Appendable target) {
     if (target instanceof Writer) {
       return (Writer) target;
diff --git a/guava/src/com/google/common/io/Closeables.java b/guava/src/com/google/common/io/Closeables.java
index b45f5f0fde..231f1644b6 100644
--- a/guava/src/com/google/common/io/Closeables.java
+++ b/guava/src/com/google/common/io/Closeables.java
@@ -14,9 +14,6 @@
 
 package com.google.common.io;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
@@ -31,11 +28,9 @@ import javax.annotation.CheckForNull;
  * @author Michael Lancaster
  * @since 1.0
  */
-@Beta
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class Closeables {
-  @VisibleForTesting static final Logger logger = Logger.getLogger(Closeables.class.getName());
+  static final Logger logger = Logger.getLogger(Closeables.class.getName());
 
   private Closeables() {}
 
diff --git a/guava/src/com/google/common/io/Closer.java b/guava/src/com/google/common/io/Closer.java
index 12998eff95..c1bb9c3716 100644
--- a/guava/src/com/google/common/io/Closer.java
+++ b/guava/src/com/google/common/io/Closer.java
@@ -16,11 +16,7 @@ package com.google.common.io;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Throwables;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.Closeable;
 import java.io.IOException;
 import java.lang.reflect.Method;
@@ -28,7 +24,6 @@ import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.logging.Level;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link Closeable} that collects {@code Closeable} resources and closes them all when it is
@@ -87,8 +82,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @since 14.0
  */
 // Coffee's for {@link Closer closers} only.
-@Beta
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class Closer implements Closeable {
 
@@ -105,13 +98,12 @@ public final class Closer implements Closeable {
     return new Closer(SUPPRESSOR);
   }
 
-  @VisibleForTesting final Suppressor suppressor;
+  final Suppressor suppressor;
 
   // only need space for 2 elements in most cases, so try to use the smallest array possible
   private final Deque<Closeable> stack = new ArrayDeque<>(4);
   @CheckForNull private Throwable thrown;
 
-  @VisibleForTesting
   Closer(Suppressor suppressor) {
     this.suppressor = checkNotNull(suppressor); // checkNotNull to satisfy null tests
   }
@@ -123,9 +115,8 @@ public final class Closer implements Closeable {
    * @return the given {@code closeable}
    */
   // close. this word no longer has any meaning to me.
-  @CanIgnoreReturnValue
   @ParametricNullness
-  public <C extends @Nullable Closeable> C register(@ParametricNullness C closeable) {
+  public <C extends Closeable> C register(@ParametricNullness C closeable) {
     if (closeable != null) {
       stack.addFirst(closeable);
     }
@@ -232,7 +223,6 @@ public final class Closer implements Closeable {
   }
 
   /** Suppression strategy interface. */
-  @VisibleForTesting
   interface Suppressor {
     /**
      * Suppresses the given exception ({@code suppressed}) which was thrown when attempting to close
@@ -243,7 +233,6 @@ public final class Closer implements Closeable {
   }
 
   /** Suppresses exceptions by logging them. */
-  @VisibleForTesting
   static final class LoggingSuppressor implements Suppressor {
 
     static final LoggingSuppressor INSTANCE = new LoggingSuppressor();
@@ -260,7 +249,6 @@ public final class Closer implements Closeable {
    * Suppresses exceptions by adding them to the exception that will be thrown using JDK7's
    * addSuppressed(Throwable) mechanism.
    */
-  @VisibleForTesting
   static final class SuppressingSuppressor implements Suppressor {
     @CheckForNull
     static SuppressingSuppressor tryCreate() {
diff --git a/guava/src/com/google/common/io/CountingInputStream.java b/guava/src/com/google/common/io/CountingInputStream.java
index a37807ae73..76c4c31a6c 100644
--- a/guava/src/com/google/common/io/CountingInputStream.java
+++ b/guava/src/com/google/common/io/CountingInputStream.java
@@ -16,8 +16,6 @@ package com.google.common.io;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -28,8 +26,6 @@ import java.io.InputStream;
  * @author Chris Nokleberg
  * @since 1.0
  */
-@Beta
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class CountingInputStream extends FilterInputStream {
 
diff --git a/guava/src/com/google/common/io/CountingOutputStream.java b/guava/src/com/google/common/io/CountingOutputStream.java
index cf62b9c377..270891e443 100644
--- a/guava/src/com/google/common/io/CountingOutputStream.java
+++ b/guava/src/com/google/common/io/CountingOutputStream.java
@@ -16,7 +16,6 @@ package com.google.common.io;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtIncompatible;
 import java.io.FilterOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
@@ -27,7 +26,6 @@ import java.io.OutputStream;
  * @author Chris Nokleberg
  * @since 1.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class CountingOutputStream extends FilterOutputStream {
 
diff --git a/guava/src/com/google/common/io/ElementTypesAreNonnullByDefault.java b/guava/src/com/google/common/io/ElementTypesAreNonnullByDefault.java
index 48bc10f192..39c2cb65ee 100644
--- a/guava/src/com/google/common/io/ElementTypesAreNonnullByDefault.java
+++ b/guava/src/com/google/common/io/ElementTypesAreNonnullByDefault.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.ElementType.TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -33,7 +32,6 @@ import javax.annotation.meta.TypeQualifierDefault;
  * unfortunately includes type-variable usages, so we also provide {@link ParametricNullness} to
  * "undo" it as best we can.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target(TYPE)
 @TypeQualifierDefault({FIELD, METHOD, PARAMETER})
diff --git a/guava/src/com/google/common/io/FileBackedOutputStream.java b/guava/src/com/google/common/io/FileBackedOutputStream.java
index 9912e2fcd1..bd589499db 100644
--- a/guava/src/com/google/common/io/FileBackedOutputStream.java
+++ b/guava/src/com/google/common/io/FileBackedOutputStream.java
@@ -16,10 +16,6 @@ package com.google.common.io;
 
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
-import com.google.errorprone.annotations.concurrent.GuardedBy;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
@@ -50,8 +46,6 @@ import javax.annotation.CheckForNull;
  * @author Chris Nokleberg
  * @since 1.0
  */
-@Beta
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class FileBackedOutputStream extends OutputStream {
   private final int fileThreshold;
@@ -59,14 +53,11 @@ public final class FileBackedOutputStream extends OutputStream {
   private final ByteSource source;
   @CheckForNull private final File parentDirectory;
 
-  @GuardedBy("this")
   private OutputStream out;
 
-  @GuardedBy("this")
   @CheckForNull
   private MemoryOutput memory;
 
-  @GuardedBy("this")
   @CheckForNull
   private File file;
 
@@ -82,7 +73,6 @@ public final class FileBackedOutputStream extends OutputStream {
   }
 
   /** Returns the file holding the data (possibly null). */
-  @VisibleForTesting
   @CheckForNull
   synchronized File getFile() {
     return file;
@@ -222,7 +212,6 @@ public final class FileBackedOutputStream extends OutputStream {
    * Checks if writing {@code len} bytes would go over threshold, and switches to file buffering if
    * so.
    */
-  @GuardedBy("this")
   private void update(int len) throws IOException {
     if (memory != null && (memory.getCount() + len > fileThreshold)) {
       File temp = File.createTempFile("FileBackedOutputStream", null, parentDirectory);
diff --git a/guava/src/com/google/common/io/FileWriteMode.java b/guava/src/com/google/common/io/FileWriteMode.java
index 86872d1bad..e69ba8a9d1 100644
--- a/guava/src/com/google/common/io/FileWriteMode.java
+++ b/guava/src/com/google/common/io/FileWriteMode.java
@@ -14,7 +14,6 @@
 
 package com.google.common.io;
 
-import com.google.common.annotations.GwtIncompatible;
 
 /**
  * Modes for opening a file for writing. The default when mode when none is specified is to truncate
@@ -22,7 +21,6 @@ import com.google.common.annotations.GwtIncompatible;
  *
  * @author Colin Decker
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public enum FileWriteMode {
   /** Specifies that writes to the opened file should append to the end of the file. */
diff --git a/guava/src/com/google/common/io/Files.java b/guava/src/com/google/common/io/Files.java
index bf6289e90f..e7a6ee1edb 100644
--- a/guava/src/com/google/common/io/Files.java
+++ b/guava/src/com/google/common/io/Files.java
@@ -18,8 +18,6 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.io.FileWriteMode.APPEND;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
@@ -31,7 +29,6 @@ import com.google.common.graph.SuccessorsFunction;
 import com.google.common.graph.Traverser;
 import com.google.common.hash.HashCode;
 import com.google.common.hash.HashFunction;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
@@ -53,7 +50,6 @@ import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Provides utility methods for working with {@linkplain File files}.
@@ -65,7 +61,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Colin Decker
  * @since 1.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class Files {
 
@@ -85,7 +80,6 @@ public final class Files {
    *     helpful predefined constants
    * @return the buffered reader
    */
-  @Beta
   public static BufferedReader newReader(File file, Charset charset) throws FileNotFoundException {
     checkNotNull(file);
     checkNotNull(charset);
@@ -104,7 +98,6 @@ public final class Files {
    *     helpful predefined constants
    * @return the buffered writer
    */
-  @Beta
   public static BufferedWriter newWriter(File file, Charset charset) throws FileNotFoundException {
     checkNotNull(file);
     checkNotNull(charset);
@@ -235,7 +228,6 @@ public final class Files {
    *     (2^31 - 1)
    * @throws IOException if an I/O error occurs
    */
-  @Beta
   public static byte[] toByteArray(File file) throws IOException {
     return asByteSource(file).read();
   }
@@ -251,7 +243,6 @@ public final class Files {
    * @deprecated Prefer {@code asCharSource(file, charset).read()}. This method is scheduled to be
    *     removed in October 2019.
    */
-  @Beta
   @Deprecated
   public static String toString(File file, Charset charset) throws IOException {
     return asCharSource(file, charset).read();
@@ -267,7 +258,6 @@ public final class Files {
    * @param to the destination file
    * @throws IOException if an I/O error occurs
    */
-  @Beta
   public static void write(byte[] from, File to) throws IOException {
     asByteSink(to).write(from);
   }
@@ -283,7 +273,6 @@ public final class Files {
    * @deprecated Prefer {@code asCharSink(to, charset).write(from)}. This method is scheduled to be
    *     removed in October 2019.
    */
-  @Beta
   @Deprecated
   public static void write(CharSequence from, File to, Charset charset) throws IOException {
     asCharSink(to, charset).write(from);
@@ -299,7 +288,6 @@ public final class Files {
    * @param to the output stream
    * @throws IOException if an I/O error occurs
    */
-  @Beta
   public static void copy(File from, OutputStream to) throws IOException {
     asByteSource(from).copyTo(to);
   }
@@ -323,7 +311,6 @@ public final class Files {
    * @throws IOException if an I/O error occurs
    * @throws IllegalArgumentException if {@code from.equals(to)}
    */
-  @Beta
   public static void copy(File from, File to) throws IOException {
     checkArgument(!from.equals(to), "Source %s and destination %s must be different", from, to);
     asByteSource(from).copyTo(asByteSink(to));
@@ -340,7 +327,6 @@ public final class Files {
    * @deprecated Prefer {@code asCharSource(from, charset).copyTo(to)}. This method is scheduled to
    *     be removed in October 2019.
    */
-  @Beta
   @Deprecated
   public
   static void copy(File from, Charset charset, Appendable to) throws IOException {
@@ -358,7 +344,6 @@ public final class Files {
    * @deprecated Prefer {@code asCharSink(to, charset, FileWriteMode.APPEND).write(from)}. This
    *     method is scheduled to be removed in October 2019.
    */
-  @Beta
   @Deprecated
   public
   static void append(CharSequence from, File to, Charset charset) throws IOException {
@@ -370,7 +355,6 @@ public final class Files {
    *
    * @throws IOException if an I/O error occurs
    */
-  @Beta
   public static boolean equal(File file1, File file2) throws IOException {
     checkNotNull(file1);
     checkNotNull(file2);
@@ -421,7 +405,6 @@ public final class Files {
    *     java.nio.file.Files#createTempDirectory}, transforming it to a {@link File} using {@link
    *     java.nio.file.Path#toFile() toFile()} if needed.
    */
-  @Beta
   @Deprecated
   public static File createTempDir() {
     File baseDir = new File(System.getProperty("java.io.tmpdir"));
@@ -452,7 +435,6 @@ public final class Files {
    * @param file the file to create or update
    * @throws IOException if an I/O error occurs
    */
-  @Beta
   @SuppressWarnings("GoodTime") // reading system time without TimeSource
   public static void touch(File file) throws IOException {
     checkNotNull(file);
@@ -470,7 +452,6 @@ public final class Files {
    *     directories of the specified file could not be created.
    * @since 4.0
    */
-  @Beta
   public static void createParentDirs(File file) throws IOException {
     checkNotNull(file);
     File parent = file.getCanonicalFile().getParentFile();
@@ -501,7 +482,6 @@ public final class Files {
    * @throws IOException if an I/O error occurs
    * @throws IllegalArgumentException if {@code from.equals(to)}
    */
-  @Beta
   public static void move(File from, File to) throws IOException {
     checkNotNull(from);
     checkNotNull(to);
@@ -530,7 +510,6 @@ public final class Files {
    * @deprecated Prefer {@code asCharSource(file, charset).readFirstLine()}. This method is
    *     scheduled to be removed in October 2019.
    */
-  @Beta
   @Deprecated
   @CheckForNull
   public
@@ -554,7 +533,6 @@ public final class Files {
    * @return a mutable {@link List} containing all the lines
    * @throws IOException if an I/O error occurs
    */
-  @Beta
   public static List<String> readLines(File file, Charset charset) throws IOException {
     // don't use asCharSource(file, charset).readLines() because that returns
     // an immutable list, which would change the behavior of this method
@@ -589,12 +567,11 @@ public final class Files {
    * @deprecated Prefer {@code asCharSource(file, charset).readLines(callback)}. This method is
    *     scheduled to be removed in October 2019.
    */
-  @Beta
   @Deprecated
-  @CanIgnoreReturnValue // some processors won't return a useful result
+  // some processors won't return a useful result
   @ParametricNullness
   public
-  static <T extends @Nullable Object> T readLines(
+  static <T extends Object> T readLines(
       File file, Charset charset, LineProcessor<T> callback) throws IOException {
     return asCharSource(file, charset).readLines(callback);
   }
@@ -611,12 +588,11 @@ public final class Files {
    * @deprecated Prefer {@code asByteSource(file).read(processor)}. This method is scheduled to be
    *     removed in October 2019.
    */
-  @Beta
   @Deprecated
-  @CanIgnoreReturnValue // some processors won't return a useful result
+  // some processors won't return a useful result
   @ParametricNullness
   public
-  static <T extends @Nullable Object> T readBytes(File file, ByteProcessor<T> processor)
+  static <T extends Object> T readBytes(File file, ByteProcessor<T> processor)
       throws IOException {
     return asByteSource(file).read(processor);
   }
@@ -632,7 +608,6 @@ public final class Files {
    * @deprecated Prefer {@code asByteSource(file).hash(hashFunction)}. This method is scheduled to
    *     be removed in October 2019.
    */
-  @Beta
   @Deprecated
   public
   static HashCode hash(File file, HashFunction hashFunction) throws IOException {
@@ -654,7 +629,6 @@ public final class Files {
    * @see FileChannel#map(MapMode, long, long)
    * @since 2.0
    */
-  @Beta
   public static MappedByteBuffer map(File file) throws IOException {
     checkNotNull(file);
     return map(file, MapMode.READ_ONLY);
@@ -677,7 +651,6 @@ public final class Files {
    * @see FileChannel#map(MapMode, long, long)
    * @since 2.0
    */
-  @Beta
   public static MappedByteBuffer map(File file, MapMode mode) throws IOException {
     return mapInternal(file, mode, -1);
   }
@@ -701,7 +674,6 @@ public final class Files {
    * @see FileChannel#map(MapMode, long, long)
    * @since 2.0
    */
-  @Beta
   public static MappedByteBuffer map(File file, MapMode mode, long size) throws IOException {
     checkArgument(size >= 0, "size (%s) may not be negative", size);
     return mapInternal(file, mode, size);
@@ -745,7 +717,6 @@ public final class Files {
    *
    * @since 11.0
    */
-  @Beta
   public static String simplifyPath(String pathname) {
     checkNotNull(pathname);
     if (pathname.length() == 0) {
@@ -806,7 +777,6 @@ public final class Files {
    *
    * @since 11.0
    */
-  @Beta
   public static String getFileExtension(String fullName) {
     checkNotNull(fullName);
     String fileName = new File(fullName).getName();
@@ -824,7 +794,6 @@ public final class Files {
    * @return The file name without its path or extension.
    * @since 14.0
    */
-  @Beta
   public static String getNameWithoutExtension(String file) {
     checkNotNull(file);
     String fileName = new File(file).getName();
@@ -854,7 +823,6 @@ public final class Files {
    *
    * @since 23.5
    */
-  @Beta
   public static Traverser<File> fileTraverser() {
     return Traverser.forTree(FILE_TREE);
   }
@@ -880,7 +848,6 @@ public final class Files {
    *
    * @since 15.0
    */
-  @Beta
   public static Predicate<File> isDirectory() {
     return FilePredicate.IS_DIRECTORY;
   }
@@ -890,7 +857,6 @@ public final class Files {
    *
    * @since 15.0
    */
-  @Beta
   public static Predicate<File> isFile() {
     return FilePredicate.IS_FILE;
   }
diff --git a/guava/src/com/google/common/io/Flushables.java b/guava/src/com/google/common/io/Flushables.java
index 1f795a24ab..5cde0a8395 100644
--- a/guava/src/com/google/common/io/Flushables.java
+++ b/guava/src/com/google/common/io/Flushables.java
@@ -14,8 +14,6 @@
 
 package com.google.common.io;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import java.io.Flushable;
 import java.io.IOException;
 import java.util.logging.Level;
@@ -27,8 +25,6 @@ import java.util.logging.Logger;
  * @author Michael Lancaster
  * @since 1.0
  */
-@Beta
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class Flushables {
   private static final Logger logger = Logger.getLogger(Flushables.class.getName());
diff --git a/guava/src/com/google/common/io/InsecureRecursiveDeleteException.java b/guava/src/com/google/common/io/InsecureRecursiveDeleteException.java
index 414093606b..581ea0736d 100644
--- a/guava/src/com/google/common/io/InsecureRecursiveDeleteException.java
+++ b/guava/src/com/google/common/io/InsecureRecursiveDeleteException.java
@@ -16,9 +16,6 @@
 
 package com.google.common.io;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.j2objc.annotations.J2ObjCIncompatible;
 import java.nio.file.FileSystemException;
 import java.nio.file.SecureDirectoryStream;
 import javax.annotation.CheckForNull;
@@ -35,9 +32,7 @@ import javax.annotation.CheckForNull;
  * @since 21.0
  * @author Colin Decker
  */
-@Beta
-@GwtIncompatible
-@J2ObjCIncompatible // java.nio.file
+// java.nio.file
 @ElementTypesAreNonnullByDefault
 public final class InsecureRecursiveDeleteException extends FileSystemException {
 
diff --git a/guava/src/com/google/common/io/Java8Compatibility.java b/guava/src/com/google/common/io/Java8Compatibility.java
index 705d97b4df..b111de73ed 100644
--- a/guava/src/com/google/common/io/Java8Compatibility.java
+++ b/guava/src/com/google/common/io/Java8Compatibility.java
@@ -14,14 +14,12 @@
 
 package com.google.common.io;
 
-import com.google.common.annotations.GwtIncompatible;
 import java.nio.Buffer;
 
 /**
  * Wrappers around {@link Buffer} methods that are covariantly overridden in Java 9+. See
  * https://github.com/google/guava/issues/3990
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 final class Java8Compatibility {
   static void clear(Buffer b) {
diff --git a/guava/src/com/google/common/io/LineBuffer.java b/guava/src/com/google/common/io/LineBuffer.java
index f944abc490..0206eb050c 100644
--- a/guava/src/com/google/common/io/LineBuffer.java
+++ b/guava/src/com/google/common/io/LineBuffer.java
@@ -14,8 +14,6 @@
 
 package com.google.common.io;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.IOException;
 
 /**
@@ -29,7 +27,6 @@ import java.io.IOException;
  * @author Chris Nokleberg
  * @since 1.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 abstract class LineBuffer {
   /** Holds partial line contents. */
@@ -84,7 +81,6 @@ abstract class LineBuffer {
   }
 
   /** Called when a line is complete. */
-  @CanIgnoreReturnValue
   private boolean finishLine(boolean sawNewline) throws IOException {
     String separator = sawReturn ? (sawNewline ? "\r\n" : "\r") : (sawNewline ? "\n" : "");
     handleLine(line.toString(), separator);
diff --git a/guava/src/com/google/common/io/LineProcessor.java b/guava/src/com/google/common/io/LineProcessor.java
index e28bebcc5f..d4a3b2b617 100644
--- a/guava/src/com/google/common/io/LineProcessor.java
+++ b/guava/src/com/google/common/io/LineProcessor.java
@@ -14,11 +14,7 @@
 
 package com.google.common.io;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.IOException;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A callback to be used with the streaming {@code readLines} methods.
@@ -29,10 +25,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Miles Barr
  * @since 1.0
  */
-@Beta
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
-public interface LineProcessor<T extends @Nullable Object> {
+public interface LineProcessor<T extends Object> {
 
   /**
    * This method will be called once for each line.
@@ -40,7 +34,7 @@ public interface LineProcessor<T extends @Nullable Object> {
    * @param line the line read from the input, without delimiter
    * @return true to continue processing, false to stop
    */
-  @CanIgnoreReturnValue // some uses know that their processor never returns false
+  // some uses know that their processor never returns false
   boolean processLine(String line) throws IOException;
 
   /** Return the result of processing all the lines. */
diff --git a/guava/src/com/google/common/io/LineReader.java b/guava/src/com/google/common/io/LineReader.java
index 2c57ac4546..976e6c84f5 100644
--- a/guava/src/com/google/common/io/LineReader.java
+++ b/guava/src/com/google/common/io/LineReader.java
@@ -17,9 +17,6 @@ package com.google.common.io;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.io.CharStreams.createBuffer;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.IOException;
 import java.io.Reader;
 import java.nio.CharBuffer;
@@ -35,8 +32,6 @@ import javax.annotation.CheckForNull;
  * @author Chris Nokleberg
  * @since 1.0
  */
-@Beta
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class LineReader {
   private final Readable readable;
@@ -68,7 +63,7 @@ public final class LineReader {
    *     line-termination characters, or {@code null} if the end of the stream has been reached.
    * @throws IOException if an I/O error occurs
    */
-  @CanIgnoreReturnValue // to skip a line
+  // to skip a line
   @CheckForNull
   public String readLine() throws IOException {
     while (lines.peek() == null) {
diff --git a/guava/src/com/google/common/io/LittleEndianDataInputStream.java b/guava/src/com/google/common/io/LittleEndianDataInputStream.java
index 88c8e27bc3..10ced0d2b2 100644
--- a/guava/src/com/google/common/io/LittleEndianDataInputStream.java
+++ b/guava/src/com/google/common/io/LittleEndianDataInputStream.java
@@ -14,13 +14,9 @@
 
 package com.google.common.io;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Preconditions;
 import com.google.common.primitives.Ints;
 import com.google.common.primitives.Longs;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotCall;
 import java.io.DataInput;
 import java.io.DataInputStream;
 import java.io.EOFException;
@@ -39,8 +35,6 @@ import java.io.InputStream;
  * @author Keith Bottner
  * @since 8.0
  */
-@Beta
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class LittleEndianDataInputStream extends FilterInputStream implements DataInput {
 
@@ -54,9 +48,8 @@ public final class LittleEndianDataInputStream extends FilterInputStream impleme
   }
 
   /** This method will throw an {@link UnsupportedOperationException}. */
-  @CanIgnoreReturnValue // to skip a line
+  // to skip a line
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public String readLine() {
     throw new UnsupportedOperationException("readLine is not supported");
   }
@@ -76,7 +69,7 @@ public final class LittleEndianDataInputStream extends FilterInputStream impleme
     return (int) in.skip(n);
   }
 
-  @CanIgnoreReturnValue // to skip a byte
+  // to skip a byte
   @Override
   public int readUnsignedByte() throws IOException {
     int b1 = in.read();
@@ -95,7 +88,7 @@ public final class LittleEndianDataInputStream extends FilterInputStream impleme
    *     little-endian byte order
    * @throws IOException if an I/O error occurs
    */
-  @CanIgnoreReturnValue // to skip some bytes
+  // to skip some bytes
   @Override
   public int readUnsignedShort() throws IOException {
     byte b1 = readAndCheckByte();
@@ -112,7 +105,7 @@ public final class LittleEndianDataInputStream extends FilterInputStream impleme
    *     byte order
    * @throws IOException if an I/O error occurs
    */
-  @CanIgnoreReturnValue // to skip some bytes
+  // to skip some bytes
   @Override
   public int readInt() throws IOException {
     byte b1 = readAndCheckByte();
@@ -131,7 +124,7 @@ public final class LittleEndianDataInputStream extends FilterInputStream impleme
    *     little-endian byte order
    * @throws IOException if an I/O error occurs
    */
-  @CanIgnoreReturnValue // to skip some bytes
+  // to skip some bytes
   @Override
   public long readLong() throws IOException {
     byte b1 = readAndCheckByte();
@@ -154,7 +147,7 @@ public final class LittleEndianDataInputStream extends FilterInputStream impleme
    *     little-endian byte order
    * @throws IOException if an I/O error occurs
    */
-  @CanIgnoreReturnValue // to skip some bytes
+  // to skip some bytes
   @Override
   public float readFloat() throws IOException {
     return Float.intBitsToFloat(readInt());
@@ -168,13 +161,13 @@ public final class LittleEndianDataInputStream extends FilterInputStream impleme
    *     little-endian byte order
    * @throws IOException if an I/O error occurs
    */
-  @CanIgnoreReturnValue // to skip some bytes
+  // to skip some bytes
   @Override
   public double readDouble() throws IOException {
     return Double.longBitsToDouble(readLong());
   }
 
-  @CanIgnoreReturnValue // to skip a field
+  // to skip a field
   @Override
   public String readUTF() throws IOException {
     return new DataInputStream(in).readUTF();
@@ -188,7 +181,7 @@ public final class LittleEndianDataInputStream extends FilterInputStream impleme
    *     byte order.
    * @throws IOException if an I/O error occurs.
    */
-  @CanIgnoreReturnValue // to skip some bytes
+  // to skip some bytes
   @Override
   public short readShort() throws IOException {
     return (short) readUnsignedShort();
@@ -202,19 +195,19 @@ public final class LittleEndianDataInputStream extends FilterInputStream impleme
    *     byte order
    * @throws IOException if an I/O error occurs
    */
-  @CanIgnoreReturnValue // to skip some bytes
+  // to skip some bytes
   @Override
   public char readChar() throws IOException {
     return (char) readUnsignedShort();
   }
 
-  @CanIgnoreReturnValue // to skip a byte
+  // to skip a byte
   @Override
   public byte readByte() throws IOException {
     return (byte) readUnsignedByte();
   }
 
-  @CanIgnoreReturnValue // to skip a byte
+  // to skip a byte
   @Override
   public boolean readBoolean() throws IOException {
     return readUnsignedByte() != 0;
diff --git a/guava/src/com/google/common/io/LittleEndianDataOutputStream.java b/guava/src/com/google/common/io/LittleEndianDataOutputStream.java
index 6e51aff49d..50652493f7 100644
--- a/guava/src/com/google/common/io/LittleEndianDataOutputStream.java
+++ b/guava/src/com/google/common/io/LittleEndianDataOutputStream.java
@@ -14,8 +14,6 @@
 
 package com.google.common.io;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Preconditions;
 import com.google.common.primitives.Longs;
 import java.io.DataOutput;
@@ -35,8 +33,6 @@ import java.io.OutputStream;
  * @author Keith Bottner
  * @since 8.0
  */
-@Beta
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class LittleEndianDataOutputStream extends FilterOutputStream implements DataOutput {
 
diff --git a/guava/src/com/google/common/io/MoreFiles.java b/guava/src/com/google/common/io/MoreFiles.java
index ffe200d5e8..519821365f 100644
--- a/guava/src/com/google/common/io/MoreFiles.java
+++ b/guava/src/com/google/common/io/MoreFiles.java
@@ -21,14 +21,11 @@ import static com.google.common.collect.Iterables.getOnlyElement;
 import static java.nio.file.LinkOption.NOFOLLOW_LINKS;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableList;
 import com.google.common.graph.SuccessorsFunction;
 import com.google.common.graph.Traverser;
-import com.google.j2objc.annotations.J2ObjCIncompatible;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -67,9 +64,7 @@ import javax.annotation.CheckForNull;
  * @since 21.0
  * @author Colin Decker
  */
-@Beta
-@GwtIncompatible
-@J2ObjCIncompatible // java.nio.file
+// java.nio.file
 @ElementTypesAreNonnullByDefault
 public final class MoreFiles {
 
diff --git a/guava/src/com/google/common/io/MultiInputStream.java b/guava/src/com/google/common/io/MultiInputStream.java
index 9a7e0fd1c0..c890b8846a 100644
--- a/guava/src/com/google/common/io/MultiInputStream.java
+++ b/guava/src/com/google/common/io/MultiInputStream.java
@@ -16,7 +16,6 @@ package com.google.common.io;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtIncompatible;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Iterator;
@@ -29,7 +28,6 @@ import javax.annotation.CheckForNull;
  * @author Chris Nokleberg
  * @since 1.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 final class MultiInputStream extends InputStream {
 
diff --git a/guava/src/com/google/common/io/MultiReader.java b/guava/src/com/google/common/io/MultiReader.java
index cc36e527b6..af138c28f1 100644
--- a/guava/src/com/google/common/io/MultiReader.java
+++ b/guava/src/com/google/common/io/MultiReader.java
@@ -16,7 +16,6 @@ package com.google.common.io;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Preconditions;
 import java.io.IOException;
 import java.io.Reader;
@@ -29,7 +28,6 @@ import javax.annotation.CheckForNull;
  * @author Bin Zhu
  * @since 1.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 class MultiReader extends Reader {
   private final Iterator<? extends CharSource> it;
diff --git a/guava/src/com/google/common/io/ParametricNullness.java b/guava/src/com/google/common/io/ParametricNullness.java
index afa0db1f5b..7a138d3fd4 100644
--- a/guava/src/com/google/common/io/ParametricNullness.java
+++ b/guava/src/com/google/common/io/ParametricNullness.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import static javax.annotation.meta.When.UNKNOWN;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -35,7 +34,6 @@ import javax.annotation.meta.TypeQualifierNickname;
  * href="https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/NullFromTypeParam.java">{@code
  * NullFromTypeParam}</a>). We use this to "undo" {@link ElementTypesAreNonnullByDefault}.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target({FIELD, METHOD, PARAMETER})
 @TypeQualifierNickname
diff --git a/guava/src/com/google/common/io/PatternFilenameFilter.java b/guava/src/com/google/common/io/PatternFilenameFilter.java
index 3cb2371e2f..af0f19b76a 100644
--- a/guava/src/com/google/common/io/PatternFilenameFilter.java
+++ b/guava/src/com/google/common/io/PatternFilenameFilter.java
@@ -14,8 +14,6 @@
 
 package com.google.common.io;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Preconditions;
 import java.io.File;
 import java.io.FilenameFilter;
@@ -29,8 +27,6 @@ import java.util.regex.PatternSyntaxException;
  * @author Apple Chow
  * @since 1.0
  */
-@Beta
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class PatternFilenameFilter implements FilenameFilter {
 
diff --git a/guava/src/com/google/common/io/ReaderInputStream.java b/guava/src/com/google/common/io/ReaderInputStream.java
index 75f8a3e1e3..bfe197c2cc 100644
--- a/guava/src/com/google/common/io/ReaderInputStream.java
+++ b/guava/src/com/google/common/io/ReaderInputStream.java
@@ -18,7 +18,6 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
 
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.primitives.UnsignedBytes;
 import java.io.IOException;
 import java.io.InputStream;
@@ -43,7 +42,6 @@ import java.util.Arrays;
  *
  * @author Chris Nokleberg
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 final class ReaderInputStream extends InputStream {
   private final Reader reader;
diff --git a/guava/src/com/google/common/io/RecursiveDeleteOption.java b/guava/src/com/google/common/io/RecursiveDeleteOption.java
index 1bb27a16b2..9f642dd344 100644
--- a/guava/src/com/google/common/io/RecursiveDeleteOption.java
+++ b/guava/src/com/google/common/io/RecursiveDeleteOption.java
@@ -16,9 +16,6 @@
 
 package com.google.common.io;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.j2objc.annotations.J2ObjCIncompatible;
 import java.nio.file.SecureDirectoryStream;
 
 /**
@@ -28,9 +25,7 @@ import java.nio.file.SecureDirectoryStream;
  * @since 21.0
  * @author Colin Decker
  */
-@Beta
-@GwtIncompatible
-@J2ObjCIncompatible // java.nio.file
+// java.nio.file
 @ElementTypesAreNonnullByDefault
 public enum RecursiveDeleteOption {
   /**
diff --git a/guava/src/com/google/common/io/Resources.java b/guava/src/com/google/common/io/Resources.java
index cc595fceec..f3fff731d3 100644
--- a/guava/src/com/google/common/io/Resources.java
+++ b/guava/src/com/google/common/io/Resources.java
@@ -17,19 +17,15 @@ package com.google.common.io;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Charsets;
 import com.google.common.base.MoreObjects;
 import com.google.common.collect.Lists;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.net.URL;
 import java.nio.charset.Charset;
 import java.util.List;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Provides utility methods for working with resources in the classpath. Note that even though these
@@ -43,8 +39,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Colin Decker
  * @since 1.0
  */
-@Beta
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class Resources {
   private Resources() {}
@@ -122,9 +116,9 @@ public final class Resources {
    * @return the output of processing the lines
    * @throws IOException if an I/O error occurs
    */
-  @CanIgnoreReturnValue // some processors won't return a useful result
+  // some processors won't return a useful result
   @ParametricNullness
-  public static <T extends @Nullable Object> T readLines(
+  public static <T extends Object> T readLines(
       URL url, Charset charset, LineProcessor<T> callback) throws IOException {
     return asCharSource(url, charset).readLines(callback);
   }
@@ -187,7 +181,7 @@ public final class Resources {
    *
    * @throws IllegalArgumentException if the resource is not found
    */
-  @CanIgnoreReturnValue // being used to check if a resource exists
+  // being used to check if a resource exists
   // TODO(cgdecker): maybe add a better way to check if a resource exists
   // e.g. Optional<URL> tryGetResource or boolean resourceExists
   public static URL getResource(String resourceName) {
@@ -205,7 +199,7 @@ public final class Resources {
    *
    * @throws IllegalArgumentException if the resource is not found
    */
-  @CanIgnoreReturnValue // being used to check if a resource exists
+  // being used to check if a resource exists
   public static URL getResource(Class<?> contextClass, String resourceName) {
     URL url = contextClass.getResource(resourceName);
     checkArgument(
diff --git a/guava/src/com/google/common/io/package-info.java b/guava/src/com/google/common/io/package-info.java
index f0666b26f4..c7bac46d6c 100644
--- a/guava/src/com/google/common/io/package-info.java
+++ b/guava/src/com/google/common/io/package-info.java
@@ -28,9 +28,7 @@
  *
  * @author Chris Nokleberg
  */
-@CheckReturnValue
 @ParametersAreNonnullByDefault
 package com.google.common.io;
 
-import com.google.errorprone.annotations.CheckReturnValue;
 import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/guava/src/com/google/common/math/BigDecimalMath.java b/guava/src/com/google/common/math/BigDecimalMath.java
index 33a55d3563..38c67ba99b 100644
--- a/guava/src/com/google/common/math/BigDecimalMath.java
+++ b/guava/src/com/google/common/math/BigDecimalMath.java
@@ -14,7 +14,6 @@
 
 package com.google.common.math;
 
-import com.google.common.annotations.GwtIncompatible;
 import java.math.BigDecimal;
 import java.math.RoundingMode;
 
@@ -24,7 +23,6 @@ import java.math.RoundingMode;
  * @author Louis Wasserman
  * @since 30.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public class BigDecimalMath {
   private BigDecimalMath() {}
diff --git a/guava/src/com/google/common/math/BigIntegerMath.java b/guava/src/com/google/common/math/BigIntegerMath.java
index 6ef1e81ed4..ceeb8ece48 100644
--- a/guava/src/com/google/common/math/BigIntegerMath.java
+++ b/guava/src/com/google/common/math/BigIntegerMath.java
@@ -25,10 +25,6 @@ import static java.math.RoundingMode.HALF_DOWN;
 import static java.math.RoundingMode.HALF_EVEN;
 import static java.math.RoundingMode.UNNECESSARY;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.math.RoundingMode;
@@ -47,7 +43,6 @@ import java.util.List;
  * @author Louis Wasserman
  * @since 11.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class BigIntegerMath {
   /**
@@ -57,7 +52,6 @@ public final class BigIntegerMath {
    * @throws IllegalArgumentException if {@code x <= 0}
    * @since 20.0
    */
-  @Beta
   public static BigInteger ceilingPowerOfTwo(BigInteger x) {
     return BigInteger.ZERO.setBit(log2(x, CEILING));
   }
@@ -69,7 +63,6 @@ public final class BigIntegerMath {
    * @throws IllegalArgumentException if {@code x <= 0}
    * @since 20.0
    */
-  @Beta
   public static BigInteger floorPowerOfTwo(BigInteger x) {
     return BigInteger.ZERO.setBit(log2(x, FLOOR));
   }
@@ -133,9 +126,8 @@ public final class BigIntegerMath {
    * of two. This can be any value, but higher values incur more class load time and linearly
    * increasing memory consumption.
    */
-  @VisibleForTesting static final int SQRT2_PRECOMPUTE_THRESHOLD = 256;
+  static final int SQRT2_PRECOMPUTE_THRESHOLD = 256;
 
-  @VisibleForTesting
   static final BigInteger SQRT2_PRECOMPUTED_BITS =
       new BigInteger("16a09e667f3bcc908b2fb1366ea957d3e3adec17512775099da2f590b0667322a", 16);
 
@@ -146,7 +138,7 @@ public final class BigIntegerMath {
    * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}
    *     is not a power of ten
    */
-  @GwtIncompatible // TODO
+  // TODO
   @SuppressWarnings("fallthrough")
   public static int log10(BigInteger x, RoundingMode mode) {
     checkPositive("x", x);
@@ -224,7 +216,7 @@ public final class BigIntegerMath {
    * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code
    *     sqrt(x)} is not an integer
    */
-  @GwtIncompatible // TODO
+  // TODO
   @SuppressWarnings("fallthrough")
   public static BigInteger sqrt(BigInteger x, RoundingMode mode) {
     checkNonNegative("x", x);
@@ -260,7 +252,7 @@ public final class BigIntegerMath {
     }
   }
 
-  @GwtIncompatible // TODO
+  // TODO
   private static BigInteger sqrtFloor(BigInteger x) {
     /*
      * Adapted from Hacker's Delight, Figure 11-1.
@@ -304,7 +296,7 @@ public final class BigIntegerMath {
     return sqrt0;
   }
 
-  @GwtIncompatible // TODO
+  // TODO
   private static BigInteger sqrtApproxWithDoubles(BigInteger x) {
     return DoubleMath.roundToBigInteger(Math.sqrt(DoubleUtils.bigToDouble(x)), HALF_EVEN);
   }
@@ -330,12 +322,10 @@ public final class BigIntegerMath {
    *     is not precisely representable as a {@code double}
    * @since 30.0
    */
-  @GwtIncompatible
   public static double roundToDouble(BigInteger x, RoundingMode mode) {
     return BigIntegerToDoubleRounder.INSTANCE.roundToDouble(x, mode);
   }
 
-  @GwtIncompatible
   private static class BigIntegerToDoubleRounder extends ToDoubleRounder<BigInteger> {
     static final BigIntegerToDoubleRounder INSTANCE = new BigIntegerToDoubleRounder();
 
@@ -369,7 +359,7 @@ public final class BigIntegerMath {
    * @throws ArithmeticException if {@code q == 0}, or if {@code mode == UNNECESSARY} and {@code a}
    *     is not an integer multiple of {@code b}
    */
-  @GwtIncompatible // TODO
+  // TODO
   public static BigInteger divide(BigInteger p, BigInteger q, RoundingMode mode) {
     BigDecimal pDec = new BigDecimal(p);
     BigDecimal qDec = new BigDecimal(q);
@@ -521,7 +511,7 @@ public final class BigIntegerMath {
   }
 
   // Returns true if BigInteger.valueOf(x.longValue()).equals(x).
-  @GwtIncompatible // TODO
+  // TODO
   static boolean fitsInLong(BigInteger x) {
     return x.bitLength() <= Long.SIZE - 1;
   }
diff --git a/guava/src/com/google/common/math/DoubleMath.java b/guava/src/com/google/common/math/DoubleMath.java
index cdd0a4b39e..13ee002726 100644
--- a/guava/src/com/google/common/math/DoubleMath.java
+++ b/guava/src/com/google/common/math/DoubleMath.java
@@ -30,11 +30,7 @@ import static java.lang.Math.getExponent;
 import static java.lang.Math.log;
 import static java.lang.Math.rint;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.primitives.Booleans;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.math.BigInteger;
 import java.math.RoundingMode;
 import java.util.Iterator;
@@ -45,14 +41,13 @@ import java.util.Iterator;
  * @author Louis Wasserman
  * @since 11.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class DoubleMath {
   /*
    * This method returns a value y such that rounding y DOWN (towards zero) gives the same result as
    * rounding x according to the specified mode.
    */
-  @GwtIncompatible // #isMathematicalInteger, com.google.common.math.DoubleUtils
+  // #isMathematicalInteger, com.google.common.math.DoubleUtils
   static double roundIntermediate(double x, RoundingMode mode) {
     if (!isFinite(x)) {
       throw new ArithmeticException("input is infinite or NaN");
@@ -128,7 +123,7 @@ public final class DoubleMath {
    *           RoundingMode#UNNECESSARY}
    *     </ul>
    */
-  @GwtIncompatible // #roundIntermediate
+  // #roundIntermediate
   public static int roundToInt(double x, RoundingMode mode) {
     double z = roundIntermediate(x, mode);
     checkInRangeForRoundingInputs(
@@ -153,7 +148,7 @@ public final class DoubleMath {
    *           RoundingMode#UNNECESSARY}
    *     </ul>
    */
-  @GwtIncompatible // #roundIntermediate
+  // #roundIntermediate
   public static long roundToLong(double x, RoundingMode mode) {
     double z = roundIntermediate(x, mode);
     checkInRangeForRoundingInputs(
@@ -180,7 +175,6 @@ public final class DoubleMath {
    *     </ul>
    */
   // #roundIntermediate, java.lang.Math.getExponent, com.google.common.math.DoubleUtils
-  @GwtIncompatible
   public static BigInteger roundToBigInteger(double x, RoundingMode mode) {
     x = roundIntermediate(x, mode);
     if (MIN_LONG_AS_DOUBLE - x < 1.0 & x < MAX_LONG_AS_DOUBLE_PLUS_ONE) {
@@ -196,7 +190,7 @@ public final class DoubleMath {
    * Returns {@code true} if {@code x} is exactly equal to {@code 2^k} for some finite integer
    * {@code k}.
    */
-  @GwtIncompatible // com.google.common.math.DoubleUtils
+  // com.google.common.math.DoubleUtils
   public static boolean isPowerOfTwo(double x) {
     if (x > 0.0 && isFinite(x)) {
       long significand = getSignificand(x);
@@ -234,7 +228,7 @@ public final class DoubleMath {
    * @throws IllegalArgumentException if {@code x <= 0.0}, {@code x} is NaN, or {@code x} is
    *     infinite
    */
-  @GwtIncompatible // java.lang.Math.getExponent, com.google.common.math.DoubleUtils
+  // java.lang.Math.getExponent, com.google.common.math.DoubleUtils
   @SuppressWarnings("fallthrough")
   public static int log2(double x, RoundingMode mode) {
     checkArgument(x > 0.0 && isFinite(x), "x must be positive and finite");
@@ -283,7 +277,7 @@ public final class DoubleMath {
    * <p>This is equivalent to, but not necessarily implemented as, the expression {@code
    * !Double.isNaN(x) && !Double.isInfinite(x) && x == Math.rint(x)}.
    */
-  @GwtIncompatible // java.lang.Math.getExponent, com.google.common.math.DoubleUtils
+  // java.lang.Math.getExponent, com.google.common.math.DoubleUtils
   public static boolean isMathematicalInteger(double x) {
     return isFinite(x)
         && (x == 0.0
@@ -314,9 +308,8 @@ public final class DoubleMath {
     }
   }
 
-  @VisibleForTesting static final int MAX_FACTORIAL = 170;
+  static final int MAX_FACTORIAL = 170;
 
-  @VisibleForTesting
   static final double[] everySixteenthFactorial = {
     0x1.0p0,
     0x1.30777758p44,
@@ -404,7 +397,6 @@ public final class DoubleMath {
    */
   @Deprecated
   // com.google.common.math.DoubleUtils
-  @GwtIncompatible
   public static double mean(double... values) {
     checkArgument(values.length > 0, "Cannot take mean of 0 values");
     long count = 1;
@@ -484,7 +476,6 @@ public final class DoubleMath {
    */
   @Deprecated
   // com.google.common.math.DoubleUtils
-  @GwtIncompatible
   public static double mean(Iterable<? extends Number> values) {
     return mean(values.iterator());
   }
@@ -504,7 +495,6 @@ public final class DoubleMath {
    */
   @Deprecated
   // com.google.common.math.DoubleUtils
-  @GwtIncompatible
   public static double mean(Iterator<? extends Number> values) {
     checkArgument(values.hasNext(), "Cannot take mean of 0 values");
     long count = 1;
@@ -518,8 +508,7 @@ public final class DoubleMath {
     return mean;
   }
 
-  @GwtIncompatible // com.google.common.math.DoubleUtils
-  @CanIgnoreReturnValue
+  // com.google.common.math.DoubleUtils
   private static double checkFinite(double argument) {
     checkArgument(isFinite(argument));
     return argument;
diff --git a/guava/src/com/google/common/math/DoubleUtils.java b/guava/src/com/google/common/math/DoubleUtils.java
index d4a07e9dfc..d655e48956 100644
--- a/guava/src/com/google/common/math/DoubleUtils.java
+++ b/guava/src/com/google/common/math/DoubleUtils.java
@@ -23,8 +23,6 @@ import static java.lang.Double.isNaN;
 import static java.lang.Double.longBitsToDouble;
 import static java.lang.Math.getExponent;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import java.math.BigInteger;
 
 /**
@@ -32,7 +30,6 @@ import java.math.BigInteger;
  *
  * @author Louis Wasserman
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 final class DoubleUtils {
   private DoubleUtils() {}
@@ -135,5 +132,5 @@ final class DoubleUtils {
     return Math.max(value, 0.0);
   }
 
-  @VisibleForTesting static final long ONE_BITS = 0x3ff0000000000000L;
+  static final long ONE_BITS = 0x3ff0000000000000L;
 }
diff --git a/guava/src/com/google/common/math/ElementTypesAreNonnullByDefault.java b/guava/src/com/google/common/math/ElementTypesAreNonnullByDefault.java
index 84999ea494..004d393378 100644
--- a/guava/src/com/google/common/math/ElementTypesAreNonnullByDefault.java
+++ b/guava/src/com/google/common/math/ElementTypesAreNonnullByDefault.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.ElementType.TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -33,7 +32,6 @@ import javax.annotation.meta.TypeQualifierDefault;
  * unfortunately includes type-variable usages, so we also provide {@link ParametricNullness} to
  * "undo" it as best we can.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target(TYPE)
 @TypeQualifierDefault({FIELD, METHOD, PARAMETER})
diff --git a/guava/src/com/google/common/math/IntMath.java b/guava/src/com/google/common/math/IntMath.java
index 17a18c6999..60b08528a9 100644
--- a/guava/src/com/google/common/math/IntMath.java
+++ b/guava/src/com/google/common/math/IntMath.java
@@ -25,10 +25,6 @@ import static java.lang.Math.min;
 import static java.math.RoundingMode.HALF_EVEN;
 import static java.math.RoundingMode.HALF_UP;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.primitives.Ints;
 import java.math.BigInteger;
 import java.math.RoundingMode;
@@ -47,12 +43,11 @@ import java.math.RoundingMode;
  * @author Louis Wasserman
  * @since 11.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class IntMath {
   // NOTE: Whenever both tests are cheap and functional, it's faster to use &, | instead of &&, ||
 
-  @VisibleForTesting static final int MAX_SIGNED_POWER_OF_TWO = 1 << (Integer.SIZE - 2);
+  static final int MAX_SIGNED_POWER_OF_TWO = 1 << (Integer.SIZE - 2);
 
   /**
    * Returns the smallest power of two greater than or equal to {@code x}. This is equivalent to
@@ -63,7 +58,6 @@ public final class IntMath {
    *     int}, i.e. when {@code x > 2^30}
    * @since 20.0
    */
-  @Beta
   public static int ceilingPowerOfTwo(int x) {
     checkPositive("x", x);
     if (x > MAX_SIGNED_POWER_OF_TWO) {
@@ -79,7 +73,6 @@ public final class IntMath {
    * @throws IllegalArgumentException if {@code x <= 0}
    * @since 20.0
    */
-  @Beta
   public static int floorPowerOfTwo(int x) {
     checkPositive("x", x);
     return Integer.highestOneBit(x);
@@ -100,7 +93,6 @@ public final class IntMath {
    * a signed int. The implementation is branch-free, and benchmarks suggest it is measurably (if
    * narrowly) faster than the straightforward ternary expression.
    */
-  @VisibleForTesting
   static int lessThanBranchFree(int x, int y) {
     // The double negation is optimized away by normal Java, but is necessary for GWT
     // to make sure bit twiddling works as expected.
@@ -146,7 +138,7 @@ public final class IntMath {
   }
 
   /** The biggest half power of two that can fit in an unsigned int. */
-  @VisibleForTesting static final int MAX_POWER_OF_SQRT2_UNSIGNED = 0xB504F333;
+  static final int MAX_POWER_OF_SQRT2_UNSIGNED = 0xB504F333;
 
   /**
    * Returns the base-10 logarithm of {@code x}, rounded according to the specified rounding mode.
@@ -155,7 +147,7 @@ public final class IntMath {
    * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}
    *     is not a power of ten
    */
-  @GwtIncompatible // need BigIntegerMath to adequately test
+  // need BigIntegerMath to adequately test
   @SuppressWarnings("fallthrough")
   public static int log10(int x, RoundingMode mode) {
     checkPositive("x", x);
@@ -198,19 +190,16 @@ public final class IntMath {
   }
 
   // maxLog10ForLeadingZeros[i] == floor(log10(2^(Long.SIZE - i)))
-  @VisibleForTesting
   static final byte[] maxLog10ForLeadingZeros = {
     9, 9, 9, 8, 8, 8, 7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 4, 4, 4, 3, 3, 3, 3, 2, 2, 2, 1, 1, 1, 0, 0, 0,
     0
   };
 
-  @VisibleForTesting
   static final int[] powersOf10 = {
     1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000
   };
 
   // halfPowersOf10[i] = largest int less than 10^(i + 0.5)
-  @VisibleForTesting
   static final int[] halfPowersOf10 = {
     3, 31, 316, 3162, 31622, 316227, 3162277, 31622776, 316227766, Integer.MAX_VALUE
   };
@@ -224,7 +213,7 @@ public final class IntMath {
    *
    * @throws IllegalArgumentException if {@code k < 0}
    */
-  @GwtIncompatible // failing tests
+  // failing tests
   public static int pow(int b, int k) {
     checkNonNegative("exponent", k);
     switch (b) {
@@ -265,7 +254,7 @@ public final class IntMath {
    * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code
    *     sqrt(x)} is not an integer
    */
-  @GwtIncompatible // need BigIntegerMath to adequately test
+  // need BigIntegerMath to adequately test
   @SuppressWarnings("fallthrough")
   public static int sqrt(int x, RoundingMode mode) {
     checkNonNegative("x", x);
@@ -532,7 +521,6 @@ public final class IntMath {
    *
    * @since 20.0
    */
-  @Beta
   public static int saturatedAdd(int a, int b) {
     return Ints.saturatedCast((long) a + b);
   }
@@ -543,7 +531,6 @@ public final class IntMath {
    *
    * @since 20.0
    */
-  @Beta
   public static int saturatedSubtract(int a, int b) {
     return Ints.saturatedCast((long) a - b);
   }
@@ -554,7 +541,6 @@ public final class IntMath {
    *
    * @since 20.0
    */
-  @Beta
   public static int saturatedMultiply(int a, int b) {
     return Ints.saturatedCast((long) a * b);
   }
@@ -565,7 +551,6 @@ public final class IntMath {
    *
    * @since 20.0
    */
-  @Beta
   public static int saturatedPow(int b, int k) {
     checkNonNegative("exponent", k);
     switch (b) {
@@ -612,7 +597,7 @@ public final class IntMath {
     }
   }
 
-  @VisibleForTesting static final int FLOOR_SQRT_MAX_INT = 46340;
+  static final int FLOOR_SQRT_MAX_INT = 46340;
 
   /**
    * Returns {@code n!}, that is, the product of the first {@code n} positive integers, {@code 1} if
@@ -673,7 +658,6 @@ public final class IntMath {
   }
 
   // binomial(biggestBinomials[k], k) fits in an int, but not binomial(biggestBinomials[k]+1,k).
-  @VisibleForTesting
   static int[] biggestBinomials = {
     Integer.MAX_VALUE,
     Integer.MAX_VALUE,
@@ -719,8 +703,7 @@ public final class IntMath {
    * @throws IllegalArgumentException if {@code n} is negative
    * @since 20.0
    */
-  @GwtIncompatible // TODO
-  @Beta
+  // TODO
   public static boolean isPrime(int n) {
     return LongMath.isPrime(n);
   }
diff --git a/guava/src/com/google/common/math/LinearTransformation.java b/guava/src/com/google/common/math/LinearTransformation.java
index 4cc1eb87db..c1cd1b04a8 100644
--- a/guava/src/com/google/common/math/LinearTransformation.java
+++ b/guava/src/com/google/common/math/LinearTransformation.java
@@ -18,9 +18,6 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.math.DoubleUtils.isFinite;
 import static java.lang.Double.NaN;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.concurrent.LazyInit;
 import javax.annotation.CheckForNull;
 
 /**
@@ -34,8 +31,6 @@ import javax.annotation.CheckForNull;
  * @author Pete Gillin
  * @since 20.0
  */
-@Beta
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public abstract class LinearTransformation {
 
@@ -163,7 +158,7 @@ public abstract class LinearTransformation {
     final double slope;
     final double yIntercept;
 
-    @CheckForNull @LazyInit LinearTransformation inverse;
+    @CheckForNull LinearTransformation inverse;
 
     RegularLinearTransformation(double slope, double yIntercept) {
       this.slope = slope;
@@ -221,7 +216,7 @@ public abstract class LinearTransformation {
 
     final double x;
 
-    @CheckForNull @LazyInit LinearTransformation inverse;
+    @CheckForNull LinearTransformation inverse;
 
     VerticalLinearTransformation(double x) {
       this.x = x;
diff --git a/guava/src/com/google/common/math/LongMath.java b/guava/src/com/google/common/math/LongMath.java
index 1e67812b73..40be5164f4 100644
--- a/guava/src/com/google/common/math/LongMath.java
+++ b/guava/src/com/google/common/math/LongMath.java
@@ -25,10 +25,6 @@ import static java.lang.Math.min;
 import static java.math.RoundingMode.HALF_EVEN;
 import static java.math.RoundingMode.HALF_UP;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.primitives.Longs;
 import com.google.common.primitives.UnsignedLongs;
 import java.math.BigInteger;
@@ -48,12 +44,11 @@ import java.math.RoundingMode;
  * @author Louis Wasserman
  * @since 11.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class LongMath {
   // NOTE: Whenever both tests are cheap and functional, it's faster to use &, | instead of &&, ||
 
-  @VisibleForTesting static final long MAX_SIGNED_POWER_OF_TWO = 1L << (Long.SIZE - 2);
+  static final long MAX_SIGNED_POWER_OF_TWO = 1L << (Long.SIZE - 2);
 
   /**
    * Returns the smallest power of two greater than or equal to {@code x}. This is equivalent to
@@ -64,7 +59,6 @@ public final class LongMath {
    *     long}, i.e. when {@code x > 2^62}
    * @since 20.0
    */
-  @Beta
   public static long ceilingPowerOfTwo(long x) {
     checkPositive("x", x);
     if (x > MAX_SIGNED_POWER_OF_TWO) {
@@ -80,7 +74,6 @@ public final class LongMath {
    * @throws IllegalArgumentException if {@code x <= 0}
    * @since 20.0
    */
-  @Beta
   public static long floorPowerOfTwo(long x) {
     checkPositive("x", x);
 
@@ -104,7 +97,6 @@ public final class LongMath {
    * signed long. The implementation is branch-free, and benchmarks suggest it is measurably faster
    * than the straightforward ternary expression.
    */
-  @VisibleForTesting
   static int lessThanBranchFree(long x, long y) {
     // Returns the sign bit of x - y.
     return (int) (~~(x - y) >>> (Long.SIZE - 1));
@@ -149,7 +141,7 @@ public final class LongMath {
   }
 
   /** The biggest half power of two that fits into an unsigned long */
-  @VisibleForTesting static final long MAX_POWER_OF_SQRT2_UNSIGNED = 0xB504F333F9DE6484L;
+  static final long MAX_POWER_OF_SQRT2_UNSIGNED = 0xB504F333F9DE6484L;
 
   /**
    * Returns the base-10 logarithm of {@code x}, rounded according to the specified rounding mode.
@@ -158,7 +150,7 @@ public final class LongMath {
    * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}
    *     is not a power of ten
    */
-  @GwtIncompatible // TODO
+  // TODO
   @SuppressWarnings("fallthrough")
   // TODO(kevinb): remove after this warning is disabled globally
   public static int log10(long x, RoundingMode mode) {
@@ -185,7 +177,7 @@ public final class LongMath {
     }
   }
 
-  @GwtIncompatible // TODO
+  // TODO
   static int log10Floor(long x) {
     /*
      * Based on Hacker's Delight Fig. 11-5, the two-table-lookup, branch-free implementation.
@@ -203,15 +195,13 @@ public final class LongMath {
   }
 
   // maxLog10ForLeadingZeros[i] == floor(log10(2^(Long.SIZE - i)))
-  @VisibleForTesting
   static final byte[] maxLog10ForLeadingZeros = {
     19, 18, 18, 18, 18, 17, 17, 17, 16, 16, 16, 15, 15, 15, 15, 14, 14, 14, 13, 13, 13, 12, 12, 12,
     12, 11, 11, 11, 10, 10, 10, 9, 9, 9, 9, 8, 8, 8, 7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 4, 4, 4, 3, 3, 3,
     3, 2, 2, 2, 1, 1, 1, 0, 0, 0
   };
 
-  @GwtIncompatible // TODO
-  @VisibleForTesting
+  // TODO
   static final long[] powersOf10 = {
     1L,
     10L,
@@ -235,8 +225,7 @@ public final class LongMath {
   };
 
   // halfPowersOf10[i] = largest long less than 10^(i + 0.5)
-  @GwtIncompatible // TODO
-  @VisibleForTesting
+  // TODO
   static final long[] halfPowersOf10 = {
     3L,
     31L,
@@ -266,7 +255,7 @@ public final class LongMath {
    *
    * @throws IllegalArgumentException if {@code k < 0}
    */
-  @GwtIncompatible // TODO
+  // TODO
   public static long pow(long b, int k) {
     checkNonNegative("exponent", k);
     if (-2 <= b && b <= 2) {
@@ -309,7 +298,7 @@ public final class LongMath {
    * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code
    *     sqrt(x)} is not an integer
    */
-  @GwtIncompatible // TODO
+  // TODO
   @SuppressWarnings("fallthrough")
   public static long sqrt(long x, RoundingMode mode) {
     checkNonNegative("x", x);
@@ -381,7 +370,7 @@ public final class LongMath {
    * @throws ArithmeticException if {@code q == 0}, or if {@code mode == UNNECESSARY} and {@code a}
    *     is not an integer multiple of {@code b}
    */
-  @GwtIncompatible // TODO
+  // TODO
   @SuppressWarnings("fallthrough")
   public static long divide(long p, long q, RoundingMode mode) {
     checkNotNull(mode);
@@ -454,7 +443,7 @@ public final class LongMath {
    * @see <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.17.3">
    *     Remainder Operator</a>
    */
-  @GwtIncompatible // TODO
+  // TODO
   public static int mod(long x, int m) {
     // Cast is safe because the result is guaranteed in the range [0, m)
     return (int) mod(x, (long) m);
@@ -478,7 +467,7 @@ public final class LongMath {
    * @see <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.17.3">
    *     Remainder Operator</a>
    */
-  @GwtIncompatible // TODO
+  // TODO
   public static long mod(long x, long m) {
     if (m <= 0) {
       throw new ArithmeticException("Modulus must be positive");
@@ -543,7 +532,7 @@ public final class LongMath {
    *
    * @throws ArithmeticException if {@code a + b} overflows in signed {@code long} arithmetic
    */
-  @GwtIncompatible // TODO
+  // TODO
   public static long checkedAdd(long a, long b) {
     long result = a + b;
     checkNoOverflow((a ^ b) < 0 | (a ^ result) >= 0, "checkedAdd", a, b);
@@ -555,7 +544,7 @@ public final class LongMath {
    *
    * @throws ArithmeticException if {@code a - b} overflows in signed {@code long} arithmetic
    */
-  @GwtIncompatible // TODO
+  // TODO
   public static long checkedSubtract(long a, long b) {
     long result = a - b;
     checkNoOverflow((a ^ b) >= 0 | (a ^ result) >= 0, "checkedSubtract", a, b);
@@ -600,7 +589,7 @@ public final class LongMath {
    * @throws ArithmeticException if {@code b} to the {@code k}th power overflows in signed {@code
    *     long} arithmetic
    */
-  @GwtIncompatible // TODO
+  // TODO
   public static long checkedPow(long b, int k) {
     checkNonNegative("exponent", k);
     if (b >= -2 & b <= 2) {
@@ -648,7 +637,6 @@ public final class LongMath {
    *
    * @since 20.0
    */
-  @Beta
   public static long saturatedAdd(long a, long b) {
     long naiveSum = a + b;
     if ((a ^ b) < 0 | (a ^ naiveSum) >= 0) {
@@ -666,7 +654,6 @@ public final class LongMath {
    *
    * @since 20.0
    */
-  @Beta
   public static long saturatedSubtract(long a, long b) {
     long naiveDifference = a - b;
     if ((a ^ b) >= 0 | (a ^ naiveDifference) >= 0) {
@@ -684,7 +671,6 @@ public final class LongMath {
    *
    * @since 20.0
    */
-  @Beta
   public static long saturatedMultiply(long a, long b) {
     // see checkedMultiply for explanation
     int leadingZeros =
@@ -714,7 +700,6 @@ public final class LongMath {
    *
    * @since 20.0
    */
-  @Beta
   public static long saturatedPow(long b, int k) {
     checkNonNegative("exponent", k);
     if (b >= -2 & b <= 2) {
@@ -763,7 +748,7 @@ public final class LongMath {
     }
   }
 
-  @VisibleForTesting static final long FLOOR_SQRT_MAX_LONG = 3037000499L;
+  static final long FLOOR_SQRT_MAX_LONG = 3037000499L;
 
   /**
    * Returns {@code n!}, that is, the product of the first {@code n} positive integers, {@code 1} if
@@ -771,7 +756,7 @@ public final class LongMath {
    *
    * @throws IllegalArgumentException if {@code n < 0}
    */
-  @GwtIncompatible // TODO
+  // TODO
   public static long factorial(int n) {
     checkNonNegative("n", n);
     return (n < factorials.length) ? factorials[n] : Long.MAX_VALUE;
@@ -924,7 +909,6 @@ public final class LongMath {
    * binomial(biggestSimpleBinomials[k], k) doesn't need to use the slower GCD-based impl, but
    * binomial(biggestSimpleBinomials[k] + 1, k) does.
    */
-  @VisibleForTesting
   static final int[] biggestSimpleBinomials = {
     Integer.MAX_VALUE,
     Integer.MAX_VALUE,
@@ -999,8 +983,7 @@ public final class LongMath {
    * @throws IllegalArgumentException if {@code n} is negative
    * @since 20.0
    */
-  @GwtIncompatible // TODO
-  @Beta
+  // TODO
   public static boolean isPrime(long n) {
     if (n < 2) {
       checkNonNegative("n", n);
@@ -1243,7 +1226,6 @@ public final class LongMath {
    * @since 30.0
    */
   @SuppressWarnings("deprecation")
-  @GwtIncompatible
   public static double roundToDouble(long x, RoundingMode mode) {
     // Logic adapted from ToDoubleRounder.
     double roundArbitrarily = (double) x;
diff --git a/guava/src/com/google/common/math/MathPreconditions.java b/guava/src/com/google/common/math/MathPreconditions.java
index 37d608a823..fa5feb30d5 100644
--- a/guava/src/com/google/common/math/MathPreconditions.java
+++ b/guava/src/com/google/common/math/MathPreconditions.java
@@ -14,8 +14,6 @@
 
 package com.google.common.math;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.math.BigInteger;
 import java.math.RoundingMode;
 
@@ -24,8 +22,6 @@ import java.math.RoundingMode;
  *
  * @author Louis Wasserman
  */
-@GwtCompatible
-@CanIgnoreReturnValue
 @ElementTypesAreNonnullByDefault
 final class MathPreconditions {
   static int checkPositive(String role, int x) {
diff --git a/guava/src/com/google/common/math/PairedStats.java b/guava/src/com/google/common/math/PairedStats.java
index 31ab9b7196..c9b4879be6 100644
--- a/guava/src/com/google/common/math/PairedStats.java
+++ b/guava/src/com/google/common/math/PairedStats.java
@@ -21,8 +21,6 @@ import static java.lang.Double.NaN;
 import static java.lang.Double.doubleToLongBits;
 import static java.lang.Double.isNaN;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Objects;
 import java.io.Serializable;
@@ -37,8 +35,6 @@ import javax.annotation.CheckForNull;
  * @author Pete Gillin
  * @since 20.0
  */
-@Beta
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class PairedStats implements Serializable {
 
diff --git a/guava/src/com/google/common/math/PairedStatsAccumulator.java b/guava/src/com/google/common/math/PairedStatsAccumulator.java
index 072ef13b3b..f24331b993 100644
--- a/guava/src/com/google/common/math/PairedStatsAccumulator.java
+++ b/guava/src/com/google/common/math/PairedStatsAccumulator.java
@@ -19,8 +19,6 @@ import static com.google.common.primitives.Doubles.isFinite;
 import static java.lang.Double.NaN;
 import static java.lang.Double.isNaN;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.primitives.Doubles;
 
 /**
@@ -30,8 +28,6 @@ import com.google.common.primitives.Doubles;
  * @author Pete Gillin
  * @since 20.0
  */
-@Beta
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class PairedStatsAccumulator {
 
diff --git a/guava/src/com/google/common/math/ParametricNullness.java b/guava/src/com/google/common/math/ParametricNullness.java
index c079b97813..6e01027306 100644
--- a/guava/src/com/google/common/math/ParametricNullness.java
+++ b/guava/src/com/google/common/math/ParametricNullness.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import static javax.annotation.meta.When.UNKNOWN;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -35,7 +34,6 @@ import javax.annotation.meta.TypeQualifierNickname;
  * href="https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/NullFromTypeParam.java">{@code
  * NullFromTypeParam}</a>). We use this to "undo" {@link ElementTypesAreNonnullByDefault}.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target({FIELD, METHOD, PARAMETER})
 @TypeQualifierNickname
diff --git a/guava/src/com/google/common/math/Quantiles.java b/guava/src/com/google/common/math/Quantiles.java
index 6ddea9bcfd..a8aecf631a 100644
--- a/guava/src/com/google/common/math/Quantiles.java
+++ b/guava/src/com/google/common/math/Quantiles.java
@@ -21,8 +21,6 @@ import static java.lang.Double.POSITIVE_INFINITY;
 import static java.util.Arrays.sort;
 import static java.util.Collections.unmodifiableMap;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.primitives.Doubles;
 import com.google.common.primitives.Ints;
 import java.math.RoundingMode;
@@ -126,8 +124,6 @@ import java.util.Map;
  * @author Pete Gillin
  * @since 20.0
  */
-@Beta
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class Quantiles {
 
diff --git a/guava/src/com/google/common/math/Stats.java b/guava/src/com/google/common/math/Stats.java
index 20c9466f5c..a11ca82b00 100644
--- a/guava/src/com/google/common/math/Stats.java
+++ b/guava/src/com/google/common/math/Stats.java
@@ -24,8 +24,6 @@ import static java.lang.Double.NaN;
 import static java.lang.Double.doubleToLongBits;
 import static java.lang.Double.isNaN;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Objects;
 import java.io.Serializable;
@@ -62,8 +60,6 @@ import javax.annotation.CheckForNull;
  * @author Kevin Bourrillion
  * @since 20.0
  */
-@Beta
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class Stats implements Serializable {
 
diff --git a/guava/src/com/google/common/math/StatsAccumulator.java b/guava/src/com/google/common/math/StatsAccumulator.java
index b28229c962..a28d226786 100644
--- a/guava/src/com/google/common/math/StatsAccumulator.java
+++ b/guava/src/com/google/common/math/StatsAccumulator.java
@@ -20,8 +20,6 @@ import static com.google.common.primitives.Doubles.isFinite;
 import static java.lang.Double.NaN;
 import static java.lang.Double.isNaN;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import java.util.Iterator;
 import java.util.stream.DoubleStream;
 import java.util.stream.IntStream;
@@ -35,8 +33,6 @@ import java.util.stream.LongStream;
  * @author Kevin Bourrillion
  * @since 20.0
  */
-@Beta
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class StatsAccumulator {
 
diff --git a/guava/src/com/google/common/math/ToDoubleRounder.java b/guava/src/com/google/common/math/ToDoubleRounder.java
index 2e7e7fae09..dd961d1722 100644
--- a/guava/src/com/google/common/math/ToDoubleRounder.java
+++ b/guava/src/com/google/common/math/ToDoubleRounder.java
@@ -17,14 +17,12 @@ package com.google.common.math;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.math.MathPreconditions.checkRoundingUnnecessary;
 
-import com.google.common.annotations.GwtIncompatible;
 import java.math.RoundingMode;
 
 /**
  * Helper type to implement rounding {@code X} to a representable {@code double} value according to
  * a {@link RoundingMode}.
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 abstract class ToDoubleRounder<X extends Number & Comparable<X>> {
   /**
diff --git a/guava/src/com/google/common/math/package-info.java b/guava/src/com/google/common/math/package-info.java
index 0408246e74..7a00a68eb5 100644
--- a/guava/src/com/google/common/math/package-info.java
+++ b/guava/src/com/google/common/math/package-info.java
@@ -22,8 +22,6 @@
  * href="https://github.com/google/guava/wiki/MathExplained">math utilities</a>.
  */
 @ParametersAreNonnullByDefault
-@CheckReturnValue
 package com.google.common.math;
 
-import com.google.errorprone.annotations.CheckReturnValue;
 import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/guava/src/com/google/common/net/ElementTypesAreNonnullByDefault.java b/guava/src/com/google/common/net/ElementTypesAreNonnullByDefault.java
index d8cfd7377d..4a695b04b8 100644
--- a/guava/src/com/google/common/net/ElementTypesAreNonnullByDefault.java
+++ b/guava/src/com/google/common/net/ElementTypesAreNonnullByDefault.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.ElementType.TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -33,7 +32,6 @@ import javax.annotation.meta.TypeQualifierDefault;
  * unfortunately includes type-variable usages, so we also provide {@link ParametricNullness} to
  * "undo" it as best we can.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target(TYPE)
 @TypeQualifierDefault({FIELD, METHOD, PARAMETER})
diff --git a/guava/src/com/google/common/net/HostAndPort.java b/guava/src/com/google/common/net/HostAndPort.java
index 19e6b6729d..0dbcba927c 100644
--- a/guava/src/com/google/common/net/HostAndPort.java
+++ b/guava/src/com/google/common/net/HostAndPort.java
@@ -18,12 +18,9 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.CharMatcher;
 import com.google.common.base.Objects;
 import com.google.common.base.Strings;
-import com.google.errorprone.annotations.Immutable;
 import java.io.Serializable;
 import javax.annotation.CheckForNull;
 
@@ -60,9 +57,6 @@ import javax.annotation.CheckForNull;
  * @author Paul Marks
  * @since 10.0
  */
-@Beta
-@Immutable
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class HostAndPort implements Serializable {
   /** Magic value indicating the absence of a port number. */
diff --git a/guava/src/com/google/common/net/HostSpecifier.java b/guava/src/com/google/common/net/HostSpecifier.java
index 7448944ab1..e568abd763 100644
--- a/guava/src/com/google/common/net/HostSpecifier.java
+++ b/guava/src/com/google/common/net/HostSpecifier.java
@@ -14,8 +14,6 @@
 
 package com.google.common.net;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Preconditions;
 import java.net.InetAddress;
 import java.text.ParseException;
@@ -41,8 +39,6 @@ import javax.annotation.CheckForNull;
  * @author Craig Berry
  * @since 5.0
  */
-@Beta
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class HostSpecifier {
 
diff --git a/guava/src/com/google/common/net/HttpHeaders.java b/guava/src/com/google/common/net/HttpHeaders.java
index f318da1514..4c31fdbde2 100644
--- a/guava/src/com/google/common/net/HttpHeaders.java
+++ b/guava/src/com/google/common/net/HttpHeaders.java
@@ -14,8 +14,6 @@
 
 package com.google.common.net;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 
 /**
  * Contains constant definitions for the HTTP header field names. See:
@@ -31,7 +29,6 @@ import com.google.common.annotations.GwtCompatible;
  * @author Kurt Alfred Kluever
  * @since 11.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class HttpHeaders {
   private HttpHeaders() {}
@@ -102,7 +99,6 @@ public final class HttpHeaders {
    *
    * @since 17.0
    */
-  @Beta
   public static final String FOLLOW_ONLY_WHEN_PRERENDER_SHOWN = "Follow-Only-When-Prerender-Shown";
   /** The HTTP {@code Host} header field name. */
   public static final String HOST = "Host";
@@ -357,7 +353,7 @@ public final class HttpHeaders {
    *
    * @since 27.1
    */
-  @Beta public static final String SOURCE_MAP = "SourceMap";
+  public static final String SOURCE_MAP = "SourceMap";
 
   /**
    * The HTTP <a href="http://tools.ietf.org/html/rfc6797#section-6.1">{@code
@@ -455,14 +451,14 @@ public final class HttpHeaders {
    *
    * @since 15.0
    */
-  @Beta public static final String PUBLIC_KEY_PINS = "Public-Key-Pins";
+  public static final String PUBLIC_KEY_PINS = "Public-Key-Pins";
   /**
    * The HTTP <a href="http://tools.ietf.org/html/draft-evans-palmer-key-pinning">{@code
    * Public-Key-Pins-Report-Only}</a> header field name.
    *
    * @since 15.0
    */
-  @Beta public static final String PUBLIC_KEY_PINS_REPORT_ONLY = "Public-Key-Pins-Report-Only";
+  public static final String PUBLIC_KEY_PINS_REPORT_ONLY = "Public-Key-Pins-Report-Only";
   /**
    * The HTTP {@code X-Request-ID} header field name.
    *
@@ -482,7 +478,7 @@ public final class HttpHeaders {
    *
    * @since 24.1
    */
-  @Beta public static final String X_DOWNLOAD_OPTIONS = "X-Download-Options";
+  public static final String X_DOWNLOAD_OPTIONS = "X-Download-Options";
   /** The HTTP {@code X-XSS-Protection} header field name. */
   public static final String X_XSS_PROTECTION = "X-XSS-Protection";
   /**
diff --git a/guava/src/com/google/common/net/InetAddresses.java b/guava/src/com/google/common/net/InetAddresses.java
index 4e2aa69953..c609d03957 100644
--- a/guava/src/com/google/common/net/InetAddresses.java
+++ b/guava/src/com/google/common/net/InetAddresses.java
@@ -17,8 +17,6 @@ package com.google.common.net;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.CharMatcher;
 import com.google.common.base.MoreObjects;
 import com.google.common.hash.Hashing;
@@ -95,8 +93,6 @@ import javax.annotation.CheckForNull;
  * @author Erik Kline
  * @since 5.0
  */
-@Beta
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class InetAddresses {
   private static final int IPV4_PART_COUNT = 4;
@@ -667,7 +663,6 @@ public final class InetAddresses {
    *
    * @since 5.0
    */
-  @Beta
   public static final class TeredoInfo {
     private final Inet4Address server;
     private final Inet4Address client;
diff --git a/guava/src/com/google/common/net/InternetDomainName.java b/guava/src/com/google/common/net/InternetDomainName.java
index 58734497db..bbd354ba60 100644
--- a/guava/src/com/google/common/net/InternetDomainName.java
+++ b/guava/src/com/google/common/net/InternetDomainName.java
@@ -18,15 +18,12 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Ascii;
 import com.google.common.base.CharMatcher;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
 import com.google.common.base.Splitter;
 import com.google.common.collect.ImmutableList;
-import com.google.errorprone.annotations.Immutable;
 import com.google.thirdparty.publicsuffix.PublicSuffixPatterns;
 import com.google.thirdparty.publicsuffix.PublicSuffixType;
 import java.util.List;
@@ -71,9 +68,6 @@ import javax.annotation.CheckForNull;
  * @author Catherine Berry
  * @since 5.0
  */
-@Beta
-@GwtCompatible(emulated = true)
-@Immutable
 @ElementTypesAreNonnullByDefault
 public final class InternetDomainName {
 
diff --git a/guava/src/com/google/common/net/MediaType.java b/guava/src/com/google/common/net/MediaType.java
index ca471616a9..2aa0985ea8 100644
--- a/guava/src/com/google/common/net/MediaType.java
+++ b/guava/src/com/google/common/net/MediaType.java
@@ -21,8 +21,6 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Ascii;
 import com.google.common.base.CharMatcher;
 import com.google.common.base.Function;
@@ -37,8 +35,6 @@ import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Multimaps;
-import com.google.errorprone.annotations.Immutable;
-import com.google.errorprone.annotations.concurrent.LazyInit;
 import java.nio.charset.Charset;
 import java.nio.charset.IllegalCharsetNameException;
 import java.nio.charset.UnsupportedCharsetException;
@@ -72,9 +68,6 @@ import javax.annotation.CheckForNull;
  * @since 12.0
  * @author Gregory Kick
  */
-@Beta
-@GwtCompatible
-@Immutable
 @ElementTypesAreNonnullByDefault
 public final class MediaType {
   private static final String CHARSET_ATTRIBUTE = "charset";
@@ -764,11 +757,11 @@ public final class MediaType {
   private final String subtype;
   private final ImmutableListMultimap<String, String> parameters;
 
-  @LazyInit @CheckForNull private String toString;
+  @CheckForNull private String toString;
 
-  @LazyInit private int hashCode;
+  private int hashCode;
 
-  @LazyInit @CheckForNull private Optional<Charset> parsedCharset;
+  @CheckForNull private Optional<Charset> parsedCharset;
 
   private MediaType(String type, String subtype, ImmutableListMultimap<String, String> parameters) {
     this.type = type;
diff --git a/guava/src/com/google/common/net/ParametricNullness.java b/guava/src/com/google/common/net/ParametricNullness.java
index acc3eab579..5491552487 100644
--- a/guava/src/com/google/common/net/ParametricNullness.java
+++ b/guava/src/com/google/common/net/ParametricNullness.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import static javax.annotation.meta.When.UNKNOWN;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -35,7 +34,6 @@ import javax.annotation.meta.TypeQualifierNickname;
  * href="https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/NullFromTypeParam.java">{@code
  * NullFromTypeParam}</a>). We use this to "undo" {@link ElementTypesAreNonnullByDefault}.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target({FIELD, METHOD, PARAMETER})
 @TypeQualifierNickname
diff --git a/guava/src/com/google/common/net/PercentEscaper.java b/guava/src/com/google/common/net/PercentEscaper.java
index 7c7de9bb36..9ac1b2be66 100644
--- a/guava/src/com/google/common/net/PercentEscaper.java
+++ b/guava/src/com/google/common/net/PercentEscaper.java
@@ -16,8 +16,6 @@ package com.google.common.net;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.escape.UnicodeEscaper;
 import javax.annotation.CheckForNull;
 
@@ -50,8 +48,6 @@ import javax.annotation.CheckForNull;
  * @author David Beaumont
  * @since 15.0
  */
-@Beta
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class PercentEscaper extends UnicodeEscaper {
 
diff --git a/guava/src/com/google/common/net/UrlEscapers.java b/guava/src/com/google/common/net/UrlEscapers.java
index c7e15efc6d..53db2115f3 100644
--- a/guava/src/com/google/common/net/UrlEscapers.java
+++ b/guava/src/com/google/common/net/UrlEscapers.java
@@ -14,7 +14,6 @@
 
 package com.google.common.net;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.escape.Escaper;
 
 /**
@@ -28,7 +27,6 @@ import com.google.common.escape.Escaper;
  * @author Chris Povirk
  * @since 15.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class UrlEscapers {
   private UrlEscapers() {}
diff --git a/guava/src/com/google/common/primitives/Booleans.java b/guava/src/com/google/common/primitives/Booleans.java
index 522049bfe3..588e822198 100644
--- a/guava/src/com/google/common/primitives/Booleans.java
+++ b/guava/src/com/google/common/primitives/Booleans.java
@@ -19,8 +19,6 @@ import static com.google.common.base.Preconditions.checkElementIndex;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 import java.util.AbstractList;
 import java.util.Arrays;
@@ -41,7 +39,6 @@ import javax.annotation.CheckForNull;
  * @author Kevin Bourrillion
  * @since 1.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class Booleans {
   private Booleans() {}
@@ -80,7 +77,6 @@ public final class Booleans {
    *
    * @since 21.0
    */
-  @Beta
   public static Comparator<Boolean> trueFirst() {
     return BooleanComparator.TRUE_FIRST;
   }
@@ -93,7 +89,6 @@ public final class Booleans {
    *
    * @since 21.0
    */
-  @Beta
   public static Comparator<Boolean> falseFirst() {
     return BooleanComparator.FALSE_FIRST;
   }
@@ -375,7 +370,6 @@ public final class Booleans {
     return new BooleanArrayAsList(backingArray);
   }
 
-  @GwtCompatible
   private static class BooleanArrayAsList extends AbstractList<Boolean>
       implements RandomAccess, Serializable {
     final boolean[] array;
@@ -510,7 +504,6 @@ public final class Booleans {
    *
    * @since 16.0
    */
-  @Beta
   public static int countTrue(boolean... values) {
     int count = 0;
     for (boolean value : values) {
diff --git a/guava/src/com/google/common/primitives/Bytes.java b/guava/src/com/google/common/primitives/Bytes.java
index 62997f34aa..67b1b5ec67 100644
--- a/guava/src/com/google/common/primitives/Bytes.java
+++ b/guava/src/com/google/common/primitives/Bytes.java
@@ -19,7 +19,6 @@ import static com.google.common.base.Preconditions.checkElementIndex;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
 
-import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 import java.util.AbstractList;
 import java.util.Arrays;
@@ -43,7 +42,6 @@ import javax.annotation.CheckForNull;
  */
 // TODO(kevinb): how to prevent warning on UnsignedBytes when building GWT
 // javadoc?
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class Bytes {
   private Bytes() {}
@@ -237,7 +235,6 @@ public final class Bytes {
     return new ByteArrayAsList(backingArray);
   }
 
-  @GwtCompatible
   private static class ByteArrayAsList extends AbstractList<Byte>
       implements RandomAccess, Serializable {
     final byte[] array;
diff --git a/guava/src/com/google/common/primitives/Chars.java b/guava/src/com/google/common/primitives/Chars.java
index 4a2e3a3449..0dd62ac6ed 100644
--- a/guava/src/com/google/common/primitives/Chars.java
+++ b/guava/src/com/google/common/primitives/Chars.java
@@ -19,9 +19,6 @@ import static com.google.common.base.Preconditions.checkElementIndex;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import java.io.Serializable;
 import java.util.AbstractList;
 import java.util.Arrays;
@@ -45,7 +42,6 @@ import javax.annotation.CheckForNull;
  * @author Kevin Bourrillion
  * @since 1.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class Chars {
   private Chars() {}
@@ -258,7 +254,6 @@ public final class Chars {
    * @throws IllegalArgumentException if {@code min > max}
    * @since 21.0
    */
-  @Beta
   public static char constrainToRange(char value, char min, char max) {
     checkArgument(min <= max, "min (%s) must be less than or equal to max (%s)", min, max);
     return value < min ? min : value < max ? value : max;
@@ -294,7 +289,7 @@ public final class Chars {
    * use a shared {@link java.nio.ByteBuffer} instance, or use {@link
    * com.google.common.io.ByteStreams#newDataOutput()} to get a growable buffer.
    */
-  @GwtIncompatible // doesn't work
+  // doesn't work
   public static byte[] toByteArray(char value) {
     return new byte[] {(byte) (value >> 8), (byte) value};
   }
@@ -309,7 +304,7 @@ public final class Chars {
    *
    * @throws IllegalArgumentException if {@code bytes} has fewer than 2 elements
    */
-  @GwtIncompatible // doesn't work
+  // doesn't work
   public static char fromByteArray(byte[] bytes) {
     checkArgument(bytes.length >= BYTES, "array too small: %s < %s", bytes.length, BYTES);
     return fromBytes(bytes[0], bytes[1]);
@@ -321,7 +316,7 @@ public final class Chars {
    *
    * @since 7.0
    */
-  @GwtIncompatible // doesn't work
+  // doesn't work
   public static char fromBytes(byte b1, byte b2) {
     return (char) ((b1 << 8) | (b2 & 0xFF));
   }
@@ -507,7 +502,6 @@ public final class Chars {
     return new CharArrayAsList(backingArray);
   }
 
-  @GwtCompatible
   private static class CharArrayAsList extends AbstractList<Character>
       implements RandomAccess, Serializable {
     final char[] array;
diff --git a/guava/src/com/google/common/primitives/Doubles.java b/guava/src/com/google/common/primitives/Doubles.java
index fab3cf610a..eb470b01e3 100644
--- a/guava/src/com/google/common/primitives/Doubles.java
+++ b/guava/src/com/google/common/primitives/Doubles.java
@@ -22,9 +22,6 @@ import static com.google.common.base.Strings.lenientFormat;
 import static java.lang.Double.NEGATIVE_INFINITY;
 import static java.lang.Double.POSITIVE_INFINITY;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Converter;
 import java.io.Serializable;
 import java.util.AbstractList;
@@ -48,7 +45,6 @@ import javax.annotation.CheckForNull;
  * @author Kevin Bourrillion
  * @since 1.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class Doubles extends DoublesMethodsForWeb {
   private Doubles() {}
@@ -211,8 +207,6 @@ public final class Doubles extends DoublesMethodsForWeb {
    *     the array
    * @throws IllegalArgumentException if {@code array} is empty
    */
-  @GwtIncompatible(
-      "Available in GWT! Annotation is to avoid conflict with GWT specialization of base class.")
   public static double min(double... array) {
     checkArgument(array.length > 0);
     double min = array[0];
@@ -231,8 +225,6 @@ public final class Doubles extends DoublesMethodsForWeb {
    *     in the array
    * @throws IllegalArgumentException if {@code array} is empty
    */
-  @GwtIncompatible(
-      "Available in GWT! Annotation is to avoid conflict with GWT specialization of base class.")
   public static double max(double... array) {
     checkArgument(array.length > 0);
     double max = array[0];
@@ -255,7 +247,6 @@ public final class Doubles extends DoublesMethodsForWeb {
    * @throws IllegalArgumentException if {@code min > max}
    * @since 21.0
    */
-  @Beta
   public static double constrainToRange(double value, double min, double max) {
     // avoid auto-boxing by not using Preconditions.checkArgument(); see Guava issue 3984
     // Reject NaN by testing for the good case (min <= max) instead of the bad (min > max).
@@ -320,7 +311,6 @@ public final class Doubles extends DoublesMethodsForWeb {
    *
    * @since 16.0
    */
-  @Beta
   public static Converter<String, Double> stringConverter() {
     return DoubleConverter.INSTANCE;
   }
@@ -522,7 +512,6 @@ public final class Doubles extends DoublesMethodsForWeb {
     return new DoubleArrayAsList(backingArray);
   }
 
-  @GwtCompatible
   private static class DoubleArrayAsList extends AbstractList<Double>
       implements RandomAccess, Serializable {
     final double[] array;
@@ -662,12 +651,12 @@ public final class Doubles extends DoublesMethodsForWeb {
    * inputs. All valid inputs must pass this regex, but it's semantically fine if not all inputs
    * that pass this regex are valid -- only a performance hit is incurred, not a semantics bug.
    */
-  @GwtIncompatible // regular expressions
+  // regular expressions
   static final
   java.util.regex.Pattern
       FLOATING_POINT_PATTERN = fpPattern();
 
-  @GwtIncompatible // regular expressions
+  // regular expressions
   private static
   java.util.regex.Pattern
       fpPattern() {
@@ -708,8 +697,7 @@ public final class Doubles extends DoublesMethodsForWeb {
    * @throws NullPointerException if {@code string} is {@code null}
    * @since 14.0
    */
-  @Beta
-  @GwtIncompatible // regular expressions
+  // regular expressions
   @CheckForNull
   public static Double tryParse(String string) {
     if (FLOATING_POINT_PATTERN.matcher(string).matches()) {
diff --git a/guava/src/com/google/common/primitives/DoublesMethodsForWeb.java b/guava/src/com/google/common/primitives/DoublesMethodsForWeb.java
index 949cbe0f5a..3023272004 100644
--- a/guava/src/com/google/common/primitives/DoublesMethodsForWeb.java
+++ b/guava/src/com/google/common/primitives/DoublesMethodsForWeb.java
@@ -14,12 +14,10 @@
 
 package com.google.common.primitives;
 
-import com.google.common.annotations.GwtCompatible;
 
 /**
  * Holder for web specializations of methods of {@code Doubles}. Intended to be empty for regular
  * version.
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 abstract class DoublesMethodsForWeb {}
diff --git a/guava/src/com/google/common/primitives/ElementTypesAreNonnullByDefault.java b/guava/src/com/google/common/primitives/ElementTypesAreNonnullByDefault.java
index 44f6869c7c..c9c38f133b 100644
--- a/guava/src/com/google/common/primitives/ElementTypesAreNonnullByDefault.java
+++ b/guava/src/com/google/common/primitives/ElementTypesAreNonnullByDefault.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.ElementType.TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -33,7 +32,6 @@ import javax.annotation.meta.TypeQualifierDefault;
  * unfortunately includes type-variable usages, so we also provide {@link ParametricNullness} to
  * "undo" it as best we can.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target(TYPE)
 @TypeQualifierDefault({FIELD, METHOD, PARAMETER})
diff --git a/guava/src/com/google/common/primitives/Floats.java b/guava/src/com/google/common/primitives/Floats.java
index b038cb2896..7442e41ff8 100644
--- a/guava/src/com/google/common/primitives/Floats.java
+++ b/guava/src/com/google/common/primitives/Floats.java
@@ -22,9 +22,6 @@ import static com.google.common.base.Strings.lenientFormat;
 import static java.lang.Float.NEGATIVE_INFINITY;
 import static java.lang.Float.POSITIVE_INFINITY;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Converter;
 import java.io.Serializable;
 import java.util.AbstractList;
@@ -46,7 +43,6 @@ import javax.annotation.CheckForNull;
  * @author Kevin Bourrillion
  * @since 1.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class Floats extends FloatsMethodsForWeb {
   private Floats() {}
@@ -206,8 +202,6 @@ public final class Floats extends FloatsMethodsForWeb {
    *     the array
    * @throws IllegalArgumentException if {@code array} is empty
    */
-  @GwtIncompatible(
-      "Available in GWT! Annotation is to avoid conflict with GWT specialization of base class.")
   public static float min(float... array) {
     checkArgument(array.length > 0);
     float min = array[0];
@@ -226,8 +220,6 @@ public final class Floats extends FloatsMethodsForWeb {
    *     in the array
    * @throws IllegalArgumentException if {@code array} is empty
    */
-  @GwtIncompatible(
-      "Available in GWT! Annotation is to avoid conflict with GWT specialization of base class.")
   public static float max(float... array) {
     checkArgument(array.length > 0);
     float max = array[0];
@@ -250,7 +242,6 @@ public final class Floats extends FloatsMethodsForWeb {
    * @throws IllegalArgumentException if {@code min > max}
    * @since 21.0
    */
-  @Beta
   public static float constrainToRange(float value, float min, float max) {
     // avoid auto-boxing by not using Preconditions.checkArgument(); see Guava issue 3984
     // Reject NaN by testing for the good case (min <= max) instead of the bad (min > max).
@@ -315,7 +306,6 @@ public final class Floats extends FloatsMethodsForWeb {
    *
    * @since 16.0
    */
-  @Beta
   public static Converter<String, Float> stringConverter() {
     return FloatConverter.INSTANCE;
   }
@@ -514,7 +504,6 @@ public final class Floats extends FloatsMethodsForWeb {
     return new FloatArrayAsList(backingArray);
   }
 
-  @GwtCompatible
   private static class FloatArrayAsList extends AbstractList<Float>
       implements RandomAccess, Serializable {
     final float[] array;
@@ -660,8 +649,7 @@ public final class Floats extends FloatsMethodsForWeb {
    * @throws NullPointerException if {@code string} is {@code null}
    * @since 14.0
    */
-  @Beta
-  @GwtIncompatible // regular expressions
+  // regular expressions
   @CheckForNull
   public static Float tryParse(String string) {
     if (Doubles.FLOATING_POINT_PATTERN.matcher(string).matches()) {
diff --git a/guava/src/com/google/common/primitives/FloatsMethodsForWeb.java b/guava/src/com/google/common/primitives/FloatsMethodsForWeb.java
index 801e2f3ef1..2d2eb45c66 100644
--- a/guava/src/com/google/common/primitives/FloatsMethodsForWeb.java
+++ b/guava/src/com/google/common/primitives/FloatsMethodsForWeb.java
@@ -14,12 +14,10 @@
 
 package com.google.common.primitives;
 
-import com.google.common.annotations.GwtCompatible;
 
 /**
  * Holder for web specializations of methods of {@code Floats}. Intended to be empty for regular
  * version.
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 abstract class FloatsMethodsForWeb {}
diff --git a/guava/src/com/google/common/primitives/ImmutableDoubleArray.java b/guava/src/com/google/common/primitives/ImmutableDoubleArray.java
index 9731c11315..616d60265d 100644
--- a/guava/src/com/google/common/primitives/ImmutableDoubleArray.java
+++ b/guava/src/com/google/common/primitives/ImmutableDoubleArray.java
@@ -17,12 +17,7 @@ package com.google.common.primitives;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Preconditions;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.CheckReturnValue;
-import com.google.errorprone.annotations.Immutable;
 import java.io.Serializable;
 import java.util.AbstractList;
 import java.util.Arrays;
@@ -85,9 +80,6 @@ import javax.annotation.CheckForNull;
  *
  * @since 22.0
  */
-@Beta
-@GwtCompatible
-@Immutable
 @ElementTypesAreNonnullByDefault
 public final class ImmutableDoubleArray implements Serializable {
   private static final ImmutableDoubleArray EMPTY = new ImmutableDoubleArray(new double[0]);
@@ -210,7 +202,6 @@ public final class ImmutableDoubleArray implements Serializable {
    * A builder for {@link ImmutableDoubleArray} instances; obtained using {@link
    * ImmutableDoubleArray#builder}.
    */
-  @CanIgnoreReturnValue
   public static final class Builder {
     private double[] array;
     private int count = 0; // <= array.length
@@ -323,7 +314,6 @@ public final class ImmutableDoubleArray implements Serializable {
      * no data is copied as part of this step, but this may occupy more memory than strictly
      * necessary. To copy the data to a right-sized backing array, use {@code .build().trimmed()}.
      */
-    @CheckReturnValue
     public ImmutableDoubleArray build() {
       return count == 0 ? EMPTY : new ImmutableDoubleArray(array, 0, count);
     }
diff --git a/guava/src/com/google/common/primitives/ImmutableIntArray.java b/guava/src/com/google/common/primitives/ImmutableIntArray.java
index cc3c671442..325ed6defc 100644
--- a/guava/src/com/google/common/primitives/ImmutableIntArray.java
+++ b/guava/src/com/google/common/primitives/ImmutableIntArray.java
@@ -17,12 +17,7 @@ package com.google.common.primitives;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Preconditions;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.CheckReturnValue;
-import com.google.errorprone.annotations.Immutable;
 import java.io.Serializable;
 import java.util.AbstractList;
 import java.util.Arrays;
@@ -85,9 +80,6 @@ import javax.annotation.CheckForNull;
  *
  * @since 22.0
  */
-@Beta
-@GwtCompatible
-@Immutable
 @ElementTypesAreNonnullByDefault
 public final class ImmutableIntArray implements Serializable {
   private static final ImmutableIntArray EMPTY = new ImmutableIntArray(new int[0]);
@@ -207,7 +199,6 @@ public final class ImmutableIntArray implements Serializable {
    * A builder for {@link ImmutableIntArray} instances; obtained using {@link
    * ImmutableIntArray#builder}.
    */
-  @CanIgnoreReturnValue
   public static final class Builder {
     private int[] array;
     private int count = 0; // <= array.length
@@ -320,7 +311,6 @@ public final class ImmutableIntArray implements Serializable {
      * no data is copied as part of this step, but this may occupy more memory than strictly
      * necessary. To copy the data to a right-sized backing array, use {@code .build().trimmed()}.
      */
-    @CheckReturnValue
     public ImmutableIntArray build() {
       return count == 0 ? EMPTY : new ImmutableIntArray(array, 0, count);
     }
diff --git a/guava/src/com/google/common/primitives/ImmutableLongArray.java b/guava/src/com/google/common/primitives/ImmutableLongArray.java
index c8f70375d2..9c00b15205 100644
--- a/guava/src/com/google/common/primitives/ImmutableLongArray.java
+++ b/guava/src/com/google/common/primitives/ImmutableLongArray.java
@@ -17,12 +17,7 @@ package com.google.common.primitives;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Preconditions;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.CheckReturnValue;
-import com.google.errorprone.annotations.Immutable;
 import java.io.Serializable;
 import java.util.AbstractList;
 import java.util.Arrays;
@@ -85,9 +80,6 @@ import javax.annotation.CheckForNull;
  *
  * @since 22.0
  */
-@Beta
-@GwtCompatible
-@Immutable
 @ElementTypesAreNonnullByDefault
 public final class ImmutableLongArray implements Serializable {
   private static final ImmutableLongArray EMPTY = new ImmutableLongArray(new long[0]);
@@ -209,7 +201,6 @@ public final class ImmutableLongArray implements Serializable {
    * A builder for {@link ImmutableLongArray} instances; obtained using {@link
    * ImmutableLongArray#builder}.
    */
-  @CanIgnoreReturnValue
   public static final class Builder {
     private long[] array;
     private int count = 0; // <= array.length
@@ -322,7 +313,6 @@ public final class ImmutableLongArray implements Serializable {
      * no data is copied as part of this step, but this may occupy more memory than strictly
      * necessary. To copy the data to a right-sized backing array, use {@code .build().trimmed()}.
      */
-    @CheckReturnValue
     public ImmutableLongArray build() {
       return count == 0 ? EMPTY : new ImmutableLongArray(array, 0, count);
     }
diff --git a/guava/src/com/google/common/primitives/Ints.java b/guava/src/com/google/common/primitives/Ints.java
index b63b0f946e..7240442d4d 100644
--- a/guava/src/com/google/common/primitives/Ints.java
+++ b/guava/src/com/google/common/primitives/Ints.java
@@ -19,9 +19,6 @@ import static com.google.common.base.Preconditions.checkElementIndex;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Converter;
 import java.io.Serializable;
 import java.util.AbstractList;
@@ -45,7 +42,6 @@ import javax.annotation.CheckForNull;
  * @author Kevin Bourrillion
  * @since 1.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class Ints extends IntsMethodsForWeb {
   private Ints() {}
@@ -222,8 +218,6 @@ public final class Ints extends IntsMethodsForWeb {
    *     the array
    * @throws IllegalArgumentException if {@code array} is empty
    */
-  @GwtIncompatible(
-      "Available in GWT! Annotation is to avoid conflict with GWT specialization of base class.")
   public static int min(int... array) {
     checkArgument(array.length > 0);
     int min = array[0];
@@ -243,8 +237,6 @@ public final class Ints extends IntsMethodsForWeb {
    *     in the array
    * @throws IllegalArgumentException if {@code array} is empty
    */
-  @GwtIncompatible(
-      "Available in GWT! Annotation is to avoid conflict with GWT specialization of base class.")
   public static int max(int... array) {
     checkArgument(array.length > 0);
     int max = array[0];
@@ -269,7 +261,6 @@ public final class Ints extends IntsMethodsForWeb {
    * @throws IllegalArgumentException if {@code min > max}
    * @since 21.0
    */
-  @Beta
   public static int constrainToRange(int value, int min, int max) {
     checkArgument(min <= max, "min (%s) must be less than or equal to max (%s)", min, max);
     return Math.min(Math.max(value, min), max);
@@ -374,7 +365,6 @@ public final class Ints extends IntsMethodsForWeb {
    *
    * @since 16.0
    */
-  @Beta
   public static Converter<String, Integer> stringConverter() {
     return IntConverter.INSTANCE;
   }
@@ -562,7 +552,6 @@ public final class Ints extends IntsMethodsForWeb {
     return new IntArrayAsList(backingArray);
   }
 
-  @GwtCompatible
   private static class IntArrayAsList extends AbstractList<Integer>
       implements RandomAccess, Serializable {
     final int[] array;
@@ -713,7 +702,6 @@ public final class Ints extends IntsMethodsForWeb {
    * @throws NullPointerException if {@code string} is {@code null}
    * @since 11.0
    */
-  @Beta
   @CheckForNull
   public static Integer tryParse(String string) {
     return tryParse(string, 10);
@@ -739,7 +727,6 @@ public final class Ints extends IntsMethodsForWeb {
    * @throws NullPointerException if {@code string} is {@code null}
    * @since 19.0
    */
-  @Beta
   @CheckForNull
   public static Integer tryParse(String string, int radix) {
     Long result = Longs.tryParse(string, radix);
diff --git a/guava/src/com/google/common/primitives/IntsMethodsForWeb.java b/guava/src/com/google/common/primitives/IntsMethodsForWeb.java
index c59c6b0586..85bd1bf4a3 100644
--- a/guava/src/com/google/common/primitives/IntsMethodsForWeb.java
+++ b/guava/src/com/google/common/primitives/IntsMethodsForWeb.java
@@ -14,12 +14,10 @@
 
 package com.google.common.primitives;
 
-import com.google.common.annotations.GwtCompatible;
 
 /**
  * Holder for web specializations of methods of {@code Ints}. Intended to be empty for regular
  * version.
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 abstract class IntsMethodsForWeb {}
diff --git a/guava/src/com/google/common/primitives/Longs.java b/guava/src/com/google/common/primitives/Longs.java
index 98c055e27a..8e55348585 100644
--- a/guava/src/com/google/common/primitives/Longs.java
+++ b/guava/src/com/google/common/primitives/Longs.java
@@ -19,8 +19,6 @@ import static com.google.common.base.Preconditions.checkElementIndex;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Converter;
 import java.io.Serializable;
 import java.util.AbstractList;
@@ -44,7 +42,6 @@ import javax.annotation.CheckForNull;
  * @author Kevin Bourrillion
  * @since 1.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class Longs {
   private Longs() {}
@@ -236,7 +233,6 @@ public final class Longs {
    * @throws IllegalArgumentException if {@code min > max}
    * @since 21.0
    */
-  @Beta
   public static long constrainToRange(long value, long min, long max) {
     checkArgument(min <= max, "min (%s) must be less than or equal to max (%s)", min, max);
     return Math.min(Math.max(value, min), max);
@@ -363,7 +359,6 @@ public final class Longs {
    * @throws NullPointerException if {@code string} is {@code null}
    * @since 14.0
    */
-  @Beta
   @CheckForNull
   public static Long tryParse(String string) {
     return tryParse(string, 10);
@@ -389,7 +384,6 @@ public final class Longs {
    * @throws NullPointerException if {@code string} is {@code null}
    * @since 19.0
    */
-  @Beta
   @CheckForNull
   public static Long tryParse(String string, int radix) {
     if (checkNotNull(string).isEmpty()) {
@@ -469,7 +463,6 @@ public final class Longs {
    *
    * @since 16.0
    */
-  @Beta
   public static Converter<String, Long> stringConverter() {
     return LongConverter.INSTANCE;
   }
@@ -658,7 +651,6 @@ public final class Longs {
     return new LongArrayAsList(backingArray);
   }
 
-  @GwtCompatible
   private static class LongArrayAsList extends AbstractList<Long>
       implements RandomAccess, Serializable {
     final long[] array;
diff --git a/guava/src/com/google/common/primitives/ParametricNullness.java b/guava/src/com/google/common/primitives/ParametricNullness.java
index 17d606c2c9..b23e60bb24 100644
--- a/guava/src/com/google/common/primitives/ParametricNullness.java
+++ b/guava/src/com/google/common/primitives/ParametricNullness.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import static javax.annotation.meta.When.UNKNOWN;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -35,7 +34,6 @@ import javax.annotation.meta.TypeQualifierNickname;
  * href="https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/NullFromTypeParam.java">{@code
  * NullFromTypeParam}</a>). We use this to "undo" {@link ElementTypesAreNonnullByDefault}.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target({FIELD, METHOD, PARAMETER})
 @TypeQualifierNickname
diff --git a/guava/src/com/google/common/primitives/ParseRequest.java b/guava/src/com/google/common/primitives/ParseRequest.java
index a102d69b06..c63bcb6724 100644
--- a/guava/src/com/google/common/primitives/ParseRequest.java
+++ b/guava/src/com/google/common/primitives/ParseRequest.java
@@ -14,10 +14,8 @@
 
 package com.google.common.primitives;
 
-import com.google.common.annotations.GwtCompatible;
 
 /** A string to be parsed as a number and the radix to interpret it in. */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 final class ParseRequest {
   final String rawValue;
diff --git a/guava/src/com/google/common/primitives/Platform.java b/guava/src/com/google/common/primitives/Platform.java
index ca31689222..1fd177b5d5 100644
--- a/guava/src/com/google/common/primitives/Platform.java
+++ b/guava/src/com/google/common/primitives/Platform.java
@@ -14,10 +14,8 @@
 
 package com.google.common.primitives;
 
-import com.google.common.annotations.GwtCompatible;
 
 /** Methods factored out so that they can be emulated differently in GWT. */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 final class Platform {
   private static final java.util.logging.Logger logger =
diff --git a/guava/src/com/google/common/primitives/Primitives.java b/guava/src/com/google/common/primitives/Primitives.java
index 7ceed03655..e7945c4771 100644
--- a/guava/src/com/google/common/primitives/Primitives.java
+++ b/guava/src/com/google/common/primitives/Primitives.java
@@ -16,7 +16,6 @@ package com.google.common.primitives;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtIncompatible;
 import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.Map;
@@ -29,7 +28,6 @@ import java.util.Set;
  * @author Kevin Bourrillion
  * @since 1.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class Primitives {
   private Primitives() {}
diff --git a/guava/src/com/google/common/primitives/Shorts.java b/guava/src/com/google/common/primitives/Shorts.java
index 09e0f7cfc3..ad250e10bc 100644
--- a/guava/src/com/google/common/primitives/Shorts.java
+++ b/guava/src/com/google/common/primitives/Shorts.java
@@ -19,9 +19,6 @@ import static com.google.common.base.Preconditions.checkElementIndex;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Converter;
 import java.io.Serializable;
 import java.util.AbstractList;
@@ -43,7 +40,6 @@ import javax.annotation.CheckForNull;
  * @author Kevin Bourrillion
  * @since 1.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class Shorts extends ShortsMethodsForWeb {
   private Shorts() {}
@@ -219,8 +215,6 @@ public final class Shorts extends ShortsMethodsForWeb {
    *     the array
    * @throws IllegalArgumentException if {@code array} is empty
    */
-  @GwtIncompatible(
-      "Available in GWT! Annotation is to avoid conflict with GWT specialization of base class.")
   public static short min(short... array) {
     checkArgument(array.length > 0);
     short min = array[0];
@@ -240,8 +234,6 @@ public final class Shorts extends ShortsMethodsForWeb {
    *     in the array
    * @throws IllegalArgumentException if {@code array} is empty
    */
-  @GwtIncompatible(
-      "Available in GWT! Annotation is to avoid conflict with GWT specialization of base class.")
   public static short max(short... array) {
     checkArgument(array.length > 0);
     short max = array[0];
@@ -266,7 +258,6 @@ public final class Shorts extends ShortsMethodsForWeb {
    * @throws IllegalArgumentException if {@code min > max}
    * @since 21.0
    */
-  @Beta
   public static short constrainToRange(short value, short min, short max) {
     checkArgument(min <= max, "min (%s) must be less than or equal to max (%s)", min, max);
     return value < min ? min : value < max ? value : max;
@@ -303,7 +294,7 @@ public final class Shorts extends ShortsMethodsForWeb {
    * use a shared {@link java.nio.ByteBuffer} instance, or use {@link
    * com.google.common.io.ByteStreams#newDataOutput()} to get a growable buffer.
    */
-  @GwtIncompatible // doesn't work
+  // doesn't work
   public static byte[] toByteArray(short value) {
     return new byte[] {(byte) (value >> 8), (byte) value};
   }
@@ -318,7 +309,7 @@ public final class Shorts extends ShortsMethodsForWeb {
    *
    * @throws IllegalArgumentException if {@code bytes} has fewer than 2 elements
    */
-  @GwtIncompatible // doesn't work
+  // doesn't work
   public static short fromByteArray(byte[] bytes) {
     checkArgument(bytes.length >= BYTES, "array too small: %s < %s", bytes.length, BYTES);
     return fromBytes(bytes[0], bytes[1]);
@@ -330,7 +321,7 @@ public final class Shorts extends ShortsMethodsForWeb {
    *
    * @since 7.0
    */
-  @GwtIncompatible // doesn't work
+  // doesn't work
   public static short fromBytes(byte b1, byte b2) {
     return (short) ((b1 << 8) | (b2 & 0xFF));
   }
@@ -372,7 +363,6 @@ public final class Shorts extends ShortsMethodsForWeb {
    *
    * @since 16.0
    */
-  @Beta
   public static Converter<String, Short> stringConverter() {
     return ShortConverter.INSTANCE;
   }
@@ -559,7 +549,6 @@ public final class Shorts extends ShortsMethodsForWeb {
     return new ShortArrayAsList(backingArray);
   }
 
-  @GwtCompatible
   private static class ShortArrayAsList extends AbstractList<Short>
       implements RandomAccess, Serializable {
     final short[] array;
diff --git a/guava/src/com/google/common/primitives/ShortsMethodsForWeb.java b/guava/src/com/google/common/primitives/ShortsMethodsForWeb.java
index bb0ff103ce..aeb0825f9b 100644
--- a/guava/src/com/google/common/primitives/ShortsMethodsForWeb.java
+++ b/guava/src/com/google/common/primitives/ShortsMethodsForWeb.java
@@ -14,12 +14,10 @@
 
 package com.google.common.primitives;
 
-import com.google.common.annotations.GwtCompatible;
 
 /**
  * Holder for web specializations of methods of {@code Shorts}. Intended to be empty for regular
  * version.
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 abstract class ShortsMethodsForWeb {}
diff --git a/guava/src/com/google/common/primitives/SignedBytes.java b/guava/src/com/google/common/primitives/SignedBytes.java
index 5fabaab6bd..9416d83b3d 100644
--- a/guava/src/com/google/common/primitives/SignedBytes.java
+++ b/guava/src/com/google/common/primitives/SignedBytes.java
@@ -18,7 +18,6 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.Arrays;
 import java.util.Comparator;
 
@@ -35,7 +34,6 @@ import java.util.Comparator;
  */
 // TODO(kevinb): how to prevent warning on UnsignedBytes when building GWT
 // javadoc?
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class SignedBytes {
   private SignedBytes() {}
diff --git a/guava/src/com/google/common/primitives/UnsignedBytes.java b/guava/src/com/google/common/primitives/UnsignedBytes.java
index 2fc47d7a4a..6fe88a68b9 100644
--- a/guava/src/com/google/common/primitives/UnsignedBytes.java
+++ b/guava/src/com/google/common/primitives/UnsignedBytes.java
@@ -19,10 +19,6 @@ import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.nio.ByteOrder;
 import java.util.Arrays;
 import java.util.Comparator;
@@ -42,7 +38,6 @@ import java.util.Comparator;
  * @author Louis Wasserman
  * @since 1.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class UnsignedBytes {
   private UnsignedBytes() {}
@@ -83,7 +78,6 @@ public final class UnsignedBytes {
    * @return the {@code byte} value that, when treated as unsigned, equals {@code value}
    * @throws IllegalArgumentException if {@code value} is negative or greater than 255
    */
-  @CanIgnoreReturnValue
   public static byte checkedCast(long value) {
     checkArgument(value >> Byte.SIZE == 0, "out of range: %s", value);
     return (byte) value;
@@ -166,7 +160,6 @@ public final class UnsignedBytes {
    *
    * @since 13.0
    */
-  @Beta
   public static String toString(byte x) {
     return toString(x, 10);
   }
@@ -181,7 +174,6 @@ public final class UnsignedBytes {
    *     and {@link Character#MAX_RADIX}.
    * @since 13.0
    */
-  @Beta
   public static String toString(byte x, int radix) {
     checkArgument(
         radix >= Character.MIN_RADIX && radix <= Character.MAX_RADIX,
@@ -200,8 +192,6 @@ public final class UnsignedBytes {
    *     Byte#parseByte(String)})
    * @since 13.0
    */
-  @Beta
-  @CanIgnoreReturnValue
   public static byte parseUnsignedByte(String string) {
     return parseUnsignedByte(string, 10);
   }
@@ -218,8 +208,6 @@ public final class UnsignedBytes {
    *     Byte#parseByte(String)})
    * @since 13.0
    */
-  @Beta
-  @CanIgnoreReturnValue
   public static byte parseUnsignedByte(String string, int radix) {
     int parse = Integer.parseInt(checkNotNull(string), radix);
     // We need to throw a NumberFormatException, so we have to duplicate checkedCast. =(
@@ -272,7 +260,6 @@ public final class UnsignedBytes {
     return LexicographicalComparatorHolder.BEST_COMPARATOR;
   }
 
-  @VisibleForTesting
   static Comparator<byte[]> lexicographicalComparatorJavaImpl() {
     return LexicographicalComparatorHolder.PureJavaComparator.INSTANCE;
   }
@@ -284,7 +271,6 @@ public final class UnsignedBytes {
    * <p>Uses reflection to gracefully fall back to the Java implementation if {@code Unsafe} isn't
    * available.
    */
-  @VisibleForTesting
   static class LexicographicalComparatorHolder {
     static final String UNSAFE_COMPARATOR_NAME =
         LexicographicalComparatorHolder.class.getName() + "$UnsafeComparator";
diff --git a/guava/src/com/google/common/primitives/UnsignedInteger.java b/guava/src/com/google/common/primitives/UnsignedInteger.java
index 0b30cef3f4..33b604da8b 100644
--- a/guava/src/com/google/common/primitives/UnsignedInteger.java
+++ b/guava/src/com/google/common/primitives/UnsignedInteger.java
@@ -20,8 +20,6 @@ import static com.google.common.primitives.UnsignedInts.INT_MASK;
 import static com.google.common.primitives.UnsignedInts.compare;
 import static com.google.common.primitives.UnsignedInts.toLong;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import java.math.BigInteger;
 import javax.annotation.CheckForNull;
 
@@ -38,7 +36,6 @@ import javax.annotation.CheckForNull;
  * @author Louis Wasserman
  * @since 11.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class UnsignedInteger extends Number implements Comparable<UnsignedInteger> {
   public static final UnsignedInteger ZERO = fromIntBits(0);
@@ -143,7 +140,7 @@ public final class UnsignedInteger extends Number implements Comparable<Unsigned
    *
    * @since 14.0
    */
-  @GwtIncompatible // Does not truncate correctly
+  // Does not truncate correctly
   public UnsignedInteger times(UnsignedInteger val) {
     // TODO(lowasser): make this GWT-compatible
     return fromIntBits(value * checkNotNull(val).value);
diff --git a/guava/src/com/google/common/primitives/UnsignedInts.java b/guava/src/com/google/common/primitives/UnsignedInts.java
index ec6474e20f..4df9cd2459 100644
--- a/guava/src/com/google/common/primitives/UnsignedInts.java
+++ b/guava/src/com/google/common/primitives/UnsignedInts.java
@@ -18,9 +18,6 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Arrays;
 import java.util.Comparator;
 
@@ -45,8 +42,6 @@ import java.util.Comparator;
  * @author Louis Wasserman
  * @since 11.0
  */
-@Beta
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class UnsignedInts {
   static final long INT_MASK = 0xffffffffL;
@@ -312,7 +307,6 @@ public final class UnsignedInts {
    * @throws NumberFormatException if the string does not contain a valid unsigned {@code int} value
    * @since 13.0
    */
-  @CanIgnoreReturnValue
   public static int decode(String stringValue) {
     ParseRequest request = ParseRequest.fromString(stringValue);
 
@@ -335,7 +329,6 @@ public final class UnsignedInts {
    * @throws NullPointerException if {@code s} is null (in contrast to {@link
    *     Integer#parseInt(String)})
    */
-  @CanIgnoreReturnValue
   public static int parseUnsignedInt(String s) {
     return parseUnsignedInt(s, 10);
   }
@@ -353,7 +346,6 @@ public final class UnsignedInts {
    * @throws NullPointerException if {@code s} is null (in contrast to {@link
    *     Integer#parseInt(String)})
    */
-  @CanIgnoreReturnValue
   public static int parseUnsignedInt(String string, int radix) {
     checkNotNull(string);
     long result = Long.parseLong(string, radix);
diff --git a/guava/src/com/google/common/primitives/UnsignedLong.java b/guava/src/com/google/common/primitives/UnsignedLong.java
index d803634f49..51a9f64368 100644
--- a/guava/src/com/google/common/primitives/UnsignedLong.java
+++ b/guava/src/com/google/common/primitives/UnsignedLong.java
@@ -17,8 +17,6 @@ package com.google.common.primitives;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.Serializable;
 import java.math.BigInteger;
 import javax.annotation.CheckForNull;
@@ -37,7 +35,6 @@ import javax.annotation.CheckForNull;
  * @author Colin Evans
  * @since 11.0
  */
-@GwtCompatible(serializable = true)
 @ElementTypesAreNonnullByDefault
 public final class UnsignedLong extends Number implements Comparable<UnsignedLong>, Serializable {
 
@@ -77,7 +74,6 @@ public final class UnsignedLong extends Number implements Comparable<UnsignedLon
    * @throws IllegalArgumentException if {@code value} is negative
    * @since 14.0
    */
-  @CanIgnoreReturnValue
   public static UnsignedLong valueOf(long value) {
     checkArgument(value >= 0, "value (%s) is outside the range for an unsigned long value", value);
     return fromLongBits(value);
@@ -89,7 +85,6 @@ public final class UnsignedLong extends Number implements Comparable<UnsignedLon
    *
    * @throws IllegalArgumentException if {@code value} is negative or {@code value >= 2^64}
    */
-  @CanIgnoreReturnValue
   public static UnsignedLong valueOf(BigInteger value) {
     checkNotNull(value);
     checkArgument(
@@ -106,7 +101,6 @@ public final class UnsignedLong extends Number implements Comparable<UnsignedLon
    * @throws NumberFormatException if the string does not contain a parsable unsigned {@code long}
    *     value
    */
-  @CanIgnoreReturnValue
   public static UnsignedLong valueOf(String string) {
     return valueOf(string, 10);
   }
@@ -119,7 +113,6 @@ public final class UnsignedLong extends Number implements Comparable<UnsignedLon
    *     value, or {@code radix} is not between {@link Character#MIN_RADIX} and {@link
    *     Character#MAX_RADIX}
    */
-  @CanIgnoreReturnValue
   public static UnsignedLong valueOf(String string, int radix) {
     return fromLongBits(UnsignedLongs.parseUnsignedLong(string, radix));
   }
diff --git a/guava/src/com/google/common/primitives/UnsignedLongs.java b/guava/src/com/google/common/primitives/UnsignedLongs.java
index 31c51cc346..5f18b6170e 100644
--- a/guava/src/com/google/common/primitives/UnsignedLongs.java
+++ b/guava/src/com/google/common/primitives/UnsignedLongs.java
@@ -18,9 +18,6 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.math.BigInteger;
 import java.util.Arrays;
 import java.util.Comparator;
@@ -48,8 +45,6 @@ import java.util.Comparator;
  * @author Colin Evans
  * @since 10.0
  */
-@Beta
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class UnsignedLongs {
   private UnsignedLongs() {}
@@ -316,7 +311,6 @@ public final class UnsignedLongs {
    * @throws NullPointerException if {@code string} is null (in contrast to {@link
    *     Long#parseLong(String)})
    */
-  @CanIgnoreReturnValue
   public static long parseUnsignedLong(String string) {
     return parseUnsignedLong(string, 10);
   }
@@ -334,7 +328,6 @@ public final class UnsignedLongs {
    * @throws NullPointerException if {@code string} is null (in contrast to {@link
    *     Long#parseLong(String)})
    */
-  @CanIgnoreReturnValue
   public static long parseUnsignedLong(String string, int radix) {
     checkNotNull(string);
     if (string.length() == 0) {
@@ -376,7 +369,6 @@ public final class UnsignedLongs {
    *     value
    * @since 13.0
    */
-  @CanIgnoreReturnValue
   public static long decode(String stringValue) {
     ParseRequest request = ParseRequest.fromString(stringValue);
 
diff --git a/guava/src/com/google/common/primitives/package-info.java b/guava/src/com/google/common/primitives/package-info.java
index 9504fa79be..e04d08cab0 100644
--- a/guava/src/com/google/common/primitives/package-info.java
+++ b/guava/src/com/google/common/primitives/package-info.java
@@ -61,8 +61,6 @@
  * </ul>
  */
 @ParametersAreNonnullByDefault
-@CheckReturnValue
 package com.google.common.primitives;
 
-import com.google.errorprone.annotations.CheckReturnValue;
 import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/guava/src/com/google/common/reflect/AbstractInvocationHandler.java b/guava/src/com/google/common/reflect/AbstractInvocationHandler.java
index 4666f992c3..cb19220ea1 100644
--- a/guava/src/com/google/common/reflect/AbstractInvocationHandler.java
+++ b/guava/src/com/google/common/reflect/AbstractInvocationHandler.java
@@ -14,13 +14,11 @@
 
 package com.google.common.reflect;
 
-import com.google.common.annotations.Beta;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.util.Arrays;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Abstract implementation of {@link InvocationHandler} that handles {@link Object#equals}, {@link
@@ -39,7 +37,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Ben Yu
  * @since 12.0
  */
-@Beta
 @ElementTypesAreNonnullByDefault
 public abstract class AbstractInvocationHandler implements InvocationHandler {
 
@@ -62,7 +59,7 @@ public abstract class AbstractInvocationHandler implements InvocationHandler {
    */
   @Override
   @CheckForNull
-  public final Object invoke(Object proxy, Method method, @CheckForNull @Nullable Object[] args)
+  public final Object invoke(Object proxy, Method method, @CheckForNull Object[] args)
       throws Throwable {
     if (args == null) {
       args = NO_ARGS;
@@ -98,7 +95,7 @@ public abstract class AbstractInvocationHandler implements InvocationHandler {
    * an empty array is passed in.
    */
   @CheckForNull
-  protected abstract Object handleInvocation(Object proxy, Method method, @Nullable Object[] args)
+  protected abstract Object handleInvocation(Object proxy, Method method, Object[] args)
       throws Throwable;
 
   /**
diff --git a/guava/src/com/google/common/reflect/ClassPath.java b/guava/src/com/google/common/reflect/ClassPath.java
index de693da5f2..ef05feb58b 100644
--- a/guava/src/com/google/common/reflect/ClassPath.java
+++ b/guava/src/com/google/common/reflect/ClassPath.java
@@ -20,8 +20,6 @@ import static com.google.common.base.StandardSystemProperty.JAVA_CLASS_PATH;
 import static com.google.common.base.StandardSystemProperty.PATH_SEPARATOR;
 import static java.util.logging.Level.WARNING;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.CharMatcher;
 import com.google.common.base.Predicate;
 import com.google.common.base.Splitter;
@@ -92,7 +90,6 @@ import javax.annotation.CheckForNull;
  * @author Ben Yu
  * @since 14.0
  */
-@Beta
 @ElementTypesAreNonnullByDefault
 public final class ClassPath {
   private static final Logger logger = Logger.getLogger(ClassPath.class.getName());
@@ -211,7 +208,6 @@ public final class ClassPath {
    *
    * @since 14.0
    */
-  @Beta
   public static class ResourceInfo {
     private final File file;
     private final String resourceName;
@@ -307,7 +303,6 @@ public final class ClassPath {
    *
    * @since 14.0
    */
-  @Beta
   public static final class ClassInfo extends ResourceInfo {
     private final String className;
 
@@ -587,7 +582,6 @@ public final class ClassPath {
    * File Specification</a>. If {@code manifest} is null, it means the jar file has no manifest, and
    * an empty set will be returned.
    */
-  @VisibleForTesting
   static ImmutableSet<File> getClassPathFromManifest(
       File jarFile, @CheckForNull Manifest manifest) {
     if (manifest == null) {
@@ -614,7 +608,6 @@ public final class ClassPath {
     return builder.build();
   }
 
-  @VisibleForTesting
   static ImmutableMap<File, ClassLoader> getClassPathEntries(ClassLoader classloader) {
     LinkedHashMap<File, ClassLoader> entries = Maps.newLinkedHashMap();
     // Search parent first, since it's the order ClassLoader#loadClass() uses.
@@ -647,7 +640,7 @@ public final class ClassPath {
    * Returns the URLs in the class path specified by the {@code java.class.path} {@linkplain
    * System#getProperty system property}.
    */
-  @VisibleForTesting // TODO(b/65488446): Make this a public API.
+  // TODO(b/65488446): Make this a public API.
   static ImmutableList<URL> parseJavaClassPath() {
     ImmutableList.Builder<URL> urls = ImmutableList.builder();
     for (String entry : Splitter.on(PATH_SEPARATOR.value()).split(JAVA_CLASS_PATH.value())) {
@@ -670,19 +663,16 @@ public final class ClassPath {
    * File Specification</a>. Even though the specification only talks about relative urls, absolute
    * urls are actually supported too (for example, in Maven surefire plugin).
    */
-  @VisibleForTesting
   static URL getClassPathEntry(File jarFile, String path) throws MalformedURLException {
     return new URL(jarFile.toURI().toURL(), path);
   }
 
-  @VisibleForTesting
   static String getClassName(String filename) {
     int classNameEnd = filename.length() - CLASS_FILE_NAME_EXTENSION.length();
     return filename.substring(0, classNameEnd).replace('/', '.');
   }
 
   // TODO(benyu): Try java.nio.file.Paths#get() when Guava drops JDK 6 support.
-  @VisibleForTesting
   static File toFile(URL url) {
     checkArgument(url.getProtocol().equals("file"));
     try {
diff --git a/guava/src/com/google/common/reflect/ElementTypesAreNonnullByDefault.java b/guava/src/com/google/common/reflect/ElementTypesAreNonnullByDefault.java
index 0e8ef3cb7b..46997d6405 100644
--- a/guava/src/com/google/common/reflect/ElementTypesAreNonnullByDefault.java
+++ b/guava/src/com/google/common/reflect/ElementTypesAreNonnullByDefault.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.ElementType.TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -33,7 +32,6 @@ import javax.annotation.meta.TypeQualifierDefault;
  * unfortunately includes type-variable usages, so we also provide {@link ParametricNullness} to
  * "undo" it as best we can.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target(TYPE)
 @TypeQualifierDefault({FIELD, METHOD, PARAMETER})
diff --git a/guava/src/com/google/common/reflect/ImmutableTypeToInstanceMap.java b/guava/src/com/google/common/reflect/ImmutableTypeToInstanceMap.java
index 7fad5ded3b..b5c24b79e5 100644
--- a/guava/src/com/google/common/reflect/ImmutableTypeToInstanceMap.java
+++ b/guava/src/com/google/common/reflect/ImmutableTypeToInstanceMap.java
@@ -14,11 +14,8 @@
 
 package com.google.common.reflect;
 
-import com.google.common.annotations.Beta;
 import com.google.common.collect.ForwardingMap;
 import com.google.common.collect.ImmutableMap;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotCall;
 import java.util.Map;
 
 /**
@@ -28,7 +25,6 @@ import java.util.Map;
  * @author Ben Yu
  * @since 13.0
  */
-@Beta
 public final class ImmutableTypeToInstanceMap<B> extends ForwardingMap<TypeToken<? extends B>, B>
     implements TypeToInstanceMap<B> {
 
@@ -58,7 +54,6 @@ public final class ImmutableTypeToInstanceMap<B> extends ForwardingMap<TypeToken
    *
    * @since 13.0
    */
-  @Beta
   public static final class Builder<B> {
     private final ImmutableMap.Builder<TypeToken<? extends B>, B> mapBuilder =
         ImmutableMap.builder();
@@ -69,7 +64,6 @@ public final class ImmutableTypeToInstanceMap<B> extends ForwardingMap<TypeToken
      * Associates {@code key} with {@code value} in the built map. Duplicate keys are not allowed,
      * and will cause {@link #build} to fail.
      */
-    @CanIgnoreReturnValue
     public <T extends B> Builder<B> put(Class<T> key, T value) {
       mapBuilder.put(TypeToken.of(key), value);
       return this;
@@ -79,7 +73,6 @@ public final class ImmutableTypeToInstanceMap<B> extends ForwardingMap<TypeToken
      * Associates {@code key} with {@code value} in the built map. Duplicate keys are not allowed,
      * and will cause {@link #build} to fail.
      */
-    @CanIgnoreReturnValue
     public <T extends B> Builder<B> put(TypeToken<T> key, T value) {
       mapBuilder.put(key.rejectTypeVariables(), value);
       return this;
@@ -117,10 +110,8 @@ public final class ImmutableTypeToInstanceMap<B> extends ForwardingMap<TypeToken
    * @deprecated unsupported operation
    * @throws UnsupportedOperationException always
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public <T extends B> T putInstance(TypeToken<T> type, T value) {
     throw new UnsupportedOperationException();
   }
@@ -131,10 +122,8 @@ public final class ImmutableTypeToInstanceMap<B> extends ForwardingMap<TypeToken
    * @deprecated unsupported operation
    * @throws UnsupportedOperationException always
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public <T extends B> T putInstance(Class<T> type, T value) {
     throw new UnsupportedOperationException();
   }
@@ -145,10 +134,8 @@ public final class ImmutableTypeToInstanceMap<B> extends ForwardingMap<TypeToken
    * @deprecated unsupported operation
    * @throws UnsupportedOperationException always
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public B put(TypeToken<? extends B> key, B value) {
     throw new UnsupportedOperationException();
   }
@@ -161,7 +148,6 @@ public final class ImmutableTypeToInstanceMap<B> extends ForwardingMap<TypeToken
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public void putAll(Map<? extends TypeToken<? extends B>, ? extends B> map) {
     throw new UnsupportedOperationException();
   }
diff --git a/guava/src/com/google/common/reflect/Invokable.java b/guava/src/com/google/common/reflect/Invokable.java
index e6d3b6c53f..3b4009d5cf 100644
--- a/guava/src/com/google/common/reflect/Invokable.java
+++ b/guava/src/com/google/common/reflect/Invokable.java
@@ -16,9 +16,7 @@ package com.google.common.reflect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
 import com.google.common.collect.ImmutableList;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.AccessibleObject;
 import java.lang.reflect.AnnotatedElement;
@@ -32,7 +30,6 @@ import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
 import java.util.Arrays;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Wrapper around either a {@link Method} or a {@link Constructor}. Convenience API is provided to
@@ -63,7 +60,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @since 14.0 (no longer implements {@link AccessibleObject} or {@code GenericDeclaration} since
  *     31.0)
  */
-@Beta
 @ElementTypesAreNonnullByDefault
 public abstract class Invokable<T, R> implements AnnotatedElement, Member {
   private final AccessibleObject accessibleObject;
@@ -254,9 +250,8 @@ public abstract class Invokable<T, R> implements AnnotatedElement, Member {
    */
   // All subclasses are owned by us and we'll make sure to get the R type right, including nullness.
   @SuppressWarnings({"unchecked", "nullness"})
-  @CanIgnoreReturnValue
   @CheckForNull
-  public final R invoke(@CheckForNull T receiver, @Nullable Object... args)
+  public final R invoke(@CheckForNull T receiver, Object... args)
       throws InvocationTargetException, IllegalAccessException {
     return (R) invokeInternal(receiver, checkNotNull(args));
   }
@@ -336,7 +331,7 @@ public abstract class Invokable<T, R> implements AnnotatedElement, Member {
   }
 
   @CheckForNull
-  abstract Object invokeInternal(@CheckForNull Object receiver, @Nullable Object[] args)
+  abstract Object invokeInternal(@CheckForNull Object receiver, Object[] args)
       throws InvocationTargetException, IllegalAccessException;
 
   abstract Type[] getGenericParameterTypes();
@@ -363,7 +358,7 @@ public abstract class Invokable<T, R> implements AnnotatedElement, Member {
 
     @Override
     @CheckForNull
-    final Object invokeInternal(@CheckForNull Object receiver, @Nullable Object[] args)
+    final Object invokeInternal(@CheckForNull Object receiver, Object[] args)
         throws InvocationTargetException, IllegalAccessException {
       return method.invoke(receiver, args);
     }
@@ -427,7 +422,7 @@ public abstract class Invokable<T, R> implements AnnotatedElement, Member {
     }
 
     @Override
-    final Object invokeInternal(@CheckForNull Object receiver, @Nullable Object[] args)
+    final Object invokeInternal(@CheckForNull Object receiver, Object[] args)
         throws InvocationTargetException, IllegalAccessException {
       try {
         return constructor.newInstance(args);
diff --git a/guava/src/com/google/common/reflect/MutableTypeToInstanceMap.java b/guava/src/com/google/common/reflect/MutableTypeToInstanceMap.java
index 2d21dbbcc7..918a482cd5 100644
--- a/guava/src/com/google/common/reflect/MutableTypeToInstanceMap.java
+++ b/guava/src/com/google/common/reflect/MutableTypeToInstanceMap.java
@@ -16,19 +16,15 @@ package com.google.common.reflect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
 import com.google.common.base.Function;
 import com.google.common.collect.ForwardingMap;
 import com.google.common.collect.ForwardingMapEntry;
 import com.google.common.collect.ForwardingSet;
 import com.google.common.collect.Iterators;
 import com.google.common.collect.Maps;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotCall;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A mutable type-to-instance map. See also {@link ImmutableTypeToInstanceMap}.
@@ -36,31 +32,28 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Ben Yu
  * @since 13.0
  */
-@Beta
 public final class MutableTypeToInstanceMap<B> extends ForwardingMap<TypeToken<? extends B>, B>
     implements TypeToInstanceMap<B> {
 
   private final Map<TypeToken<? extends B>, B> backingMap = Maps.newHashMap();
 
   @Override
-  public <T extends B> @Nullable T getInstance(Class<T> type) {
+  public <T extends B> T getInstance(Class<T> type) {
     return trustedGet(TypeToken.of(type));
   }
 
   @Override
-  public <T extends B> @Nullable T getInstance(TypeToken<T> type) {
+  public <T extends B> T getInstance(TypeToken<T> type) {
     return trustedGet(type.rejectTypeVariables());
   }
 
   @Override
-  @CanIgnoreReturnValue
-  public <T extends B> @Nullable T putInstance(Class<T> type, @Nullable T value) {
+  public <T extends B> T putInstance(Class<T> type, T value) {
     return trustedPut(TypeToken.of(type), value);
   }
 
   @Override
-  @CanIgnoreReturnValue
-  public <T extends B> @Nullable T putInstance(TypeToken<T> type, @Nullable T value) {
+  public <T extends B> T putInstance(TypeToken<T> type, T value) {
     return trustedPut(type.rejectTypeVariables(), value);
   }
 
@@ -70,10 +63,8 @@ public final class MutableTypeToInstanceMap<B> extends ForwardingMap<TypeToken<?
    * @deprecated unsupported operation
    * @throws UnsupportedOperationException always
    */
-  @CanIgnoreReturnValue
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public B put(TypeToken<? extends B> key, B value) {
     throw new UnsupportedOperationException("Please use putInstance() instead.");
   }
@@ -86,7 +77,6 @@ public final class MutableTypeToInstanceMap<B> extends ForwardingMap<TypeToken<?
    */
   @Deprecated
   @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   public void putAll(Map<? extends TypeToken<? extends B>, ? extends B> map) {
     throw new UnsupportedOperationException("Please use putInstance() instead.");
   }
@@ -102,12 +92,12 @@ public final class MutableTypeToInstanceMap<B> extends ForwardingMap<TypeToken<?
   }
 
   @SuppressWarnings("unchecked") // value could not get in if not a T
-  private <T extends B> @Nullable T trustedPut(TypeToken<T> type, @Nullable T value) {
+  private <T extends B> T trustedPut(TypeToken<T> type, T value) {
     return (T) backingMap.put(type, value);
   }
 
   @SuppressWarnings("unchecked") // value could not get in if not a T
-  private <T extends B> @Nullable T trustedGet(TypeToken<T> type) {
+  private <T extends B> T trustedGet(TypeToken<T> type) {
     return (T) backingMap.get(type);
   }
 
diff --git a/guava/src/com/google/common/reflect/Parameter.java b/guava/src/com/google/common/reflect/Parameter.java
index 61ab85a3fd..1d35a1b206 100644
--- a/guava/src/com/google/common/reflect/Parameter.java
+++ b/guava/src/com/google/common/reflect/Parameter.java
@@ -16,14 +16,12 @@ package com.google.common.reflect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.AnnotatedElement;
 import java.lang.reflect.AnnotatedType;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Represents a method or constructor parameter.
@@ -31,7 +29,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Ben Yu
  * @since 14.0
  */
-@Beta
 @ElementTypesAreNonnullByDefault
 public final class Parameter implements AnnotatedElement {
 
@@ -113,7 +110,6 @@ public final class Parameter implements AnnotatedElement {
   // @Override on JDK8
   @Override
   public <A extends Annotation> A[] getDeclaredAnnotationsByType(Class<A> annotationType) {
-    @Nullable
     A[] result = FluentIterable.from(annotations).filter(annotationType).toArray(annotationType);
     @SuppressWarnings("nullness") // safe because the input list contains no nulls
     A[] cast = (A[]) result;
diff --git a/guava/src/com/google/common/reflect/ParametricNullness.java b/guava/src/com/google/common/reflect/ParametricNullness.java
index 588aa5f597..9a4c13e9b5 100644
--- a/guava/src/com/google/common/reflect/ParametricNullness.java
+++ b/guava/src/com/google/common/reflect/ParametricNullness.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import static javax.annotation.meta.When.UNKNOWN;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -35,7 +34,6 @@ import javax.annotation.meta.TypeQualifierNickname;
  * href="https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/NullFromTypeParam.java">{@code
  * NullFromTypeParam}</a>). We use this to "undo" {@link ElementTypesAreNonnullByDefault}.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target({FIELD, METHOD, PARAMETER})
 @TypeQualifierNickname
diff --git a/guava/src/com/google/common/reflect/Reflection.java b/guava/src/com/google/common/reflect/Reflection.java
index fa35f7f2de..9544963481 100644
--- a/guava/src/com/google/common/reflect/Reflection.java
+++ b/guava/src/com/google/common/reflect/Reflection.java
@@ -17,7 +17,6 @@ package com.google.common.reflect;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Proxy;
 
@@ -26,7 +25,6 @@ import java.lang.reflect.Proxy;
  *
  * @since 12.0
  */
-@Beta
 @ElementTypesAreNonnullByDefault
 public final class Reflection {
 
diff --git a/guava/src/com/google/common/reflect/TypeParameter.java b/guava/src/com/google/common/reflect/TypeParameter.java
index 9c64abb727..69cd8291a9 100644
--- a/guava/src/com/google/common/reflect/TypeParameter.java
+++ b/guava/src/com/google/common/reflect/TypeParameter.java
@@ -16,7 +16,6 @@ package com.google.common.reflect;
 
 import static com.google.common.base.Preconditions.checkArgument;
 
-import com.google.common.annotations.Beta;
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
 import javax.annotation.CheckForNull;
@@ -34,7 +33,6 @@ import javax.annotation.CheckForNull;
  * @author Ben Yu
  * @since 12.0
  */
-@Beta
 @ElementTypesAreNonnullByDefault
 /*
  * A nullable bound would let users create a TypeParameter instance for a parameter with a nullable
diff --git a/guava/src/com/google/common/reflect/TypeResolver.java b/guava/src/com/google/common/reflect/TypeResolver.java
index fbe48c1e88..5bff86dc3a 100644
--- a/guava/src/com/google/common/reflect/TypeResolver.java
+++ b/guava/src/com/google/common/reflect/TypeResolver.java
@@ -19,7 +19,6 @@ import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static java.util.Arrays.asList;
 
-import com.google.common.annotations.Beta;
 import com.google.common.base.Joiner;
 import com.google.common.base.Objects;
 import com.google.common.collect.ImmutableMap;
@@ -51,7 +50,6 @@ import javax.annotation.CheckForNull;
  * @author Ben Yu
  * @since 15.0
  */
-@Beta
 @ElementTypesAreNonnullByDefault
 public final class TypeResolver {
 
diff --git a/guava/src/com/google/common/reflect/TypeToInstanceMap.java b/guava/src/com/google/common/reflect/TypeToInstanceMap.java
index 443b2580cf..9db8e031d7 100644
--- a/guava/src/com/google/common/reflect/TypeToInstanceMap.java
+++ b/guava/src/com/google/common/reflect/TypeToInstanceMap.java
@@ -14,11 +14,7 @@
 
 package com.google.common.reflect;
 
-import com.google.common.annotations.Beta;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotMock;
 import java.util.Map;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A map, each entry of which maps a {@link TypeToken} to an instance of that type. In addition to
@@ -39,8 +35,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Ben Yu
  * @since 13.0
  */
-@Beta
-@DoNotMock("Use ImmutableTypeToInstanceMap or MutableTypeToInstanceMap")
 public interface TypeToInstanceMap<B> extends Map<TypeToken<? extends B>, B> {
 
   /**
@@ -51,14 +45,14 @@ public interface TypeToInstanceMap<B> extends Map<TypeToken<? extends B>, B> {
    * <p>{@code getInstance(Foo.class)} is equivalent to {@code
    * getInstance(TypeToken.of(Foo.class))}.
    */
-  <T extends B> @Nullable T getInstance(Class<T> type);
+  <T extends B> T getInstance(Class<T> type);
 
   /**
    * Returns the value the specified type is mapped to, or {@code null} if no entry for this type is
    * present. This will only return a value that was bound to this specific type, not a value that
    * may have been bound to a subtype.
    */
-  <T extends B> @Nullable T getInstance(TypeToken<T> type);
+  <T extends B> T getInstance(TypeToken<T> type);
 
   /**
    * Maps the specified class to the specified value. Does <i>not</i> associate this value with any
@@ -70,8 +64,7 @@ public interface TypeToInstanceMap<B> extends Map<TypeToken<? extends B>, B> {
    * @return the value previously associated with this class (possibly {@code null}), or {@code
    *     null} if there was no previous entry.
    */
-  @CanIgnoreReturnValue
-  <T extends B> @Nullable T putInstance(Class<T> type, @Nullable T value);
+  <T extends B> T putInstance(Class<T> type, T value);
 
   /**
    * Maps the specified type to the specified value. Does <i>not</i> associate this value with any
@@ -80,6 +73,5 @@ public interface TypeToInstanceMap<B> extends Map<TypeToken<? extends B>, B> {
    * @return the value previously associated with this type (possibly {@code null}), or {@code null}
    *     if there was no previous entry.
    */
-  @CanIgnoreReturnValue
-  <T extends B> @Nullable T putInstance(TypeToken<T> type, @Nullable T value);
+  <T extends B> T putInstance(TypeToken<T> type, T value);
 }
diff --git a/guava/src/com/google/common/reflect/TypeToken.java b/guava/src/com/google/common/reflect/TypeToken.java
index f107b70818..98ff5359c3 100644
--- a/guava/src/com/google/common/reflect/TypeToken.java
+++ b/guava/src/com/google/common/reflect/TypeToken.java
@@ -19,8 +19,6 @@ import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Joiner;
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
@@ -31,7 +29,6 @@ import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Ordering;
 import com.google.common.primitives.Primitives;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.Serializable;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.GenericArrayType;
@@ -97,7 +94,6 @@ import javax.annotation.CheckForNull;
  * @author Ben Yu
  * @since 12.0
  */
-@Beta
 @SuppressWarnings("serial") // SimpleTypeToken is the serialized form.
 @ElementTypesAreNonnullByDefault
 public abstract class TypeToken<T> extends TypeCapture<T> implements Serializable {
@@ -865,7 +861,6 @@ public abstract class TypeToken<T> extends TypeCapture<T> implements Serializabl
    * Ensures that this type token doesn't contain type variables, which can cause unchecked type
    * errors for callers like {@link TypeToInstanceMap}.
    */
-  @CanIgnoreReturnValue
   final TypeToken<T> rejectTypeVariables() {
     new TypeVisitor() {
       @Override
@@ -1168,7 +1163,6 @@ public abstract class TypeToken<T> extends TypeCapture<T> implements Serializabl
    * <p>If {@code cls} isn't parameterized and isn't a generic array, the type token of the class is
    * returned.
    */
-  @VisibleForTesting
   static <T> TypeToken<? extends T> toGenericType(Class<T> cls) {
     if (cls.isArray()) {
       Type arrayOfGenericType =
@@ -1402,7 +1396,6 @@ public abstract class TypeToken<T> extends TypeCapture<T> implements Serializabl
     }
 
     /** Collects all types to map, and returns the total depth from T up to Object. */
-    @CanIgnoreReturnValue
     private int collectTypes(K type, Map<? super K, Integer> map) {
       Integer existing = map.get(type);
       if (existing != null) {
diff --git a/guava/src/com/google/common/reflect/TypeVisitor.java b/guava/src/com/google/common/reflect/TypeVisitor.java
index 416397bc77..ba4f5c9b8d 100644
--- a/guava/src/com/google/common/reflect/TypeVisitor.java
+++ b/guava/src/com/google/common/reflect/TypeVisitor.java
@@ -21,7 +21,6 @@ import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
 import java.lang.reflect.WildcardType;
 import java.util.Set;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Based on what a {@link Type} is, dispatch it to the corresponding {@code visit*} method. By
@@ -63,7 +62,7 @@ abstract class TypeVisitor {
    * Visits the given types. Null types are ignored. This allows subclasses to call {@code
    * visit(parameterizedType.getOwnerType())} safely without having to check nulls.
    */
-  public final void visit(@Nullable Type... types) {
+  public final void visit(Type... types) {
     for (Type type : types) {
       if (type == null || !visited.add(type)) {
         // null owner type, or already visited;
diff --git a/guava/src/com/google/common/reflect/Types.java b/guava/src/com/google/common/reflect/Types.java
index 0dc327d3d1..aa3dadc9a9 100644
--- a/guava/src/com/google/common/reflect/Types.java
+++ b/guava/src/com/google/common/reflect/Types.java
@@ -19,7 +19,6 @@ import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.transform;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.base.Objects;
@@ -46,7 +45,6 @@ import java.util.Collection;
 import java.util.Map.Entry;
 import java.util.concurrent.atomic.AtomicReference;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Utilities for working with {@link Type}.
@@ -157,13 +155,11 @@ final class Types {
   }
 
   /** Returns a new {@link WildcardType} with {@code upperBound}. */
-  @VisibleForTesting
   static WildcardType subtypeOf(Type upperBound) {
     return new WildcardTypeImpl(new Type[0], new Type[] {upperBound});
   }
 
   /** Returns a new {@link WildcardType} with {@code lowerBound}. */
-  @VisibleForTesting
   static WildcardType supertypeOf(Type lowerBound) {
     return new WildcardTypeImpl(new Type[] {lowerBound}, new Type[] {Object.class});
   }
@@ -180,7 +176,7 @@ final class Types {
   @CheckForNull
   static Type getComponentType(Type type) {
     checkNotNull(type);
-    final AtomicReference<@Nullable Type> result = new AtomicReference<>();
+    final AtomicReference<Type> result = new AtomicReference<>();
     new TypeVisitor() {
       @Override
       void visitTypeVariable(TypeVariable<?> t) {
@@ -393,7 +389,7 @@ final class Types {
 
     @Override
     @CheckForNull
-    public Object invoke(Object proxy, Method method, @CheckForNull @Nullable Object[] args)
+    public Object invoke(Object proxy, Method method, @CheckForNull Object[] args)
         throws Throwable {
       String methodName = method.getName();
       Method typeVariableMethod = typeVariableMethods.get(methodName);
diff --git a/guava/src/com/google/common/reflect/package-info.java b/guava/src/com/google/common/reflect/package-info.java
index 6b6047169c..10f59219aa 100644
--- a/guava/src/com/google/common/reflect/package-info.java
+++ b/guava/src/com/google/common/reflect/package-info.java
@@ -16,9 +16,7 @@
  * This package contains utilities to work with Java reflection. It is a part of the open-source <a
  * href="http://github.com/google/guava">Guava</a> library.
  */
-@CheckReturnValue
 @ParametersAreNonnullByDefault
 package com.google.common.reflect;
 
-import com.google.errorprone.annotations.CheckReturnValue;
 import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/guava/src/com/google/common/util/concurrent/AbstractCatchingFuture.java b/guava/src/com/google/common/util/concurrent/AbstractCatchingFuture.java
index 76eada2140..7984bf43ef 100644
--- a/guava/src/com/google/common/util/concurrent/AbstractCatchingFuture.java
+++ b/guava/src/com/google/common/util/concurrent/AbstractCatchingFuture.java
@@ -20,24 +20,20 @@ import static com.google.common.util.concurrent.MoreExecutors.rejectionPropagati
 import static com.google.common.util.concurrent.NullnessCasts.uncheckedCastNullableTToT;
 import static com.google.common.util.concurrent.Platform.isInstanceOfThrowableClass;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Function;
 import com.google.common.util.concurrent.internal.InternalFutureFailureAccess;
 import com.google.common.util.concurrent.internal.InternalFutures;
-import com.google.errorprone.annotations.ForOverride;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** Implementations of {@code Futures.catching*}. */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 @SuppressWarnings("nullness") // TODO(b/147136275): Remove once our checker understands & and |.
 abstract class AbstractCatchingFuture<
-        V extends @Nullable Object, X extends Throwable, F, T extends @Nullable Object>
+        V extends Object, X extends Throwable, F, T extends Object>
     extends FluentFuture.TrustedFuture<V> implements Runnable {
-  static <V extends @Nullable Object, X extends Throwable> ListenableFuture<V> create(
+  static <V extends Object, X extends Throwable> ListenableFuture<V> create(
       ListenableFuture<? extends V> input,
       Class<X> exceptionType,
       Function<? super X, ? extends V> fallback,
@@ -47,7 +43,7 @@ abstract class AbstractCatchingFuture<
     return future;
   }
 
-  static <X extends Throwable, V extends @Nullable Object> ListenableFuture<V> create(
+  static <X extends Throwable, V extends Object> ListenableFuture<V> create(
       ListenableFuture<? extends V> input,
       Class<X> exceptionType,
       AsyncFunction<? super X, ? extends V> fallback,
@@ -167,12 +163,10 @@ abstract class AbstractCatchingFuture<
   }
 
   /** Template method for subtypes to actually run the fallback. */
-  @ForOverride
   @ParametricNullness
   abstract T doFallback(F fallback, X throwable) throws Exception;
 
   /** Template method for subtypes to actually set the result. */
-  @ForOverride
   abstract void setResult(@ParametricNullness T result);
 
   @Override
@@ -187,7 +181,7 @@ abstract class AbstractCatchingFuture<
    * An {@link AbstractCatchingFuture} that delegates to an {@link AsyncFunction} and {@link
    * #setFuture(ListenableFuture)}.
    */
-  private static final class AsyncCatchingFuture<V extends @Nullable Object, X extends Throwable>
+  private static final class AsyncCatchingFuture<V extends Object, X extends Throwable>
       extends AbstractCatchingFuture<
           V, X, AsyncFunction<? super X, ? extends V>, ListenableFuture<? extends V>> {
     AsyncCatchingFuture(
@@ -219,7 +213,7 @@ abstract class AbstractCatchingFuture<
    * An {@link AbstractCatchingFuture} that delegates to a {@link Function} and {@link
    * #set(Object)}.
    */
-  private static final class CatchingFuture<V extends @Nullable Object, X extends Throwable>
+  private static final class CatchingFuture<V extends Object, X extends Throwable>
       extends AbstractCatchingFuture<V, X, Function<? super X, ? extends V>, V> {
     CatchingFuture(
         ListenableFuture<? extends V> input,
diff --git a/guava/src/com/google/common/util/concurrent/AbstractExecutionThreadService.java b/guava/src/com/google/common/util/concurrent/AbstractExecutionThreadService.java
index df5b462d32..444b17d940 100644
--- a/guava/src/com/google/common/util/concurrent/AbstractExecutionThreadService.java
+++ b/guava/src/com/google/common/util/concurrent/AbstractExecutionThreadService.java
@@ -14,10 +14,7 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Supplier;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.time.Duration;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
@@ -33,7 +30,6 @@ import java.util.logging.Logger;
  * @author Jesse Wilson
  * @since 1.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public abstract class AbstractExecutionThreadService implements Service {
   private static final Logger logger =
@@ -148,7 +144,6 @@ public abstract class AbstractExecutionThreadService implements Service {
    * implementing {@code stopping}. Note, however, that {@code stopping} does not run at exactly the
    * same times as {@code triggerShutdown}.
    */
-  @Beta
   protected void triggerShutdown() {}
 
   /**
@@ -198,7 +193,6 @@ public abstract class AbstractExecutionThreadService implements Service {
   }
 
   /** @since 15.0 */
-  @CanIgnoreReturnValue
   @Override
   public final Service startAsync() {
     delegate.startAsync();
@@ -206,7 +200,6 @@ public abstract class AbstractExecutionThreadService implements Service {
   }
 
   /** @since 15.0 */
-  @CanIgnoreReturnValue
   @Override
   public final Service stopAsync() {
     delegate.stopAsync();
diff --git a/guava/src/com/google/common/util/concurrent/AbstractFuture.java b/guava/src/com/google/common/util/concurrent/AbstractFuture.java
index 9f09428105..5d9a48cd19 100644
--- a/guava/src/com/google/common/util/concurrent/AbstractFuture.java
+++ b/guava/src/com/google/common/util/concurrent/AbstractFuture.java
@@ -22,14 +22,9 @@ import static java.lang.System.identityHashCode;
 import static java.util.Objects.requireNonNull;
 import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Strings;
 import com.google.common.util.concurrent.internal.InternalFutureFailureAccess;
 import com.google.common.util.concurrent.internal.InternalFutures;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.ForOverride;
-import com.google.j2objc.annotations.ReflectionSupport;
 import java.security.AccessController;
 import java.security.PrivilegedActionException;
 import java.security.PrivilegedExceptionAction;
@@ -46,7 +41,6 @@ import java.util.concurrent.locks.LockSupport;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An abstract implementation of {@link ListenableFuture}, intended for advanced users only. More
@@ -71,10 +65,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
   "ShortCircuitBoolean", // we use non-short circuiting comparisons intentionally
   "nullness", // TODO(b/147136275): Remove once our checker understands & and |.
 })
-@GwtCompatible(emulated = true)
-@ReflectionSupport(value = ReflectionSupport.Level.FULL)
 @ElementTypesAreNonnullByDefault
-public abstract class AbstractFuture<V extends @Nullable Object> extends InternalFutureFailureAccess
+public abstract class AbstractFuture<V extends Object> extends InternalFutureFailureAccess
     implements ListenableFuture<V> {
   // NOTE: Whenever both tests are cheap and functional, it's faster to use &, | instead of &&, ||
 
@@ -98,22 +90,20 @@ public abstract class AbstractFuture<V extends @Nullable Object> extends Interna
    * of this interface must also be an AbstractFuture and must not override or expose for overriding
    * any of the public methods of ListenableFuture.
    */
-  interface Trusted<V extends @Nullable Object> extends ListenableFuture<V> {}
+  interface Trusted<V extends Object> extends ListenableFuture<V> {}
 
   /**
    * A less abstract subclass of AbstractFuture. This can be used to optimize setFuture by ensuring
    * that {@link #get} calls exactly the implementation of {@link AbstractFuture#get}.
    */
-  abstract static class TrustedFuture<V extends @Nullable Object> extends AbstractFuture<V>
+  abstract static class TrustedFuture<V extends Object> extends AbstractFuture<V>
       implements Trusted<V> {
-    @CanIgnoreReturnValue
     @Override
     @ParametricNullness
     public final V get() throws InterruptedException, ExecutionException {
       return super.get();
     }
 
-    @CanIgnoreReturnValue
     @Override
     @ParametricNullness
     public final V get(long timeout, TimeUnit unit)
@@ -136,7 +126,6 @@ public abstract class AbstractFuture<V extends @Nullable Object> extends Interna
       super.addListener(listener, executor);
     }
 
-    @CanIgnoreReturnValue
     @Override
     public final boolean cancel(boolean mayInterruptIfRunning) {
       return super.cancel(mayInterruptIfRunning);
@@ -335,7 +324,7 @@ public abstract class AbstractFuture<V extends @Nullable Object> extends Interna
   }
 
   /** A special value that encodes the 'setFuture' state. */
-  private static final class SetFuture<V extends @Nullable Object> implements Runnable {
+  private static final class SetFuture<V extends Object> implements Runnable {
     final AbstractFuture<V> owner;
     final ListenableFuture<? extends V> future;
 
@@ -417,7 +406,6 @@ public abstract class AbstractFuture<V extends @Nullable Object> extends Interna
    *
    * @throws CancellationException {@inheritDoc}
    */
-  @CanIgnoreReturnValue
   @Override
   @ParametricNullness
   public V get(long timeout, TimeUnit unit)
@@ -530,7 +518,6 @@ public abstract class AbstractFuture<V extends @Nullable Object> extends Interna
    *
    * @throws CancellationException {@inheritDoc}
    */
-  @CanIgnoreReturnValue
   @Override
   @ParametricNullness
   public V get() throws InterruptedException, ExecutionException {
@@ -622,7 +609,6 @@ public abstract class AbstractFuture<V extends @Nullable Object> extends Interna
    * <p>Beware of completing a future while holding a lock. Its listeners may do slow work or
    * acquire other locks, risking deadlocks.
    */
-  @CanIgnoreReturnValue
   @Override
   public boolean cancel(boolean mayInterruptIfRunning) {
     Object localValue = value;
@@ -771,7 +757,6 @@ public abstract class AbstractFuture<V extends @Nullable Object> extends Interna
    * @param value the value to be used as the result
    * @return true if the attempt was accepted, completing the {@code Future}
    */
-  @CanIgnoreReturnValue
   protected boolean set(@ParametricNullness V value) {
     Object valueToSet = value == null ? NULL : value;
     if (ATOMIC_HELPER.casValue(this, null, valueToSet)) {
@@ -796,7 +781,6 @@ public abstract class AbstractFuture<V extends @Nullable Object> extends Interna
    * @param throwable the exception to be used as the failed result
    * @return true if the attempt was accepted, completing the {@code Future}
    */
-  @CanIgnoreReturnValue
   protected boolean setException(Throwable throwable) {
     Object valueToSet = new Failure(checkNotNull(throwable));
     if (ATOMIC_HELPER.casValue(this, null, valueToSet)) {
@@ -835,7 +819,6 @@ public abstract class AbstractFuture<V extends @Nullable Object> extends Interna
    *     cancelled or set.
    * @since 19.0
    */
-  @CanIgnoreReturnValue
   protected boolean setFuture(ListenableFuture<? extends V> future) {
     checkNotNull(future);
     Object localValue = value;
@@ -966,7 +949,7 @@ public abstract class AbstractFuture<V extends @Nullable Object> extends Interna
    * internal dependency on other /util/concurrent classes.
    */
   @ParametricNullness
-  private static <V extends @Nullable Object> V getUninterruptibly(Future<V> future)
+  private static <V extends Object> V getUninterruptibly(Future<V> future)
       throws ExecutionException {
     boolean interrupted = false;
     try {
@@ -1048,8 +1031,6 @@ public abstract class AbstractFuture<V extends @Nullable Object> extends Interna
    *
    * @since 20.0
    */
-  @Beta
-  @ForOverride
   protected void afterDone() {}
 
   // TODO(b/114236866): Inherit doc from InternalFutureFailureAccess. Also, -link to its URL.
diff --git a/guava/src/com/google/common/util/concurrent/AbstractIdleService.java b/guava/src/com/google/common/util/concurrent/AbstractIdleService.java
index fe9faf9e58..721b4c2096 100644
--- a/guava/src/com/google/common/util/concurrent/AbstractIdleService.java
+++ b/guava/src/com/google/common/util/concurrent/AbstractIdleService.java
@@ -14,10 +14,7 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Supplier;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.j2objc.annotations.WeakOuter;
 import java.time.Duration;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
@@ -31,14 +28,12 @@ import java.util.concurrent.TimeoutException;
  * @author Chris Nokleberg
  * @since 1.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public abstract class AbstractIdleService implements Service {
 
   /* Thread names will look like {@code "MyService STARTING"}. */
   private final Supplier<String> threadNameSupplier = new ThreadNameSupplier();
 
-  @WeakOuter
   private final class ThreadNameSupplier implements Supplier<String> {
     @Override
     public String get() {
@@ -49,7 +44,6 @@ public abstract class AbstractIdleService implements Service {
   /* use AbstractService for state management */
   private final Service delegate = new DelegateService();
 
-  @WeakOuter
   private final class DelegateService extends AbstractService {
     @Override
     protected final void doStart() {
@@ -144,7 +138,6 @@ public abstract class AbstractIdleService implements Service {
   }
 
   /** @since 15.0 */
-  @CanIgnoreReturnValue
   @Override
   public final Service startAsync() {
     delegate.startAsync();
@@ -152,7 +145,6 @@ public abstract class AbstractIdleService implements Service {
   }
 
   /** @since 15.0 */
-  @CanIgnoreReturnValue
   @Override
   public final Service stopAsync() {
     delegate.stopAsync();
diff --git a/guava/src/com/google/common/util/concurrent/AbstractListeningExecutorService.java b/guava/src/com/google/common/util/concurrent/AbstractListeningExecutorService.java
index fd5c5c9115..98d8ede515 100644
--- a/guava/src/com/google/common/util/concurrent/AbstractListeningExecutorService.java
+++ b/guava/src/com/google/common/util/concurrent/AbstractListeningExecutorService.java
@@ -14,13 +14,9 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.concurrent.AbstractExecutorService;
 import java.util.concurrent.Callable;
 import java.util.concurrent.RunnableFuture;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Abstract {@link ListeningExecutorService} implementation that creates {@link ListenableFuture}
@@ -33,23 +29,20 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Chris Povirk
  * @since 14.0
  */
-@Beta
-@CanIgnoreReturnValue
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public abstract class AbstractListeningExecutorService extends AbstractExecutorService
     implements ListeningExecutorService {
 
   /** @since 19.0 (present with return type {@code ListenableFutureTask} since 14.0) */
   @Override
-  protected final <T extends @Nullable Object> RunnableFuture<T> newTaskFor(
+  protected final <T extends Object> RunnableFuture<T> newTaskFor(
       Runnable runnable, @ParametricNullness T value) {
     return TrustedListenableFutureTask.create(runnable, value);
   }
 
   /** @since 19.0 (present with return type {@code ListenableFutureTask} since 14.0) */
   @Override
-  protected final <T extends @Nullable Object> RunnableFuture<T> newTaskFor(Callable<T> callable) {
+  protected final <T extends Object> RunnableFuture<T> newTaskFor(Callable<T> callable) {
     return TrustedListenableFutureTask.create(callable);
   }
 
@@ -59,13 +52,13 @@ public abstract class AbstractListeningExecutorService extends AbstractExecutorS
   }
 
   @Override
-  public <T extends @Nullable Object> ListenableFuture<T> submit(
+  public <T extends Object> ListenableFuture<T> submit(
       Runnable task, @ParametricNullness T result) {
     return (ListenableFuture<T>) super.submit(task, result);
   }
 
   @Override
-  public <T extends @Nullable Object> ListenableFuture<T> submit(Callable<T> task) {
+  public <T extends Object> ListenableFuture<T> submit(Callable<T> task) {
     return (ListenableFuture<T>) super.submit(task);
   }
 }
diff --git a/guava/src/com/google/common/util/concurrent/AbstractScheduledService.java b/guava/src/com/google/common/util/concurrent/AbstractScheduledService.java
index 87fb6df4d1..1f81f23f16 100644
--- a/guava/src/com/google/common/util/concurrent/AbstractScheduledService.java
+++ b/guava/src/com/google/common/util/concurrent/AbstractScheduledService.java
@@ -21,11 +21,7 @@ import static com.google.common.util.concurrent.Internal.toNanosSaturated;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Supplier;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.concurrent.GuardedBy;
-import com.google.j2objc.annotations.WeakOuter;
 import java.time.Duration;
 import java.util.concurrent.Callable;
 import java.util.concurrent.Executor;
@@ -40,7 +36,6 @@ import java.util.concurrent.locks.ReentrantLock;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Base class for services that can implement {@link #startUp} and {@link #shutDown} but while in
@@ -99,7 +94,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Luke Sandberg
  * @since 11.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public abstract class AbstractScheduledService implements Service {
   private static final Logger logger = Logger.getLogger(AbstractScheduledService.class.getName());
@@ -201,7 +195,6 @@ public abstract class AbstractScheduledService implements Service {
   /* use AbstractService for state management */
   private final AbstractService delegate = new ServiceDelegate();
 
-  @WeakOuter
   private final class ServiceDelegate extends AbstractService {
 
     // A handle to the running task so that we can stop it when a shutdown has been requested.
@@ -215,7 +208,6 @@ public abstract class AbstractScheduledService implements Service {
     // lock.
     private final ReentrantLock lock = new ReentrantLock();
 
-    @WeakOuter
     class Task implements Runnable {
       @Override
       public void run() {
@@ -367,7 +359,6 @@ public abstract class AbstractScheduledService implements Service {
    * fails}.
    */
   protected ScheduledExecutorService executor() {
-    @WeakOuter
     class ThreadFactoryImpl implements ThreadFactory {
       @Override
       public Thread newThread(Runnable runnable) {
@@ -435,7 +426,6 @@ public abstract class AbstractScheduledService implements Service {
   }
 
   /** @since 15.0 */
-  @CanIgnoreReturnValue
   @Override
   public final Service startAsync() {
     delegate.startAsync();
@@ -443,7 +433,6 @@ public abstract class AbstractScheduledService implements Service {
   }
 
   /** @since 15.0 */
-  @CanIgnoreReturnValue
   @Override
   public final Service stopAsync() {
     delegate.stopAsync();
@@ -521,7 +510,7 @@ public abstract class AbstractScheduledService implements Service {
   public abstract static class CustomScheduler extends Scheduler {
 
     /** A callable class that can reschedule itself using a {@link CustomScheduler}. */
-    private final class ReschedulableCallable implements Callable<@Nullable Void> {
+    private final class ReschedulableCallable implements Callable<Void> {
 
       /** The underlying task. */
       private final Runnable wrappedRunnable;
@@ -564,7 +553,6 @@ public abstract class AbstractScheduledService implements Service {
       private final ReentrantLock lock = new ReentrantLock();
 
       /** The future that represents the next execution of this task. */
-      @GuardedBy("lock")
       @CheckForNull
       private SupplantableFuture cancellationDelegate;
 
@@ -587,7 +575,6 @@ public abstract class AbstractScheduledService implements Service {
        * Atomically reschedules this task and assigns the new future to {@link
        * #cancellationDelegate}.
        */
-      @CanIgnoreReturnValue
       public Cancellable reschedule() {
         // invoke the callback outside the lock, prevents some shenanigans.
         Schedule schedule;
@@ -627,7 +614,6 @@ public abstract class AbstractScheduledService implements Service {
         return toReturn;
       }
 
-      @GuardedBy("lock")
       /*
        * The GuardedBy checker warns us that we're not holding cancellationDelegate.lock. But in
        * fact we are holding it because it is the same as this.lock, which we know we are holding,
@@ -645,7 +631,7 @@ public abstract class AbstractScheduledService implements Service {
         return cancellationDelegate;
       }
 
-      private ScheduledFuture<@Nullable Void> submitToExecutor(Schedule schedule) {
+      private ScheduledFuture<Void> submitToExecutor(Schedule schedule) {
         return executor.schedule(this, schedule.delay, schedule.unit);
       }
     }
@@ -657,10 +643,9 @@ public abstract class AbstractScheduledService implements Service {
     private static final class SupplantableFuture implements Cancellable {
       private final ReentrantLock lock;
 
-      @GuardedBy("lock")
-      private Future<@Nullable Void> currentFuture;
+      private Future<Void> currentFuture;
 
-      SupplantableFuture(ReentrantLock lock, Future<@Nullable Void> currentFuture) {
+      SupplantableFuture(ReentrantLock lock, Future<Void> currentFuture) {
         this.lock = lock;
         this.currentFuture = currentFuture;
       }
diff --git a/guava/src/com/google/common/util/concurrent/AbstractService.java b/guava/src/com/google/common/util/concurrent/AbstractService.java
index ae400963c7..3530b18225 100644
--- a/guava/src/com/google/common/util/concurrent/AbstractService.java
+++ b/guava/src/com/google/common/util/concurrent/AbstractService.java
@@ -25,14 +25,8 @@ import static com.google.common.util.concurrent.Service.State.STOPPING;
 import static com.google.common.util.concurrent.Service.State.TERMINATED;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.util.concurrent.Monitor.Guard;
 import com.google.common.util.concurrent.Service.State; // javadoc needs this
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.ForOverride;
-import com.google.errorprone.annotations.concurrent.GuardedBy;
-import com.google.j2objc.annotations.WeakOuter;
 import java.time.Duration;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
@@ -49,7 +43,6 @@ import javax.annotation.CheckForNull;
  * @author Luke Sandberg
  * @since 1.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public abstract class AbstractService implements Service {
   private static final ListenerCallQueue.Event<Listener> STARTING_EVENT =
@@ -122,7 +115,6 @@ public abstract class AbstractService implements Service {
 
   private final Guard isStartable = new IsStartableGuard();
 
-  @WeakOuter
   private final class IsStartableGuard extends Guard {
     IsStartableGuard() {
       super(AbstractService.this.monitor);
@@ -136,7 +128,6 @@ public abstract class AbstractService implements Service {
 
   private final Guard isStoppable = new IsStoppableGuard();
 
-  @WeakOuter
   private final class IsStoppableGuard extends Guard {
     IsStoppableGuard() {
       super(AbstractService.this.monitor);
@@ -150,7 +141,6 @@ public abstract class AbstractService implements Service {
 
   private final Guard hasReachedRunning = new HasReachedRunningGuard();
 
-  @WeakOuter
   private final class HasReachedRunningGuard extends Guard {
     HasReachedRunningGuard() {
       super(AbstractService.this.monitor);
@@ -164,7 +154,6 @@ public abstract class AbstractService implements Service {
 
   private final Guard isStopped = new IsStoppedGuard();
 
-  @WeakOuter
   private final class IsStoppedGuard extends Guard {
     IsStoppedGuard() {
       super(AbstractService.this.monitor);
@@ -203,7 +192,6 @@ public abstract class AbstractService implements Service {
    * convenient. It is invoked exactly once on service startup, even when {@link #startAsync} is
    * called multiple times.
    */
-  @ForOverride
   protected abstract void doStart();
 
   /**
@@ -220,7 +208,6 @@ public abstract class AbstractService implements Service {
    * invoked immediately. Instead, it will be deferred until after the service is {@link
    * State#RUNNING}. Services that need to cancel startup work can override {@link #doCancelStart}.
    */
-  @ForOverride
   protected abstract void doStop();
 
   /**
@@ -237,11 +224,8 @@ public abstract class AbstractService implements Service {
    *
    * @since 27.0
    */
-  @Beta
-  @ForOverride
   protected void doCancelStart() {}
 
-  @CanIgnoreReturnValue
   @Override
   public final Service startAsync() {
     if (monitor.enterIf(isStartable)) {
@@ -261,7 +245,6 @@ public abstract class AbstractService implements Service {
     return this;
   }
 
-  @CanIgnoreReturnValue
   @Override
   public final Service stopAsync() {
     if (monitor.enterIf(isStoppable)) {
@@ -370,7 +353,6 @@ public abstract class AbstractService implements Service {
   }
 
   /** Checks that the current state is equal to the expected state. */
-  @GuardedBy("monitor")
   private void checkCurrentState(State expected) {
     State actual = state();
     if (actual != expected) {
diff --git a/guava/src/com/google/common/util/concurrent/AbstractTransformFuture.java b/guava/src/com/google/common/util/concurrent/AbstractTransformFuture.java
index dd68791594..3a2413a495 100644
--- a/guava/src/com/google/common/util/concurrent/AbstractTransformFuture.java
+++ b/guava/src/com/google/common/util/concurrent/AbstractTransformFuture.java
@@ -18,23 +18,19 @@ import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.util.concurrent.Futures.getDone;
 import static com.google.common.util.concurrent.MoreExecutors.rejectionPropagatingExecutor;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Function;
-import com.google.errorprone.annotations.ForOverride;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** Implementations of {@code Futures.transform*}. */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 @SuppressWarnings("nullness") // TODO(b/147136275): Remove once our checker understands & and |.
 abstract class AbstractTransformFuture<
-        I extends @Nullable Object, O extends @Nullable Object, F, T extends @Nullable Object>
+        I extends Object, O extends Object, F, T extends Object>
     extends FluentFuture.TrustedFuture<O> implements Runnable {
-  static <I extends @Nullable Object, O extends @Nullable Object> ListenableFuture<O> create(
+  static <I extends Object, O extends Object> ListenableFuture<O> create(
       ListenableFuture<I> input,
       AsyncFunction<? super I, ? extends O> function,
       Executor executor) {
@@ -44,7 +40,7 @@ abstract class AbstractTransformFuture<
     return output;
   }
 
-  static <I extends @Nullable Object, O extends @Nullable Object> ListenableFuture<O> create(
+  static <I extends Object, O extends Object> ListenableFuture<O> create(
       ListenableFuture<I> input, Function<? super I, ? extends O> function, Executor executor) {
     checkNotNull(function);
     TransformFuture<I, O> output = new TransformFuture<>(input, function);
@@ -168,12 +164,10 @@ abstract class AbstractTransformFuture<
   }
 
   /** Template method for subtypes to actually run the transform. */
-  @ForOverride
   @ParametricNullness
   abstract T doTransform(F function, @ParametricNullness I result) throws Exception;
 
   /** Template method for subtypes to actually set the result. */
-  @ForOverride
   abstract void setResult(@ParametricNullness T result);
 
   @Override
@@ -206,7 +200,7 @@ abstract class AbstractTransformFuture<
    * #setFuture(ListenableFuture)}.
    */
   private static final class AsyncTransformFuture<
-          I extends @Nullable Object, O extends @Nullable Object>
+          I extends Object, O extends Object>
       extends AbstractTransformFuture<
           I, O, AsyncFunction<? super I, ? extends O>, ListenableFuture<? extends O>> {
     AsyncTransformFuture(
@@ -237,7 +231,7 @@ abstract class AbstractTransformFuture<
    * An {@link AbstractTransformFuture} that delegates to a {@link Function} and {@link
    * #set(Object)}.
    */
-  private static final class TransformFuture<I extends @Nullable Object, O extends @Nullable Object>
+  private static final class TransformFuture<I extends Object, O extends Object>
       extends AbstractTransformFuture<I, O, Function<? super I, ? extends O>, O> {
     TransformFuture(
         ListenableFuture<? extends I> inputFuture, Function<? super I, ? extends O> function) {
diff --git a/guava/src/com/google/common/util/concurrent/AggregateFuture.java b/guava/src/com/google/common/util/concurrent/AggregateFuture.java
index a32e76cdc3..0325842be6 100644
--- a/guava/src/com/google/common/util/concurrent/AggregateFuture.java
+++ b/guava/src/com/google/common/util/concurrent/AggregateFuture.java
@@ -23,16 +23,12 @@ import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 import static java.util.Objects.requireNonNull;
 import static java.util.logging.Level.SEVERE;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.ImmutableCollection;
-import com.google.errorprone.annotations.ForOverride;
-import com.google.errorprone.annotations.OverridingMethodsMustInvokeSuper;
 import java.util.Set;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.logging.Logger;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A future whose value is derived from a collection of input futures.
@@ -40,9 +36,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @param <InputT> the type of the individual inputs
  * @param <OutputT> the type of the output (i.e. this) future
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-abstract class AggregateFuture<InputT extends @Nullable Object, OutputT extends @Nullable Object>
+abstract class AggregateFuture<InputT extends Object, OutputT extends Object>
     extends AggregateFutureState<OutputT> {
   private static final Logger logger = Logger.getLogger(AggregateFuture.class.getName());
 
@@ -318,8 +313,6 @@ abstract class AggregateFuture<InputT extends @Nullable Object, OutputT extends
    * description of CL 265462958.
    */
   // TODO(user): Write more tests for memory retention.
-  @ForOverride
-  @OverridingMethodsMustInvokeSuper
   void releaseResources(ReleaseResourcesReason reason) {
     checkNotNull(reason);
     /*
diff --git a/guava/src/com/google/common/util/concurrent/AggregateFutureState.java b/guava/src/com/google/common/util/concurrent/AggregateFutureState.java
index ee23ca021e..51fd5dfcca 100644
--- a/guava/src/com/google/common/util/concurrent/AggregateFutureState.java
+++ b/guava/src/com/google/common/util/concurrent/AggregateFutureState.java
@@ -19,15 +19,12 @@ import static java.util.Objects.requireNonNull;
 import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;
 import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.j2objc.annotations.ReflectionSupport;
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A helper which does some thread-safe operations for aggregate futures, which must be implemented
@@ -38,10 +35,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *   <li>Decrements a counter atomically
  * </ul>
  */
-@GwtCompatible(emulated = true)
-@ReflectionSupport(value = ReflectionSupport.Level.FULL)
 @ElementTypesAreNonnullByDefault
-abstract class AggregateFutureState<OutputT extends @Nullable Object>
+abstract class AggregateFutureState<OutputT extends Object>
     extends AbstractFuture.TrustedFuture<OutputT> {
   // Lazily initialized the first time we see an exception; not released until all the input futures
   // have completed and we have processed them all.
diff --git a/guava/src/com/google/common/util/concurrent/AsyncCallable.java b/guava/src/com/google/common/util/concurrent/AsyncCallable.java
index 826f3c2947..3f257a014c 100644
--- a/guava/src/com/google/common/util/concurrent/AsyncCallable.java
+++ b/guava/src/com/google/common/util/concurrent/AsyncCallable.java
@@ -14,10 +14,7 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import java.util.concurrent.Future;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Computes a value, possibly asynchronously. For an example usage and more information, see {@link
@@ -28,11 +25,9 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @since 20.0
  */
-@Beta
 @FunctionalInterface
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public interface AsyncCallable<V extends @Nullable Object> {
+public interface AsyncCallable<V extends Object> {
   /**
    * Computes a result {@code Future}. The output {@code Future} need not be {@linkplain
    * Future#isDone done}, making {@code AsyncCallable} suitable for asynchronous derivations.
diff --git a/guava/src/com/google/common/util/concurrent/AsyncFunction.java b/guava/src/com/google/common/util/concurrent/AsyncFunction.java
index 3a19db4a5e..37da9c6e73 100644
--- a/guava/src/com/google/common/util/concurrent/AsyncFunction.java
+++ b/guava/src/com/google/common/util/concurrent/AsyncFunction.java
@@ -14,9 +14,7 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.concurrent.Future;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Transforms a value, possibly asynchronously. For an example usage and more information, see
@@ -25,10 +23,9 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Chris Povirk
  * @since 11.0
  */
-@GwtCompatible
 @FunctionalInterface
 @ElementTypesAreNonnullByDefault
-public interface AsyncFunction<I extends @Nullable Object, O extends @Nullable Object> {
+public interface AsyncFunction<I extends Object, O extends Object> {
   /**
    * Returns an output {@code Future} to use in place of the given {@code input}. The output {@code
    * Future} need not be {@linkplain Future#isDone done}, making {@code AsyncFunction} suitable for
diff --git a/guava/src/com/google/common/util/concurrent/AtomicDouble.java b/guava/src/com/google/common/util/concurrent/AtomicDouble.java
index 81da695cc4..f130be37d8 100644
--- a/guava/src/com/google/common/util/concurrent/AtomicDouble.java
+++ b/guava/src/com/google/common/util/concurrent/AtomicDouble.java
@@ -17,9 +17,6 @@ package com.google.common.util.concurrent;
 import static java.lang.Double.doubleToRawLongBits;
 import static java.lang.Double.longBitsToDouble;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.j2objc.annotations.ReflectionSupport;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 
 /**
@@ -51,8 +48,6 @@ import java.util.concurrent.atomic.AtomicLongFieldUpdater;
  * @author Martin Buchholz
  * @since 11.0
  */
-@GwtIncompatible
-@ReflectionSupport(value = ReflectionSupport.Level.FULL)
 @ElementTypesAreNonnullByDefault
 public class AtomicDouble extends Number implements java.io.Serializable {
   private static final long serialVersionUID = 0L;
@@ -153,7 +148,6 @@ public class AtomicDouble extends Number implements java.io.Serializable {
    * @param delta the value to add
    * @return the previous value
    */
-  @CanIgnoreReturnValue
   public final double getAndAdd(double delta) {
     while (true) {
       long current = value;
@@ -172,7 +166,6 @@ public class AtomicDouble extends Number implements java.io.Serializable {
    * @param delta the value to add
    * @return the updated value
    */
-  @CanIgnoreReturnValue
   public final double addAndGet(double delta) {
     while (true) {
       long current = value;
diff --git a/guava/src/com/google/common/util/concurrent/AtomicDoubleArray.java b/guava/src/com/google/common/util/concurrent/AtomicDoubleArray.java
index 58407f5d5a..0e2e5b74ed 100644
--- a/guava/src/com/google/common/util/concurrent/AtomicDoubleArray.java
+++ b/guava/src/com/google/common/util/concurrent/AtomicDoubleArray.java
@@ -16,9 +16,7 @@ package com.google.common.util.concurrent;
 import static java.lang.Double.doubleToRawLongBits;
 import static java.lang.Double.longBitsToDouble;
 
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.primitives.ImmutableLongArray;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.concurrent.atomic.AtomicLongArray;
 
 /**
@@ -43,7 +41,6 @@ import java.util.concurrent.atomic.AtomicLongArray;
  * @author Martin Buchholz
  * @since 11.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public class AtomicDoubleArray implements java.io.Serializable {
   private static final long serialVersionUID = 0L;
@@ -169,7 +166,6 @@ public class AtomicDoubleArray implements java.io.Serializable {
    * @param delta the value to add
    * @return the previous value
    */
-  @CanIgnoreReturnValue
   public final double getAndAdd(int i, double delta) {
     while (true) {
       long current = longs.get(i);
@@ -189,7 +185,6 @@ public class AtomicDoubleArray implements java.io.Serializable {
    * @param delta the value to add
    * @return the updated value
    */
-  @CanIgnoreReturnValue
   public double addAndGet(int i, double delta) {
     while (true) {
       long current = longs.get(i);
diff --git a/guava/src/com/google/common/util/concurrent/AtomicLongMap.java b/guava/src/com/google/common/util/concurrent/AtomicLongMap.java
index 456b3aceb1..9f8ec6567c 100644
--- a/guava/src/com/google/common/util/concurrent/AtomicLongMap.java
+++ b/guava/src/com/google/common/util/concurrent/AtomicLongMap.java
@@ -18,9 +18,6 @@ package com.google.common.util.concurrent;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.Serializable;
 import java.util.Collections;
 import java.util.Map;
@@ -54,7 +51,6 @@ import javax.annotation.CheckForNull;
  * @author Charles Fry
  * @since 11.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class AtomicLongMap<K> implements Serializable {
   private final ConcurrentHashMap<K, Long> map;
@@ -86,7 +82,6 @@ public final class AtomicLongMap<K> implements Serializable {
   /**
    * Increments by one the value currently associated with {@code key}, and returns the new value.
    */
-  @CanIgnoreReturnValue
   public long incrementAndGet(K key) {
     return addAndGet(key, 1);
   }
@@ -94,7 +89,6 @@ public final class AtomicLongMap<K> implements Serializable {
   /**
    * Decrements by one the value currently associated with {@code key}, and returns the new value.
    */
-  @CanIgnoreReturnValue
   public long decrementAndGet(K key) {
     return addAndGet(key, -1);
   }
@@ -103,7 +97,6 @@ public final class AtomicLongMap<K> implements Serializable {
    * Adds {@code delta} to the value currently associated with {@code key}, and returns the new
    * value.
    */
-  @CanIgnoreReturnValue
   public long addAndGet(K key, long delta) {
     return accumulateAndGet(key, delta, Long::sum);
   }
@@ -111,7 +104,6 @@ public final class AtomicLongMap<K> implements Serializable {
   /**
    * Increments by one the value currently associated with {@code key}, and returns the old value.
    */
-  @CanIgnoreReturnValue
   public long getAndIncrement(K key) {
     return getAndAdd(key, 1);
   }
@@ -119,7 +111,6 @@ public final class AtomicLongMap<K> implements Serializable {
   /**
    * Decrements by one the value currently associated with {@code key}, and returns the old value.
    */
-  @CanIgnoreReturnValue
   public long getAndDecrement(K key) {
     return getAndAdd(key, -1);
   }
@@ -128,7 +119,6 @@ public final class AtomicLongMap<K> implements Serializable {
    * Adds {@code delta} to the value currently associated with {@code key}, and returns the old
    * value.
    */
-  @CanIgnoreReturnValue
   public long getAndAdd(K key, long delta) {
     return getAndAccumulate(key, delta, Long::sum);
   }
@@ -140,7 +130,6 @@ public final class AtomicLongMap<K> implements Serializable {
    *
    * @since 21.0
    */
-  @CanIgnoreReturnValue
   public long updateAndGet(K key, LongUnaryOperator updaterFunction) {
     checkNotNull(updaterFunction);
     return map.compute(
@@ -154,7 +143,6 @@ public final class AtomicLongMap<K> implements Serializable {
    *
    * @since 21.0
    */
-  @CanIgnoreReturnValue
   public long getAndUpdate(K key, LongUnaryOperator updaterFunction) {
     checkNotNull(updaterFunction);
     AtomicLong holder = new AtomicLong();
@@ -176,7 +164,6 @@ public final class AtomicLongMap<K> implements Serializable {
    *
    * @since 21.0
    */
-  @CanIgnoreReturnValue
   public long accumulateAndGet(K key, long x, LongBinaryOperator accumulatorFunction) {
     checkNotNull(accumulatorFunction);
     return updateAndGet(key, oldValue -> accumulatorFunction.applyAsLong(oldValue, x));
@@ -190,7 +177,6 @@ public final class AtomicLongMap<K> implements Serializable {
    *
    * @since 21.0
    */
-  @CanIgnoreReturnValue
   public long getAndAccumulate(K key, long x, LongBinaryOperator accumulatorFunction) {
     checkNotNull(accumulatorFunction);
     return getAndUpdate(key, oldValue -> accumulatorFunction.applyAsLong(oldValue, x));
@@ -200,7 +186,6 @@ public final class AtomicLongMap<K> implements Serializable {
    * Associates {@code newValue} with {@code key} in this map, and returns the value previously
    * associated with {@code key}, or zero if there was no such value.
    */
-  @CanIgnoreReturnValue
   public long put(K key, long newValue) {
     return getAndUpdate(key, x -> newValue);
   }
@@ -219,7 +204,6 @@ public final class AtomicLongMap<K> implements Serializable {
    * Removes and returns the value associated with {@code key}. If {@code key} is not in the map,
    * this method has no effect and returns zero.
    */
-  @CanIgnoreReturnValue
   public long remove(K key) {
     Long result = map.remove(key);
     return (result == null) ? 0L : result.longValue();
@@ -238,8 +222,6 @@ public final class AtomicLongMap<K> implements Serializable {
    *
    * @since 20.0
    */
-  @Beta
-  @CanIgnoreReturnValue
   public boolean removeIfZero(K key) {
     return remove(key, 0);
   }
diff --git a/guava/src/com/google/common/util/concurrent/Atomics.java b/guava/src/com/google/common/util/concurrent/Atomics.java
index c1b6964ec2..4fde232b2f 100644
--- a/guava/src/com/google/common/util/concurrent/Atomics.java
+++ b/guava/src/com/google/common/util/concurrent/Atomics.java
@@ -14,10 +14,8 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.GwtIncompatible;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.atomic.AtomicReferenceArray;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to classes in the {@code java.util.concurrent.atomic} package.
@@ -25,7 +23,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kurt Alfred Kluever
  * @since 10.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class Atomics {
   private Atomics() {}
@@ -35,7 +32,7 @@ public final class Atomics {
    *
    * @return a new {@code AtomicReference} with no initial value
    */
-  public static <V> AtomicReference<@Nullable V> newReference() {
+  public static <V> AtomicReference<V> newReference() {
     return new AtomicReference<>();
   }
 
@@ -45,7 +42,7 @@ public final class Atomics {
    * @param initialValue the initial value
    * @return a new {@code AtomicReference} with the given initial value
    */
-  public static <V extends @Nullable Object> AtomicReference<V> newReference(
+  public static <V extends Object> AtomicReference<V> newReference(
       @ParametricNullness V initialValue) {
     return new AtomicReference<>(initialValue);
   }
@@ -56,7 +53,7 @@ public final class Atomics {
    * @param length the length of the array
    * @return a new {@code AtomicReferenceArray} with the given length
    */
-  public static <E> AtomicReferenceArray<@Nullable E> newReferenceArray(int length) {
+  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {
     return new AtomicReferenceArray<>(length);
   }
 
@@ -67,7 +64,7 @@ public final class Atomics {
    * @param array the array to copy elements from
    * @return a new {@code AtomicReferenceArray} copied from the given array
    */
-  public static <E extends @Nullable Object> AtomicReferenceArray<E> newReferenceArray(E[] array) {
+  public static <E extends Object> AtomicReferenceArray<E> newReferenceArray(E[] array) {
     return new AtomicReferenceArray<>(array);
   }
 }
diff --git a/guava/src/com/google/common/util/concurrent/Callables.java b/guava/src/com/google/common/util/concurrent/Callables.java
index 47b52643dc..b6c0f91ab0 100644
--- a/guava/src/com/google/common/util/concurrent/Callables.java
+++ b/guava/src/com/google/common/util/concurrent/Callables.java
@@ -16,12 +16,8 @@ package com.google.common.util.concurrent;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Supplier;
 import java.util.concurrent.Callable;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to the {@link Callable} interface.
@@ -29,13 +25,12 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Isaac Shum
  * @since 1.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class Callables {
   private Callables() {}
 
   /** Creates a {@code Callable} which immediately returns a preset value each time it is called. */
-  public static <T extends @Nullable Object> Callable<T> returning(
+  public static <T extends Object> Callable<T> returning(
       @ParametricNullness final T value) {
     return new Callable<T>() {
       @Override
@@ -54,9 +49,7 @@ public final class Callables {
    *
    * @since 20.0
    */
-  @Beta
-  @GwtIncompatible
-  public static <T extends @Nullable Object> AsyncCallable<T> asAsyncCallable(
+  public static <T extends Object> AsyncCallable<T> asAsyncCallable(
       final Callable<T> callable, final ListeningExecutorService listeningExecutorService) {
     checkNotNull(callable);
     checkNotNull(listeningExecutorService);
@@ -76,8 +69,8 @@ public final class Callables {
    * @param nameSupplier The supplier of thread names, {@link Supplier#get get} will be called once
    *     for each invocation of the wrapped callable.
    */
-  @GwtIncompatible // threads
-  static <T extends @Nullable Object> Callable<T> threadRenaming(
+  // threads
+  static <T extends Object> Callable<T> threadRenaming(
       final Callable<T> callable, final Supplier<String> nameSupplier) {
     checkNotNull(nameSupplier);
     checkNotNull(callable);
@@ -107,7 +100,7 @@ public final class Callables {
    * @param nameSupplier The supplier of thread names, {@link Supplier#get get} will be called once
    *     for each invocation of the wrapped callable.
    */
-  @GwtIncompatible // threads
+  // threads
   static Runnable threadRenaming(final Runnable task, final Supplier<String> nameSupplier) {
     checkNotNull(nameSupplier);
     checkNotNull(task);
@@ -129,7 +122,7 @@ public final class Callables {
   }
 
   /** Tries to set name of the given {@link Thread}, returns true if successful. */
-  @GwtIncompatible // threads
+  // threads
   private static boolean trySetName(final String threadName, Thread currentThread) {
     /*
      * setName should usually succeed, but the security manager can prohibit it. Is there a way to
diff --git a/guava/src/com/google/common/util/concurrent/ClosingFuture.java b/guava/src/com/google/common/util/concurrent/ClosingFuture.java
index 8859fbcdef..89bb581bc1 100644
--- a/guava/src/com/google/common/util/concurrent/ClosingFuture.java
+++ b/guava/src/com/google/common/util/concurrent/ClosingFuture.java
@@ -36,17 +36,12 @@ import static java.util.logging.Level.FINER;
 import static java.util.logging.Level.SEVERE;
 import static java.util.logging.Level.WARNING;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Function;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.util.concurrent.ClosingFuture.Combiner.AsyncCombiningCallable;
 import com.google.common.util.concurrent.ClosingFuture.Combiner.CombiningCallable;
 import com.google.common.util.concurrent.Futures.FutureCombiner;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotMock;
-import com.google.j2objc.annotations.RetainedWith;
 import java.io.Closeable;
 import java.util.IdentityHashMap;
 import java.util.Map;
@@ -60,7 +55,6 @@ import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.logging.Logger;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A step in a pipeline of an asynchronous computation. When the last step in the computation is
@@ -190,11 +184,10 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @since 30.0
  */
 // TODO(dpb): Consider reusing one CloseableList for the entire pipeline, modulo combinations.
-@Beta // @Beta for one release.
-@DoNotMock("Use ClosingFuture.from(Futures.immediate*Future)")
+// @Beta for one release.
 @ElementTypesAreNonnullByDefault
 // TODO(dpb): GWT compatibility.
-public final class ClosingFuture<V extends @Nullable Object> {
+public final class ClosingFuture<V extends Object> {
 
   private static final Logger logger = Logger.getLogger(ClosingFuture.class.getName());
 
@@ -203,7 +196,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
    * done.
    */
   public static final class DeferredCloser {
-    @RetainedWith private final CloseableList list;
+    private final CloseableList list;
 
     DeferredCloser(CloseableList list) {
       this.list = list;
@@ -232,9 +225,8 @@ public final class ClosingFuture<V extends @Nullable Object> {
      * @param closingExecutor the object will be closed on this executor
      * @return the first argument
      */
-    @CanIgnoreReturnValue
     @ParametricNullness
-    public <C extends @Nullable Object & @Nullable AutoCloseable> C eventuallyClose(
+    public <C extends Object & AutoCloseable> C eventuallyClose(
         @ParametricNullness C closeable, Executor closingExecutor) {
       checkNotNull(closingExecutor);
       if (closeable != null) {
@@ -250,7 +242,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
    * @param <V> the type of the result
    */
   @FunctionalInterface
-  public interface ClosingCallable<V extends @Nullable Object> {
+  public interface ClosingCallable<V extends Object> {
     /**
      * Computes a result, or throws an exception if unable to do so.
      *
@@ -269,7 +261,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
    * @since 30.1
    */
   @FunctionalInterface
-  public interface AsyncClosingCallable<V extends @Nullable Object> {
+  public interface AsyncClosingCallable<V extends Object> {
     /**
      * Computes a result, or throws an exception if unable to do so.
      *
@@ -287,7 +279,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
    * @param <U> the type of the result of the function
    */
   @FunctionalInterface
-  public interface ClosingFunction<T extends @Nullable Object, U extends @Nullable Object> {
+  public interface ClosingFunction<T extends Object, U extends Object> {
 
     /**
      * Applies this function to an input, or throws an exception if unable to do so.
@@ -307,7 +299,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
    * @param <U> the type of the result of the function
    */
   @FunctionalInterface
-  public interface AsyncClosingFunction<T extends @Nullable Object, U extends @Nullable Object> {
+  public interface AsyncClosingFunction<T extends Object, U extends Object> {
     /**
      * Applies this function to an input, or throws an exception if unable to do so.
      *
@@ -328,7 +320,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
    * @param <V> the type of the value of a successful operation
    * @see ClosingFuture#finishToValueAndCloser(ValueAndCloserConsumer, Executor)
    */
-  public static final class ValueAndCloser<V extends @Nullable Object> {
+  public static final class ValueAndCloser<V extends Object> {
 
     private final ClosingFuture<? extends V> closingFuture;
 
@@ -374,7 +366,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
    * @see ClosingFuture#finishToValueAndCloser(ValueAndCloserConsumer, Executor)
    */
   @FunctionalInterface
-  public interface ValueAndCloserConsumer<V extends @Nullable Object> {
+  public interface ValueAndCloserConsumer<V extends Object> {
 
     /** Accepts a {@link ValueAndCloser} for the last step in a {@link ClosingFuture} pipeline. */
     void accept(ValueAndCloser<V> valueAndCloser);
@@ -386,7 +378,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
    * @throws java.util.concurrent.RejectedExecutionException if the task cannot be scheduled for
    *     execution
    */
-  public static <V extends @Nullable Object> ClosingFuture<V> submit(
+  public static <V extends Object> ClosingFuture<V> submit(
       ClosingCallable<V> callable, Executor executor) {
     return new ClosingFuture<>(callable, executor);
   }
@@ -398,7 +390,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
    *     execution
    * @since 30.1
    */
-  public static <V extends @Nullable Object> ClosingFuture<V> submitAsync(
+  public static <V extends Object> ClosingFuture<V> submitAsync(
       AsyncClosingCallable<V> callable, Executor executor) {
     return new ClosingFuture<>(callable, executor);
   }
@@ -410,7 +402,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
    * implements {@link Closeable}. In order to start a pipeline with a value that will be closed
    * when the pipeline is done, use {@link #submit(ClosingCallable, Executor)} instead.
    */
-  public static <V extends @Nullable Object> ClosingFuture<V> from(ListenableFuture<V> future) {
+  public static <V extends Object> ClosingFuture<V> from(ListenableFuture<V> future) {
     return new ClosingFuture<V>(future);
   }
 
@@ -436,14 +428,14 @@ public final class ClosingFuture<V extends @Nullable Object> {
    *     ClosingFuture#from}.
    */
   @Deprecated
-  public static <C extends @Nullable Object & @Nullable AutoCloseable>
+  public static <C extends Object & AutoCloseable>
       ClosingFuture<C> eventuallyClosing(
           ListenableFuture<C> future, final Executor closingExecutor) {
     checkNotNull(closingExecutor);
     final ClosingFuture<C> closingFuture = new ClosingFuture<>(nonCancellationPropagating(future));
     Futures.addCallback(
         future,
-        new FutureCallback<@Nullable AutoCloseable>() {
+        new FutureCallback<AutoCloseable>() {
           @Override
           public void onSuccess(@CheckForNull AutoCloseable result) {
             closingFuture.closeables.closer.eventuallyClose(result, closingExecutor);
@@ -498,7 +490,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
    * @throws IllegalStateException if a {@code ClosingFuture} has already been derived from any of
    *     the arguments, or if any has already been {@linkplain #finishToFuture() finished}
    */
-  public static <V1 extends @Nullable Object, V2 extends @Nullable Object>
+  public static <V1 extends Object, V2 extends Object>
       Combiner2<V1, V2> whenAllSucceed(ClosingFuture<V1> future1, ClosingFuture<V2> future2) {
     return new Combiner2<>(future1, future2);
   }
@@ -514,7 +506,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
    *     the arguments, or if any has already been {@linkplain #finishToFuture() finished}
    */
   public static <
-          V1 extends @Nullable Object, V2 extends @Nullable Object, V3 extends @Nullable Object>
+          V1 extends Object, V2 extends Object, V3 extends Object>
       Combiner3<V1, V2, V3> whenAllSucceed(
           ClosingFuture<V1> future1, ClosingFuture<V2> future2, ClosingFuture<V3> future3) {
     return new Combiner3<>(future1, future2, future3);
@@ -531,10 +523,10 @@ public final class ClosingFuture<V extends @Nullable Object> {
    *     the arguments, or if any has already been {@linkplain #finishToFuture() finished}
    */
   public static <
-          V1 extends @Nullable Object,
-          V2 extends @Nullable Object,
-          V3 extends @Nullable Object,
-          V4 extends @Nullable Object>
+          V1 extends Object,
+          V2 extends Object,
+          V3 extends Object,
+          V4 extends Object>
       Combiner4<V1, V2, V3, V4> whenAllSucceed(
           ClosingFuture<V1> future1,
           ClosingFuture<V2> future2,
@@ -554,11 +546,11 @@ public final class ClosingFuture<V extends @Nullable Object> {
    *     the arguments, or if any has already been {@linkplain #finishToFuture() finished}
    */
   public static <
-          V1 extends @Nullable Object,
-          V2 extends @Nullable Object,
-          V3 extends @Nullable Object,
-          V4 extends @Nullable Object,
-          V5 extends @Nullable Object>
+          V1 extends Object,
+          V2 extends Object,
+          V3 extends Object,
+          V4 extends Object,
+          V5 extends Object>
       Combiner5<V1, V2, V3, V4, V5> whenAllSucceed(
           ClosingFuture<V1> future1,
           ClosingFuture<V2> future2,
@@ -690,7 +682,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
    *     one, or if this {@code ClosingFuture} has already been {@linkplain #finishToFuture()
    *     finished}
    */
-  public <U extends @Nullable Object> ClosingFuture<U> transform(
+  public <U extends Object> ClosingFuture<U> transform(
       final ClosingFunction<? super V, U> function, Executor executor) {
     checkNotNull(function);
     AsyncFunction<V, U> applyFunction =
@@ -784,7 +776,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
    *     one, or if this {@code ClosingFuture} has already been {@linkplain #finishToFuture()
    *     finished}
    */
-  public <U extends @Nullable Object> ClosingFuture<U> transformAsync(
+  public <U extends Object> ClosingFuture<U> transformAsync(
       final AsyncClosingFunction<? super V, U> function, Executor executor) {
     checkNotNull(function);
     AsyncFunction<V, U> applyFunction =
@@ -828,7 +820,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
    * @param function transforms the value of a {@code ClosingFuture} step to a {@link
    *     ListenableFuture} with the value of a derived step
    */
-  public static <V extends @Nullable Object, U extends @Nullable Object>
+  public static <V extends Object, U extends Object>
       AsyncClosingFunction<V, U> withoutCloser(final AsyncFunction<V, U> function) {
     checkNotNull(function);
     return new AsyncClosingFunction<V, U>() {
@@ -1098,7 +1090,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
         executor);
   }
 
-  private static <C extends @Nullable Object, V extends C> void provideValueAndCloser(
+  private static <C extends Object, V extends C> void provideValueAndCloser(
       ValueAndCloserConsumer<C> consumer, ClosingFuture<V> closingFuture) {
     consumer.accept(new ValueAndCloser<C>(closingFuture));
   }
@@ -1119,7 +1111,6 @@ public final class ClosingFuture<V extends @Nullable Object> {
    * @return {@code false} if the step could not be cancelled, typically because it has already
    *     completed normally; {@code true} otherwise
    */
-  @CanIgnoreReturnValue
   public boolean cancel(boolean mayInterruptIfRunning) {
     logger.log(FINER, "cancelling {0}", this);
     boolean cancelled = future.cancel(mayInterruptIfRunning);
@@ -1134,7 +1125,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
     closeables.close();
   }
 
-  private <U extends @Nullable Object> ClosingFuture<U> derive(FluentFuture<U> future) {
+  private <U extends Object> ClosingFuture<U> derive(FluentFuture<U> future) {
     ClosingFuture<U> derived = new ClosingFuture<>(future);
     becomeSubsumedInto(derived.closeables);
     return derived;
@@ -1171,7 +1162,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
      *     AsyncCombiningCallable#call(DeferredCloser, Peeker)}
      */
     @ParametricNullness
-    public final <D extends @Nullable Object> D getDone(ClosingFuture<D> closingFuture)
+    public final <D extends Object> D getDone(ClosingFuture<D> closingFuture)
         throws ExecutionException {
       checkState(beingCalled);
       checkArgument(futures.contains(closingFuture));
@@ -1179,7 +1170,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
     }
 
     @ParametricNullness
-    private <V extends @Nullable Object> V call(
+    private <V extends Object> V call(
         CombiningCallable<V> combiner, CloseableList closeables) throws Exception {
       beingCalled = true;
       CloseableList newCloseables = new CloseableList();
@@ -1191,7 +1182,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
       }
     }
 
-    private <V extends @Nullable Object> FluentFuture<V> callAsync(
+    private <V extends Object> FluentFuture<V> callAsync(
         AsyncCombiningCallable<V> combiner, CloseableList closeables) throws Exception {
       beingCalled = true;
       CloseableList newCloseables = new CloseableList();
@@ -1230,8 +1221,6 @@ public final class ClosingFuture<V extends @Nullable Object> {
    * }</pre>
    */
   // TODO(cpovirk): Use simple name instead of fully qualified after we stop building with JDK 8.
-  @com.google.errorprone.annotations.DoNotMock(
-      "Use ClosingFuture.whenAllSucceed() or .whenAllComplete() instead.")
   public static class Combiner {
 
     private final CloseableList closeables = new CloseableList();
@@ -1242,7 +1231,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
      * @param <V> the type of the result
      */
     @FunctionalInterface
-    public interface CombiningCallable<V extends @Nullable Object> {
+    public interface CombiningCallable<V extends Object> {
       /**
        * Computes a result, or throws an exception if unable to do so.
        *
@@ -1263,7 +1252,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
      * @param <V> the type of the result
      */
     @FunctionalInterface
-    public interface AsyncCombiningCallable<V extends @Nullable Object> {
+    public interface AsyncCombiningCallable<V extends Object> {
       /**
        * Computes a {@link ClosingFuture} result, or throws an exception if unable to do so.
        *
@@ -1302,7 +1291,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
      * <p>If the combiningCallable throws an {@code ExecutionException}, the cause of the thrown
      * {@code ExecutionException} will be extracted and used as the failure of the derived step.
      */
-    public <V extends @Nullable Object> ClosingFuture<V> call(
+    public <V extends Object> ClosingFuture<V> call(
         final CombiningCallable<V> combiningCallable, Executor executor) {
       Callable<V> callable =
           new Callable<V>() {
@@ -1359,7 +1348,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
      * <p>The same warnings about doing heavyweight operations within {@link
      * ClosingFuture#transformAsync(AsyncClosingFunction, Executor)} apply here.
      */
-    public <V extends @Nullable Object> ClosingFuture<V> callAsync(
+    public <V extends Object> ClosingFuture<V> callAsync(
         final AsyncCombiningCallable<V> combiningCallable, Executor executor) {
       AsyncCallable<V> asyncCallable =
           new AsyncCallable<V>() {
@@ -1379,7 +1368,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
       return derived;
     }
 
-    private FutureCombiner<@Nullable Object> futureCombiner() {
+    private FutureCombiner<Object> futureCombiner() {
       return allMustSucceed
           ? Futures.whenAllSucceed(inputFutures())
           : Futures.whenAllComplete(inputFutures());
@@ -1406,7 +1395,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
    * @param <V1> the type returned by the first future
    * @param <V2> the type returned by the second future
    */
-  public static final class Combiner2<V1 extends @Nullable Object, V2 extends @Nullable Object>
+  public static final class Combiner2<V1 extends Object, V2 extends Object>
       extends Combiner {
 
     /**
@@ -1419,7 +1408,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
      */
     @FunctionalInterface
     public interface ClosingFunction2<
-        V1 extends @Nullable Object, V2 extends @Nullable Object, U extends @Nullable Object> {
+        V1 extends Object, V2 extends Object, U extends Object> {
 
       /**
        * Applies this function to two inputs, or throws an exception if unable to do so.
@@ -1444,7 +1433,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
      */
     @FunctionalInterface
     public interface AsyncClosingFunction2<
-        V1 extends @Nullable Object, V2 extends @Nullable Object, U extends @Nullable Object> {
+        V1 extends Object, V2 extends Object, U extends Object> {
 
       /**
        * Applies this function to two inputs, or throws an exception if unable to do so.
@@ -1481,7 +1470,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
      * <p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code
      * ExecutionException} will be extracted and used as the failure of the derived step.
      */
-    public <U extends @Nullable Object> ClosingFuture<U> call(
+    public <U extends Object> ClosingFuture<U> call(
         final ClosingFunction2<V1, V2, U> function, Executor executor) {
       return call(
           new CombiningCallable<U>() {
@@ -1535,7 +1524,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
      * <p>The same warnings about doing heavyweight operations within {@link
      * ClosingFuture#transformAsync(AsyncClosingFunction, Executor)} apply here.
      */
-    public <U extends @Nullable Object> ClosingFuture<U> callAsync(
+    public <U extends Object> ClosingFuture<U> callAsync(
         final AsyncClosingFunction2<V1, V2, U> function, Executor executor) {
       return callAsync(
           new AsyncCombiningCallable<U>() {
@@ -1563,7 +1552,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
    * @param <V3> the type returned by the third future
    */
   public static final class Combiner3<
-          V1 extends @Nullable Object, V2 extends @Nullable Object, V3 extends @Nullable Object>
+          V1 extends Object, V2 extends Object, V3 extends Object>
       extends Combiner {
     /**
      * A function that returns a value when applied to the values of the three futures passed to
@@ -1576,10 +1565,10 @@ public final class ClosingFuture<V extends @Nullable Object> {
      */
     @FunctionalInterface
     public interface ClosingFunction3<
-        V1 extends @Nullable Object,
-        V2 extends @Nullable Object,
-        V3 extends @Nullable Object,
-        U extends @Nullable Object> {
+        V1 extends Object,
+        V2 extends Object,
+        V3 extends Object,
+        U extends Object> {
       /**
        * Applies this function to three inputs, or throws an exception if unable to do so.
        *
@@ -1608,10 +1597,10 @@ public final class ClosingFuture<V extends @Nullable Object> {
      */
     @FunctionalInterface
     public interface AsyncClosingFunction3<
-        V1 extends @Nullable Object,
-        V2 extends @Nullable Object,
-        V3 extends @Nullable Object,
-        U extends @Nullable Object> {
+        V1 extends Object,
+        V2 extends Object,
+        V3 extends Object,
+        U extends Object> {
       /**
        * Applies this function to three inputs, or throws an exception if unable to do so.
        *
@@ -1653,7 +1642,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
      * <p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code
      * ExecutionException} will be extracted and used as the failure of the derived step.
      */
-    public <U extends @Nullable Object> ClosingFuture<U> call(
+    public <U extends Object> ClosingFuture<U> call(
         final ClosingFunction3<V1, V2, V3, U> function, Executor executor) {
       return call(
           new CombiningCallable<U>() {
@@ -1711,7 +1700,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
      * <p>The same warnings about doing heavyweight operations within {@link
      * ClosingFuture#transformAsync(AsyncClosingFunction, Executor)} apply here.
      */
-    public <U extends @Nullable Object> ClosingFuture<U> callAsync(
+    public <U extends Object> ClosingFuture<U> callAsync(
         final AsyncClosingFunction3<V1, V2, V3, U> function, Executor executor) {
       return callAsync(
           new AsyncCombiningCallable<U>() {
@@ -1744,10 +1733,10 @@ public final class ClosingFuture<V extends @Nullable Object> {
    * @param <V4> the type returned by the fourth future
    */
   public static final class Combiner4<
-          V1 extends @Nullable Object,
-          V2 extends @Nullable Object,
-          V3 extends @Nullable Object,
-          V4 extends @Nullable Object>
+          V1 extends Object,
+          V2 extends Object,
+          V3 extends Object,
+          V4 extends Object>
       extends Combiner {
     /**
      * A function that returns a value when applied to the values of the four futures passed to
@@ -1761,11 +1750,11 @@ public final class ClosingFuture<V extends @Nullable Object> {
      */
     @FunctionalInterface
     public interface ClosingFunction4<
-        V1 extends @Nullable Object,
-        V2 extends @Nullable Object,
-        V3 extends @Nullable Object,
-        V4 extends @Nullable Object,
-        U extends @Nullable Object> {
+        V1 extends Object,
+        V2 extends Object,
+        V3 extends Object,
+        V4 extends Object,
+        U extends Object> {
       /**
        * Applies this function to four inputs, or throws an exception if unable to do so.
        *
@@ -1797,11 +1786,11 @@ public final class ClosingFuture<V extends @Nullable Object> {
      */
     @FunctionalInterface
     public interface AsyncClosingFunction4<
-        V1 extends @Nullable Object,
-        V2 extends @Nullable Object,
-        V3 extends @Nullable Object,
-        V4 extends @Nullable Object,
-        U extends @Nullable Object> {
+        V1 extends Object,
+        V2 extends Object,
+        V3 extends Object,
+        V4 extends Object,
+        U extends Object> {
       /**
        * Applies this function to four inputs, or throws an exception if unable to do so.
        *
@@ -1849,7 +1838,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
      * <p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code
      * ExecutionException} will be extracted and used as the failure of the derived step.
      */
-    public <U extends @Nullable Object> ClosingFuture<U> call(
+    public <U extends Object> ClosingFuture<U> call(
         final ClosingFunction4<V1, V2, V3, V4, U> function, Executor executor) {
       return call(
           new CombiningCallable<U>() {
@@ -1908,7 +1897,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
      * <p>The same warnings about doing heavyweight operations within {@link
      * ClosingFuture#transformAsync(AsyncClosingFunction, Executor)} apply here.
      */
-    public <U extends @Nullable Object> ClosingFuture<U> callAsync(
+    public <U extends Object> ClosingFuture<U> callAsync(
         final AsyncClosingFunction4<V1, V2, V3, V4, U> function, Executor executor) {
       return callAsync(
           new AsyncCombiningCallable<U>() {
@@ -1943,11 +1932,11 @@ public final class ClosingFuture<V extends @Nullable Object> {
    * @param <V5> the type returned by the fifth future
    */
   public static final class Combiner5<
-          V1 extends @Nullable Object,
-          V2 extends @Nullable Object,
-          V3 extends @Nullable Object,
-          V4 extends @Nullable Object,
-          V5 extends @Nullable Object>
+          V1 extends Object,
+          V2 extends Object,
+          V3 extends Object,
+          V4 extends Object,
+          V5 extends Object>
       extends Combiner {
     /**
      * A function that returns a value when applied to the values of the five futures passed to
@@ -1963,12 +1952,12 @@ public final class ClosingFuture<V extends @Nullable Object> {
      */
     @FunctionalInterface
     public interface ClosingFunction5<
-        V1 extends @Nullable Object,
-        V2 extends @Nullable Object,
-        V3 extends @Nullable Object,
-        V4 extends @Nullable Object,
-        V5 extends @Nullable Object,
-        U extends @Nullable Object> {
+        V1 extends Object,
+        V2 extends Object,
+        V3 extends Object,
+        V4 extends Object,
+        V5 extends Object,
+        U extends Object> {
       /**
        * Applies this function to five inputs, or throws an exception if unable to do so.
        *
@@ -2002,12 +1991,12 @@ public final class ClosingFuture<V extends @Nullable Object> {
      */
     @FunctionalInterface
     public interface AsyncClosingFunction5<
-        V1 extends @Nullable Object,
-        V2 extends @Nullable Object,
-        V3 extends @Nullable Object,
-        V4 extends @Nullable Object,
-        V5 extends @Nullable Object,
-        U extends @Nullable Object> {
+        V1 extends Object,
+        V2 extends Object,
+        V3 extends Object,
+        V4 extends Object,
+        V5 extends Object,
+        U extends Object> {
       /**
        * Applies this function to five inputs, or throws an exception if unable to do so.
        *
@@ -2060,7 +2049,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
      * <p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code
      * ExecutionException} will be extracted and used as the failure of the derived step.
      */
-    public <U extends @Nullable Object> ClosingFuture<U> call(
+    public <U extends Object> ClosingFuture<U> call(
         final ClosingFunction5<V1, V2, V3, V4, V5, U> function, Executor executor) {
       return call(
           new CombiningCallable<U>() {
@@ -2121,7 +2110,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
      * <p>The same warnings about doing heavyweight operations within {@link
      * ClosingFuture#transformAsync(AsyncClosingFunction, Executor)} apply here.
      */
-    public <U extends @Nullable Object> ClosingFuture<U> callAsync(
+    public <U extends Object> ClosingFuture<U> callAsync(
         final AsyncClosingFunction5<V1, V2, V3, V4, V5, U> function, Executor executor) {
       return callAsync(
           new AsyncCombiningCallable<U>() {
@@ -2203,7 +2192,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
     private volatile boolean closed;
     @CheckForNull private volatile CountDownLatch whenClosed;
 
-    <V extends @Nullable Object, U extends @Nullable Object>
+    <V extends Object, U extends Object>
         ListenableFuture<U> applyClosingFunction(
             ClosingFunction<? super V, U> transformation, @ParametricNullness V input)
             throws Exception {
@@ -2216,7 +2205,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
       }
     }
 
-    <V extends @Nullable Object, U extends @Nullable Object>
+    <V extends Object, U extends Object>
         FluentFuture<U> applyAsyncClosingFunction(
             AsyncClosingFunction<V, U> transformation, @ParametricNullness V input)
             throws Exception {
@@ -2286,7 +2275,6 @@ public final class ClosingFuture<V extends @Nullable Object> {
    * Returns an object that can be used to wait until this objects' deferred closeables have all had
    * {@link Runnable}s that close them submitted to each one's closing {@link Executor}.
    */
-  @VisibleForTesting
   CountDownLatch whenClosedCountDown() {
     return closeables.whenClosedCountDown();
   }
diff --git a/guava/src/com/google/common/util/concurrent/CollectionFuture.java b/guava/src/com/google/common/util/concurrent/CollectionFuture.java
index c106c157e2..706130e097 100644
--- a/guava/src/com/google/common/util/concurrent/CollectionFuture.java
+++ b/guava/src/com/google/common/util/concurrent/CollectionFuture.java
@@ -17,18 +17,15 @@ package com.google.common.util.concurrent;
 import static com.google.common.collect.Lists.newArrayListWithCapacity;
 import static java.util.Collections.unmodifiableList;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.ImmutableCollection;
 import com.google.common.collect.Lists;
 import java.util.Collections;
 import java.util.List;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** Aggregate future that collects (stores) results of each future. */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
-abstract class CollectionFuture<V extends @Nullable Object, C extends @Nullable Object>
+abstract class CollectionFuture<V extends Object, C extends Object>
     extends AggregateFuture<V, C> {
   /*
    * We access this field racily but safely. For discussion of a similar situation, see the comments
@@ -36,17 +33,17 @@ abstract class CollectionFuture<V extends @Nullable Object, C extends @Nullable
    * there: cancel() never reads this field, only writes to it. That makes the race here completely
    * harmless, rather than just 99.99% harmless.
    */
-  @CheckForNull private List<@Nullable Present<V>> values;
+  @CheckForNull private List<Present<V>> values;
 
   CollectionFuture(
       ImmutableCollection<? extends ListenableFuture<? extends V>> futures,
       boolean allMustSucceed) {
     super(futures, allMustSucceed, true);
 
-    List<@Nullable Present<V>> values =
+    List<Present<V>> values =
         futures.isEmpty()
-            ? Collections.<@Nullable Present<V>>emptyList()
-            : Lists.<@Nullable Present<V>>newArrayListWithCapacity(futures.size());
+            ? Collections.<Present<V>>emptyList()
+            : Lists.<Present<V>>newArrayListWithCapacity(futures.size());
 
     // Populate the results list with null initially.
     for (int i = 0; i < futures.size(); ++i) {
@@ -58,7 +55,7 @@ abstract class CollectionFuture<V extends @Nullable Object, C extends @Nullable
 
   @Override
   final void collectOneValue(int index, @ParametricNullness V returnValue) {
-    List<@Nullable Present<V>> localValues = values;
+    List<Present<V>> localValues = values;
     if (localValues != null) {
       localValues.set(index, new Present<>(returnValue));
     }
@@ -66,7 +63,7 @@ abstract class CollectionFuture<V extends @Nullable Object, C extends @Nullable
 
   @Override
   final void handleAllCompleted() {
-    List<@Nullable Present<V>> localValues = values;
+    List<Present<V>> localValues = values;
     if (localValues != null) {
       set(combine(localValues));
     }
@@ -78,11 +75,11 @@ abstract class CollectionFuture<V extends @Nullable Object, C extends @Nullable
     this.values = null;
   }
 
-  abstract C combine(List<@Nullable Present<V>> values);
+  abstract C combine(List<Present<V>> values);
 
   /** Used for {@link Futures#allAsList} and {@link Futures#successfulAsList}. */
-  static final class ListFuture<V extends @Nullable Object>
-      extends CollectionFuture<V, List<@Nullable V>> {
+  static final class ListFuture<V extends Object>
+      extends CollectionFuture<V, List<V>> {
     ListFuture(
         ImmutableCollection<? extends ListenableFuture<? extends V>> futures,
         boolean allMustSucceed) {
@@ -91,8 +88,8 @@ abstract class CollectionFuture<V extends @Nullable Object, C extends @Nullable
     }
 
     @Override
-    public List<@Nullable V> combine(List<@Nullable Present<V>> values) {
-      List<@Nullable V> result = newArrayListWithCapacity(values.size());
+    public List<V> combine(List<Present<V>> values) {
+      List<V> result = newArrayListWithCapacity(values.size());
       for (Present<V> element : values) {
         result.add(element != null ? element.value : null);
       }
@@ -101,7 +98,7 @@ abstract class CollectionFuture<V extends @Nullable Object, C extends @Nullable
   }
 
   /** The result of a successful {@code Future}. */
-  private static final class Present<V extends @Nullable Object> {
+  private static final class Present<V extends Object> {
     V value;
 
     Present(V value) {
diff --git a/guava/src/com/google/common/util/concurrent/CombinedFuture.java b/guava/src/com/google/common/util/concurrent/CombinedFuture.java
index c22211164c..69e3a7b49c 100644
--- a/guava/src/com/google/common/util/concurrent/CombinedFuture.java
+++ b/guava/src/com/google/common/util/concurrent/CombinedFuture.java
@@ -17,22 +17,18 @@ package com.google.common.util.concurrent;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.util.concurrent.AggregateFuture.ReleaseResourcesReason.OUTPUT_FUTURE_DONE;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.ImmutableCollection;
-import com.google.j2objc.annotations.WeakOuter;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.RejectedExecutionException;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** Aggregate future that computes its value by calling a callable. */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-final class CombinedFuture<V extends @Nullable Object>
-    extends AggregateFuture<@Nullable Object, V> {
+final class CombinedFuture<V extends Object>
+    extends AggregateFuture<Object, V> {
   @CheckForNull private CombinedFutureInterruptibleTask<?> task;
 
   CombinedFuture(
@@ -89,8 +85,7 @@ final class CombinedFuture<V extends @Nullable Object>
     }
   }
 
-  @WeakOuter
-  private abstract class CombinedFutureInterruptibleTask<T extends @Nullable Object>
+  private abstract class CombinedFutureInterruptibleTask<T extends Object>
       extends InterruptibleTask<T> {
     private final Executor listenerExecutor;
 
@@ -150,7 +145,6 @@ final class CombinedFuture<V extends @Nullable Object>
     abstract void setValue(@ParametricNullness T value);
   }
 
-  @WeakOuter
   private final class AsyncCallableInterruptibleTask
       extends CombinedFutureInterruptibleTask<ListenableFuture<V>> {
     private final AsyncCallable<V> callable;
@@ -181,7 +175,6 @@ final class CombinedFuture<V extends @Nullable Object>
     }
   }
 
-  @WeakOuter
   private final class CallableInterruptibleTask extends CombinedFutureInterruptibleTask<V> {
     private final Callable<V> callable;
 
diff --git a/guava/src/com/google/common/util/concurrent/CycleDetectingLockFactory.java b/guava/src/com/google/common/util/concurrent/CycleDetectingLockFactory.java
index b6b161d1a2..033c598cb2 100644
--- a/guava/src/com/google/common/util/concurrent/CycleDetectingLockFactory.java
+++ b/guava/src/com/google/common/util/concurrent/CycleDetectingLockFactory.java
@@ -17,9 +17,6 @@ package com.google.common.util.concurrent;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableSet;
@@ -27,8 +24,6 @@ import com.google.common.collect.Lists;
 import com.google.common.collect.MapMaker;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.j2objc.annotations.Weak;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -160,9 +155,7 @@ import javax.annotation.CheckForNull;
  * @author Darick Tong
  * @since 13.0
  */
-@Beta
-@CanIgnoreReturnValue // TODO(cpovirk): Consider being more strict.
-@GwtIncompatible
+// TODO(cpovirk): Consider being more strict.
 @ElementTypesAreNonnullByDefault
 public class CycleDetectingLockFactory {
 
@@ -173,7 +166,6 @@ public class CycleDetectingLockFactory {
    *
    * @since 13.0
    */
-  @Beta
   public interface Policy {
 
     /**
@@ -193,7 +185,6 @@ public class CycleDetectingLockFactory {
    *
    * @since 13.0
    */
-  @Beta
   public enum Policies implements Policy {
     /**
      * When potential deadlock is detected, this policy results in the throwing of the {@code
@@ -304,7 +295,6 @@ public class CycleDetectingLockFactory {
    * disallowedPriorLocks} prepopulated with nodes according to the natural ordering of the
    * associated Enum values.
    */
-  @VisibleForTesting
   static <E extends Enum<E>> Map<E, LockGraphNode> createNodes(Class<E> clazz) {
     EnumMap<E, LockGraphNode> map = Maps.newEnumMap(clazz);
     E[] keys = clazz.getEnumConstants();
@@ -394,13 +384,11 @@ public class CycleDetectingLockFactory {
    * @param <E> The Enum type representing the explicit lock ordering.
    * @since 13.0
    */
-  @Beta
   public static final class WithExplicitOrdering<E extends Enum<E>>
       extends CycleDetectingLockFactory {
 
     private final Map<E, LockGraphNode> lockGraphNodes;
 
-    @VisibleForTesting
     WithExplicitOrdering(Policy policy, Map<E, LockGraphNode> lockGraphNodes) {
       super(policy);
       this.lockGraphNodes = lockGraphNodes;
@@ -534,7 +522,6 @@ public class CycleDetectingLockFactory {
    *
    * @since 13.0
    */
-  @Beta
   public static final class PotentialDeadlockException extends ExampleStackTrace {
 
     private final ExampleStackTrace conflictingStackTrace;
@@ -863,7 +850,7 @@ public class CycleDetectingLockFactory {
 
   private class CycleDetectingReentrantReadLock extends ReentrantReadWriteLock.ReadLock {
 
-    @Weak final CycleDetectingReentrantReadWriteLock readWriteLock;
+    final CycleDetectingReentrantReadWriteLock readWriteLock;
 
     CycleDetectingReentrantReadLock(CycleDetectingReentrantReadWriteLock readWriteLock) {
       super(readWriteLock);
@@ -922,7 +909,7 @@ public class CycleDetectingLockFactory {
 
   private class CycleDetectingReentrantWriteLock extends ReentrantReadWriteLock.WriteLock {
 
-    @Weak final CycleDetectingReentrantReadWriteLock readWriteLock;
+    final CycleDetectingReentrantReadWriteLock readWriteLock;
 
     CycleDetectingReentrantWriteLock(CycleDetectingReentrantReadWriteLock readWriteLock) {
       super(readWriteLock);
diff --git a/guava/src/com/google/common/util/concurrent/DirectExecutor.java b/guava/src/com/google/common/util/concurrent/DirectExecutor.java
index 0c3a46b703..4d12e1ec45 100644
--- a/guava/src/com/google/common/util/concurrent/DirectExecutor.java
+++ b/guava/src/com/google/common/util/concurrent/DirectExecutor.java
@@ -14,14 +14,12 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.concurrent.Executor;
 
 /**
  * An {@link Executor} that runs each task in the thread that invokes {@link Executor#execute
  * execute}.
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 enum DirectExecutor implements Executor {
   INSTANCE;
diff --git a/guava/src/com/google/common/util/concurrent/ElementTypesAreNonnullByDefault.java b/guava/src/com/google/common/util/concurrent/ElementTypesAreNonnullByDefault.java
index 34871255e8..669a53b41e 100644
--- a/guava/src/com/google/common/util/concurrent/ElementTypesAreNonnullByDefault.java
+++ b/guava/src/com/google/common/util/concurrent/ElementTypesAreNonnullByDefault.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.ElementType.TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -33,7 +32,6 @@ import javax.annotation.meta.TypeQualifierDefault;
  * unfortunately includes type-variable usages, so we also provide {@link ParametricNullness} to
  * "undo" it as best we can.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target(TYPE)
 @TypeQualifierDefault({FIELD, METHOD, PARAMETER})
diff --git a/guava/src/com/google/common/util/concurrent/ExecutionError.java b/guava/src/com/google/common/util/concurrent/ExecutionError.java
index deaff15a42..7df64a4553 100644
--- a/guava/src/com/google/common/util/concurrent/ExecutionError.java
+++ b/guava/src/com/google/common/util/concurrent/ExecutionError.java
@@ -14,7 +14,6 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.GwtCompatible;
 import javax.annotation.CheckForNull;
 
 /**
@@ -27,7 +26,6 @@ import javax.annotation.CheckForNull;
  * @author Chris Povirk
  * @since 10.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public class ExecutionError extends Error {
   /*
diff --git a/guava/src/com/google/common/util/concurrent/ExecutionList.java b/guava/src/com/google/common/util/concurrent/ExecutionList.java
index 96fc51ca88..35e6ce940b 100644
--- a/guava/src/com/google/common/util/concurrent/ExecutionList.java
+++ b/guava/src/com/google/common/util/concurrent/ExecutionList.java
@@ -16,8 +16,6 @@ package com.google.common.util.concurrent;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.concurrent.GuardedBy;
 import java.util.concurrent.Executor;
 import java.util.logging.Level;
 import java.util.logging.Logger;
@@ -39,7 +37,6 @@ import javax.annotation.CheckForNull;
  * @author Sven Mawson
  * @since 1.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class ExecutionList {
   /** Logger to log exceptions caught when running runnables. */
@@ -49,11 +46,9 @@ public final class ExecutionList {
    * The runnable, executor pairs to execute. This acts as a stack threaded through the {@link
    * RunnableExecutorPair#next} field.
    */
-  @GuardedBy("this")
   @CheckForNull
   private RunnableExecutorPair runnables;
 
-  @GuardedBy("this")
   private boolean executed;
 
   /** Creates a new, empty {@link ExecutionList}. */
diff --git a/guava/src/com/google/common/util/concurrent/ExecutionSequencer.java b/guava/src/com/google/common/util/concurrent/ExecutionSequencer.java
index 148f50b8fa..134d155c37 100644
--- a/guava/src/com/google/common/util/concurrent/ExecutionSequencer.java
+++ b/guava/src/com/google/common/util/concurrent/ExecutionSequencer.java
@@ -25,12 +25,10 @@ import static com.google.common.util.concurrent.Futures.immediateVoidFuture;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
 import java.util.concurrent.Callable;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicReference;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Serializes execution of tasks, somewhat like an "asynchronous {@code synchronized} block." Each
@@ -80,7 +78,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @since 26.0
  */
-@Beta
 @ElementTypesAreNonnullByDefault
 public final class ExecutionSequencer {
 
@@ -92,7 +89,7 @@ public final class ExecutionSequencer {
   }
 
   /** This reference acts as a pointer tracking the head of a linked list of ListenableFutures. */
-  private final AtomicReference<ListenableFuture<@Nullable Void>> ref =
+  private final AtomicReference<ListenableFuture<Void>> ref =
       new AtomicReference<>(immediateVoidFuture());
 
   private ThreadConfinedTaskQueue latestTaskQueue = new ThreadConfinedTaskQueue();
@@ -140,7 +137,7 @@ public final class ExecutionSequencer {
    * execute, but if the output future is cancelled before {@link Callable#call()} is invoked,
    * {@link Callable#call()} will not be invoked.
    */
-  public <T extends @Nullable Object> ListenableFuture<T> submit(
+  public <T extends Object> ListenableFuture<T> submit(
       final Callable<T> callable, Executor executor) {
     checkNotNull(callable);
     checkNotNull(executor);
@@ -166,7 +163,7 @@ public final class ExecutionSequencer {
    * callable} or a callable that has begun to execute, but if the output future is cancelled before
    * {@link AsyncCallable#call()} is invoked, {@link AsyncCallable#call()} will not be invoked.
    */
-  public <T extends @Nullable Object> ListenableFuture<T> submitAsync(
+  public <T extends Object> ListenableFuture<T> submitAsync(
       final AsyncCallable<T> callable, final Executor executor) {
     checkNotNull(callable);
     checkNotNull(executor);
@@ -197,9 +194,9 @@ public final class ExecutionSequencer {
      * have completed - namely after oldFuture is done, and taskFuture has either completed or been
      * cancelled before the callable started execution.
      */
-    final SettableFuture<@Nullable Void> newFuture = SettableFuture.create();
+    final SettableFuture<Void> newFuture = SettableFuture.create();
 
-    final ListenableFuture<@Nullable Void> oldFuture = ref.getAndSet(newFuture);
+    final ListenableFuture<Void> oldFuture = ref.getAndSet(newFuture);
 
     // Invoke our task once the previous future completes.
     final TrustedListenableFutureTask<T> taskFuture = TrustedListenableFutureTask.create(task);
diff --git a/guava/src/com/google/common/util/concurrent/FakeTimeLimiter.java b/guava/src/com/google/common/util/concurrent/FakeTimeLimiter.java
index ddc9440188..dfdc9b7073 100644
--- a/guava/src/com/google/common/util/concurrent/FakeTimeLimiter.java
+++ b/guava/src/com/google/common/util/concurrent/FakeTimeLimiter.java
@@ -16,13 +16,9 @@ package com.google.common.util.concurrent;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A TimeLimiter implementation which actually does not attempt to limit time at all. This may be
@@ -34,9 +30,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Jens Nyman
  * @since 1.0
  */
-@Beta
-@CanIgnoreReturnValue
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class FakeTimeLimiter implements TimeLimiter {
   @Override
@@ -50,7 +43,7 @@ public final class FakeTimeLimiter implements TimeLimiter {
 
   @Override
   @ParametricNullness
-  public <T extends @Nullable Object> T callWithTimeout(
+  public <T extends Object> T callWithTimeout(
       Callable<T> callable, long timeoutDuration, TimeUnit timeoutUnit) throws ExecutionException {
     checkNotNull(callable);
     checkNotNull(timeoutUnit);
@@ -71,7 +64,7 @@ public final class FakeTimeLimiter implements TimeLimiter {
 
   @Override
   @ParametricNullness
-  public <T extends @Nullable Object> T callUninterruptiblyWithTimeout(
+  public <T extends Object> T callUninterruptiblyWithTimeout(
       Callable<T> callable, long timeoutDuration, TimeUnit timeoutUnit) throws ExecutionException {
     return callWithTimeout(callable, timeoutDuration, timeoutUnit);
   }
diff --git a/guava/src/com/google/common/util/concurrent/FluentFuture.java b/guava/src/com/google/common/util/concurrent/FluentFuture.java
index 4320b78b9e..1fa385f5d5 100644
--- a/guava/src/com/google/common/util/concurrent/FluentFuture.java
+++ b/guava/src/com/google/common/util/concurrent/FluentFuture.java
@@ -17,19 +17,13 @@ package com.google.common.util.concurrent;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.util.concurrent.Internal.toNanosSaturated;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Function;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotMock;
 import java.time.Duration;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link ListenableFuture} that supports fluent chains of operations. For example:
@@ -72,27 +66,22 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @since 23.0
  */
-@Beta
-@DoNotMock("Use FluentFuture.from(Futures.immediate*Future) or SettableFuture")
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
-public abstract class FluentFuture<V extends @Nullable Object>
+public abstract class FluentFuture<V extends Object>
     extends GwtFluentFutureCatchingSpecialization<V> {
 
   /**
    * A less abstract subclass of AbstractFuture. This can be used to optimize setFuture by ensuring
    * that {@link #get} calls exactly the implementation of {@link AbstractFuture#get}.
    */
-  abstract static class TrustedFuture<V extends @Nullable Object> extends FluentFuture<V>
+  abstract static class TrustedFuture<V extends Object> extends FluentFuture<V>
       implements AbstractFuture.Trusted<V> {
-    @CanIgnoreReturnValue
     @Override
     @ParametricNullness
     public final V get() throws InterruptedException, ExecutionException {
       return super.get();
     }
 
-    @CanIgnoreReturnValue
     @Override
     @ParametricNullness
     public final V get(long timeout, TimeUnit unit)
@@ -115,7 +104,6 @@ public abstract class FluentFuture<V extends @Nullable Object>
       super.addListener(listener, executor);
     }
 
-    @CanIgnoreReturnValue
     @Override
     public final boolean cancel(boolean mayInterruptIfRunning) {
       return super.cancel(mayInterruptIfRunning);
@@ -131,7 +119,7 @@ public abstract class FluentFuture<V extends @Nullable Object>
    * directly. If not, it is wrapped in a {@code FluentFuture} that delegates all calls to the
    * original {@code ListenableFuture}.
    */
-  public static <V extends @Nullable Object> FluentFuture<V> from(ListenableFuture<V> future) {
+  public static <V extends Object> FluentFuture<V> from(ListenableFuture<V> future) {
     return future instanceof FluentFuture
         ? (FluentFuture<V>) future
         : new ForwardingFluentFuture<V>(future);
@@ -144,7 +132,7 @@ public abstract class FluentFuture<V extends @Nullable Object>
    * @since 28.0
    */
   @Deprecated
-  public static <V extends @Nullable Object> FluentFuture<V> from(FluentFuture<V> future) {
+  public static <V extends Object> FluentFuture<V> from(FluentFuture<V> future) {
     return checkNotNull(future);
   }
 
@@ -265,7 +253,7 @@ public abstract class FluentFuture<V extends @Nullable Object>
    * @param scheduledExecutor The executor service to enforce the timeout.
    * @since 28.0
    */
-  @GwtIncompatible // ScheduledExecutorService
+  // ScheduledExecutorService
   public final FluentFuture<V> withTimeout(
       Duration timeout, ScheduledExecutorService scheduledExecutor) {
     return withTimeout(toNanosSaturated(timeout), TimeUnit.NANOSECONDS, scheduledExecutor);
@@ -281,7 +269,7 @@ public abstract class FluentFuture<V extends @Nullable Object>
    * @param unit the time unit of the time parameter
    * @param scheduledExecutor The executor service to enforce the timeout.
    */
-  @GwtIncompatible // ScheduledExecutorService
+  // ScheduledExecutorService
   @SuppressWarnings("GoodTime") // should accept a java.time.Duration
   public final FluentFuture<V> withTimeout(
       long timeout, TimeUnit unit, ScheduledExecutorService scheduledExecutor) {
@@ -327,7 +315,7 @@ public abstract class FluentFuture<V extends @Nullable Object>
    * @return A future that holds result of the function (if the input succeeded) or the original
    *     input's failure (if not)
    */
-  public final <T extends @Nullable Object> FluentFuture<T> transformAsync(
+  public final <T extends Object> FluentFuture<T> transformAsync(
       AsyncFunction<? super V, T> function, Executor executor) {
     return (FluentFuture<T>) Futures.transformAsync(this, function, executor);
   }
@@ -364,7 +352,7 @@ public abstract class FluentFuture<V extends @Nullable Object>
    * @param executor Executor to run the function in.
    * @return A future that holds result of the transformation.
    */
-  public final <T extends @Nullable Object> FluentFuture<T> transform(
+  public final <T extends Object> FluentFuture<T> transform(
       Function<? super V, T> function, Executor executor) {
     return (FluentFuture<T>) Futures.transform(this, function, executor);
   }
diff --git a/guava/src/com/google/common/util/concurrent/ForwardingBlockingDeque.java b/guava/src/com/google/common/util/concurrent/ForwardingBlockingDeque.java
index d0d72a8159..7506825948 100644
--- a/guava/src/com/google/common/util/concurrent/ForwardingBlockingDeque.java
+++ b/guava/src/com/google/common/util/concurrent/ForwardingBlockingDeque.java
@@ -16,7 +16,6 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.ForwardingDeque;
 import java.util.Collection;
 import java.util.concurrent.BlockingDeque;
@@ -44,7 +43,6 @@ import javax.annotation.CheckForNull;
  * @author Emily Soldal
  * @since 21.0 (since 14.0 as {@link com.google.common.collect.ForwardingBlockingDeque})
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public abstract class ForwardingBlockingDeque<E> extends ForwardingDeque<E>
     implements BlockingDeque<E> {
diff --git a/guava/src/com/google/common/util/concurrent/ForwardingBlockingQueue.java b/guava/src/com/google/common/util/concurrent/ForwardingBlockingQueue.java
index dc8511d94c..088804c358 100644
--- a/guava/src/com/google/common/util/concurrent/ForwardingBlockingQueue.java
+++ b/guava/src/com/google/common/util/concurrent/ForwardingBlockingQueue.java
@@ -14,9 +14,7 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.ForwardingQueue;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Collection;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.TimeUnit;
@@ -36,8 +34,7 @@ import javax.annotation.CheckForNull;
  * @param <E> the type of elements held in this collection
  * @since 4.0
  */
-@CanIgnoreReturnValue // TODO(cpovirk): Consider being more strict.
-@GwtIncompatible
+// TODO(cpovirk): Consider being more strict.
 @ElementTypesAreNonnullByDefault
 public abstract class ForwardingBlockingQueue<E> extends ForwardingQueue<E>
     implements BlockingQueue<E> {
diff --git a/guava/src/com/google/common/util/concurrent/ForwardingExecutorService.java b/guava/src/com/google/common/util/concurrent/ForwardingExecutorService.java
index ed78b86856..0122143b2c 100644
--- a/guava/src/com/google/common/util/concurrent/ForwardingExecutorService.java
+++ b/guava/src/com/google/common/util/concurrent/ForwardingExecutorService.java
@@ -14,9 +14,7 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.ForwardingObject;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Collection;
 import java.util.List;
 import java.util.concurrent.Callable;
@@ -25,7 +23,6 @@ import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An executor service which forwards all its method calls to another executor service. Subclasses
@@ -35,8 +32,7 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Kurt Alfred Kluever
  * @since 10.0
  */
-@CanIgnoreReturnValue // TODO(cpovirk): Consider being more strict.
-@GwtIncompatible
+// TODO(cpovirk): Consider being more strict.
 @ElementTypesAreNonnullByDefault
 public abstract class ForwardingExecutorService extends ForwardingObject
     implements ExecutorService {
@@ -52,26 +48,26 @@ public abstract class ForwardingExecutorService extends ForwardingObject
   }
 
   @Override
-  public <T extends @Nullable Object> List<Future<T>> invokeAll(
+  public <T extends Object> List<Future<T>> invokeAll(
       Collection<? extends Callable<T>> tasks) throws InterruptedException {
     return delegate().invokeAll(tasks);
   }
 
   @Override
-  public <T extends @Nullable Object> List<Future<T>> invokeAll(
+  public <T extends Object> List<Future<T>> invokeAll(
       Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
       throws InterruptedException {
     return delegate().invokeAll(tasks, timeout, unit);
   }
 
   @Override
-  public <T extends @Nullable Object> T invokeAny(Collection<? extends Callable<T>> tasks)
+  public <T extends Object> T invokeAny(Collection<? extends Callable<T>> tasks)
       throws InterruptedException, ExecutionException {
     return delegate().invokeAny(tasks);
   }
 
   @Override
-  public <T extends @Nullable Object> T invokeAny(
+  public <T extends Object> T invokeAny(
       Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
       throws InterruptedException, ExecutionException, TimeoutException {
     return delegate().invokeAny(tasks, timeout, unit);
@@ -103,7 +99,7 @@ public abstract class ForwardingExecutorService extends ForwardingObject
   }
 
   @Override
-  public <T extends @Nullable Object> Future<T> submit(Callable<T> task) {
+  public <T extends Object> Future<T> submit(Callable<T> task) {
     return delegate().submit(task);
   }
 
@@ -113,7 +109,7 @@ public abstract class ForwardingExecutorService extends ForwardingObject
   }
 
   @Override
-  public <T extends @Nullable Object> Future<T> submit(
+  public <T extends Object> Future<T> submit(
       Runnable task, @ParametricNullness T result) {
     return delegate().submit(task, result);
   }
diff --git a/guava/src/com/google/common/util/concurrent/ForwardingFluentFuture.java b/guava/src/com/google/common/util/concurrent/ForwardingFluentFuture.java
index cb779c34ed..ce517a218d 100644
--- a/guava/src/com/google/common/util/concurrent/ForwardingFluentFuture.java
+++ b/guava/src/com/google/common/util/concurrent/ForwardingFluentFuture.java
@@ -16,12 +16,10 @@ package com.google.common.util.concurrent;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * {@link FluentFuture} that forwards all calls to a delegate.
@@ -33,9 +31,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * existing {@code ListenableFuture}, implemented atop a {@link ForwardingListenableFuture} that
  * forwards to that future and adds the desired methods.
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-final class ForwardingFluentFuture<V extends @Nullable Object> extends FluentFuture<V> {
+final class ForwardingFluentFuture<V extends Object> extends FluentFuture<V> {
   private final ListenableFuture<V> delegate;
 
   ForwardingFluentFuture(ListenableFuture<V> delegate) {
diff --git a/guava/src/com/google/common/util/concurrent/ForwardingFuture.java b/guava/src/com/google/common/util/concurrent/ForwardingFuture.java
index 47002b03a3..2c1d21a164 100644
--- a/guava/src/com/google/common/util/concurrent/ForwardingFuture.java
+++ b/guava/src/com/google/common/util/concurrent/ForwardingFuture.java
@@ -14,15 +14,12 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ForwardingObject;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link Future} which forwards all its method calls to another future. Subclasses should
@@ -34,10 +31,9 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Sven Mawson
  * @since 1.0
  */
-@CanIgnoreReturnValue // TODO(cpovirk): Consider being more strict.
-@GwtCompatible
+// TODO(cpovirk): Consider being more strict.
 @ElementTypesAreNonnullByDefault
-public abstract class ForwardingFuture<V extends @Nullable Object> extends ForwardingObject
+public abstract class ForwardingFuture<V extends Object> extends ForwardingObject
     implements Future<V> {
   /** Constructor for use by subclasses. */
   protected ForwardingFuture() {}
@@ -80,7 +76,7 @@ public abstract class ForwardingFuture<V extends @Nullable Object> extends Forwa
    *
    * @since 9.0
    */
-  public abstract static class SimpleForwardingFuture<V extends @Nullable Object>
+  public abstract static class SimpleForwardingFuture<V extends Object>
       extends ForwardingFuture<V> {
     private final Future<V> delegate;
 
diff --git a/guava/src/com/google/common/util/concurrent/ForwardingListenableFuture.java b/guava/src/com/google/common/util/concurrent/ForwardingListenableFuture.java
index 386809194b..078e6d3bc4 100644
--- a/guava/src/com/google/common/util/concurrent/ForwardingListenableFuture.java
+++ b/guava/src/com/google/common/util/concurrent/ForwardingListenableFuture.java
@@ -14,11 +14,8 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Preconditions;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.concurrent.Executor;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link ListenableFuture} which forwards all its method calls to another future. Subclasses
@@ -30,10 +27,9 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Shardul Deo
  * @since 4.0
  */
-@CanIgnoreReturnValue // TODO(cpovirk): Consider being more strict.
-@GwtCompatible
+// TODO(cpovirk): Consider being more strict.
 @ElementTypesAreNonnullByDefault
-public abstract class ForwardingListenableFuture<V extends @Nullable Object>
+public abstract class ForwardingListenableFuture<V extends Object>
     extends ForwardingFuture<V> implements ListenableFuture<V> {
 
   /** Constructor for use by subclasses. */
@@ -54,7 +50,7 @@ public abstract class ForwardingListenableFuture<V extends @Nullable Object>
    *
    * @since 9.0
    */
-  public abstract static class SimpleForwardingListenableFuture<V extends @Nullable Object>
+  public abstract static class SimpleForwardingListenableFuture<V extends Object>
       extends ForwardingListenableFuture<V> {
     private final ListenableFuture<V> delegate;
 
diff --git a/guava/src/com/google/common/util/concurrent/ForwardingListeningExecutorService.java b/guava/src/com/google/common/util/concurrent/ForwardingListeningExecutorService.java
index fe25b867af..12fdb81ddf 100644
--- a/guava/src/com/google/common/util/concurrent/ForwardingListeningExecutorService.java
+++ b/guava/src/com/google/common/util/concurrent/ForwardingListeningExecutorService.java
@@ -14,10 +14,7 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.concurrent.Callable;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A listening executor service which forwards all its method calls to another listening executor
@@ -28,8 +25,7 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Isaac Shum
  * @since 10.0
  */
-@CanIgnoreReturnValue // TODO(cpovirk): Consider being more strict.
-@GwtIncompatible
+// TODO(cpovirk): Consider being more strict.
 @ElementTypesAreNonnullByDefault
 public abstract class ForwardingListeningExecutorService extends ForwardingExecutorService
     implements ListeningExecutorService {
@@ -40,7 +36,7 @@ public abstract class ForwardingListeningExecutorService extends ForwardingExecu
   protected abstract ListeningExecutorService delegate();
 
   @Override
-  public <T extends @Nullable Object> ListenableFuture<T> submit(Callable<T> task) {
+  public <T extends Object> ListenableFuture<T> submit(Callable<T> task) {
     return delegate().submit(task);
   }
 
@@ -50,7 +46,7 @@ public abstract class ForwardingListeningExecutorService extends ForwardingExecu
   }
 
   @Override
-  public <T extends @Nullable Object> ListenableFuture<T> submit(
+  public <T extends Object> ListenableFuture<T> submit(
       Runnable task, @ParametricNullness T result) {
     return delegate().submit(task, result);
   }
diff --git a/guava/src/com/google/common/util/concurrent/FutureCallback.java b/guava/src/com/google/common/util/concurrent/FutureCallback.java
index f5684e7c90..0abb16c8c5 100644
--- a/guava/src/com/google/common/util/concurrent/FutureCallback.java
+++ b/guava/src/com/google/common/util/concurrent/FutureCallback.java
@@ -14,10 +14,8 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.GwtCompatible;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A callback for accepting the results of a {@link java.util.concurrent.Future} computation
@@ -28,9 +26,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Anthony Zana
  * @since 10.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public interface FutureCallback<V extends @Nullable Object> {
+public interface FutureCallback<V extends Object> {
   /** Invoked with the result of the {@code Future} computation when it is successful. */
   void onSuccess(@ParametricNullness V result);
 
diff --git a/guava/src/com/google/common/util/concurrent/Futures.java b/guava/src/com/google/common/util/concurrent/Futures.java
index 43205b88b3..558468fb72 100644
--- a/guava/src/com/google/common/util/concurrent/Futures.java
+++ b/guava/src/com/google/common/util/concurrent/Futures.java
@@ -21,9 +21,6 @@ import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 import static com.google.common.util.concurrent.Uninterruptibles.getUninterruptibly;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Function;
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Preconditions;
@@ -33,7 +30,6 @@ import com.google.common.util.concurrent.ImmediateFuture.ImmediateCancelledFutur
 import com.google.common.util.concurrent.ImmediateFuture.ImmediateFailedFuture;
 import com.google.common.util.concurrent.internal.InternalFutureFailureAccess;
 import com.google.common.util.concurrent.internal.InternalFutures;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.time.Duration;
 import java.util.Collection;
 import java.util.List;
@@ -48,7 +44,6 @@ import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicInteger;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to the {@link Future} interface.
@@ -74,7 +69,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Sven Mawson
  * @since 1.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class Futures extends GwtFuturesCatchingSpecialization {
 
@@ -130,7 +124,7 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    * getters just return the value. This {@code Future} can't be canceled or timed out and its
    * {@code isDone()} method always returns {@code true}.
    */
-  public static <V extends @Nullable Object> ListenableFuture<V> immediateFuture(
+  public static <V extends Object> ListenableFuture<V> immediateFuture(
       @ParametricNullness V value) {
     if (value == null) {
       // This cast is safe because null is assignable to V for all V (i.e. it is bivariant)
@@ -148,8 +142,8 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    * @since 29.0
    */
   @SuppressWarnings("unchecked")
-  public static ListenableFuture<@Nullable Void> immediateVoidFuture() {
-    return (ListenableFuture<@Nullable Void>) ImmediateFuture.NULL;
+  public static ListenableFuture<Void> immediateVoidFuture() {
+    return (ListenableFuture<Void>) ImmediateFuture.NULL;
   }
 
   /**
@@ -159,7 +153,7 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    * returns {@code true}. Calling {@code get()} will immediately throw the provided {@code
    * Throwable} wrapped in an {@code ExecutionException}.
    */
-  public static <V extends @Nullable Object> ListenableFuture<V> immediateFailedFuture(
+  public static <V extends Object> ListenableFuture<V> immediateFailedFuture(
       Throwable throwable) {
     checkNotNull(throwable);
     return new ImmediateFailedFuture<V>(throwable);
@@ -171,7 +165,7 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    *
    * @since 14.0
    */
-  public static <V extends @Nullable Object> ListenableFuture<V> immediateCancelledFuture() {
+  public static <V extends Object> ListenableFuture<V> immediateCancelledFuture() {
     return new ImmediateCancelledFuture<V>();
   }
 
@@ -181,8 +175,7 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    * @throws RejectedExecutionException if the task cannot be scheduled for execution
    * @since 28.2
    */
-  @Beta
-  public static <O extends @Nullable Object> ListenableFuture<O> submit(
+  public static <O extends Object> ListenableFuture<O> submit(
       Callable<O> callable, Executor executor) {
     TrustedListenableFutureTask<O> task = TrustedListenableFutureTask.create(callable);
     executor.execute(task);
@@ -196,9 +189,8 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    * @throws RejectedExecutionException if the task cannot be scheduled for execution
    * @since 28.2
    */
-  @Beta
-  public static ListenableFuture<@Nullable Void> submit(Runnable runnable, Executor executor) {
-    TrustedListenableFutureTask<@Nullable Void> task =
+  public static ListenableFuture<Void> submit(Runnable runnable, Executor executor) {
+    TrustedListenableFutureTask<Void> task =
         TrustedListenableFutureTask.create(runnable, null);
     executor.execute(task);
     return task;
@@ -210,8 +202,7 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    * @throws RejectedExecutionException if the task cannot be scheduled for execution
    * @since 23.0
    */
-  @Beta
-  public static <O extends @Nullable Object> ListenableFuture<O> submitAsync(
+  public static <O extends Object> ListenableFuture<O> submitAsync(
       AsyncCallable<O> callable, Executor executor) {
     TrustedListenableFutureTask<O> task = TrustedListenableFutureTask.create(callable);
     executor.execute(task);
@@ -224,9 +215,8 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    * @throws RejectedExecutionException if the task cannot be scheduled for execution
    * @since 28.0
    */
-  @Beta
-  @GwtIncompatible // java.util.concurrent.ScheduledExecutorService
-  public static <O extends @Nullable Object> ListenableFuture<O> scheduleAsync(
+  // java.util.concurrent.ScheduledExecutorService
+  public static <O extends Object> ListenableFuture<O> scheduleAsync(
       AsyncCallable<O> callable, Duration delay, ScheduledExecutorService executorService) {
     return scheduleAsync(callable, toNanosSaturated(delay), TimeUnit.NANOSECONDS, executorService);
   }
@@ -237,10 +227,9 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    * @throws RejectedExecutionException if the task cannot be scheduled for execution
    * @since 23.0
    */
-  @Beta
-  @GwtIncompatible // java.util.concurrent.ScheduledExecutorService
+  // java.util.concurrent.ScheduledExecutorService
   @SuppressWarnings("GoodTime") // should accept a java.time.Duration
-  public static <O extends @Nullable Object> ListenableFuture<O> scheduleAsync(
+  public static <O extends Object> ListenableFuture<O> scheduleAsync(
       AsyncCallable<O> callable,
       long delay,
       TimeUnit timeUnit,
@@ -295,9 +284,8 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    * @param executor the executor that runs {@code fallback} if {@code input} fails
    * @since 19.0
    */
-  @Beta
   @Partially.GwtIncompatible("AVAILABLE but requires exceptionType to be Throwable.class")
-  public static <V extends @Nullable Object, X extends Throwable> ListenableFuture<V> catching(
+  public static <V extends Object, X extends Throwable> ListenableFuture<V> catching(
       ListenableFuture<? extends V> input,
       Class<X> exceptionType,
       Function<? super X, ? extends V> fallback,
@@ -360,9 +348,8 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    * @param executor the executor that runs {@code fallback} if {@code input} fails
    * @since 19.0 (similar functionality in 14.0 as {@code withFallback})
    */
-  @Beta
   @Partially.GwtIncompatible("AVAILABLE but requires exceptionType to be Throwable.class")
-  public static <V extends @Nullable Object, X extends Throwable> ListenableFuture<V> catchingAsync(
+  public static <V extends Object, X extends Throwable> ListenableFuture<V> catchingAsync(
       ListenableFuture<? extends V> input,
       Class<X> exceptionType,
       AsyncFunction<? super X, ? extends V> fallback,
@@ -381,9 +368,8 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    * @param scheduledExecutor The executor service to enforce the timeout.
    * @since 28.0
    */
-  @Beta
-  @GwtIncompatible // java.util.concurrent.ScheduledExecutorService
-  public static <V extends @Nullable Object> ListenableFuture<V> withTimeout(
+  // java.util.concurrent.ScheduledExecutorService
+  public static <V extends Object> ListenableFuture<V> withTimeout(
       ListenableFuture<V> delegate, Duration time, ScheduledExecutorService scheduledExecutor) {
     return withTimeout(delegate, toNanosSaturated(time), TimeUnit.NANOSECONDS, scheduledExecutor);
   }
@@ -400,10 +386,9 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    * @param scheduledExecutor The executor service to enforce the timeout.
    * @since 19.0
    */
-  @Beta
-  @GwtIncompatible // java.util.concurrent.ScheduledExecutorService
+  // java.util.concurrent.ScheduledExecutorService
   @SuppressWarnings("GoodTime") // should accept a java.time.Duration
-  public static <V extends @Nullable Object> ListenableFuture<V> withTimeout(
+  public static <V extends Object> ListenableFuture<V> withTimeout(
       ListenableFuture<V> delegate,
       long time,
       TimeUnit unit,
@@ -446,8 +431,7 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    *     input's failure (if not)
    * @since 19.0 (in 11.0 as {@code transform})
    */
-  @Beta
-  public static <I extends @Nullable Object, O extends @Nullable Object>
+  public static <I extends Object, O extends Object>
       ListenableFuture<O> transformAsync(
           ListenableFuture<I> input,
           AsyncFunction<? super I, ? extends O> function,
@@ -484,8 +468,7 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    * @return A future that holds result of the transformation.
    * @since 9.0 (in 2.0 as {@code compose})
    */
-  @Beta
-  public static <I extends @Nullable Object, O extends @Nullable Object>
+  public static <I extends Object, O extends Object>
       ListenableFuture<O> transform(
           ListenableFuture<I> input, Function<? super I, ? extends O> function, Executor executor) {
     return AbstractTransformFuture.create(input, function, executor);
@@ -511,9 +494,8 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    * @return A future that returns the result of the transformation.
    * @since 10.0
    */
-  @Beta
-  @GwtIncompatible // TODO
-  public static <I extends @Nullable Object, O extends @Nullable Object> Future<O> lazyTransform(
+  // TODO
+  public static <I extends Object, O extends Object> Future<O> lazyTransform(
       final Future<I> input, final Function<? super I, ? extends O> function) {
     checkNotNull(input);
     checkNotNull(function);
@@ -571,11 +553,10 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    * @return a future that provides a list of the results of the component futures
    * @since 10.0
    */
-  @Beta
   @SafeVarargs
-  public static <V extends @Nullable Object> ListenableFuture<List<V>> allAsList(
+  public static <V extends Object> ListenableFuture<List<V>> allAsList(
       ListenableFuture<? extends V>... futures) {
-    ListenableFuture<List<@Nullable V>> nullable =
+    ListenableFuture<List<V>> nullable =
         new ListFuture<V>(ImmutableList.copyOf(futures), true);
     // allAsList ensures that it fills the output list with V instances.
     @SuppressWarnings("nullness")
@@ -599,10 +580,9 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    * @return a future that provides a list of the results of the component futures
    * @since 10.0
    */
-  @Beta
-  public static <V extends @Nullable Object> ListenableFuture<List<V>> allAsList(
+  public static <V extends Object> ListenableFuture<List<V>> allAsList(
       Iterable<? extends ListenableFuture<? extends V>> futures) {
-    ListenableFuture<List<@Nullable V>> nullable =
+    ListenableFuture<List<V>> nullable =
         new ListFuture<V>(ImmutableList.copyOf(futures), true);
     // allAsList ensures that it fills the output list with V instances.
     @SuppressWarnings("nullness")
@@ -618,9 +598,8 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    *
    * @since 20.0
    */
-  @Beta
   @SafeVarargs
-  public static <V extends @Nullable Object> FutureCombiner<V> whenAllComplete(
+  public static <V extends Object> FutureCombiner<V> whenAllComplete(
       ListenableFuture<? extends V>... futures) {
     return new FutureCombiner<V>(false, ImmutableList.copyOf(futures));
   }
@@ -633,8 +612,7 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    *
    * @since 20.0
    */
-  @Beta
-  public static <V extends @Nullable Object> FutureCombiner<V> whenAllComplete(
+  public static <V extends Object> FutureCombiner<V> whenAllComplete(
       Iterable<? extends ListenableFuture<? extends V>> futures) {
     return new FutureCombiner<V>(false, ImmutableList.copyOf(futures));
   }
@@ -646,9 +624,8 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    *
    * @since 20.0
    */
-  @Beta
   @SafeVarargs
-  public static <V extends @Nullable Object> FutureCombiner<V> whenAllSucceed(
+  public static <V extends Object> FutureCombiner<V> whenAllSucceed(
       ListenableFuture<? extends V>... futures) {
     return new FutureCombiner<V>(true, ImmutableList.copyOf(futures));
   }
@@ -660,8 +637,7 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    *
    * @since 20.0
    */
-  @Beta
-  public static <V extends @Nullable Object> FutureCombiner<V> whenAllSucceed(
+  public static <V extends Object> FutureCombiner<V> whenAllSucceed(
       Iterable<? extends ListenableFuture<? extends V>> futures) {
     return new FutureCombiner<V>(true, ImmutableList.copyOf(futures));
   }
@@ -692,10 +668,8 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    *
    * @since 20.0
    */
-  @Beta
-  @CanIgnoreReturnValue // TODO(cpovirk): Consider removing, especially if we provide run(Runnable)
-  @GwtCompatible
-  public static final class FutureCombiner<V extends @Nullable Object> {
+  // TODO(cpovirk): Consider removing, especially if we provide run(Runnable)
+  public static final class FutureCombiner<V extends Object> {
     private final boolean allMustSucceed;
     private final ImmutableList<ListenableFuture<? extends V>> futures;
 
@@ -719,7 +693,7 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
      *
      * <p>Canceling this future will attempt to cancel all the component futures.
      */
-    public <C extends @Nullable Object> ListenableFuture<C> callAsync(
+    public <C extends Object> ListenableFuture<C> callAsync(
         AsyncCallable<C> combiner, Executor executor) {
       return new CombinedFuture<C>(futures, allMustSucceed, executor, combiner);
     }
@@ -738,8 +712,8 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
      *
      * <p>Canceling this future will attempt to cancel all the component futures.
      */
-    @CanIgnoreReturnValue // TODO(cpovirk): Remove this
-    public <C extends @Nullable Object> ListenableFuture<C> call(
+    // TODO(cpovirk): Remove this
+    public <C extends Object> ListenableFuture<C> call(
         Callable<C> combiner, Executor executor) {
       return new CombinedFuture<C>(futures, allMustSucceed, executor, combiner);
     }
@@ -757,7 +731,7 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
      */
     public ListenableFuture<?> run(final Runnable combiner, Executor executor) {
       return call(
-          new Callable<@Nullable Void>() {
+          new Callable<Void>() {
             @Override
             @CheckForNull
             public Void call() throws Exception {
@@ -776,8 +750,7 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    *
    * @since 15.0
    */
-  @Beta
-  public static <V extends @Nullable Object> ListenableFuture<V> nonCancellationPropagating(
+  public static <V extends Object> ListenableFuture<V> nonCancellationPropagating(
       ListenableFuture<V> future) {
     if (future.isDone()) {
       return future;
@@ -788,7 +761,7 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
   }
 
   /** A wrapped future that does not propagate cancellation to its delegate. */
-  private static final class NonCancellationPropagatingFuture<V extends @Nullable Object>
+  private static final class NonCancellationPropagatingFuture<V extends Object>
       extends AbstractFuture.TrustedFuture<V> implements Runnable {
     @CheckForNull private ListenableFuture<V> delegate;
 
@@ -852,9 +825,8 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    * whenAllComplete().collectSuccesses(). That API would have a signature more like the current
    * one.
    */
-  @Beta
   @SafeVarargs
-  public static <V extends @Nullable Object> ListenableFuture<List<@Nullable V>> successfulAsList(
+  public static <V extends Object> ListenableFuture<List<V>> successfulAsList(
       ListenableFuture<? extends V>... futures) {
     return new ListFuture<V>(ImmutableList.copyOf(futures), false);
   }
@@ -877,8 +849,7 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    * @return a future that provides a list of the results of the component futures
    * @since 10.0
    */
-  @Beta
-  public static <V extends @Nullable Object> ListenableFuture<List<@Nullable V>> successfulAsList(
+  public static <V extends Object> ListenableFuture<List<V>> successfulAsList(
       Iterable<? extends ListenableFuture<? extends V>> futures) {
     return new ListFuture<V>(ImmutableList.copyOf(futures), false);
   }
@@ -904,8 +875,7 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    *
    * @since 17.0
    */
-  @Beta
-  public static <T extends @Nullable Object> ImmutableList<ListenableFuture<T>> inCompletionOrder(
+  public static <T extends Object> ImmutableList<ListenableFuture<T>> inCompletionOrder(
       Iterable<? extends ListenableFuture<? extends T>> futures) {
     ListenableFuture<? extends T>[] copy = gwtCompatibleToArray(futures);
     final InCompletionOrderState<T> state = new InCompletionOrderState<>(copy);
@@ -935,7 +905,7 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
 
   /** Can't use Iterables.toArray because it's not gwt compatible */
   @SuppressWarnings("unchecked")
-  private static <T extends @Nullable Object> ListenableFuture<? extends T>[] gwtCompatibleToArray(
+  private static <T extends Object> ListenableFuture<? extends T>[] gwtCompatibleToArray(
       Iterable<? extends ListenableFuture<? extends T>> futures) {
     final Collection<ListenableFuture<? extends T>> collection;
     if (futures instanceof Collection) {
@@ -949,7 +919,7 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
   // This can't be a TrustedFuture, because TrustedFuture has clever optimizations that
   // mean cancel won't be called if this Future is passed into setFuture, and then
   // cancelled.
-  private static final class InCompletionOrderFuture<T extends @Nullable Object>
+  private static final class InCompletionOrderFuture<T extends Object>
       extends AbstractFuture<T> {
     @CheckForNull private InCompletionOrderState<T> state;
 
@@ -997,7 +967,7 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
     }
   }
 
-  private static final class InCompletionOrderState<T extends @Nullable Object> {
+  private static final class InCompletionOrderState<T extends Object> {
     // A happens-before edge between the writes of these fields and their reads exists, because
     // in order to read these fields, the corresponding write to incompleteOutputCount must have
     // been read.
@@ -1005,7 +975,7 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
     private boolean shouldInterrupt = true;
     private final AtomicInteger incompleteOutputCount;
     // We set the elements of the array to null as they complete.
-    private final @Nullable ListenableFuture<? extends T>[] inputFutures;
+    private final ListenableFuture<? extends T>[] inputFutures;
     private volatile int delegateIndex = 0;
 
     private InCompletionOrderState(ListenableFuture<? extends T>[] inputFutures) {
@@ -1098,7 +1068,7 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    * @param executor The executor to run {@code callback} when the future completes.
    * @since 10.0
    */
-  public static <V extends @Nullable Object> void addCallback(
+  public static <V extends Object> void addCallback(
       final ListenableFuture<V> future,
       final FutureCallback<? super V> callback,
       Executor executor) {
@@ -1107,7 +1077,7 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
   }
 
   /** See {@link #addCallback(ListenableFuture, FutureCallback, Executor)} for behavioral notes. */
-  private static final class CallbackListener<V extends @Nullable Object> implements Runnable {
+  private static final class CallbackListener<V extends Object> implements Runnable {
     final Future<V> future;
     final FutureCallback<? super V> callback;
 
@@ -1164,10 +1134,9 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    * @throws IllegalStateException if the {@code Future} is not done
    * @since 20.0
    */
-  @CanIgnoreReturnValue
   // TODO(cpovirk): Consider calling getDone() in our own code.
   @ParametricNullness
-  public static <V extends @Nullable Object> V getDone(Future<V> future) throws ExecutionException {
+  public static <V extends Object> V getDone(Future<V> future) throws ExecutionException {
     /*
      * We throw IllegalStateException, since the call could succeed later. Perhaps we "should" throw
      * IllegalArgumentException, since the call could succeed with a different argument. Those
@@ -1224,11 +1193,9 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    *     does not have a suitable constructor
    * @since 19.0 (in 10.0 as {@code get})
    */
-  @Beta
-  @CanIgnoreReturnValue
-  @GwtIncompatible // reflection
+  // reflection
   @ParametricNullness
-  public static <V extends @Nullable Object, X extends Exception> V getChecked(
+  public static <V extends Object, X extends Exception> V getChecked(
       Future<V> future, Class<X> exceptionClass) throws X {
     return FuturesGetChecked.getChecked(future, exceptionClass);
   }
@@ -1276,11 +1243,9 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    *     does not have a suitable constructor
    * @since 28.0
    */
-  @Beta
-  @CanIgnoreReturnValue
-  @GwtIncompatible // reflection
+  // reflection
   @ParametricNullness
-  public static <V extends @Nullable Object, X extends Exception> V getChecked(
+  public static <V extends Object, X extends Exception> V getChecked(
       Future<V> future, Class<X> exceptionClass, Duration timeout) throws X {
     return getChecked(future, exceptionClass, toNanosSaturated(timeout), TimeUnit.NANOSECONDS);
   }
@@ -1328,12 +1293,10 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    *     does not have a suitable constructor
    * @since 19.0 (in 10.0 as {@code get} and with different parameter order)
    */
-  @Beta
-  @CanIgnoreReturnValue
-  @GwtIncompatible // reflection
+  // reflection
   @SuppressWarnings("GoodTime") // should accept a java.time.Duration
   @ParametricNullness
-  public static <V extends @Nullable Object, X extends Exception> V getChecked(
+  public static <V extends Object, X extends Exception> V getChecked(
       Future<V> future, Class<X> exceptionClass, long timeout, TimeUnit unit) throws X {
     return FuturesGetChecked.getChecked(future, exceptionClass, timeout, unit);
   }
@@ -1372,9 +1335,8 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    * @throws CancellationException if {@code get} throws a {@code CancellationException}
    * @since 10.0
    */
-  @CanIgnoreReturnValue
   @ParametricNullness
-  public static <V extends @Nullable Object> V getUnchecked(Future<V> future) {
+  public static <V extends Object> V getUnchecked(Future<V> future) {
     checkNotNull(future);
     try {
       return getUninterruptibly(future);
diff --git a/guava/src/com/google/common/util/concurrent/FuturesGetChecked.java b/guava/src/com/google/common/util/concurrent/FuturesGetChecked.java
index 6f09b8066d..b7c0335a7e 100644
--- a/guava/src/com/google/common/util/concurrent/FuturesGetChecked.java
+++ b/guava/src/com/google/common/util/concurrent/FuturesGetChecked.java
@@ -18,12 +18,8 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static java.lang.Thread.currentThread;
 import static java.util.Arrays.asList;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Function;
 import com.google.common.collect.Ordering;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.j2objc.annotations.J2ObjCIncompatible;
 import java.lang.ref.WeakReference;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
@@ -36,24 +32,19 @@ import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** Static methods used to implement {@link Futures#getChecked(Future, Class)}. */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 final class FuturesGetChecked {
-  @CanIgnoreReturnValue
   @ParametricNullness
-  static <V extends @Nullable Object, X extends Exception> V getChecked(
+  static <V extends Object, X extends Exception> V getChecked(
       Future<V> future, Class<X> exceptionClass) throws X {
     return getChecked(bestGetCheckedTypeValidator(), future, exceptionClass);
   }
 
   /** Implementation of {@link Futures#getChecked(Future, Class)}. */
-  @CanIgnoreReturnValue
-  @VisibleForTesting
   @ParametricNullness
-  static <V extends @Nullable Object, X extends Exception> V getChecked(
+  static <V extends Object, X extends Exception> V getChecked(
       GetCheckedTypeValidator validator, Future<V> future, Class<X> exceptionClass) throws X {
     validator.validateClass(exceptionClass);
     try {
@@ -68,9 +59,8 @@ final class FuturesGetChecked {
   }
 
   /** Implementation of {@link Futures#getChecked(Future, Class, long, TimeUnit)}. */
-  @CanIgnoreReturnValue
   @ParametricNullness
-  static <V extends @Nullable Object, X extends Exception> V getChecked(
+  static <V extends Object, X extends Exception> V getChecked(
       Future<V> future, Class<X> exceptionClass, long timeout, TimeUnit unit) throws X {
     // TODO(cpovirk): benchmark a version of this method that accepts a GetCheckedTypeValidator
     bestGetCheckedTypeValidator().validateClass(exceptionClass);
@@ -87,7 +77,6 @@ final class FuturesGetChecked {
     }
   }
 
-  @VisibleForTesting
   interface GetCheckedTypeValidator {
     void validateClass(Class<? extends Exception> exceptionClass);
   }
@@ -96,13 +85,11 @@ final class FuturesGetChecked {
     return GetCheckedTypeValidatorHolder.BEST_VALIDATOR;
   }
 
-  @VisibleForTesting
   static GetCheckedTypeValidator weakSetValidator() {
     return GetCheckedTypeValidatorHolder.WeakSetValidator.INSTANCE;
   }
 
-  @J2ObjCIncompatible // ClassValue
-  @VisibleForTesting
+  // ClassValue
   static GetCheckedTypeValidator classValueValidator() {
     return GetCheckedTypeValidatorHolder.ClassValueValidator.INSTANCE;
   }
@@ -113,14 +100,13 @@ final class FuturesGetChecked {
    *
    * <p>Uses reflection to gracefully fall back to when certain implementations aren't available.
    */
-  @VisibleForTesting
   static class GetCheckedTypeValidatorHolder {
     static final String CLASS_VALUE_VALIDATOR_NAME =
         GetCheckedTypeValidatorHolder.class.getName() + "$ClassValueValidator";
 
     static final GetCheckedTypeValidator BEST_VALIDATOR = getBestValidator();
 
-    @J2ObjCIncompatible // ClassValue
+    // ClassValue
     enum ClassValueValidator implements GetCheckedTypeValidator {
       INSTANCE;
 
@@ -286,12 +272,10 @@ final class FuturesGetChecked {
     }
   }
 
-  @VisibleForTesting
   static boolean isCheckedException(Class<? extends Exception> type) {
     return !RuntimeException.class.isAssignableFrom(type);
   }
 
-  @VisibleForTesting
   static void checkExceptionClassValidity(Class<? extends Exception> exceptionClass) {
     checkArgument(
         isCheckedException(exceptionClass),
diff --git a/guava/src/com/google/common/util/concurrent/GwtFluentFutureCatchingSpecialization.java b/guava/src/com/google/common/util/concurrent/GwtFluentFutureCatchingSpecialization.java
index d29a673dd8..0545c341e0 100644
--- a/guava/src/com/google/common/util/concurrent/GwtFluentFutureCatchingSpecialization.java
+++ b/guava/src/com/google/common/util/concurrent/GwtFluentFutureCatchingSpecialization.java
@@ -14,17 +14,14 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.GwtCompatible;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Hidden superclass of {@link FluentFuture} that provides us a place to declare special GWT
  * versions of the {@link FluentFuture#catching(Class, com.google.common.base.Function)
  * FluentFuture.catching} family of methods. Those versions have slightly different signatures.
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
-abstract class GwtFluentFutureCatchingSpecialization<V extends @Nullable Object>
+abstract class GwtFluentFutureCatchingSpecialization<V extends Object>
     extends AbstractFuture<V> {
   /*
    * This server copy of the class is empty. The corresponding GWT copy contains alternative
diff --git a/guava/src/com/google/common/util/concurrent/GwtFuturesCatchingSpecialization.java b/guava/src/com/google/common/util/concurrent/GwtFuturesCatchingSpecialization.java
index 95131cec33..1be8753f27 100644
--- a/guava/src/com/google/common/util/concurrent/GwtFuturesCatchingSpecialization.java
+++ b/guava/src/com/google/common/util/concurrent/GwtFuturesCatchingSpecialization.java
@@ -14,7 +14,6 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.GwtCompatible;
 
 /**
  * Hidden superclass of {@link Futures} that provides us a place to declare special GWT versions of
@@ -22,7 +21,6 @@ import com.google.common.annotations.GwtCompatible;
  * java.util.concurrent.Executor) Futures.catching} family of methods. Those versions have slightly
  * different signatures.
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 abstract class GwtFuturesCatchingSpecialization {
   /*
diff --git a/guava/src/com/google/common/util/concurrent/ImmediateFuture.java b/guava/src/com/google/common/util/concurrent/ImmediateFuture.java
index 81912f5d81..43b247c6a2 100644
--- a/guava/src/com/google/common/util/concurrent/ImmediateFuture.java
+++ b/guava/src/com/google/common/util/concurrent/ImmediateFuture.java
@@ -16,21 +16,18 @@ package com.google.common.util.concurrent;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.util.concurrent.AbstractFuture.TrustedFuture;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** Implementation of {@link Futures#immediateFuture}. */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 // TODO(cpovirk): Make this final (but that may break Mockito spy calls).
-class ImmediateFuture<V extends @Nullable Object> implements ListenableFuture<V> {
-  static final ListenableFuture<?> NULL = new ImmediateFuture<@Nullable Object>(null);
+class ImmediateFuture<V extends Object> implements ListenableFuture<V> {
+  static final ListenableFuture<?> NULL = new ImmediateFuture<Object>(null);
 
   private static final Logger log = Logger.getLogger(ImmediateFuture.class.getName());
 
@@ -91,13 +88,13 @@ class ImmediateFuture<V extends @Nullable Object> implements ListenableFuture<V>
     return super.toString() + "[status=SUCCESS, result=[" + value + "]]";
   }
 
-  static final class ImmediateFailedFuture<V extends @Nullable Object> extends TrustedFuture<V> {
+  static final class ImmediateFailedFuture<V extends Object> extends TrustedFuture<V> {
     ImmediateFailedFuture(Throwable thrown) {
       setException(thrown);
     }
   }
 
-  static final class ImmediateCancelledFuture<V extends @Nullable Object> extends TrustedFuture<V> {
+  static final class ImmediateCancelledFuture<V extends Object> extends TrustedFuture<V> {
     ImmediateCancelledFuture() {
       cancel(false);
     }
diff --git a/guava/src/com/google/common/util/concurrent/Internal.java b/guava/src/com/google/common/util/concurrent/Internal.java
index 06bee2ea09..b8fc26aa6b 100644
--- a/guava/src/com/google/common/util/concurrent/Internal.java
+++ b/guava/src/com/google/common/util/concurrent/Internal.java
@@ -14,11 +14,10 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.GwtIncompatible;
 import java.time.Duration;
 
 /** This class is for {@code com.google.common.util.concurrent} use only! */
-@GwtIncompatible // java.time.Duration
+// java.time.Duration
 @ElementTypesAreNonnullByDefault
 final class Internal {
 
diff --git a/guava/src/com/google/common/util/concurrent/InterruptibleTask.java b/guava/src/com/google/common/util/concurrent/InterruptibleTask.java
index 168adf24b3..2baf3ff8f1 100644
--- a/guava/src/com/google/common/util/concurrent/InterruptibleTask.java
+++ b/guava/src/com/google/common/util/concurrent/InterruptibleTask.java
@@ -16,24 +16,18 @@ package com.google.common.util.concurrent;
 
 import static com.google.common.util.concurrent.NullnessCasts.uncheckedCastNullableTToT;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.VisibleForTesting;
-import com.google.j2objc.annotations.ReflectionSupport;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.locks.AbstractOwnableSynchronizer;
 import java.util.concurrent.locks.LockSupport;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
-@GwtCompatible(emulated = true)
-@ReflectionSupport(value = ReflectionSupport.Level.FULL)
 @ElementTypesAreNonnullByDefault
 // Some Android 5.0.x Samsung devices have bugs in JDK reflection APIs that cause
 // getDeclaredField to throw a NoSuchFieldException when the field is definitely there.
 // Since this class only needs CAS on one field, we can avoid this bug by extending AtomicReference
 // instead of using an AtomicReferenceFieldUpdater. This reference stores Thread instances
 // and DONE/INTERRUPTED - they have a common ancestor of Runnable.
-abstract class InterruptibleTask<T extends @Nullable Object>
-    extends AtomicReference<@Nullable Runnable> implements Runnable {
+abstract class InterruptibleTask<T extends Object>
+    extends AtomicReference<Runnable> implements Runnable {
   static {
     // Prevent rare disastrous classloading in first call to LockSupport.park.
     // See: https://bugs.openjdk.java.net/browse/JDK-8074773
@@ -216,7 +210,6 @@ abstract class InterruptibleTask<T extends @Nullable Object>
    * currentRunner thread is blocked on the progress of the interruptor thread, which can help
    * identify deadlocks.
    */
-  @VisibleForTesting
   static final class Blocker extends AbstractOwnableSynchronizer implements Runnable {
     private final InterruptibleTask<?> task;
 
diff --git a/guava/src/com/google/common/util/concurrent/JdkFutureAdapters.java b/guava/src/com/google/common/util/concurrent/JdkFutureAdapters.java
index 82f8d950df..7f11423c43 100644
--- a/guava/src/com/google/common/util/concurrent/JdkFutureAdapters.java
+++ b/guava/src/com/google/common/util/concurrent/JdkFutureAdapters.java
@@ -17,14 +17,11 @@ package com.google.common.util.concurrent;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.util.concurrent.Uninterruptibles.getUninterruptibly;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.atomic.AtomicBoolean;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Utilities necessary for working with libraries that supply plain {@link Future} instances. Note
@@ -34,8 +31,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Sven Mawson
  * @since 10.0 (replacing {@code Futures.makeListenable}, which existed in 1.0)
  */
-@Beta
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class JdkFutureAdapters {
   /**
@@ -51,7 +46,7 @@ public final class JdkFutureAdapters {
    * ListenableFutureTask}, {@link AbstractFuture}, and other utilities over creating plain {@code
    * Future} instances to be upgraded to {@code ListenableFuture} after the fact.
    */
-  public static <V extends @Nullable Object> ListenableFuture<V> listenInPoolThread(
+  public static <V extends Object> ListenableFuture<V> listenInPoolThread(
       Future<V> future) {
     if (future instanceof ListenableFuture) {
       return (ListenableFuture<V>) future;
@@ -79,7 +74,7 @@ public final class JdkFutureAdapters {
    *
    * @since 12.0
    */
-  public static <V extends @Nullable Object> ListenableFuture<V> listenInPoolThread(
+  public static <V extends Object> ListenableFuture<V> listenInPoolThread(
       Future<V> future, Executor executor) {
     checkNotNull(executor);
     if (future instanceof ListenableFuture) {
@@ -97,7 +92,7 @@ public final class JdkFutureAdapters {
    * <p>If the delegate future is interrupted or throws an unexpected unchecked exception, the
    * listeners will not be invoked.
    */
-  private static class ListenableFutureAdapter<V extends @Nullable Object>
+  private static class ListenableFutureAdapter<V extends Object>
       extends ForwardingFuture<V> implements ListenableFuture<V> {
 
     private static final ThreadFactory threadFactory =
diff --git a/guava/src/com/google/common/util/concurrent/ListenableFuture.java b/guava/src/com/google/common/util/concurrent/ListenableFuture.java
index cf0199adee..70d93422b4 100644
--- a/guava/src/com/google/common/util/concurrent/ListenableFuture.java
+++ b/guava/src/com/google/common/util/concurrent/ListenableFuture.java
@@ -14,11 +14,9 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.errorprone.annotations.DoNotMock;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Future;
 import java.util.concurrent.RejectedExecutionException;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link Future} that accepts completion listeners. Each listener has an associated executor, and
@@ -115,7 +113,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * that affects users, especially users of the Android Gradle Plugin, since the plugin developers
  * put in a special hack for us: https://issuetracker.google.com/issues/131431257)
  */
-@DoNotMock("Use the methods in Futures (like immediateFuture) or SettableFuture")
 /*
  * It would make sense to also annotate this class with @ElementTypesAreNonnullByDefault. However,
  * it makes no difference because this class is already covered by the package-level
@@ -125,7 +122,7 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * we're seeing a breakage internally when we add that annotation :)
  *
  */
-public interface ListenableFuture<V extends @Nullable Object> extends Future<V> {
+public interface ListenableFuture<V extends Object> extends Future<V> {
   /**
    * Registers a listener to be {@linkplain Executor#execute(Runnable) run} on the given executor.
    * The listener will run when the {@code Future}'s computation is {@linkplain Future#isDone()
diff --git a/guava/src/com/google/common/util/concurrent/ListenableFutureTask.java b/guava/src/com/google/common/util/concurrent/ListenableFutureTask.java
index 9fdcc53ede..a49cbd8680 100644
--- a/guava/src/com/google/common/util/concurrent/ListenableFutureTask.java
+++ b/guava/src/com/google/common/util/concurrent/ListenableFutureTask.java
@@ -17,15 +17,12 @@ package com.google.common.util.concurrent;
 import static java.lang.Math.min;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.FutureTask;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link FutureTask} that also implements the {@link ListenableFuture} interface. Unlike {@code
@@ -40,9 +37,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Sven Mawson
  * @since 1.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
-public class ListenableFutureTask<V extends @Nullable Object> extends FutureTask<V>
+public class ListenableFutureTask<V extends Object> extends FutureTask<V>
     implements ListenableFuture<V> {
   // TODO(cpovirk): explore ways of making ListenableFutureTask final. There are some valid reasons
   // such as BoundedQueueExecutorService to allow extends but it would be nice to make it final to
@@ -58,7 +54,7 @@ public class ListenableFutureTask<V extends @Nullable Object> extends FutureTask
    * @param callable the callable task
    * @since 10.0
    */
-  public static <V extends @Nullable Object> ListenableFutureTask<V> create(Callable<V> callable) {
+  public static <V extends Object> ListenableFutureTask<V> create(Callable<V> callable) {
     return new ListenableFutureTask<V>(callable);
   }
 
@@ -72,7 +68,7 @@ public class ListenableFutureTask<V extends @Nullable Object> extends FutureTask
    *     ListenableFutureTask.create(runnable, null)}
    * @since 10.0
    */
-  public static <V extends @Nullable Object> ListenableFutureTask<V> create(
+  public static <V extends Object> ListenableFutureTask<V> create(
       Runnable runnable, @ParametricNullness V result) {
     return new ListenableFutureTask<V>(runnable, result);
   }
@@ -90,7 +86,6 @@ public class ListenableFutureTask<V extends @Nullable Object> extends FutureTask
     executionList.add(listener, exec);
   }
 
-  @CanIgnoreReturnValue
   @Override
   @ParametricNullness
   public V get(long timeout, TimeUnit unit)
diff --git a/guava/src/com/google/common/util/concurrent/ListenableScheduledFuture.java b/guava/src/com/google/common/util/concurrent/ListenableScheduledFuture.java
index e5aa5e302e..823b6608f2 100644
--- a/guava/src/com/google/common/util/concurrent/ListenableScheduledFuture.java
+++ b/guava/src/com/google/common/util/concurrent/ListenableScheduledFuture.java
@@ -14,10 +14,7 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import java.util.concurrent.ScheduledFuture;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Helper interface to implement both {@link ListenableFuture} and {@link ScheduledFuture}.
@@ -25,8 +22,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Anthony Zana
  * @since 15.0
  */
-@Beta
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public interface ListenableScheduledFuture<V extends @Nullable Object>
+public interface ListenableScheduledFuture<V extends Object>
     extends ScheduledFuture<V>, ListenableFuture<V> {}
diff --git a/guava/src/com/google/common/util/concurrent/ListenerCallQueue.java b/guava/src/com/google/common/util/concurrent/ListenerCallQueue.java
index ed8c9065ac..12dca444c9 100644
--- a/guava/src/com/google/common/util/concurrent/ListenerCallQueue.java
+++ b/guava/src/com/google/common/util/concurrent/ListenerCallQueue.java
@@ -16,10 +16,8 @@ package com.google.common.util.concurrent;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Queues;
-import com.google.errorprone.annotations.concurrent.GuardedBy;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -52,7 +50,6 @@ import java.util.logging.Logger;
  * the listeners can be delayed slightly so that locks can be dropped. Also, because {@link
  * #dispatch} is expected to be called concurrently, it is idempotent.
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 final class ListenerCallQueue<L> {
   // TODO(cpovirk): consider using the logger associated with listener.getClass().
@@ -133,13 +130,10 @@ final class ListenerCallQueue<L> {
     final L listener;
     final Executor executor;
 
-    @GuardedBy("this")
     final Queue<ListenerCallQueue.Event<L>> waitQueue = Queues.newArrayDeque();
 
-    @GuardedBy("this")
     final Queue<Object> labelQueue = Queues.newArrayDeque();
 
-    @GuardedBy("this")
     boolean isThreadScheduled;
 
     PerListenerQueue(L listener, Executor executor) {
diff --git a/guava/src/com/google/common/util/concurrent/ListeningExecutorService.java b/guava/src/com/google/common/util/concurrent/ListeningExecutorService.java
index 83ea759f8e..dc96275e63 100644
--- a/guava/src/com/google/common/util/concurrent/ListeningExecutorService.java
+++ b/guava/src/com/google/common/util/concurrent/ListeningExecutorService.java
@@ -14,8 +14,6 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.DoNotMock;
 import java.util.Collection;
 import java.util.List;
 import java.util.concurrent.Callable;
@@ -23,7 +21,6 @@ import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.TimeUnit;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An {@link ExecutorService} that returns {@link ListenableFuture} instances. To create an instance
@@ -33,10 +30,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Chris Povirk
  * @since 10.0
  */
-@DoNotMock(
-    "Use TestingExecutors.sameThreadScheduledExecutor, or wrap a real Executor from "
-        + "java.util.concurrent.Executors with MoreExecutors.listeningDecorator")
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public interface ListeningExecutorService extends ExecutorService {
   /**
@@ -44,7 +37,7 @@ public interface ListeningExecutorService extends ExecutorService {
    * @throws RejectedExecutionException {@inheritDoc}
    */
   @Override
-  <T extends @Nullable Object> ListenableFuture<T> submit(Callable<T> task);
+  <T extends Object> ListenableFuture<T> submit(Callable<T> task);
 
   /**
    * @return a {@code ListenableFuture} representing pending completion of the task
@@ -58,7 +51,7 @@ public interface ListeningExecutorService extends ExecutorService {
    * @throws RejectedExecutionException {@inheritDoc}
    */
   @Override
-  <T extends @Nullable Object> ListenableFuture<T> submit(
+  <T extends Object> ListenableFuture<T> submit(
       Runnable task, @ParametricNullness T result);
 
   /**
@@ -80,7 +73,7 @@ public interface ListeningExecutorService extends ExecutorService {
    * @throws NullPointerException if any task is null
    */
   @Override
-  <T extends @Nullable Object> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
+  <T extends Object> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
       throws InterruptedException;
 
   /**
@@ -103,7 +96,7 @@ public interface ListeningExecutorService extends ExecutorService {
    * @throws NullPointerException if any task is null
    */
   @Override
-  <T extends @Nullable Object> List<Future<T>> invokeAll(
+  <T extends Object> List<Future<T>> invokeAll(
       Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
       throws InterruptedException;
 }
diff --git a/guava/src/com/google/common/util/concurrent/ListeningScheduledExecutorService.java b/guava/src/com/google/common/util/concurrent/ListeningScheduledExecutorService.java
index 25185b91a4..58d5c02654 100644
--- a/guava/src/com/google/common/util/concurrent/ListeningScheduledExecutorService.java
+++ b/guava/src/com/google/common/util/concurrent/ListeningScheduledExecutorService.java
@@ -16,12 +16,10 @@ package com.google.common.util.concurrent;
 
 import static com.google.common.util.concurrent.Internal.toNanosSaturated;
 
-import com.google.common.annotations.GwtIncompatible;
 import java.time.Duration;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link ScheduledExecutorService} that returns {@link ListenableFuture} instances from its
@@ -32,7 +30,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Chris Povirk
  * @since 10.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public interface ListeningScheduledExecutorService
     extends ScheduledExecutorService, ListeningExecutorService {
@@ -52,7 +49,7 @@ public interface ListeningScheduledExecutorService
 
   /** @since 15.0 (previously returned ScheduledFuture) */
   @Override
-  <V extends @Nullable Object> ListenableScheduledFuture<V> schedule(
+  <V extends Object> ListenableScheduledFuture<V> schedule(
       Callable<V> callable, long delay, TimeUnit unit);
 
   /**
@@ -60,7 +57,7 @@ public interface ListeningScheduledExecutorService
    *
    * @since 29.0
    */
-  default <V extends @Nullable Object> ListenableScheduledFuture<V> schedule(
+  default <V extends Object> ListenableScheduledFuture<V> schedule(
       Callable<V> callable, Duration delay) {
     return schedule(callable, toNanosSaturated(delay), TimeUnit.NANOSECONDS);
   }
diff --git a/guava/src/com/google/common/util/concurrent/Monitor.java b/guava/src/com/google/common/util/concurrent/Monitor.java
index 6696b97ee0..c77aab5052 100644
--- a/guava/src/com/google/common/util/concurrent/Monitor.java
+++ b/guava/src/com/google/common/util/concurrent/Monitor.java
@@ -17,11 +17,7 @@ package com.google.common.util.concurrent;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.util.concurrent.Internal.toNanosSaturated;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.primitives.Longs;
-import com.google.errorprone.annotations.concurrent.GuardedBy;
-import com.google.j2objc.annotations.Weak;
 import java.time.Duration;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.Condition;
@@ -200,8 +196,6 @@ import javax.annotation.CheckForNull;
  * @author Martin Buchholz
  * @since 10.0
  */
-@Beta
-@GwtIncompatible
 @SuppressWarnings("GuardedBy") // TODO(b/35466881): Fix or suppress.
 @ElementTypesAreNonnullByDefault
 public final class Monitor {
@@ -304,17 +298,14 @@ public final class Monitor {
    *
    * @since 10.0
    */
-  @Beta
   public abstract static class Guard {
 
-    @Weak final Monitor monitor;
+    final Monitor monitor;
     final Condition condition;
 
-    @GuardedBy("monitor.lock")
     int waiterCount = 0;
 
     /** The next active guard */
-    @GuardedBy("monitor.lock")
     @CheckForNull
     Guard next;
 
@@ -341,7 +332,6 @@ public final class Monitor {
    * The guards associated with this monitor that currently have waiters ({@code waiterCount > 0}).
    * A linked list threaded through the Guard.next field.
    */
-  @GuardedBy("lock")
   @CheckForNull
   private Guard activeGuards = null;
 
@@ -1088,7 +1078,6 @@ public final class Monitor {
    * <p>This method must not be called from within a beginWaitingFor/endWaitingFor block, or else
    * the current thread's guard might be mistakenly signalled, leading to a lost signal.
    */
-  @GuardedBy("lock")
   private void signalNextWaiter() {
     for (Guard guard = activeGuards; guard != null; guard = guard.next) {
       if (isSatisfied(guard)) {
@@ -1120,7 +1109,6 @@ public final class Monitor {
    * Exactly like guard.isSatisfied(), but in addition signals all waiting threads in the (hopefully
    * unlikely) event that isSatisfied() throws.
    */
-  @GuardedBy("lock")
   private boolean isSatisfied(Guard guard) {
     try {
       return guard.isSatisfied();
@@ -1131,7 +1119,6 @@ public final class Monitor {
   }
 
   /** Signals all threads waiting on guards. */
-  @GuardedBy("lock")
   private void signalAllWaiters() {
     for (Guard guard = activeGuards; guard != null; guard = guard.next) {
       guard.condition.signalAll();
@@ -1139,7 +1126,6 @@ public final class Monitor {
   }
 
   /** Records that the current thread is about to wait on the specified guard. */
-  @GuardedBy("lock")
   private void beginWaitingFor(Guard guard) {
     int waiters = guard.waiterCount++;
     if (waiters == 0) {
@@ -1150,7 +1136,6 @@ public final class Monitor {
   }
 
   /** Records that the current thread is no longer waiting on the specified guard. */
-  @GuardedBy("lock")
   private void endWaitingFor(Guard guard) {
     int waiters = --guard.waiterCount;
     if (waiters == 0) {
@@ -1175,7 +1160,6 @@ public final class Monitor {
    * responsibility to ensure that the guard is *not* currently satisfied.
    */
 
-  @GuardedBy("lock")
   private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException {
     if (signalBeforeWaiting) {
       signalNextWaiter();
@@ -1190,7 +1174,6 @@ public final class Monitor {
     }
   }
 
-  @GuardedBy("lock")
   private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting) {
     if (signalBeforeWaiting) {
       signalNextWaiter();
@@ -1206,7 +1189,6 @@ public final class Monitor {
   }
 
   /** Caller should check before calling that guard is not satisfied. */
-  @GuardedBy("lock")
   private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)
       throws InterruptedException {
     boolean firstTime = true;
diff --git a/guava/src/com/google/common/util/concurrent/MoreExecutors.java b/guava/src/com/google/common/util/concurrent/MoreExecutors.java
index fc61fbab38..878db965dc 100644
--- a/guava/src/com/google/common/util/concurrent/MoreExecutors.java
+++ b/guava/src/com/google/common/util/concurrent/MoreExecutors.java
@@ -18,17 +18,11 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.util.concurrent.Internal.toNanosSaturated;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Supplier;
 import com.google.common.base.Throwables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Queues;
 import com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.concurrent.GuardedBy;
 import java.lang.reflect.InvocationTargetException;
 import java.time.Duration;
 import java.util.Collection;
@@ -51,7 +45,6 @@ import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link ExecutorService},
@@ -62,7 +55,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Justin Mahoney
  * @since 3.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class MoreExecutors {
   private MoreExecutors() {}
@@ -80,8 +72,7 @@ public final class MoreExecutors {
    * @return an unmodifiable version of the input which will not hang the JVM
    * @since 28.0
    */
-  @Beta
-  @GwtIncompatible // TODO
+  // TODO
   public static ExecutorService getExitingExecutorService(
       ThreadPoolExecutor executor, Duration terminationTimeout) {
     return getExitingExecutorService(
@@ -101,8 +92,7 @@ public final class MoreExecutors {
    * @param timeUnit unit of time for the time parameter
    * @return an unmodifiable version of the input which will not hang the JVM
    */
-  @Beta
-  @GwtIncompatible // TODO
+  // TODO
   @SuppressWarnings("GoodTime") // should accept a java.time.Duration
   public static ExecutorService getExitingExecutorService(
       ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {
@@ -122,8 +112,7 @@ public final class MoreExecutors {
    * @param executor the executor to modify to make sure it exits when the application is finished
    * @return an unmodifiable version of the input which will not hang the JVM
    */
-  @Beta
-  @GwtIncompatible // concurrency
+  // concurrency
   public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {
     return new Application().getExitingExecutorService(executor);
   }
@@ -141,8 +130,7 @@ public final class MoreExecutors {
    * @return an unmodifiable version of the input which will not hang the JVM
    * @since 28.0
    */
-  @Beta
-  @GwtIncompatible // java.time.Duration
+  // java.time.Duration
   public static ScheduledExecutorService getExitingScheduledExecutorService(
       ScheduledThreadPoolExecutor executor, Duration terminationTimeout) {
     return getExitingScheduledExecutorService(
@@ -162,8 +150,7 @@ public final class MoreExecutors {
    * @param timeUnit unit of time for the time parameter
    * @return an unmodifiable version of the input which will not hang the JVM
    */
-  @Beta
-  @GwtIncompatible // TODO
+  // TODO
   @SuppressWarnings("GoodTime") // should accept a java.time.Duration
   public static ScheduledExecutorService getExitingScheduledExecutorService(
       ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {
@@ -184,8 +171,7 @@ public final class MoreExecutors {
    * @param executor the executor to modify to make sure it exits when the application is finished
    * @return an unmodifiable version of the input which will not hang the JVM
    */
-  @Beta
-  @GwtIncompatible // TODO
+  // TODO
   public static ScheduledExecutorService getExitingScheduledExecutorService(
       ScheduledThreadPoolExecutor executor) {
     return new Application().getExitingScheduledExecutorService(executor);
@@ -202,8 +188,7 @@ public final class MoreExecutors {
    *     JVM
    * @since 28.0
    */
-  @Beta
-  @GwtIncompatible // java.time.Duration
+  // java.time.Duration
   public static void addDelayedShutdownHook(ExecutorService service, Duration terminationTimeout) {
     addDelayedShutdownHook(service, toNanosSaturated(terminationTimeout), TimeUnit.NANOSECONDS);
   }
@@ -219,8 +204,7 @@ public final class MoreExecutors {
    *     JVM
    * @param timeUnit unit of time for the time parameter
    */
-  @Beta
-  @GwtIncompatible // TODO
+  // TODO
   @SuppressWarnings("GoodTime") // should accept a java.time.Duration
   public static void addDelayedShutdownHook(
       ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {
@@ -228,8 +212,7 @@ public final class MoreExecutors {
   }
 
   /** Represents the current application to register shutdown hooks. */
-  @GwtIncompatible // TODO
-  @VisibleForTesting
+  // TODO
   static class Application {
 
     final ExecutorService getExitingExecutorService(
@@ -282,13 +265,12 @@ public final class MoreExecutors {
               }));
     }
 
-    @VisibleForTesting
     void addShutdownHook(Thread hook) {
       Runtime.getRuntime().addShutdownHook(hook);
     }
   }
 
-  @GwtIncompatible // TODO
+  // TODO
   private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {
     executor.setThreadFactory(
         new ThreadFactoryBuilder()
@@ -298,7 +280,7 @@ public final class MoreExecutors {
   }
 
   // See newDirectExecutorService javadoc for behavioral notes.
-  @GwtIncompatible // TODO
+  // TODO
   private static final class DirectExecutorService extends AbstractListeningExecutorService {
     /** Lock used whenever accessing the state variables (runningTasks, shutdown) of the executor */
     private final Object lock = new Object();
@@ -310,10 +292,8 @@ public final class MoreExecutors {
      *   - Shutdown: runningTasks > 0 and shutdown == true
      *   - Terminated: runningTasks == 0 and shutdown == true
      */
-    @GuardedBy("lock")
     private int runningTasks = 0;
 
-    @GuardedBy("lock")
     private boolean shutdown = false;
 
     @Override
@@ -426,7 +406,7 @@ public final class MoreExecutors {
    *
    * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)
    */
-  @GwtIncompatible // TODO
+  // TODO
   public static ListeningExecutorService newDirectExecutorService() {
     return new DirectExecutorService();
   }
@@ -527,8 +507,6 @@ public final class MoreExecutors {
    *
    * @since 23.3 (since 23.1 as {@code sequentialExecutor})
    */
-  @Beta
-  @GwtIncompatible
   public static Executor newSequentialExecutor(Executor delegate) {
     return new SequentialExecutor(delegate);
   }
@@ -548,7 +526,7 @@ public final class MoreExecutors {
    *
    * @since 10.0
    */
-  @GwtIncompatible // TODO
+  // TODO
   public static ListeningExecutorService listeningDecorator(ExecutorService delegate) {
     return (delegate instanceof ListeningExecutorService)
         ? (ListeningExecutorService) delegate
@@ -573,7 +551,7 @@ public final class MoreExecutors {
    *
    * @since 10.0
    */
-  @GwtIncompatible // TODO
+  // TODO
   public static ListeningScheduledExecutorService listeningDecorator(
       ScheduledExecutorService delegate) {
     return (delegate instanceof ListeningScheduledExecutorService)
@@ -581,7 +559,7 @@ public final class MoreExecutors {
         : new ScheduledListeningDecorator(delegate);
   }
 
-  @GwtIncompatible // TODO
+  // TODO
   private static class ListeningDecorator extends AbstractListeningExecutorService {
     private final ExecutorService delegate;
 
@@ -625,7 +603,7 @@ public final class MoreExecutors {
     }
   }
 
-  @GwtIncompatible // TODO
+  // TODO
   private static final class ScheduledListeningDecorator extends ListeningDecorator
       implements ListeningScheduledExecutorService {
     @SuppressWarnings("hiding")
@@ -638,14 +616,14 @@ public final class MoreExecutors {
 
     @Override
     public ListenableScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
-      TrustedListenableFutureTask<@Nullable Void> task =
+      TrustedListenableFutureTask<Void> task =
           TrustedListenableFutureTask.create(command, null);
       ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);
-      return new ListenableScheduledTask<@Nullable Void>(task, scheduled);
+      return new ListenableScheduledTask<Void>(task, scheduled);
     }
 
     @Override
-    public <V extends @Nullable Object> ListenableScheduledFuture<V> schedule(
+    public <V extends Object> ListenableScheduledFuture<V> schedule(
         Callable<V> callable, long delay, TimeUnit unit) {
       TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);
       ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);
@@ -657,7 +635,7 @@ public final class MoreExecutors {
         Runnable command, long initialDelay, long period, TimeUnit unit) {
       NeverSuccessfulListenableFutureTask task = new NeverSuccessfulListenableFutureTask(command);
       ScheduledFuture<?> scheduled = delegate.scheduleAtFixedRate(task, initialDelay, period, unit);
-      return new ListenableScheduledTask<@Nullable Void>(task, scheduled);
+      return new ListenableScheduledTask<Void>(task, scheduled);
     }
 
     @Override
@@ -666,10 +644,10 @@ public final class MoreExecutors {
       NeverSuccessfulListenableFutureTask task = new NeverSuccessfulListenableFutureTask(command);
       ScheduledFuture<?> scheduled =
           delegate.scheduleWithFixedDelay(task, initialDelay, delay, unit);
-      return new ListenableScheduledTask<@Nullable Void>(task, scheduled);
+      return new ListenableScheduledTask<Void>(task, scheduled);
     }
 
-    private static final class ListenableScheduledTask<V extends @Nullable Object>
+    private static final class ListenableScheduledTask<V extends Object>
         extends SimpleForwardingListenableFuture<V> implements ListenableScheduledFuture<V> {
 
       private final ScheduledFuture<?> scheduledDelegate;
@@ -703,9 +681,9 @@ public final class MoreExecutors {
       }
     }
 
-    @GwtIncompatible // TODO
+    // TODO
     private static final class NeverSuccessfulListenableFutureTask
-        extends AbstractFuture.TrustedFuture<@Nullable Void> implements Runnable {
+        extends AbstractFuture.TrustedFuture<Void> implements Runnable {
       private final Runnable delegate;
 
       public NeverSuccessfulListenableFutureTask(Runnable delegate) {
@@ -744,9 +722,8 @@ public final class MoreExecutors {
    * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}
    * implementations.
    */
-  @GwtIncompatible
   @ParametricNullness
-  static <T extends @Nullable Object> T invokeAnyImpl(
+  static <T extends Object> T invokeAnyImpl(
       ListeningExecutorService executorService,
       Collection<? extends Callable<T>> tasks,
       boolean timed,
@@ -761,9 +738,8 @@ public final class MoreExecutors {
    * implementations.
    */
   @SuppressWarnings("GoodTime") // should accept a java.time.Duration
-  @GwtIncompatible
   @ParametricNullness
-  static <T extends @Nullable Object> T invokeAnyImpl(
+  static <T extends Object> T invokeAnyImpl(
       ListeningExecutorService executorService,
       Collection<? extends Callable<T>> tasks,
       boolean timed,
@@ -842,8 +818,8 @@ public final class MoreExecutors {
   /**
    * Submits the task and adds a listener that adds the future to {@code queue} when it completes.
    */
-  @GwtIncompatible // TODO
-  private static <T extends @Nullable Object> ListenableFuture<T> submitAndAddQueueListener(
+  // TODO
+  private static <T extends Object> ListenableFuture<T> submitAndAddQueueListener(
       ListeningExecutorService executorService,
       Callable<T> task,
       final BlockingQueue<Future<T>> queue) {
@@ -869,8 +845,7 @@ public final class MoreExecutors {
    *
    * @since 14.0
    */
-  @Beta
-  @GwtIncompatible // concurrency
+  // concurrency
   public static ThreadFactory platformThreadFactory() {
     if (!isAppEngineWithApiClasses()) {
       return Executors.defaultThreadFactory();
@@ -896,7 +871,7 @@ public final class MoreExecutors {
     }
   }
 
-  @GwtIncompatible // TODO
+  // TODO
   private static boolean isAppEngineWithApiClasses() {
     if (System.getProperty("com.google.appengine.runtime.environment") == null) {
       return false;
@@ -931,7 +906,7 @@ public final class MoreExecutors {
    * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name} unless
    * changing the name is forbidden by the security manager.
    */
-  @GwtIncompatible // concurrency
+  // concurrency
   static Thread newThread(String name, Runnable runnable) {
     checkNotNull(name);
     checkNotNull(runnable);
@@ -958,7 +933,7 @@ public final class MoreExecutors {
    * @param executor The executor to decorate
    * @param nameSupplier The source of names for each task
    */
-  @GwtIncompatible // concurrency
+  // concurrency
   static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {
     checkNotNull(executor);
     checkNotNull(nameSupplier);
@@ -981,14 +956,14 @@ public final class MoreExecutors {
    * @param service The executor to decorate
    * @param nameSupplier The source of names for each task
    */
-  @GwtIncompatible // concurrency
+  // concurrency
   static ExecutorService renamingDecorator(
       final ExecutorService service, final Supplier<String> nameSupplier) {
     checkNotNull(service);
     checkNotNull(nameSupplier);
     return new WrappingExecutorService(service) {
       @Override
-      protected <T extends @Nullable Object> Callable<T> wrapTask(Callable<T> callable) {
+      protected <T extends Object> Callable<T> wrapTask(Callable<T> callable) {
         return Callables.threadRenaming(callable, nameSupplier);
       }
 
@@ -1010,14 +985,14 @@ public final class MoreExecutors {
    * @param service The executor to decorate
    * @param nameSupplier The source of names for each task
    */
-  @GwtIncompatible // concurrency
+  // concurrency
   static ScheduledExecutorService renamingDecorator(
       final ScheduledExecutorService service, final Supplier<String> nameSupplier) {
     checkNotNull(service);
     checkNotNull(nameSupplier);
     return new WrappingScheduledExecutorService(service) {
       @Override
-      protected <T extends @Nullable Object> Callable<T> wrapTask(Callable<T> callable) {
+      protected <T extends Object> Callable<T> wrapTask(Callable<T> callable) {
         return Callables.threadRenaming(callable, nameSupplier);
       }
 
@@ -1051,9 +1026,7 @@ public final class MoreExecutors {
    *     if the call timed out or was interrupted
    * @since 28.0
    */
-  @Beta
-  @CanIgnoreReturnValue
-  @GwtIncompatible // java.time.Duration
+  // java.time.Duration
   public static boolean shutdownAndAwaitTermination(ExecutorService service, Duration timeout) {
     return shutdownAndAwaitTermination(service, toNanosSaturated(timeout), TimeUnit.NANOSECONDS);
   }
@@ -1082,9 +1055,7 @@ public final class MoreExecutors {
    *     if the call timed out or was interrupted
    * @since 17.0
    */
-  @Beta
-  @CanIgnoreReturnValue
-  @GwtIncompatible // concurrency
+  // concurrency
   @SuppressWarnings("GoodTime") // should accept a java.time.Duration
   public static boolean shutdownAndAwaitTermination(
       ExecutorService service, long timeout, TimeUnit unit) {
diff --git a/guava/src/com/google/common/util/concurrent/NullnessCasts.java b/guava/src/com/google/common/util/concurrent/NullnessCasts.java
index 0a0d719ef2..73a074a014 100644
--- a/guava/src/com/google/common/util/concurrent/NullnessCasts.java
+++ b/guava/src/com/google/common/util/concurrent/NullnessCasts.java
@@ -14,12 +14,9 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.GwtCompatible;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** A utility method to perform unchecked casts to suppress errors produced by nullness analyses. */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 final class NullnessCasts {
   /**
@@ -52,7 +49,7 @@ final class NullnessCasts {
    */
   @SuppressWarnings("nullness")
   @ParametricNullness
-  static <T extends @Nullable Object> T uncheckedCastNullableTToT(@CheckForNull T t) {
+  static <T extends Object> T uncheckedCastNullableTToT(@CheckForNull T t) {
     return t;
   }
 
@@ -67,7 +64,7 @@ final class NullnessCasts {
    */
   @SuppressWarnings("nullness")
   @ParametricNullness
-  static <T extends @Nullable Object> T uncheckedNull() {
+  static <T extends Object> T uncheckedNull() {
     return null;
   }
 
diff --git a/guava/src/com/google/common/util/concurrent/ParametricNullness.java b/guava/src/com/google/common/util/concurrent/ParametricNullness.java
index ebc5928cfe..7a8b24a922 100644
--- a/guava/src/com/google/common/util/concurrent/ParametricNullness.java
+++ b/guava/src/com/google/common/util/concurrent/ParametricNullness.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import static javax.annotation.meta.When.UNKNOWN;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -35,7 +34,6 @@ import javax.annotation.meta.TypeQualifierNickname;
  * href="https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/NullFromTypeParam.java">{@code
  * NullFromTypeParam}</a>). We use this to "undo" {@link ElementTypesAreNonnullByDefault}.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target({FIELD, METHOD, PARAMETER})
 @TypeQualifierNickname
diff --git a/guava/src/com/google/common/util/concurrent/Partially.java b/guava/src/com/google/common/util/concurrent/Partially.java
index 7aa16e776f..be93681575 100644
--- a/guava/src/com/google/common/util/concurrent/Partially.java
+++ b/guava/src/com/google/common/util/concurrent/Partially.java
@@ -14,7 +14,6 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
@@ -31,7 +30,6 @@ import java.lang.annotation.Target;
  * compiler to autostrip the normal server method in order to expose the special, inherited GWT
  * version.
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 final class Partially {
   /**
diff --git a/guava/src/com/google/common/util/concurrent/Platform.java b/guava/src/com/google/common/util/concurrent/Platform.java
index cfb96a0ad7..9e7916d52e 100644
--- a/guava/src/com/google/common/util/concurrent/Platform.java
+++ b/guava/src/com/google/common/util/concurrent/Platform.java
@@ -14,11 +14,9 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.GwtCompatible;
 import javax.annotation.CheckForNull;
 
 /** Methods factored out so that they can be emulated differently in GWT. */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 final class Platform {
   static boolean isInstanceOfThrowableClass(
diff --git a/guava/src/com/google/common/util/concurrent/RateLimiter.java b/guava/src/com/google/common/util/concurrent/RateLimiter.java
index 4b8b025541..123e512e0d 100644
--- a/guava/src/com/google/common/util/concurrent/RateLimiter.java
+++ b/guava/src/com/google/common/util/concurrent/RateLimiter.java
@@ -21,13 +21,9 @@ import static java.lang.Math.max;
 import static java.util.concurrent.TimeUnit.MICROSECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Stopwatch;
 import com.google.common.util.concurrent.SmoothRateLimiter.SmoothBursty;
 import com.google.common.util.concurrent.SmoothRateLimiter.SmoothWarmingUp;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.time.Duration;
 import java.util.Locale;
 import java.util.concurrent.TimeUnit;
@@ -92,8 +88,6 @@ import javax.annotation.CheckForNull;
  */
 // TODO(user): switch to nano precision. A natural unit of cost is "bytes", and a micro precision
 // would mean a maximum rate of "1MB/s", which might be small in some cases.
-@Beta
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public abstract class RateLimiter {
   /**
@@ -130,7 +124,6 @@ public abstract class RateLimiter {
     return create(permitsPerSecond, SleepingStopwatch.createFromSystemTimer());
   }
 
-  @VisibleForTesting
   static RateLimiter create(double permitsPerSecond, SleepingStopwatch stopwatch) {
     RateLimiter rateLimiter = new SmoothBursty(stopwatch, 1.0 /* maxBurstSeconds */);
     rateLimiter.setRate(permitsPerSecond);
@@ -196,7 +189,6 @@ public abstract class RateLimiter {
         permitsPerSecond, warmupPeriod, unit, 3.0, SleepingStopwatch.createFromSystemTimer());
   }
 
-  @VisibleForTesting
   static RateLimiter create(
       double permitsPerSecond,
       long warmupPeriod,
@@ -285,7 +277,6 @@ public abstract class RateLimiter {
    * @return time spent sleeping to enforce rate, in seconds; 0.0 if not rate-limited
    * @since 16.0 (present in 13.0 with {@code void} return type})
    */
-  @CanIgnoreReturnValue
   public double acquire() {
     return acquire(1);
   }
@@ -299,7 +290,6 @@ public abstract class RateLimiter {
    * @throws IllegalArgumentException if the requested number of permits is negative or zero
    * @since 16.0 (present in 13.0 with {@code void} return type})
    */
-  @CanIgnoreReturnValue
   public double acquire(int permits) {
     long microsToWait = reserve(permits);
     stopwatch.sleepMicrosUninterruptibly(microsToWait);
diff --git a/guava/src/com/google/common/util/concurrent/Runnables.java b/guava/src/com/google/common/util/concurrent/Runnables.java
index 5503f68ae5..a0610ef2a8 100644
--- a/guava/src/com/google/common/util/concurrent/Runnables.java
+++ b/guava/src/com/google/common/util/concurrent/Runnables.java
@@ -14,16 +14,12 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 
 /**
  * Static utility methods pertaining to the {@link Runnable} interface.
  *
  * @since 16.0
  */
-@Beta
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public final class Runnables {
 
diff --git a/guava/src/com/google/common/util/concurrent/SequentialExecutor.java b/guava/src/com/google/common/util/concurrent/SequentialExecutor.java
index 052c7e012b..8f29b93a80 100644
--- a/guava/src/com/google/common/util/concurrent/SequentialExecutor.java
+++ b/guava/src/com/google/common/util/concurrent/SequentialExecutor.java
@@ -21,10 +21,7 @@ import static com.google.common.util.concurrent.SequentialExecutor.WorkerRunning
 import static com.google.common.util.concurrent.SequentialExecutor.WorkerRunningState.RUNNING;
 import static java.lang.System.identityHashCode;
 
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Preconditions;
-import com.google.errorprone.annotations.concurrent.GuardedBy;
-import com.google.j2objc.annotations.RetainedWith;
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.concurrent.Executor;
@@ -47,7 +44,6 @@ import javax.annotation.CheckForNull;
  * If an {@code Error} is thrown, the error will propagate and execution will stop until it is
  * restarted by a call to {@link #execute}.
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 final class SequentialExecutor implements Executor {
   private static final Logger log = Logger.getLogger(SequentialExecutor.class.getName());
@@ -65,11 +61,9 @@ final class SequentialExecutor implements Executor {
   /** Underlying executor that all submitted Runnable objects are run on. */
   private final Executor executor;
 
-  @GuardedBy("queue")
   private final Deque<Runnable> queue = new ArrayDeque<>();
 
   /** see {@link WorkerRunningState} */
-  @GuardedBy("queue")
   private WorkerRunningState workerRunningState = IDLE;
 
   /**
@@ -79,10 +73,9 @@ final class SequentialExecutor implements Executor {
    * it would observe the QUEUING state and set it to QUEUED, and the worker would never be
    * scheduled again for future submissions.
    */
-  @GuardedBy("queue")
   private long workerRunCount = 0;
 
-  @RetainedWith private final QueueWorker worker = new QueueWorker();
+  private final QueueWorker worker = new QueueWorker();
 
   /** Use {@link MoreExecutors#newSequentialExecutor} */
   SequentialExecutor(Executor executor) {
diff --git a/guava/src/com/google/common/util/concurrent/Service.java b/guava/src/com/google/common/util/concurrent/Service.java
index dd0c7e6d94..e0b29244f1 100644
--- a/guava/src/com/google/common/util/concurrent/Service.java
+++ b/guava/src/com/google/common/util/concurrent/Service.java
@@ -16,9 +16,6 @@ package com.google.common.util.concurrent;
 
 import static com.google.common.util.concurrent.Internal.toNanosSaturated;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotMock;
 import java.time.Duration;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
@@ -54,8 +51,6 @@ import java.util.concurrent.TimeoutException;
  * @author Luke Sandberg
  * @since 9.0 (in 1.0 as {@code com.google.common.base.Service})
  */
-@DoNotMock("Create an AbstractIdleService")
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public interface Service {
   /**
@@ -66,7 +61,6 @@ public interface Service {
    * @throws IllegalStateException if the service is not {@link State#NEW}
    * @since 15.0
    */
-  @CanIgnoreReturnValue
   Service startAsync();
 
   /** Returns {@code true} if this service is {@linkplain State#RUNNING running}. */
@@ -85,7 +79,6 @@ public interface Service {
    * @return this
    * @since 15.0
    */
-  @CanIgnoreReturnValue
   Service stopAsync();
 
   /**
diff --git a/guava/src/com/google/common/util/concurrent/ServiceManager.java b/guava/src/com/google/common/util/concurrent/ServiceManager.java
index d2dda7a1ec..d434a815e6 100644
--- a/guava/src/com/google/common/util/concurrent/ServiceManager.java
+++ b/guava/src/com/google/common/util/concurrent/ServiceManager.java
@@ -31,7 +31,6 @@ import static com.google.common.util.concurrent.Service.State.STOPPING;
 import static com.google.common.util.concurrent.Service.State.TERMINATED;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Function;
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Stopwatch;
@@ -49,10 +48,6 @@ import com.google.common.collect.Multiset;
 import com.google.common.collect.Ordering;
 import com.google.common.collect.SetMultimap;
 import com.google.common.util.concurrent.Service.State;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.concurrent.GuardedBy;
-import com.google.j2objc.annotations.J2ObjCIncompatible;
-import com.google.j2objc.annotations.WeakOuter;
 import java.lang.ref.WeakReference;
 import java.time.Duration;
 import java.util.Collections;
@@ -120,7 +115,6 @@ import java.util.logging.Logger;
  * @author Luke Sandberg
  * @since 14.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class ServiceManager implements ServiceManagerBridge {
   private static final Logger logger = Logger.getLogger(ServiceManager.class.getName());
@@ -262,7 +256,6 @@ public final class ServiceManager implements ServiceManagerBridge {
    * @throws IllegalStateException if any of the Services are not {@link State#NEW new} when the
    *     method is called.
    */
-  @CanIgnoreReturnValue
   public ServiceManager startAsync() {
     for (Service service : services) {
       State state = service.state();
@@ -332,7 +325,6 @@ public final class ServiceManager implements ServiceManagerBridge {
    *
    * @return this
    */
-  @CanIgnoreReturnValue
   public ServiceManager stopAsync() {
     for (Service service : services) {
       service.stopAsync();
@@ -423,7 +415,6 @@ public final class ServiceManager implements ServiceManagerBridge {
    *     by startup time.
    * @since 31.0
    */
-  @J2ObjCIncompatible
   public ImmutableMap<Service, Duration> startupDurations() {
     return ImmutableMap.copyOf(
         Maps.<Service, Long, Duration>transformValues(startupTimes(), Duration::ofMillis));
@@ -443,14 +434,11 @@ public final class ServiceManager implements ServiceManagerBridge {
   private static final class ServiceManagerState {
     final Monitor monitor = new Monitor();
 
-    @GuardedBy("monitor")
     final SetMultimap<State, Service> servicesByState =
         MultimapBuilder.enumKeys(State.class).linkedHashSetValues().build();
 
-    @GuardedBy("monitor")
     final Multiset<State> states = servicesByState.keys();
 
-    @GuardedBy("monitor")
     final Map<Service, Stopwatch> startupTimers = Maps.newIdentityHashMap();
 
     /**
@@ -466,10 +454,8 @@ public final class ServiceManager implements ServiceManagerBridge {
      * to any service performing a transition, then we can fail in the ServiceManager constructor
      * rather than in a Service.Listener callback.
      */
-    @GuardedBy("monitor")
     boolean ready;
 
-    @GuardedBy("monitor")
     boolean transitioned;
 
     final int numberOfServices;
@@ -480,14 +466,12 @@ public final class ServiceManager implements ServiceManagerBridge {
      */
     final Monitor.Guard awaitHealthGuard = new AwaitHealthGuard();
 
-    @WeakOuter
     final class AwaitHealthGuard extends Monitor.Guard {
       AwaitHealthGuard() {
         super(ServiceManagerState.this.monitor);
       }
 
       @Override
-      @GuardedBy("ServiceManagerState.this.monitor")
       public boolean isSatisfied() {
         // All services have started or some service has terminated/failed.
         return states.count(RUNNING) == numberOfServices
@@ -500,14 +484,12 @@ public final class ServiceManager implements ServiceManagerBridge {
     /** Controls how long to wait for all services to reach a terminal state. */
     final Monitor.Guard stoppedGuard = new StoppedGuard();
 
-    @WeakOuter
     final class StoppedGuard extends Monitor.Guard {
       StoppedGuard() {
         super(ServiceManagerState.this.monitor);
       }
 
       @Override
-      @GuardedBy("ServiceManagerState.this.monitor")
       public boolean isSatisfied() {
         return states.count(TERMINATED) + states.count(FAILED) == numberOfServices;
       }
@@ -760,7 +742,6 @@ public final class ServiceManager implements ServiceManagerBridge {
       listeners.dispatch();
     }
 
-    @GuardedBy("monitor")
     void checkHealthy() {
       if (states.count(RUNNING) != numberOfServices) {
         IllegalStateException exception =
diff --git a/guava/src/com/google/common/util/concurrent/ServiceManagerBridge.java b/guava/src/com/google/common/util/concurrent/ServiceManagerBridge.java
index 7ae430e3d2..f1432b3a1e 100644
--- a/guava/src/com/google/common/util/concurrent/ServiceManagerBridge.java
+++ b/guava/src/com/google/common/util/concurrent/ServiceManagerBridge.java
@@ -16,7 +16,6 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.ImmutableMultimap;
 import com.google.common.util.concurrent.Service.State;
 
@@ -25,7 +24,6 @@ import com.google.common.util.concurrent.Service.State;
  * servicesByState()}, to ensure binary compatibility with older Guava versions that specified
  * {@code servicesByState()} to return {@code ImmutableMultimap}.
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 interface ServiceManagerBridge {
   ImmutableMultimap<State, Service> servicesByState();
diff --git a/guava/src/com/google/common/util/concurrent/SettableFuture.java b/guava/src/com/google/common/util/concurrent/SettableFuture.java
index 893161e270..e721982ea8 100644
--- a/guava/src/com/google/common/util/concurrent/SettableFuture.java
+++ b/guava/src/com/google/common/util/concurrent/SettableFuture.java
@@ -14,9 +14,6 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link ListenableFuture} whose result can be set by a {@link #set(Object)}, {@link
@@ -32,30 +29,26 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Sven Mawson
  * @since 9.0 (in 1.0 as {@code ValueFuture})
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-public final class SettableFuture<V extends @Nullable Object>
+public final class SettableFuture<V extends Object>
     extends AbstractFuture.TrustedFuture<V> {
   /**
    * Creates a new {@code SettableFuture} that can be completed or cancelled by a later method call.
    */
-  public static <V extends @Nullable Object> SettableFuture<V> create() {
+  public static <V extends Object> SettableFuture<V> create() {
     return new SettableFuture<V>();
   }
 
-  @CanIgnoreReturnValue
   @Override
   public boolean set(@ParametricNullness V value) {
     return super.set(value);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public boolean setException(Throwable throwable) {
     return super.setException(throwable);
   }
 
-  @CanIgnoreReturnValue
   @Override
   public boolean setFuture(ListenableFuture<? extends V> future) {
     return super.setFuture(future);
diff --git a/guava/src/com/google/common/util/concurrent/SimpleTimeLimiter.java b/guava/src/com/google/common/util/concurrent/SimpleTimeLimiter.java
index 5a1969e016..352ecee7cd 100644
--- a/guava/src/com/google/common/util/concurrent/SimpleTimeLimiter.java
+++ b/guava/src/com/google/common/util/concurrent/SimpleTimeLimiter.java
@@ -17,11 +17,8 @@ package com.google.common.util.concurrent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.ObjectArrays;
 import com.google.common.collect.Sets;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -35,7 +32,6 @@ import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A TimeLimiter that runs method calls in the background using an {@link ExecutorService}. If the
@@ -45,8 +41,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Jens Nyman
  * @since 1.0
  */
-@Beta
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class SimpleTimeLimiter implements TimeLimiter {
 
@@ -90,10 +84,10 @@ public final class SimpleTimeLimiter implements TimeLimiter {
           @Override
           @CheckForNull
           public Object invoke(
-              Object obj, final Method method, @CheckForNull final @Nullable Object[] args)
+              Object obj, final Method method, @CheckForNull final Object[] args)
               throws Throwable {
-            Callable<@Nullable Object> callable =
-                new Callable<@Nullable Object>() {
+            Callable<Object> callable =
+                new Callable<Object>() {
                   @Override
                   @CheckForNull
                   public Object call() throws Exception {
@@ -119,7 +113,7 @@ public final class SimpleTimeLimiter implements TimeLimiter {
     return interfaceType.cast(object);
   }
 
-  private <T extends @Nullable Object> T callWithTimeout(
+  private <T extends Object> T callWithTimeout(
       Callable<T> callable, long timeoutDuration, TimeUnit timeoutUnit, boolean amInterruptible)
       throws Exception {
     checkNotNull(callable);
@@ -147,9 +141,8 @@ public final class SimpleTimeLimiter implements TimeLimiter {
     }
   }
 
-  @CanIgnoreReturnValue
   @Override
-  public <T extends @Nullable Object> T callWithTimeout(
+  public <T extends Object> T callWithTimeout(
       Callable<T> callable, long timeoutDuration, TimeUnit timeoutUnit)
       throws TimeoutException, InterruptedException, ExecutionException {
     checkNotNull(callable);
@@ -169,9 +162,8 @@ public final class SimpleTimeLimiter implements TimeLimiter {
     }
   }
 
-  @CanIgnoreReturnValue
   @Override
-  public <T extends @Nullable Object> T callUninterruptiblyWithTimeout(
+  public <T extends Object> T callUninterruptiblyWithTimeout(
       Callable<T> callable, long timeoutDuration, TimeUnit timeoutUnit)
       throws TimeoutException, ExecutionException {
     checkNotNull(callable);
diff --git a/guava/src/com/google/common/util/concurrent/SmoothRateLimiter.java b/guava/src/com/google/common/util/concurrent/SmoothRateLimiter.java
index ca78905908..9314fd80e2 100644
--- a/guava/src/com/google/common/util/concurrent/SmoothRateLimiter.java
+++ b/guava/src/com/google/common/util/concurrent/SmoothRateLimiter.java
@@ -17,11 +17,9 @@ package com.google.common.util.concurrent;
 import static java.lang.Math.min;
 import static java.util.concurrent.TimeUnit.SECONDS;
 
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.math.LongMath;
 import java.util.concurrent.TimeUnit;
 
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 abstract class SmoothRateLimiter extends RateLimiter {
   /*
diff --git a/guava/src/com/google/common/util/concurrent/Striped.java b/guava/src/com/google/common/util/concurrent/Striped.java
index fc8bcd8f30..124dc6b3d3 100644
--- a/guava/src/com/google/common/util/concurrent/Striped.java
+++ b/guava/src/com/google/common/util/concurrent/Striped.java
@@ -16,9 +16,6 @@ package com.google.common.util.concurrent;
 
 import static com.google.common.collect.Lists.newArrayList;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Preconditions;
 import com.google.common.base.Supplier;
@@ -41,7 +38,6 @@ import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A striped {@code Lock/Semaphore/ReadWriteLock}. This offers the underlying lock striping similar
@@ -82,8 +78,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Dimitris Andreou
  * @since 13.0
  */
-@Beta
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public abstract class Striped<L> {
   /**
@@ -436,9 +430,8 @@ public abstract class Striped<L> {
    * AtomicReferenceArray of size 2^k. To map a user key into a stripe, we take a k-bit slice of the
    * user key's (smeared) hashCode(). The stripes are lazily initialized and are weakly referenced.
    */
-  @VisibleForTesting
   static class SmallLazyStriped<L> extends PowerOfTwoStriped<L> {
-    final AtomicReferenceArray<@Nullable ArrayReference<? extends L>> locks;
+    final AtomicReferenceArray<ArrayReference<? extends L>> locks;
     final Supplier<L> supplier;
     final int size;
     final ReferenceQueue<L> queue = new ReferenceQueue<L>();
@@ -508,7 +501,6 @@ public abstract class Striped<L> {
    * where the key domain is [0..2^k). To map a user key into a stripe, we take a k-bit slice of the
    * user key's (smeared) hashCode(). The stripes are lazily initialized and are weakly referenced.
    */
-  @VisibleForTesting
   static class LargeLazyStriped<L> extends PowerOfTwoStriped<L> {
     final ConcurrentMap<Integer, L> locks;
     final Supplier<L> supplier;
diff --git a/guava/src/com/google/common/util/concurrent/ThreadFactoryBuilder.java b/guava/src/com/google/common/util/concurrent/ThreadFactoryBuilder.java
index 1027f3c83e..fadbaa8101 100644
--- a/guava/src/com/google/common/util/concurrent/ThreadFactoryBuilder.java
+++ b/guava/src/com/google/common/util/concurrent/ThreadFactoryBuilder.java
@@ -18,9 +18,6 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static java.util.Objects.requireNonNull;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.CheckReturnValue;
 import java.lang.Thread.UncaughtExceptionHandler;
 import java.util.Locale;
 import java.util.concurrent.Executors;
@@ -45,8 +42,6 @@ import javax.annotation.CheckForNull;
  * @author Kurt Alfred Kluever
  * @since 4.0
  */
-@CanIgnoreReturnValue
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class ThreadFactoryBuilder {
   @CheckForNull private String nameFormat = null;
@@ -143,7 +138,6 @@ public final class ThreadFactoryBuilder {
    *
    * @return the fully constructed {@link ThreadFactory}
    */
-  @CheckReturnValue
   public ThreadFactory build() {
     return doBuild(this);
   }
diff --git a/guava/src/com/google/common/util/concurrent/TimeLimiter.java b/guava/src/com/google/common/util/concurrent/TimeLimiter.java
index 0245fec3ca..3c1a0890e9 100644
--- a/guava/src/com/google/common/util/concurrent/TimeLimiter.java
+++ b/guava/src/com/google/common/util/concurrent/TimeLimiter.java
@@ -16,16 +16,11 @@ package com.google.common.util.concurrent;
 
 import static com.google.common.util.concurrent.Internal.toNanosSaturated;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotMock;
 import java.time.Duration;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Imposes a time limit on method calls.
@@ -34,9 +29,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Jens Nyman
  * @since 1.0
  */
-@Beta
-@DoNotMock("Use FakeTimeLimiter")
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public interface TimeLimiter {
 
@@ -145,8 +137,7 @@ public interface TimeLimiter {
    * @since 22.0
    */
   @SuppressWarnings("GoodTime") // should accept a java.time.Duration
-  @CanIgnoreReturnValue
-  <T extends @Nullable Object> T callWithTimeout(
+  <T extends Object> T callWithTimeout(
       Callable<T> callable, long timeoutDuration, TimeUnit timeoutUnit)
       throws TimeoutException, InterruptedException, ExecutionException;
 
@@ -166,8 +157,7 @@ public interface TimeLimiter {
    * @throws ExecutionError if {@code callable} throws an {@code Error}
    * @since 28.0
    */
-  @CanIgnoreReturnValue
-  default <T extends @Nullable Object> T callWithTimeout(Callable<T> callable, Duration timeout)
+  default <T extends Object> T callWithTimeout(Callable<T> callable, Duration timeout)
       throws TimeoutException, InterruptedException, ExecutionException {
     return callWithTimeout(callable, toNanosSaturated(timeout), TimeUnit.NANOSECONDS);
   }
@@ -192,8 +182,7 @@ public interface TimeLimiter {
    * @since 22.0
    */
   @SuppressWarnings("GoodTime") // should accept a java.time.Duration
-  @CanIgnoreReturnValue
-  <T extends @Nullable Object> T callUninterruptiblyWithTimeout(
+  <T extends Object> T callUninterruptiblyWithTimeout(
       Callable<T> callable, long timeoutDuration, TimeUnit timeoutUnit)
       throws TimeoutException, ExecutionException;
 
@@ -215,8 +204,7 @@ public interface TimeLimiter {
    * @throws ExecutionError if {@code callable} throws an {@code Error}
    * @since 28.0
    */
-  @CanIgnoreReturnValue
-  default <T extends @Nullable Object> T callUninterruptiblyWithTimeout(
+  default <T extends Object> T callUninterruptiblyWithTimeout(
       Callable<T> callable, Duration timeout) throws TimeoutException, ExecutionException {
     return callUninterruptiblyWithTimeout(
         callable, toNanosSaturated(timeout), TimeUnit.NANOSECONDS);
diff --git a/guava/src/com/google/common/util/concurrent/TimeoutFuture.java b/guava/src/com/google/common/util/concurrent/TimeoutFuture.java
index 219a0981a6..3e6d5a6edd 100644
--- a/guava/src/com/google/common/util/concurrent/TimeoutFuture.java
+++ b/guava/src/com/google/common/util/concurrent/TimeoutFuture.java
@@ -16,7 +16,6 @@ package com.google.common.util.concurrent;
 
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Preconditions;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
@@ -25,7 +24,6 @@ import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@code Futures#withTimeout}.
@@ -34,10 +32,9 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * in an {@link ExecutionException}) if the specified duration expires. The delegate future is
  * interrupted and cancelled if it times out.
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
-final class TimeoutFuture<V extends @Nullable Object> extends FluentFuture.TrustedFuture<V> {
-  static <V extends @Nullable Object> ListenableFuture<V> create(
+final class TimeoutFuture<V extends Object> extends FluentFuture.TrustedFuture<V> {
+  static <V extends Object> ListenableFuture<V> create(
       ListenableFuture<V> delegate,
       long time,
       TimeUnit unit,
@@ -81,7 +78,7 @@ final class TimeoutFuture<V extends @Nullable Object> extends FluentFuture.Trust
   }
 
   /** A runnable that is called when the delegate or the timer completes. */
-  private static final class Fire<V extends @Nullable Object> implements Runnable {
+  private static final class Fire<V extends Object> implements Runnable {
     @CheckForNull TimeoutFuture<V> timeoutFutureRef;
 
     Fire(TimeoutFuture<V> timeoutFuture) {
diff --git a/guava/src/com/google/common/util/concurrent/TrustedListenableFutureTask.java b/guava/src/com/google/common/util/concurrent/TrustedListenableFutureTask.java
index a2c2115c3b..aafe62249d 100644
--- a/guava/src/com/google/common/util/concurrent/TrustedListenableFutureTask.java
+++ b/guava/src/com/google/common/util/concurrent/TrustedListenableFutureTask.java
@@ -16,13 +16,10 @@ package com.google.common.util.concurrent;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.GwtCompatible;
-import com.google.j2objc.annotations.WeakOuter;
 import java.util.concurrent.Callable;
 import java.util.concurrent.Executors;
 import java.util.concurrent.RunnableFuture;
 import javax.annotation.CheckForNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link RunnableFuture} that also implements the {@link ListenableFuture} interface.
@@ -30,17 +27,16 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * <p>This should be used in preference to {@link ListenableFutureTask} when possible for
  * performance reasons.
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
-class TrustedListenableFutureTask<V extends @Nullable Object> extends FluentFuture.TrustedFuture<V>
+class TrustedListenableFutureTask<V extends Object> extends FluentFuture.TrustedFuture<V>
     implements RunnableFuture<V> {
 
-  static <V extends @Nullable Object> TrustedListenableFutureTask<V> create(
+  static <V extends Object> TrustedListenableFutureTask<V> create(
       AsyncCallable<V> callable) {
     return new TrustedListenableFutureTask<V>(callable);
   }
 
-  static <V extends @Nullable Object> TrustedListenableFutureTask<V> create(Callable<V> callable) {
+  static <V extends Object> TrustedListenableFutureTask<V> create(Callable<V> callable) {
     return new TrustedListenableFutureTask<V>(callable);
   }
 
@@ -53,7 +49,7 @@ class TrustedListenableFutureTask<V extends @Nullable Object> extends FluentFutu
    *     result, consider using constructions of the form: {@code ListenableFuture<?> f =
    *     ListenableFutureTask.create(runnable, null)}
    */
-  static <V extends @Nullable Object> TrustedListenableFutureTask<V> create(
+  static <V extends Object> TrustedListenableFutureTask<V> create(
       Runnable runnable, @ParametricNullness V result) {
     return new TrustedListenableFutureTask<V>(Executors.callable(runnable, result));
   }
@@ -112,7 +108,6 @@ class TrustedListenableFutureTask<V extends @Nullable Object> extends FluentFutu
     return super.pendingToString();
   }
 
-  @WeakOuter
   private final class TrustedFutureInterruptibleTask extends InterruptibleTask<V> {
     private final Callable<V> callable;
 
@@ -147,7 +142,6 @@ class TrustedListenableFutureTask<V extends @Nullable Object> extends FluentFutu
     }
   }
 
-  @WeakOuter
   private final class TrustedFutureInterruptibleAsyncTask
       extends InterruptibleTask<ListenableFuture<V>> {
     private final AsyncCallable<V> callable;
diff --git a/guava/src/com/google/common/util/concurrent/UncaughtExceptionHandlers.java b/guava/src/com/google/common/util/concurrent/UncaughtExceptionHandlers.java
index a1add8bcbb..5d543e8b4b 100644
--- a/guava/src/com/google/common/util/concurrent/UncaughtExceptionHandlers.java
+++ b/guava/src/com/google/common/util/concurrent/UncaughtExceptionHandlers.java
@@ -16,8 +16,6 @@ package com.google.common.util.concurrent;
 
 import static java.util.logging.Level.SEVERE;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.common.annotations.VisibleForTesting;
 import java.lang.Thread.UncaughtExceptionHandler;
 import java.util.Locale;
 import java.util.logging.Logger;
@@ -28,7 +26,6 @@ import java.util.logging.Logger;
  * @author Gregory Kick
  * @since 8.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public final class UncaughtExceptionHandlers {
   private UncaughtExceptionHandlers() {}
@@ -53,7 +50,6 @@ public final class UncaughtExceptionHandlers {
     return new Exiter(Runtime.getRuntime());
   }
 
-  @VisibleForTesting
   static final class Exiter implements UncaughtExceptionHandler {
     private static final Logger logger = Logger.getLogger(Exiter.class.getName());
 
diff --git a/guava/src/com/google/common/util/concurrent/UncheckedExecutionException.java b/guava/src/com/google/common/util/concurrent/UncheckedExecutionException.java
index 713f4a69e7..9fe4b10295 100644
--- a/guava/src/com/google/common/util/concurrent/UncheckedExecutionException.java
+++ b/guava/src/com/google/common/util/concurrent/UncheckedExecutionException.java
@@ -14,7 +14,6 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.GwtCompatible;
 import javax.annotation.CheckForNull;
 
 /**
@@ -32,7 +31,6 @@ import javax.annotation.CheckForNull;
  * @author Charles Fry
  * @since 10.0
  */
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public class UncheckedExecutionException extends RuntimeException {
   /*
diff --git a/guava/src/com/google/common/util/concurrent/UncheckedTimeoutException.java b/guava/src/com/google/common/util/concurrent/UncheckedTimeoutException.java
index 8e30fca37f..9a02731d1b 100644
--- a/guava/src/com/google/common/util/concurrent/UncheckedTimeoutException.java
+++ b/guava/src/com/google/common/util/concurrent/UncheckedTimeoutException.java
@@ -14,7 +14,6 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.GwtIncompatible;
 import javax.annotation.CheckForNull;
 
 /**
@@ -23,7 +22,6 @@ import javax.annotation.CheckForNull;
  * @author Kevin Bourrillion
  * @since 1.0
  */
-@GwtIncompatible
 @ElementTypesAreNonnullByDefault
 public class UncheckedTimeoutException extends RuntimeException {
   public UncheckedTimeoutException() {}
diff --git a/guava/src/com/google/common/util/concurrent/Uninterruptibles.java b/guava/src/com/google/common/util/concurrent/Uninterruptibles.java
index 94678ecf32..33d323cad4 100644
--- a/guava/src/com/google/common/util/concurrent/Uninterruptibles.java
+++ b/guava/src/com/google/common/util/concurrent/Uninterruptibles.java
@@ -18,11 +18,7 @@ import static com.google.common.base.Verify.verify;
 import static com.google.common.util.concurrent.Internal.toNanosSaturated;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Preconditions;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.time.Duration;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.CancellationException;
@@ -35,7 +31,6 @@ import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.locks.Condition;
 import java.util.concurrent.locks.Lock;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Utilities for treating interruptible operations as uninterruptible. In all cases, if a thread is
@@ -45,7 +40,6 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Anthony Zana
  * @since 10.0
  */
-@GwtCompatible(emulated = true)
 @ElementTypesAreNonnullByDefault
 public final class Uninterruptibles {
 
@@ -53,7 +47,7 @@ public final class Uninterruptibles {
   // methods is identical, save for method being invoked.
 
   /** Invokes {@code latch.}{@link CountDownLatch#await() await()} uninterruptibly. */
-  @GwtIncompatible // concurrency
+  // concurrency
   public static void awaitUninterruptibly(CountDownLatch latch) {
     boolean interrupted = false;
     try {
@@ -78,9 +72,8 @@ public final class Uninterruptibles {
    *
    * @since 28.0
    */
-  @CanIgnoreReturnValue // TODO(cpovirk): Consider being more strict.
-  @GwtIncompatible // concurrency
-  @Beta
+  // TODO(cpovirk): Consider being more strict.
+  // concurrency
   public static boolean awaitUninterruptibly(CountDownLatch latch, Duration timeout) {
     return awaitUninterruptibly(latch, toNanosSaturated(timeout), TimeUnit.NANOSECONDS);
   }
@@ -89,8 +82,8 @@ public final class Uninterruptibles {
    * Invokes {@code latch.}{@link CountDownLatch#await(long, TimeUnit) await(timeout, unit)}
    * uninterruptibly.
    */
-  @CanIgnoreReturnValue // TODO(cpovirk): Consider being more strict.
-  @GwtIncompatible // concurrency
+  // TODO(cpovirk): Consider being more strict.
+  // concurrency
   @SuppressWarnings("GoodTime") // should accept a java.time.Duration
   public static boolean awaitUninterruptibly(CountDownLatch latch, long timeout, TimeUnit unit) {
     boolean interrupted = false;
@@ -120,8 +113,7 @@ public final class Uninterruptibles {
    *
    * @since 28.0
    */
-  @GwtIncompatible // concurrency
-  @Beta
+  // concurrency
   public static boolean awaitUninterruptibly(Condition condition, Duration timeout) {
     return awaitUninterruptibly(condition, toNanosSaturated(timeout), TimeUnit.NANOSECONDS);
   }
@@ -132,7 +124,7 @@ public final class Uninterruptibles {
    *
    * @since 23.6
    */
-  @GwtIncompatible // concurrency
+  // concurrency
   @SuppressWarnings("GoodTime") // should accept a java.time.Duration
   public static boolean awaitUninterruptibly(Condition condition, long timeout, TimeUnit unit) {
     boolean interrupted = false;
@@ -156,7 +148,7 @@ public final class Uninterruptibles {
   }
 
   /** Invokes {@code toJoin.}{@link Thread#join() join()} uninterruptibly. */
-  @GwtIncompatible // concurrency
+  // concurrency
   public static void joinUninterruptibly(Thread toJoin) {
     boolean interrupted = false;
     try {
@@ -181,8 +173,7 @@ public final class Uninterruptibles {
    *
    * @since 28.0
    */
-  @GwtIncompatible // concurrency
-  @Beta
+  // concurrency
   public static void joinUninterruptibly(Thread toJoin, Duration timeout) {
     joinUninterruptibly(toJoin, toNanosSaturated(timeout), TimeUnit.NANOSECONDS);
   }
@@ -191,7 +182,7 @@ public final class Uninterruptibles {
    * Invokes {@code unit.}{@link TimeUnit#timedJoin(Thread, long) timedJoin(toJoin, timeout)}
    * uninterruptibly.
    */
-  @GwtIncompatible // concurrency
+  // concurrency
   @SuppressWarnings("GoodTime") // should accept a java.time.Duration
   public static void joinUninterruptibly(Thread toJoin, long timeout, TimeUnit unit) {
     Preconditions.checkNotNull(toJoin);
@@ -233,9 +224,8 @@ public final class Uninterruptibles {
    * @throws ExecutionException if the computation threw an exception
    * @throws CancellationException if the computation was cancelled
    */
-  @CanIgnoreReturnValue
   @ParametricNullness
-  public static <V extends @Nullable Object> V getUninterruptibly(Future<V> future)
+  public static <V extends Object> V getUninterruptibly(Future<V> future)
       throws ExecutionException {
     boolean interrupted = false;
     try {
@@ -272,11 +262,9 @@ public final class Uninterruptibles {
    * @throws TimeoutException if the wait timed out
    * @since 28.0
    */
-  @CanIgnoreReturnValue
-  @GwtIncompatible // java.time.Duration
-  @Beta
+  // java.time.Duration
   @ParametricNullness
-  public static <V extends @Nullable Object> V getUninterruptibly(
+  public static <V extends Object> V getUninterruptibly(
       Future<V> future, Duration timeout) throws ExecutionException, TimeoutException {
     return getUninterruptibly(future, toNanosSaturated(timeout), TimeUnit.NANOSECONDS);
   }
@@ -299,11 +287,10 @@ public final class Uninterruptibles {
    * @throws CancellationException if the computation was cancelled
    * @throws TimeoutException if the wait timed out
    */
-  @CanIgnoreReturnValue
-  @GwtIncompatible // TODO
+  // TODO
   @SuppressWarnings("GoodTime") // should accept a java.time.Duration
   @ParametricNullness
-  public static <V extends @Nullable Object> V getUninterruptibly(
+  public static <V extends Object> V getUninterruptibly(
       Future<V> future, long timeout, TimeUnit unit) throws ExecutionException, TimeoutException {
     boolean interrupted = false;
     try {
@@ -327,7 +314,7 @@ public final class Uninterruptibles {
   }
 
   /** Invokes {@code queue.}{@link BlockingQueue#take() take()} uninterruptibly. */
-  @GwtIncompatible // concurrency
+  // concurrency
   public static <E> E takeUninterruptibly(BlockingQueue<E> queue) {
     boolean interrupted = false;
     try {
@@ -353,7 +340,7 @@ public final class Uninterruptibles {
    * @throws IllegalArgumentException if some property of the specified element prevents it from
    *     being added to the given queue
    */
-  @GwtIncompatible // concurrency
+  // concurrency
   public static <E> void putUninterruptibly(BlockingQueue<E> queue, E element) {
     boolean interrupted = false;
     try {
@@ -378,15 +365,14 @@ public final class Uninterruptibles {
    *
    * @since 28.0
    */
-  @GwtIncompatible // concurrency
-  @Beta
+  // concurrency
   public static void sleepUninterruptibly(Duration sleepFor) {
     sleepUninterruptibly(toNanosSaturated(sleepFor), TimeUnit.NANOSECONDS);
   }
 
   // TODO(user): Support Sleeper somehow (wrapper or interface method)?
   /** Invokes {@code unit.}{@link TimeUnit#sleep(long) sleep(sleepFor)} uninterruptibly. */
-  @GwtIncompatible // concurrency
+  // concurrency
   @SuppressWarnings("GoodTime") // should accept a java.time.Duration
   public static void sleepUninterruptibly(long sleepFor, TimeUnit unit) {
     boolean interrupted = false;
@@ -416,8 +402,7 @@ public final class Uninterruptibles {
    *
    * @since 28.0
    */
-  @GwtIncompatible // concurrency
-  @Beta
+  // concurrency
   public static boolean tryAcquireUninterruptibly(Semaphore semaphore, Duration timeout) {
     return tryAcquireUninterruptibly(semaphore, toNanosSaturated(timeout), TimeUnit.NANOSECONDS);
   }
@@ -428,7 +413,7 @@ public final class Uninterruptibles {
    *
    * @since 18.0
    */
-  @GwtIncompatible // concurrency
+  // concurrency
   @SuppressWarnings("GoodTime") // should accept a java.time.Duration
   public static boolean tryAcquireUninterruptibly(
       Semaphore semaphore, long timeout, TimeUnit unit) {
@@ -441,8 +426,7 @@ public final class Uninterruptibles {
    *
    * @since 28.0
    */
-  @GwtIncompatible // concurrency
-  @Beta
+  // concurrency
   public static boolean tryAcquireUninterruptibly(
       Semaphore semaphore, int permits, Duration timeout) {
     return tryAcquireUninterruptibly(
@@ -455,7 +439,7 @@ public final class Uninterruptibles {
    *
    * @since 18.0
    */
-  @GwtIncompatible // concurrency
+  // concurrency
   @SuppressWarnings("GoodTime") // should accept a java.time.Duration
   public static boolean tryAcquireUninterruptibly(
       Semaphore semaphore, int permits, long timeout, TimeUnit unit) {
@@ -486,8 +470,7 @@ public final class Uninterruptibles {
    *
    * @since 30.0
    */
-  @GwtIncompatible // concurrency
-  @Beta
+  // concurrency
   public static boolean tryLockUninterruptibly(Lock lock, Duration timeout) {
     return tryLockUninterruptibly(lock, toNanosSaturated(timeout), TimeUnit.NANOSECONDS);
   }
@@ -498,7 +481,7 @@ public final class Uninterruptibles {
    *
    * @since 30.0
    */
-  @GwtIncompatible // concurrency
+  // concurrency
   @SuppressWarnings("GoodTime") // should accept a java.time.Duration
   public static boolean tryLockUninterruptibly(Lock lock, long timeout, TimeUnit unit) {
     boolean interrupted = false;
@@ -527,8 +510,7 @@ public final class Uninterruptibles {
    *
    * @since 30.0
    */
-  @Beta
-  @GwtIncompatible // concurrency
+  // concurrency
   public static void awaitTerminationUninterruptibly(ExecutorService executor) {
     // TODO(cpovirk): We could optimize this to avoid calling nanoTime() at all.
     verify(awaitTerminationUninterruptibly(executor, Long.MAX_VALUE, NANOSECONDS));
@@ -540,8 +522,7 @@ public final class Uninterruptibles {
    *
    * @since 30.0
    */
-  @Beta
-  @GwtIncompatible // concurrency
+  // concurrency
   public static boolean awaitTerminationUninterruptibly(
       ExecutorService executor, Duration timeout) {
     return awaitTerminationUninterruptibly(executor, toNanosSaturated(timeout), NANOSECONDS);
@@ -553,8 +534,7 @@ public final class Uninterruptibles {
    *
    * @since 30.0
    */
-  @Beta
-  @GwtIncompatible // concurrency
+  // concurrency
   @SuppressWarnings("GoodTime")
   public static boolean awaitTerminationUninterruptibly(
       ExecutorService executor, long timeout, TimeUnit unit) {
diff --git a/guava/src/com/google/common/util/concurrent/WrappingExecutorService.java b/guava/src/com/google/common/util/concurrent/WrappingExecutorService.java
index 03c08cc2f9..94ccfbb052 100644
--- a/guava/src/com/google/common/util/concurrent/WrappingExecutorService.java
+++ b/guava/src/com/google/common/util/concurrent/WrappingExecutorService.java
@@ -17,9 +17,7 @@ package com.google.common.util.concurrent;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Throwables.throwIfUnchecked;
 
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.ImmutableList;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Collection;
 import java.util.List;
 import java.util.concurrent.Callable;
@@ -29,7 +27,6 @@ import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An abstract {@code ExecutorService} that allows subclasses to {@linkplain #wrapTask(Callable)
@@ -41,8 +38,7 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @author Chris Nokleberg
  */
-@CanIgnoreReturnValue // TODO(cpovirk): Consider being more strict.
-@GwtIncompatible
+// TODO(cpovirk): Consider being more strict.
 @ElementTypesAreNonnullByDefault
 abstract class WrappingExecutorService implements ExecutorService {
   private final ExecutorService delegate;
@@ -55,7 +51,7 @@ abstract class WrappingExecutorService implements ExecutorService {
    * Wraps a {@code Callable} for submission to the underlying executor. This method is also applied
    * to any {@code Runnable} passed to the default implementation of {@link #wrapTask(Runnable)}.
    */
-  protected abstract <T extends @Nullable Object> Callable<T> wrapTask(Callable<T> callable);
+  protected abstract <T extends Object> Callable<T> wrapTask(Callable<T> callable);
 
   /**
    * Wraps a {@code Runnable} for submission to the underlying executor. The default implementation
@@ -81,7 +77,7 @@ abstract class WrappingExecutorService implements ExecutorService {
    *
    * @throws NullPointerException if any element of {@code tasks} is null
    */
-  private <T extends @Nullable Object> ImmutableList<Callable<T>> wrapTasks(
+  private <T extends Object> ImmutableList<Callable<T>> wrapTasks(
       Collection<? extends Callable<T>> tasks) {
     ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();
     for (Callable<T> task : tasks) {
@@ -97,7 +93,7 @@ abstract class WrappingExecutorService implements ExecutorService {
   }
 
   @Override
-  public final <T extends @Nullable Object> Future<T> submit(Callable<T> task) {
+  public final <T extends Object> Future<T> submit(Callable<T> task) {
     return delegate.submit(wrapTask(checkNotNull(task)));
   }
 
@@ -107,32 +103,32 @@ abstract class WrappingExecutorService implements ExecutorService {
   }
 
   @Override
-  public final <T extends @Nullable Object> Future<T> submit(
+  public final <T extends Object> Future<T> submit(
       Runnable task, @ParametricNullness T result) {
     return delegate.submit(wrapTask(task), result);
   }
 
   @Override
-  public final <T extends @Nullable Object> List<Future<T>> invokeAll(
+  public final <T extends Object> List<Future<T>> invokeAll(
       Collection<? extends Callable<T>> tasks) throws InterruptedException {
     return delegate.invokeAll(wrapTasks(tasks));
   }
 
   @Override
-  public final <T extends @Nullable Object> List<Future<T>> invokeAll(
+  public final <T extends Object> List<Future<T>> invokeAll(
       Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
       throws InterruptedException {
     return delegate.invokeAll(wrapTasks(tasks), timeout, unit);
   }
 
   @Override
-  public final <T extends @Nullable Object> T invokeAny(Collection<? extends Callable<T>> tasks)
+  public final <T extends Object> T invokeAny(Collection<? extends Callable<T>> tasks)
       throws InterruptedException, ExecutionException {
     return delegate.invokeAny(wrapTasks(tasks));
   }
 
   @Override
-  public final <T extends @Nullable Object> T invokeAny(
+  public final <T extends Object> T invokeAny(
       Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
       throws InterruptedException, ExecutionException, TimeoutException {
     return delegate.invokeAny(wrapTasks(tasks), timeout, unit);
diff --git a/guava/src/com/google/common/util/concurrent/WrappingScheduledExecutorService.java b/guava/src/com/google/common/util/concurrent/WrappingScheduledExecutorService.java
index 48f23c12c7..7d52c99d55 100644
--- a/guava/src/com/google/common/util/concurrent/WrappingScheduledExecutorService.java
+++ b/guava/src/com/google/common/util/concurrent/WrappingScheduledExecutorService.java
@@ -14,13 +14,10 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.GwtIncompatible;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An abstract {@code ScheduledExecutorService} that allows subclasses to {@linkplain
@@ -30,8 +27,7 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  *
  * @author Luke Sandberg
  */
-@CanIgnoreReturnValue // TODO(cpovirk): Consider being more strict.
-@GwtIncompatible
+// TODO(cpovirk): Consider being more strict.
 @ElementTypesAreNonnullByDefault
 abstract class WrappingScheduledExecutorService extends WrappingExecutorService
     implements ScheduledExecutorService {
@@ -48,7 +44,7 @@ abstract class WrappingScheduledExecutorService extends WrappingExecutorService
   }
 
   @Override
-  public final <V extends @Nullable Object> ScheduledFuture<V> schedule(
+  public final <V extends Object> ScheduledFuture<V> schedule(
       Callable<V> task, long delay, TimeUnit unit) {
     return delegate.schedule(wrapTask(task), delay, unit);
   }
diff --git a/guava/src/com/google/common/util/concurrent/package-info.java b/guava/src/com/google/common/util/concurrent/package-info.java
index a2533c1fc8..ab9565abec 100644
--- a/guava/src/com/google/common/util/concurrent/package-info.java
+++ b/guava/src/com/google/common/util/concurrent/package-info.java
@@ -25,9 +25,7 @@
  * <p>This package is a part of the open-source <a href="http://github.com/google/guava">Guava</a>
  * library.
  */
-@CheckReturnValue
 @ParametersAreNonnullByDefault
 package com.google.common.util.concurrent;
 
-import com.google.errorprone.annotations.CheckReturnValue;
 import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/guava/src/com/google/common/xml/ElementTypesAreNonnullByDefault.java b/guava/src/com/google/common/xml/ElementTypesAreNonnullByDefault.java
index b4fb4e3fe4..c4dc0b2d69 100644
--- a/guava/src/com/google/common/xml/ElementTypesAreNonnullByDefault.java
+++ b/guava/src/com/google/common/xml/ElementTypesAreNonnullByDefault.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.ElementType.TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -33,7 +32,6 @@ import javax.annotation.meta.TypeQualifierDefault;
  * unfortunately includes type-variable usages, so we also provide {@link ParametricNullness} to
  * "undo" it as best we can.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target(TYPE)
 @TypeQualifierDefault({FIELD, METHOD, PARAMETER})
diff --git a/guava/src/com/google/common/xml/ParametricNullness.java b/guava/src/com/google/common/xml/ParametricNullness.java
index a476558fbf..42f29cd05f 100644
--- a/guava/src/com/google/common/xml/ParametricNullness.java
+++ b/guava/src/com/google/common/xml/ParametricNullness.java
@@ -22,7 +22,6 @@ import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import static javax.annotation.meta.When.UNKNOWN;
 
-import com.google.common.annotations.GwtCompatible;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.annotation.Nonnull;
@@ -35,7 +34,6 @@ import javax.annotation.meta.TypeQualifierNickname;
  * href="https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/NullFromTypeParam.java">{@code
  * NullFromTypeParam}</a>). We use this to "undo" {@link ElementTypesAreNonnullByDefault}.
  */
-@GwtCompatible
 @Retention(RUNTIME)
 @Target({FIELD, METHOD, PARAMETER})
 @TypeQualifierNickname
diff --git a/guava/src/com/google/common/xml/XmlEscapers.java b/guava/src/com/google/common/xml/XmlEscapers.java
index a1c637c355..7d73ceff4d 100644
--- a/guava/src/com/google/common/xml/XmlEscapers.java
+++ b/guava/src/com/google/common/xml/XmlEscapers.java
@@ -14,8 +14,6 @@
 
 package com.google.common.xml;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.escape.Escaper;
 import com.google.common.escape.Escapers;
 
@@ -38,8 +36,6 @@ import com.google.common.escape.Escapers;
  * @author David Beaumont
  * @since 15.0
  */
-@Beta
-@GwtCompatible
 @ElementTypesAreNonnullByDefault
 public class XmlEscapers {
   private XmlEscapers() {}
diff --git a/guava/src/com/google/common/xml/package-info.java b/guava/src/com/google/common/xml/package-info.java
index bd4c952162..87eafd44c5 100644
--- a/guava/src/com/google/common/xml/package-info.java
+++ b/guava/src/com/google/common/xml/package-info.java
@@ -20,9 +20,7 @@
  * <p>This package is a part of the open-source <a href="http://github.com/google/guava">Guava</a>
  * library.
  */
-@CheckReturnValue
 @ParametersAreNonnullByDefault
 package com.google.common.xml;
 
-import com.google.errorprone.annotations.CheckReturnValue;
 import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java b/guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java
index 9e5f173666..eca2000ba4 100644
--- a/guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java
+++ b/guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java
@@ -18,8 +18,6 @@
 
 package com.google.thirdparty.publicsuffix;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.ImmutableMap;
 
 /**
@@ -34,8 +32,6 @@ import com.google.common.collect.ImmutableMap;
  *
  * @since 16.0
  */
-@GwtCompatible
-@Beta
 public final class PublicSuffixPatterns {
   private PublicSuffixPatterns() {}
 
diff --git a/guava/src/com/google/thirdparty/publicsuffix/PublicSuffixType.java b/guava/src/com/google/thirdparty/publicsuffix/PublicSuffixType.java
index be1d07f8a1..af4ba691fc 100644
--- a/guava/src/com/google/thirdparty/publicsuffix/PublicSuffixType.java
+++ b/guava/src/com/google/thirdparty/publicsuffix/PublicSuffixType.java
@@ -14,8 +14,6 @@
 
 package com.google.thirdparty.publicsuffix;
 
-import com.google.common.annotations.Beta;
-import com.google.common.annotations.GwtCompatible;
 
 /**
  * <b>Do not use this class directly. For access to public-suffix information, use {@link
@@ -25,8 +23,6 @@ import com.google.common.annotations.GwtCompatible;
  *
  * @since 23.3
  */
-@Beta
-@GwtCompatible
 public enum PublicSuffixType {
 
   /** Public suffix that is provided by a private company, e.g. "blogspot.com" */
diff --git a/guava/src/com/google/thirdparty/publicsuffix/TrieParser.java b/guava/src/com/google/thirdparty/publicsuffix/TrieParser.java
index dd7778040e..49446b190a 100644
--- a/guava/src/com/google/thirdparty/publicsuffix/TrieParser.java
+++ b/guava/src/com/google/thirdparty/publicsuffix/TrieParser.java
@@ -14,14 +14,12 @@
 
 package com.google.thirdparty.publicsuffix;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Queues;
 import java.util.Deque;
 
 /** Parser for a map of reversed domain names stored as a serialized radix tree. */
-@GwtCompatible
 final class TrieParser {
   private static final Joiner PREFIX_JOINER = Joiner.on("");
 
-- 
2.39.1

