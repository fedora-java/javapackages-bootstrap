From 1a61004c3143643d2868689553e81c508d8dbe5b Mon Sep 17 00:00:00 2001
From: Mikolaj Izdebski <mizdebsk@redhat.com>
Date: Wed, 23 Aug 2023 08:14:04 +0200
Subject: [PATCH] Generate bootstrap sources

Generated with:

    java -cp bootstrap/javacc.jar org.javacc.parser.Main -OUTPUT_DIRECTORY=generated/org/javacc/parser src/main/javacc/JavaCC.jj

    java -cp bootstrap/javacc.jar org.javacc.jjtree.Main -OUTPUT_DIRECTORY=generated/org/javacc/jjtree src/main/jjtree/JJTree.jjt

    java -cp bootstrap/javacc.jar org.javacc.parser.Main -OUTPUT_DIRECTORY=generated/org/javacc/jjtree generated/org/javacc/jjtree/JJTree.jj

    java -cp bootstrap/javacc.jar org.javacc.parser.Main -OUTPUT_DIRECTORY=generated/org/javacc/utils src/main/javacc/ConditionParser.jj

    rm generated/org/javacc/parser/Token.java
    rm generated/org/javacc/jjtree/ASTBNF.java
    rm generated/org/javacc/jjtree/ASTBNFAction.java
    rm generated/org/javacc/jjtree/ASTBNFDeclaration.java
    rm generated/org/javacc/jjtree/ASTBNFNodeScope.java
    rm generated/org/javacc/jjtree/ASTCompilationUnit.java
    rm generated/org/javacc/jjtree/ASTExpansionNodeScope.java
    rm generated/org/javacc/jjtree/ASTGrammar.java
    rm generated/org/javacc/jjtree/ASTJavacode.java
    rm generated/org/javacc/jjtree/ASTJavacodeBody.java
    rm generated/org/javacc/jjtree/ASTNodeDescriptor.java
    rm generated/org/javacc/jjtree/ASTNodeDescriptorExpression.java
    rm generated/org/javacc/jjtree/ASTOptionBinding.java
    rm generated/org/javacc/jjtree/ASTOptions.java
    rm generated/org/javacc/jjtree/JJTreeParserVisitor.java
    rm generated/org/javacc/jjtree/Token.java

Forwarded: not-needed
---
 .../org/javacc/jjtree/ASTBNFAssignment.java   |   20 +
 generated/org/javacc/jjtree/ASTBNFChoice.java |   20 +
 .../org/javacc/jjtree/ASTBNFLookahead.java    |   20 +
 .../org/javacc/jjtree/ASTBNFNonTerminal.java  |   20 +
 .../org/javacc/jjtree/ASTBNFOneOrMore.java    |   20 +
 .../javacc/jjtree/ASTBNFParenthesized.java    |   20 +
 .../org/javacc/jjtree/ASTBNFSequence.java     |   20 +
 .../org/javacc/jjtree/ASTBNFTryBlock.java     |   20 +
 .../org/javacc/jjtree/ASTBNFZeroOrMore.java   |   20 +
 .../org/javacc/jjtree/ASTBNFZeroOrOne.java    |   20 +
 .../org/javacc/jjtree/ASTCharDescriptor.java  |   20 +
 .../javacc/jjtree/ASTPrimaryExpression.java   |   20 +
 .../org/javacc/jjtree/ASTProductions.java     |   20 +
 generated/org/javacc/jjtree/ASTRE.java        |   20 +
 .../org/javacc/jjtree/ASTRECharList.java      |   20 +
 generated/org/javacc/jjtree/ASTREChoice.java  |   20 +
 generated/org/javacc/jjtree/ASTREEOF.java     |   20 +
 generated/org/javacc/jjtree/ASTRENamed.java   |   20 +
 .../org/javacc/jjtree/ASTREOneOrMore.java     |   20 +
 .../org/javacc/jjtree/ASTREParenthesized.java |   20 +
 .../org/javacc/jjtree/ASTREReference.java     |   20 +
 .../org/javacc/jjtree/ASTRESequence.java      |   20 +
 generated/org/javacc/jjtree/ASTRESpec.java    |   20 +
 .../org/javacc/jjtree/ASTREStringLiteral.java |   20 +
 .../org/javacc/jjtree/ASTREZeroOrMore.java    |   20 +
 .../org/javacc/jjtree/ASTREZeroOrOne.java     |   20 +
 .../javacc/jjtree/ASTRRepetitionRange.java    |   20 +
 .../org/javacc/jjtree/ASTTokenDecls.java      |   20 +
 .../javacc/jjtree/JJTJJTreeParserState.java   |  123 +
 generated/org/javacc/jjtree/JJTree.jj         | 3943 +++++++
 generated/org/javacc/jjtree/JJTreeParser.java | 9674 +++++++++++++++++
 .../javacc/jjtree/JJTreeParserConstants.java  |  414 +
 .../jjtree/JJTreeParserTokenManager.java      | 2456 +++++
 .../jjtree/JJTreeParserTreeConstants.java     |   95 +
 .../org/javacc/jjtree/JavaCharStream.java     |  616 ++
 generated/org/javacc/jjtree/Node.java         |   38 +
 .../org/javacc/jjtree/ParseException.java     |  198 +
 generated/org/javacc/jjtree/SimpleNode.java   |   92 +
 .../org/javacc/jjtree/TokenMgrError.java      |  140 +
 generated/org/javacc/parser/JavaCCParser.java | 9468 ++++++++++++++++
 .../javacc/parser/JavaCCParserConstants.java  |  451 +
 .../parser/JavaCCParserTokenManager.java      | 2723 +++++
 .../org/javacc/parser/JavaCharStream.java     |  621 ++
 .../org/javacc/parser/ParseException.java     |  203 +
 .../org/javacc/parser/TokenMgrError.java      |  145 +
 .../org/javacc/utils/ConditionParser.java     |  361 +
 .../utils/ConditionParserConstants.java       |   77 +
 .../utils/ConditionParserTokenManager.java    |  771 ++
 .../org/javacc/utils/JavaCharStream.java      |  616 ++
 .../org/javacc/utils/ParseException.java      |  198 +
 generated/org/javacc/utils/Token.java         |  124 +
 generated/org/javacc/utils/TokenMgrError.java |  140 +
 52 files changed, 34247 insertions(+)
 create mode 100644 generated/org/javacc/jjtree/ASTBNFAssignment.java
 create mode 100644 generated/org/javacc/jjtree/ASTBNFChoice.java
 create mode 100644 generated/org/javacc/jjtree/ASTBNFLookahead.java
 create mode 100644 generated/org/javacc/jjtree/ASTBNFNonTerminal.java
 create mode 100644 generated/org/javacc/jjtree/ASTBNFOneOrMore.java
 create mode 100644 generated/org/javacc/jjtree/ASTBNFParenthesized.java
 create mode 100644 generated/org/javacc/jjtree/ASTBNFSequence.java
 create mode 100644 generated/org/javacc/jjtree/ASTBNFTryBlock.java
 create mode 100644 generated/org/javacc/jjtree/ASTBNFZeroOrMore.java
 create mode 100644 generated/org/javacc/jjtree/ASTBNFZeroOrOne.java
 create mode 100644 generated/org/javacc/jjtree/ASTCharDescriptor.java
 create mode 100644 generated/org/javacc/jjtree/ASTPrimaryExpression.java
 create mode 100644 generated/org/javacc/jjtree/ASTProductions.java
 create mode 100644 generated/org/javacc/jjtree/ASTRE.java
 create mode 100644 generated/org/javacc/jjtree/ASTRECharList.java
 create mode 100644 generated/org/javacc/jjtree/ASTREChoice.java
 create mode 100644 generated/org/javacc/jjtree/ASTREEOF.java
 create mode 100644 generated/org/javacc/jjtree/ASTRENamed.java
 create mode 100644 generated/org/javacc/jjtree/ASTREOneOrMore.java
 create mode 100644 generated/org/javacc/jjtree/ASTREParenthesized.java
 create mode 100644 generated/org/javacc/jjtree/ASTREReference.java
 create mode 100644 generated/org/javacc/jjtree/ASTRESequence.java
 create mode 100644 generated/org/javacc/jjtree/ASTRESpec.java
 create mode 100644 generated/org/javacc/jjtree/ASTREStringLiteral.java
 create mode 100644 generated/org/javacc/jjtree/ASTREZeroOrMore.java
 create mode 100644 generated/org/javacc/jjtree/ASTREZeroOrOne.java
 create mode 100644 generated/org/javacc/jjtree/ASTRRepetitionRange.java
 create mode 100644 generated/org/javacc/jjtree/ASTTokenDecls.java
 create mode 100644 generated/org/javacc/jjtree/JJTJJTreeParserState.java
 create mode 100644 generated/org/javacc/jjtree/JJTree.jj
 create mode 100644 generated/org/javacc/jjtree/JJTreeParser.java
 create mode 100644 generated/org/javacc/jjtree/JJTreeParserConstants.java
 create mode 100644 generated/org/javacc/jjtree/JJTreeParserTokenManager.java
 create mode 100644 generated/org/javacc/jjtree/JJTreeParserTreeConstants.java
 create mode 100644 generated/org/javacc/jjtree/JavaCharStream.java
 create mode 100644 generated/org/javacc/jjtree/Node.java
 create mode 100644 generated/org/javacc/jjtree/ParseException.java
 create mode 100644 generated/org/javacc/jjtree/SimpleNode.java
 create mode 100644 generated/org/javacc/jjtree/TokenMgrError.java
 create mode 100644 generated/org/javacc/parser/JavaCCParser.java
 create mode 100644 generated/org/javacc/parser/JavaCCParserConstants.java
 create mode 100644 generated/org/javacc/parser/JavaCCParserTokenManager.java
 create mode 100644 generated/org/javacc/parser/JavaCharStream.java
 create mode 100644 generated/org/javacc/parser/ParseException.java
 create mode 100644 generated/org/javacc/parser/TokenMgrError.java
 create mode 100644 generated/org/javacc/utils/ConditionParser.java
 create mode 100644 generated/org/javacc/utils/ConditionParserConstants.java
 create mode 100644 generated/org/javacc/utils/ConditionParserTokenManager.java
 create mode 100644 generated/org/javacc/utils/JavaCharStream.java
 create mode 100644 generated/org/javacc/utils/ParseException.java
 create mode 100644 generated/org/javacc/utils/Token.java
 create mode 100644 generated/org/javacc/utils/TokenMgrError.java

diff --git a/generated/org/javacc/jjtree/ASTBNFAssignment.java b/generated/org/javacc/jjtree/ASTBNFAssignment.java
new file mode 100644
index 00000000..548e2c97
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTBNFAssignment.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTBNFAssignment.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTBNFAssignment extends JJTreeNode{
+  public ASTBNFAssignment(int id) {
+    super(id);
+  }
+
+  public ASTBNFAssignment(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=9e2c114ef6bd0cc567a838484e6b3e71 (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ASTBNFChoice.java b/generated/org/javacc/jjtree/ASTBNFChoice.java
new file mode 100644
index 00000000..1e5593b2
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTBNFChoice.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTBNFChoice.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTBNFChoice extends JJTreeNode{
+  public ASTBNFChoice(int id) {
+    super(id);
+  }
+
+  public ASTBNFChoice(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=052caf317c5dbcba3fc5527be8c521ba (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ASTBNFLookahead.java b/generated/org/javacc/jjtree/ASTBNFLookahead.java
new file mode 100644
index 00000000..009512ad
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTBNFLookahead.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTBNFLookahead.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTBNFLookahead extends JJTreeNode{
+  public ASTBNFLookahead(int id) {
+    super(id);
+  }
+
+  public ASTBNFLookahead(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=3505f2519108679b2bd0f13ad60386d8 (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ASTBNFNonTerminal.java b/generated/org/javacc/jjtree/ASTBNFNonTerminal.java
new file mode 100644
index 00000000..b94d2fe4
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTBNFNonTerminal.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTBNFNonTerminal.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTBNFNonTerminal extends JJTreeNode{
+  public ASTBNFNonTerminal(int id) {
+    super(id);
+  }
+
+  public ASTBNFNonTerminal(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=a533c768890ba216ba639b0d042aa586 (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ASTBNFOneOrMore.java b/generated/org/javacc/jjtree/ASTBNFOneOrMore.java
new file mode 100644
index 00000000..96ed158d
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTBNFOneOrMore.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTBNFOneOrMore.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTBNFOneOrMore extends JJTreeNode{
+  public ASTBNFOneOrMore(int id) {
+    super(id);
+  }
+
+  public ASTBNFOneOrMore(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=7f86baee0698ad85aef0406a45085a17 (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ASTBNFParenthesized.java b/generated/org/javacc/jjtree/ASTBNFParenthesized.java
new file mode 100644
index 00000000..8385fd77
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTBNFParenthesized.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTBNFParenthesized.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTBNFParenthesized extends JJTreeNode{
+  public ASTBNFParenthesized(int id) {
+    super(id);
+  }
+
+  public ASTBNFParenthesized(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=5b26f7acfb1ded38c0769661542dc85d (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ASTBNFSequence.java b/generated/org/javacc/jjtree/ASTBNFSequence.java
new file mode 100644
index 00000000..36315e33
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTBNFSequence.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTBNFSequence.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTBNFSequence extends JJTreeNode{
+  public ASTBNFSequence(int id) {
+    super(id);
+  }
+
+  public ASTBNFSequence(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=bfb704e59ed3d42bae5342413c2fdd49 (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ASTBNFTryBlock.java b/generated/org/javacc/jjtree/ASTBNFTryBlock.java
new file mode 100644
index 00000000..52d285e7
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTBNFTryBlock.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTBNFTryBlock.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTBNFTryBlock extends JJTreeNode{
+  public ASTBNFTryBlock(int id) {
+    super(id);
+  }
+
+  public ASTBNFTryBlock(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=d21ffab193632f97de92a8956dd20fdd (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ASTBNFZeroOrMore.java b/generated/org/javacc/jjtree/ASTBNFZeroOrMore.java
new file mode 100644
index 00000000..4db16ee0
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTBNFZeroOrMore.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTBNFZeroOrMore.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTBNFZeroOrMore extends JJTreeNode{
+  public ASTBNFZeroOrMore(int id) {
+    super(id);
+  }
+
+  public ASTBNFZeroOrMore(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=546ee267d3fb68a46c1903eba27578f5 (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ASTBNFZeroOrOne.java b/generated/org/javacc/jjtree/ASTBNFZeroOrOne.java
new file mode 100644
index 00000000..8d7ac1bc
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTBNFZeroOrOne.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTBNFZeroOrOne.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTBNFZeroOrOne extends JJTreeNode{
+  public ASTBNFZeroOrOne(int id) {
+    super(id);
+  }
+
+  public ASTBNFZeroOrOne(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=95bf97d8a859496ced55422e46d24dcc (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ASTCharDescriptor.java b/generated/org/javacc/jjtree/ASTCharDescriptor.java
new file mode 100644
index 00000000..e1a58c40
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTCharDescriptor.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTCharDescriptor.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTCharDescriptor extends JJTreeNode{
+  public ASTCharDescriptor(int id) {
+    super(id);
+  }
+
+  public ASTCharDescriptor(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=caa87bfaa4c0977389440998ccd2bf59 (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ASTPrimaryExpression.java b/generated/org/javacc/jjtree/ASTPrimaryExpression.java
new file mode 100644
index 00000000..4ce60c31
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTPrimaryExpression.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTPrimaryExpression.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTPrimaryExpression extends JJTreeNode{
+  public ASTPrimaryExpression(int id) {
+    super(id);
+  }
+
+  public ASTPrimaryExpression(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=5f967e9bf70d30209a140d5ae9e9e3b2 (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ASTProductions.java b/generated/org/javacc/jjtree/ASTProductions.java
new file mode 100644
index 00000000..b347982a
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTProductions.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTProductions.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTProductions extends JJTreeNode{
+  public ASTProductions(int id) {
+    super(id);
+  }
+
+  public ASTProductions(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=399a573fc8a72f2bc29114225dda1f42 (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ASTRE.java b/generated/org/javacc/jjtree/ASTRE.java
new file mode 100644
index 00000000..6b553472
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTRE.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTRE.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTRE extends JJTreeNode{
+  public ASTRE(int id) {
+    super(id);
+  }
+
+  public ASTRE(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=680176e0d824df7cf4420960f7e7e335 (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ASTRECharList.java b/generated/org/javacc/jjtree/ASTRECharList.java
new file mode 100644
index 00000000..8b78beba
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTRECharList.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTRECharList.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTRECharList extends JJTreeNode{
+  public ASTRECharList(int id) {
+    super(id);
+  }
+
+  public ASTRECharList(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=53244a46b338e5633121747716afc4f3 (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ASTREChoice.java b/generated/org/javacc/jjtree/ASTREChoice.java
new file mode 100644
index 00000000..7a4aa4ad
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTREChoice.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTREChoice.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTREChoice extends JJTreeNode{
+  public ASTREChoice(int id) {
+    super(id);
+  }
+
+  public ASTREChoice(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=523743eec7f2ae16e8135511eb77c2b9 (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ASTREEOF.java b/generated/org/javacc/jjtree/ASTREEOF.java
new file mode 100644
index 00000000..8189a093
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTREEOF.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTREEOF.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTREEOF extends JJTreeNode{
+  public ASTREEOF(int id) {
+    super(id);
+  }
+
+  public ASTREEOF(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=7ab3d6030062519cb080b48d2fd819e8 (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ASTRENamed.java b/generated/org/javacc/jjtree/ASTRENamed.java
new file mode 100644
index 00000000..424f2a00
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTRENamed.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTRENamed.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTRENamed extends JJTreeNode{
+  public ASTRENamed(int id) {
+    super(id);
+  }
+
+  public ASTRENamed(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=78d15ab72d40375c8c1c9a6ff12cbf60 (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ASTREOneOrMore.java b/generated/org/javacc/jjtree/ASTREOneOrMore.java
new file mode 100644
index 00000000..238dc1c9
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTREOneOrMore.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTREOneOrMore.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTREOneOrMore extends JJTreeNode{
+  public ASTREOneOrMore(int id) {
+    super(id);
+  }
+
+  public ASTREOneOrMore(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=c3d37cb3446c7e5f2cc9243ba32db115 (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ASTREParenthesized.java b/generated/org/javacc/jjtree/ASTREParenthesized.java
new file mode 100644
index 00000000..39e4dc9a
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTREParenthesized.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTREParenthesized.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTREParenthesized extends JJTreeNode{
+  public ASTREParenthesized(int id) {
+    super(id);
+  }
+
+  public ASTREParenthesized(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=348f595f433cd9385a8d2d2b7557e9a6 (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ASTREReference.java b/generated/org/javacc/jjtree/ASTREReference.java
new file mode 100644
index 00000000..39d93d84
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTREReference.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTREReference.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTREReference extends JJTreeNode{
+  public ASTREReference(int id) {
+    super(id);
+  }
+
+  public ASTREReference(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=6b0035f242d2da5a694fbfc5afed4704 (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ASTRESequence.java b/generated/org/javacc/jjtree/ASTRESequence.java
new file mode 100644
index 00000000..81750783
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTRESequence.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTRESequence.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTRESequence extends JJTreeNode{
+  public ASTRESequence(int id) {
+    super(id);
+  }
+
+  public ASTRESequence(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=a525f44f9ca18bed753fd493a2e8c1e0 (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ASTRESpec.java b/generated/org/javacc/jjtree/ASTRESpec.java
new file mode 100644
index 00000000..74acbd47
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTRESpec.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTRESpec.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTRESpec extends JJTreeNode{
+  public ASTRESpec(int id) {
+    super(id);
+  }
+
+  public ASTRESpec(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=43ed571dfed6d58c5f347bce42ed80ba (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ASTREStringLiteral.java b/generated/org/javacc/jjtree/ASTREStringLiteral.java
new file mode 100644
index 00000000..dc63b564
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTREStringLiteral.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTREStringLiteral.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTREStringLiteral extends JJTreeNode{
+  public ASTREStringLiteral(int id) {
+    super(id);
+  }
+
+  public ASTREStringLiteral(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=4d20e188a97828e0797fb0817b1d2044 (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ASTREZeroOrMore.java b/generated/org/javacc/jjtree/ASTREZeroOrMore.java
new file mode 100644
index 00000000..08f965f8
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTREZeroOrMore.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTREZeroOrMore.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTREZeroOrMore extends JJTreeNode{
+  public ASTREZeroOrMore(int id) {
+    super(id);
+  }
+
+  public ASTREZeroOrMore(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=fa3e9a267c8afbd0ba6696fdd9f03d32 (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ASTREZeroOrOne.java b/generated/org/javacc/jjtree/ASTREZeroOrOne.java
new file mode 100644
index 00000000..37d44191
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTREZeroOrOne.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTREZeroOrOne.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTREZeroOrOne extends JJTreeNode{
+  public ASTREZeroOrOne(int id) {
+    super(id);
+  }
+
+  public ASTREZeroOrOne(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=7a82043bf29ef56f3304163eb8dbef57 (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ASTRRepetitionRange.java b/generated/org/javacc/jjtree/ASTRRepetitionRange.java
new file mode 100644
index 00000000..ab585a2b
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTRRepetitionRange.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTRRepetitionRange.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTRRepetitionRange extends JJTreeNode{
+  public ASTRRepetitionRange(int id) {
+    super(id);
+  }
+
+  public ASTRRepetitionRange(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=2781035a62114c91f0bbef62a272a717 (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ASTTokenDecls.java b/generated/org/javacc/jjtree/ASTTokenDecls.java
new file mode 100644
index 00000000..5ba16528
--- /dev/null
+++ b/generated/org/javacc/jjtree/ASTTokenDecls.java
@@ -0,0 +1,20 @@
+/* Generated By:JJTree: Do not edit this line. ASTTokenDecls.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class ASTTokenDecls extends JJTreeNode{
+  public ASTTokenDecls(int id) {
+    super(id);
+  }
+
+  public ASTTokenDecls(JJTreeParser p, int id) {
+    super(p, id);
+  }
+
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+}
+/* JavaCC - OriginalChecksum=37956bbc162702bf5bf5818fd9e20ebc (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/JJTJJTreeParserState.java b/generated/org/javacc/jjtree/JJTJJTreeParserState.java
new file mode 100644
index 00000000..387c99aa
--- /dev/null
+++ b/generated/org/javacc/jjtree/JJTJJTreeParserState.java
@@ -0,0 +1,123 @@
+/* Generated By:JavaCC: Do not edit this line. JJTJJTreeParserState.java Version 4.1d1 */
+package org.javacc.jjtree;
+
+public class JJTJJTreeParserState {
+  private java.util.List nodes;
+  private java.util.List marks;
+
+  private int sp;        // number of nodes on stack
+  private int mk;        // current mark
+  private boolean node_created;
+
+  public JJTJJTreeParserState() {
+    nodes = new java.util.ArrayList();
+    marks = new java.util.ArrayList();
+    sp = 0;
+    mk = 0;
+  }
+
+  /* Determines whether the current node was actually closed and
+     pushed.  This should only be called in the final user action of a
+     node scope.  */
+  public boolean nodeCreated() {
+    return node_created;
+  }
+
+  /* Call this to reinitialize the node stack.  It is called
+     automatically by the parser's ReInit() method. */
+  public void reset() {
+    nodes.clear();
+    marks.clear();
+    sp = 0;
+    mk = 0;
+  }
+
+  /* Returns the root node of the AST.  It only makes sense to call
+     this after a successful parse. */
+  public Node rootNode() {
+    return (Node)nodes.get(0);
+  }
+
+  /* Pushes a node on to the stack. */
+  public void pushNode(Node n) {
+    nodes.add(n);
+    ++sp;
+  }
+
+  /* Returns the node on the top of the stack, and remove it from the
+     stack.  */
+  public Node popNode() {
+    if (--sp < mk) {
+      mk = ((Integer)marks.remove(marks.size()-1)).intValue();
+    }
+    return (Node)nodes.remove(nodes.size()-1);
+  }
+
+  /* Returns the node currently on the top of the stack. */
+  public Node peekNode() {
+    return (Node)nodes.get(nodes.size()-1);
+  }
+
+  /* Returns the number of children on the stack in the current node
+     scope. */
+  public int nodeArity() {
+    return sp - mk;
+  }
+
+
+  public void clearNodeScope(Node n) {
+    while (sp > mk) {
+      popNode();
+    }
+    mk = ((Integer)marks.remove(marks.size()-1)).intValue();
+  }
+
+
+  public void openNodeScope(Node n) {
+    marks.add(new Integer(mk));
+    mk = sp;
+    n.jjtOpen();
+  }
+
+
+  /* A definite node is constructed from a specified number of
+     children.  That number of nodes are popped from the stack and
+     made the children of the definite node.  Then the definite node
+     is pushed on to the stack. */
+  public void closeNodeScope(Node n, int num) {
+    mk = ((Integer)marks.remove(marks.size()-1)).intValue();
+    while (num-- > 0) {
+      Node c = popNode();
+      c.jjtSetParent(n);
+      n.jjtAddChild(c, num);
+    }
+    n.jjtClose();
+    pushNode(n);
+    node_created = true;
+  }
+
+
+  /* A conditional node is constructed if its condition is true.  All
+     the nodes that have been pushed since the node was opened are
+     made children of the conditional node, which is then pushed
+     on to the stack.  If the condition is false the node is not
+     constructed and they are left on the stack. */
+  public void closeNodeScope(Node n, boolean condition) {
+    if (condition) {
+      int a = nodeArity();
+      mk = ((Integer)marks.remove(marks.size()-1)).intValue();
+      while (a-- > 0) {
+        Node c = popNode();
+        c.jjtSetParent(n);
+        n.jjtAddChild(c, a);
+      }
+      n.jjtClose();
+      pushNode(n);
+      node_created = true;
+    } else {
+      mk = ((Integer)marks.remove(marks.size()-1)).intValue();
+      node_created = false;
+    }
+  }
+}
+/* JavaCC - OriginalChecksum=9103b1d5887ce3d619703abeeb59f8fe (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/JJTree.jj b/generated/org/javacc/jjtree/JJTree.jj
new file mode 100644
index 00000000..d7294079
--- /dev/null
+++ b/generated/org/javacc/jjtree/JJTree.jj
@@ -0,0 +1,3943 @@
+/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. generated/org/javacc/jjtree/JJTree.jj */
+/*@egen*//* Copyright (c) 2006, Sun Microsystems, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *     * Redistributions of source code must retain the above copyright notice,
+ *       this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the Sun Microsystems, Inc. nor the names of its
+ *       contributors may be used to endorse or promote products derived from
+ *       this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+options {
+               
+                           
+                       
+  JAVA_UNICODE_ESCAPE = true;
+  STATIC = false;
+                            
+                 
+}
+
+PARSER_BEGIN(JJTreeParser)
+
+package org.javacc.jjtree;
+
+public class JJTreeParser/*@bgen(jjtree)*/implements JJTreeParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
+  protected JJTJJTreeParserState jjtree = new JJTJJTreeParserState();
+
+/*@egen*/
+
+  void jjtreeOpenNodeScope(Node n)
+  {
+	((JJTreeNode)n).setFirstToken(getToken(1));
+  }
+
+  void jjtreeCloseNodeScope(Node n)
+  {
+	((JJTreeNode)n).setLastToken(getToken(0));
+  }
+
+
+  /**
+   * Returns true if the next token is not in the FOLLOW list of "expansion".
+   * It is used to decide when the end of an "expansion" has been reached.
+   */
+  private boolean notTailOfExpansionUnit() {
+    Token t;
+    t = getToken(1);
+    if (t.kind == BIT_OR || t.kind == COMMA || t.kind == RPAREN || t.kind == RBRACE || t.kind == RBRACKET) return false;
+    return true;
+  }
+
+  protected boolean isJavaLanguage = true;
+
+  private void eatUptoCloseBrace() {
+    int b = 1;
+    while(getToken(1).kind != RBRACE || --b != 0) {
+      if (getToken(1).kind == EOF) break;
+      if (getNextToken().kind == LBRACE) b++;
+    }
+  }
+
+}
+
+PARSER_END(JJTreeParser)
+
+
+/**********************************************
+ * THE JAVACC TOKEN SPECIFICATION STARTS HERE *
+ **********************************************/
+
+/* JAVACC RESERVED WORDS: These are the only tokens in JavaCC but not in Java */
+
+TOKEN :
+{
+//  Options is no longer a reserved word (Issue 126)
+//  < _OPTIONS: "options" >
+  < _LOOKAHEAD: "LOOKAHEAD" >
+| < _IGNORE_CASE: "IGNORE_CASE" >
+| < _PARSER_BEGIN: "PARSER_BEGIN" >
+| < _PARSER_END: "PARSER_END" >
+| < _JAVACODE: "JAVACODE" >
+| < _TOKEN: "TOKEN" >
+| < _SPECIAL_TOKEN: "SPECIAL_TOKEN" >
+| < _MORE: "MORE" >
+| < _SKIP: "SKIP" >
+| < _TOKEN_MGR_DECLS: "TOKEN_MGR_DECLS" >
+| < _EOF: "EOF" >
+}
+
+/*
+ * The remainder of the tokens are exactly (except for the removal of tokens
+ * containing ">>" and "<<") as in the Java grammar and must be diff equivalent
+ * (again with the exceptions above) to it.
+ */
+
+/* WHITE SPACE */
+
+SPECIAL_TOKEN :
+{
+  " "
+| "\t"
+| "\n"
+| "\r"
+| "\f"
+}
+
+/* COMMENTS */
+
+MORE :
+{
+  "//" : IN_SINGLE_LINE_COMMENT
+|
+  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
+|
+  "/*" : IN_MULTI_LINE_COMMENT
+}
+
+
+<IN_SINGLE_LINE_COMMENT>
+SPECIAL_TOKEN :
+{
+  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
+}
+
+<IN_FORMAL_COMMENT>
+SPECIAL_TOKEN :
+{
+  <FORMAL_COMMENT: "*/" > : DEFAULT
+}
+
+<IN_MULTI_LINE_COMMENT>
+SPECIAL_TOKEN :
+{
+  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
+}
+
+<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
+MORE :
+{
+  < ~[] >
+}
+
+/* JAVA RESERVED WORDS AND LITERALS */
+
+TOKEN :
+{
+  < ABSTRACT: "abstract" >
+| < BOOLEAN: "boolean" >
+| < BREAK: "break" >
+| < BYTE: "byte" >
+| < CASE: "case" >
+| < CATCH: "catch" >
+| < CHAR: "char" >
+| < CLASS: "class" >
+| < CONST: "const" >
+| < CONTINUE: "continue" >
+| < _DEFAULT: "default" >
+| < DO: "do" >
+| < DOUBLE: "double" >
+| < ELSE: "else" >
+| < EXTENDS: "extends" >
+| < FALSE: "false" >
+| < FINAL: "final" >
+| < FINALLY: "finally" >
+| < FLOAT: "float" >
+| < FOR: "for" >
+| < GOTO: "goto" >
+| < IF: "if" >
+| < IMPLEMENTS: "implements" >
+| < IMPORT: "import" >
+| < INSTANCEOF: "instanceof" >
+| < INT: "int" >
+| < INTERFACE: "interface" >
+| < LONG: "long" >
+| < NATIVE: "native" >
+| < NEW: "new" >
+| < NULL: "null" >
+| < PACKAGE: "package">
+| < PRIVATE: "private" >
+| < PROTECTED: "protected" >
+| < PUBLIC: "public" >
+| < RETURN: "return" >
+| < SHORT: "short" >
+| < STATIC: "static" >
+| < SUPER: "super" >
+| < SWITCH: "switch" >
+| < SYNCHRONIZED: "synchronized" >
+| < THIS: "this" >
+| < THROW: "throw" >
+| < THROWS: "throws" >
+| < TRANSIENT: "transient" >
+| < TRUE: "true" >
+| < TRY: "try" >
+| < VOID: "void" >
+| < VOLATILE: "volatile" >
+| < WHILE: "while" >
+}
+
+/* JAVA LITERALS */
+
+TOKEN :
+{
+  < INTEGER_LITERAL:
+        <DECIMAL_LITERAL> (["l","L"])?
+      | <HEX_LITERAL> (["l","L"])?
+      | <OCTAL_LITERAL> (["l","L"])?
+  >
+|
+  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
+|
+  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
+|
+  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
+|
+  < FLOATING_POINT_LITERAL:
+        <DECIMAL_FLOATING_POINT_LITERAL>
+      | <HEXADECIMAL_FLOATING_POINT_LITERAL>
+  >
+|
+  < #DECIMAL_FLOATING_POINT_LITERAL:
+        (["0"-"9"])+ "." (["0"-"9"])* (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?
+      | "." (["0"-"9"])+ (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?
+      | (["0"-"9"])+ <DECIMAL_EXPONENT> (["f","F","d","D"])?
+      | (["0"-"9"])+ (<DECIMAL_EXPONENT>)? ["f","F","d","D"]
+  >
+|
+  < #DECIMAL_EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
+|
+  < #HEXADECIMAL_FLOATING_POINT_LITERAL:
+        "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])+ (".")? <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?
+      | "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])* "." (["0"-"9","a"-"f","A"-"F"])+ <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?
+  >
+|
+  < #HEXADECIMAL_EXPONENT: ["p","P"] (["+","-"])? (["0"-"9"])+ >
+|
+  < CHARACTER_LITERAL:
+      "'"
+      (   (~["'","\\","\n","\r"])
+        | ("\\"
+            ( ["n","t","b","r","f","\\","'","\""]
+            | ["0"-"7"] ( ["0"-"7"] )?
+            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
+            )
+          )
+      )
+      "'"
+  >
+|
+  < STRING_LITERAL:
+      "\""
+      (   (~["\"","\\","\n","\r"])
+        | ("\\"
+            ( ["n","t","b","r","f","\\","'","\""]
+            | ["0"-"7"] ( ["0"-"7"] )?
+            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
+            )
+          )
+      )*
+      "\""
+  >
+}
+
+/* SEPARATORS */
+
+TOKEN :
+{
+  < LPAREN: "(" >
+| < RPAREN: ")" >
+| < LBRACE: "{" >
+| < RBRACE: "}" >
+| < LBRACKET: "[" >
+| < RBRACKET: "]" >
+| < SEMICOLON: ";" >
+| < COMMA: "," >
+| < DOT: "." >
+| < HASH: "#" >
+}
+
+/* OPERATORS */
+
+TOKEN :
+{
+  < ASSIGN: "=" >
+//| < GT: ">" >
+| < LT: "<" >
+| < BANG: "!" >
+| < TILDE: "~" >
+| < HOOK: "?" >
+| < COLON: ":" >
+| < DOUBLECOLON: "::" >
+| < EQ: "==" >
+| < LE: "<=" >
+| < GE: ">=" >
+| < NE: "!=" >
+| < SC_OR: "||" >
+| < SC_AND: "&&" >
+| < INCR: "++" >
+| < DECR: "--" >
+| < PLUS: "+" >
+| < MINUS: "-" >
+| < STAR: "*" >
+| < SLASH: "/" >
+| < BIT_AND: "&" >
+| < BIT_OR: "|" >
+| < XOR: "^" >
+| < REM: "%" >
+//	| < LSHIFT: "<<" >
+//	| < RSIGNEDSHIFT: ">>" >
+//	| < RUNSIGNEDSHIFT: ">>>" >
+| < PLUSASSIGN: "+=" >
+| < MINUSASSIGN: "-=" >
+| < STARASSIGN: "*=" >
+| < SLASHASSIGN: "/=" >
+| < ANDASSIGN: "&=" >
+| < ORASSIGN: "|=" >
+| < XORASSIGN: "^=" >
+| < REMASSIGN: "%=" >
+//	| < LSHIFTASSIGN: "<<=" >
+//	| < RSIGNEDSHIFTASSIGN: ">>=" >
+//	| < RUNSIGNEDSHIFTASSIGN: ">>>=" >
+}
+
+
+/* >'s need special attention due to generics syntax. */
+TOKEN :
+{
+  < RUNSIGNEDSHIFT: ">>>" >
+  {
+     matchedToken.kind = GT;
+     ((Token.GTToken)matchedToken).realKind = RUNSIGNEDSHIFT;
+     input_stream.backup(2);
+     matchedToken.image = ">";
+  }
+| < RSIGNEDSHIFT: ">>" >
+  {
+     matchedToken.kind = GT;
+     ((Token.GTToken)matchedToken).realKind = RSIGNEDSHIFT;
+     input_stream.backup(1);
+     matchedToken.image = ">";
+  }
+| < GT: ">" >
+}
+
+
+/************************************************
+ * THE JAVACC GRAMMAR SPECIFICATION STARTS HERE *
+ ************************************************/
+
+void javacc_input()          :
+	{/*@bgen(jjtree) Grammar */
+          ASTGrammar jjtn000 = new ASTGrammar(JJTGRAMMAR);
+          boolean jjtc000 = true;
+          jjtree.openNodeScope(jjtn000);
+          jjtreeOpenNodeScope(jjtn000);
+/*@egen*/
+	  Token t;
+	}
+{/*@bgen(jjtree) Grammar */
+  try {
+/*@egen*/
+  javacc_options()
+  {
+    // TODO :: CBA --  Require Unification of output language specific processing into a single Enum class
+    isJavaLanguage = JJTreeOptions.isOutputLanguageJava();
+  }/*@bgen(jjtree) #CompilationUnit( true) */
+  {
+    ASTCompilationUnit jjtn001 = new ASTCompilationUnit(JJTCOMPILATIONUNIT);
+    boolean jjtc001 = true;
+    jjtree.openNodeScope(jjtn001);
+    jjtreeOpenNodeScope(jjtn001);
+  }
+  try {
+/*@egen*/
+  (
+    "PARSER_BEGIN" "(" t=identifier() ")"
+	{
+	  JJTreeGlobals.parserName = t.image;
+
+          if (!isJavaLanguage) {
+            while(getToken(1).kind != _PARSER_END) {
+              getNextToken();
+            }
+          }
+	}
+    CompilationUnit()
+    "PARSER_END" "(" identifier() ")"/*@bgen(jjtree)*/
+        {
+          jjtree.closeNodeScope(jjtn001,  true);
+          jjtc001 = false;
+          jjtreeCloseNodeScope(jjtn001);
+        }
+/*@egen*/
+	{
+	  if (JJTreeOptions.getNodePackage().equals("")) {
+	    JJTreeGlobals.nodePackageName = JJTreeGlobals.packageName;
+	  } else {
+	    JJTreeGlobals.nodePackageName = JJTreeOptions.getNodePackage();
+	  }
+	}
+  )/*@bgen(jjtree)*/
+  } catch (Throwable jjte001) {
+    if (jjtc001) {
+      jjtree.clearNodeScope(jjtn001);
+      jjtc001 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte001 instanceof RuntimeException) {
+      throw (RuntimeException)jjte001;
+    }
+    if (jjte001 instanceof ParseException) {
+      throw (ParseException)jjte001;
+    }
+    throw (Error)jjte001;
+  } finally {
+    if (jjtc001) {
+      jjtree.closeNodeScope(jjtn001,  true);
+      jjtreeCloseNodeScope(jjtn001);
+    }
+  }
+/*@egen*/                       /*@bgen(jjtree) Productions */
+  {
+    ASTProductions jjtn002 = new ASTProductions(JJTPRODUCTIONS);
+    boolean jjtc002 = true;
+    jjtree.openNodeScope(jjtn002);
+    jjtreeOpenNodeScope(jjtn002);
+  }
+  try {
+/*@egen*/
+  (
+    ( production() )+
+  )/*@bgen(jjtree)*/
+  } catch (Throwable jjte002) {
+    if (jjtc002) {
+      jjtree.clearNodeScope(jjtn002);
+      jjtc002 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte002 instanceof RuntimeException) {
+      throw (RuntimeException)jjte002;
+    }
+    if (jjte002 instanceof ParseException) {
+      throw (ParseException)jjte002;
+    }
+    throw (Error)jjte002;
+  } finally {
+    if (jjtc002) {
+      jjtree.closeNodeScope(jjtn002, true);
+      jjtreeCloseNodeScope(jjtn002);
+    }
+  }
+/*@egen*/             
+  <EOF>/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      jjtreeCloseNodeScope(jjtn000);
+    }
+  }
+/*@egen*/
+}
+
+void javacc_options() :
+	{
+	}
+{
+  [ LOOKAHEAD( { getToken(1).image.equals("options") })/*@bgen(jjtree) Options */
+                                                        {
+                                                          ASTOptions jjtn001 = new ASTOptions(JJTOPTIONS);
+                                                          boolean jjtc001 = true;
+                                                          jjtree.openNodeScope(jjtn001);
+                                                          jjtreeOpenNodeScope(jjtn001);
+                                                        }
+                                                        try {
+/*@egen*/ ( <IDENTIFIER> "{" ( option_binding() )* "}" )/*@bgen(jjtree)*/
+                                                        } catch (Throwable jjte001) {
+                                                          if (jjtc001) {
+                                                            jjtree.clearNodeScope(jjtn001);
+                                                            jjtc001 = false;
+                                                          } else {
+                                                            jjtree.popNode();
+                                                          }
+                                                          if (jjte001 instanceof RuntimeException) {
+                                                            throw (RuntimeException)jjte001;
+                                                          }
+                                                          if (jjte001 instanceof ParseException) {
+                                                            throw (ParseException)jjte001;
+                                                          }
+                                                          throw (Error)jjte001;
+                                                        } finally {
+                                                          if (jjtc001) {
+                                                            jjtree.closeNodeScope(jjtn001, true);
+                                                            jjtreeCloseNodeScope(jjtn001);
+                                                          }
+                                                        }
+/*@egen*/          ]
+	{
+	  JJTreeOptions.normalize();
+	}
+}
+
+void option_binding()                :
+	{/*@bgen(jjtree) OptionBinding */
+          ASTOptionBinding jjtn000 = new ASTOptionBinding(JJTOPTIONBINDING);
+          boolean jjtc000 = true;
+          jjtree.openNodeScope(jjtn000);
+          jjtreeOpenNodeScope(jjtn000);
+/*@egen*/
+	  Token o, v;
+	}
+{/*@bgen(jjtree) OptionBinding */
+  try {
+/*@egen*/
+  ( o=<IDENTIFIER> | o="LOOKAHEAD" | o="IGNORE_CASE" | o="static" )
+  "="
+  (
+     v=IntegerLiteral()
+        {
+	  JJTreeOptions.setInputFileOption(o, v, o.image, Integer.valueOf(v.image));
+	  jjtn000.initialize(o.image, v.image);
+	}
+   | v=BooleanLiteral()
+        {
+	  JJTreeOptions.setInputFileOption(o, v, o.image,
+				     Boolean.valueOf(v.image));
+	  jjtn000.initialize(o.image, v.image);
+	}
+   | v=StringLiteral()
+        {	
+	  String vs = TokenUtils.remove_escapes_and_quotes(v, v.image);
+	  JJTreeOptions.setInputFileOption(o, v, o.image, (Object)vs);
+	  jjtn000.initialize(o.image, vs);
+	}
+  ) ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      jjtreeCloseNodeScope(jjtn000);
+    }
+  }
+/*@egen*/
+}
+
+void production() :
+	{
+	}
+{
+  LOOKAHEAD(1)
+  /*
+   * Since JAVACODE is both a JavaCC reserved word and a Java identifier,
+   * we need to give preference to "javacode_production" over
+   * "bnf_production".
+   */
+  javacode_production()
+|
+  LOOKAHEAD(1)
+  /*
+   * Since SKIP, TOKEN, etc. are both JavaCC reserved words and Java
+   * identifiers, we need to give preference to "regular_expression_production"
+   * over "bnf_production".
+   */
+  regular_expr_production()
+|
+  LOOKAHEAD(1)
+  /*
+   * Since TOKEN_MGR_DECLS is both a JavaCC reserved word and a Java identifier,
+   * we need to give preference to "token_manager_decls" over
+   * "bnf_production".
+   */
+  token_manager_decls()
+|
+  bnf_production()
+}
+
+void javacode_production()           :
+	{/*@bgen(jjtree) Javacode */
+          ASTJavacode jjtn000 = new ASTJavacode(JJTJAVACODE);
+          boolean jjtc000 = true;
+          jjtree.openNodeScope(jjtn000);
+          jjtreeOpenNodeScope(jjtn000);
+/*@egen*/
+	  Token t1, t2;
+	  ASTJavacode prod;
+	  ASTNodeDescriptor nd = null;
+	  String n;
+	}
+{/*@bgen(jjtree) Javacode */
+        try {
+/*@egen*/
+        {
+	  prod = jjtn000;
+	}
+  "JAVACODE"
+  AccessModifier() ResultType() t1=identifier() FormalParameters()
+  {
+    if (!isJavaLanguage) {
+      while(getToken(1).kind != LBRACE) {
+        getNextToken();
+      }
+    }
+  }
+    [
+      "throws" n=Name()
+	{
+	  prod.throws_list.addElement(n);
+	}
+      ( "," n=Name()
+	{
+	  prod.throws_list.addElement(n);
+	}
+      )*
+    ]
+    [ nd=node_descriptor() ]
+
+    // This is really a Block()
+    t2="{"
+        {
+	  prod.name = t1.image;
+	  prod.stmBeginLoc = t2;
+          if (!isJavaLanguage) {
+            eatUptoCloseBrace();
+          }
+	}/*@bgen(jjtree) JavacodeBody */
+    {
+      ASTJavacodeBody jjtn001 = new ASTJavacodeBody(JJTJAVACODEBODY);
+      boolean jjtc001 = true;
+      jjtree.openNodeScope(jjtn001);
+      jjtreeOpenNodeScope(jjtn001);
+    }
+    try {
+/*@egen*/
+    (
+      ( BlockStatement() )*/*@bgen(jjtree)*/
+        {
+          jjtree.closeNodeScope(jjtn001, true);
+          jjtc001 = false;
+          jjtreeCloseNodeScope(jjtn001);
+        }
+/*@egen*/
+        {
+	  jjtn001.node_scope = new NodeScope(prod, nd);
+	}
+    )/*@bgen(jjtree)*/
+    } catch (Throwable jjte001) {
+      if (jjtc001) {
+        jjtree.clearNodeScope(jjtn001);
+        jjtc001 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte001 instanceof RuntimeException) {
+        throw (RuntimeException)jjte001;
+      }
+      if (jjte001 instanceof ParseException) {
+        throw (ParseException)jjte001;
+      }
+      throw (Error)jjte001;
+    } finally {
+      if (jjtc001) {
+        jjtree.closeNodeScope(jjtn001, true);
+        jjtreeCloseNodeScope(jjtn001);
+      }
+    }
+/*@egen*/              
+    "}"/*@bgen(jjtree)*/
+        {
+          jjtree.closeNodeScope(jjtn000, true);
+          jjtc000 = false;
+          jjtreeCloseNodeScope(jjtn000);
+        }
+/*@egen*/
+        {
+	  JJTreeGlobals.productions.put(prod.name, prod);
+	}/*@bgen(jjtree)*/
+        } catch (Throwable jjte000) {
+          if (jjtc000) {
+            jjtree.clearNodeScope(jjtn000);
+            jjtc000 = false;
+          } else {
+            jjtree.popNode();
+          }
+          if (jjte000 instanceof RuntimeException) {
+            throw (RuntimeException)jjte000;
+          }
+          if (jjte000 instanceof ParseException) {
+            throw (ParseException)jjte000;
+          }
+          throw (Error)jjte000;
+        } finally {
+          if (jjtc000) {
+            jjtree.closeNodeScope(jjtn000, true);
+            jjtreeCloseNodeScope(jjtn000);
+          }
+        }
+/*@egen*/
+}
+
+void bnf_production()      :
+	{/*@bgen(jjtree) BNF */
+          ASTBNF jjtn000 = new ASTBNF(JJTBNF);
+          boolean jjtc000 = true;
+          jjtree.openNodeScope(jjtn000);
+          jjtreeOpenNodeScope(jjtn000);
+/*@egen*/
+	  Token t1, t2;
+	  ASTBNF prod;
+	  ASTNodeDescriptor nd = null;
+	  NodeScope ns;
+	  JJTreeNode eu;
+	  String n;
+	}
+{/*@bgen(jjtree) BNF */
+        try {
+/*@egen*/
+        {
+	  prod = jjtn000;
+	}
+  AccessModifier() ResultType() t1=identifier() FormalParameters()
+  /*{
+    if (!isJavaLanguage) {
+      while(getToken(1).kind != LBRACE && getToken(1).kind != HASH) {
+        getNextToken();
+      }
+    }
+  }*/
+  [
+    "throws" n=Name()
+        {
+	  prod.throws_list.addElement(n);
+	}
+    ( "," n=Name()
+        {
+	  prod.throws_list.addElement(n);
+	}
+    )*
+  ]
+  [ nd=node_descriptor() ]
+  ":"
+
+  // This is really a Block()
+  t2="{"
+        {
+	  prod.name = t1.image;
+	  prod.declBeginLoc = t2;
+	  ns = new NodeScope(prod, nd);
+          if (!isJavaLanguage) {
+            eatUptoCloseBrace();
+          }
+	}/*@bgen(jjtree) BNFDeclaration */
+  {
+    ASTBNFDeclaration jjtn001 = new ASTBNFDeclaration(JJTBNFDECLARATION);
+    boolean jjtc001 = true;
+    jjtree.openNodeScope(jjtn001);
+    jjtreeOpenNodeScope(jjtn001);
+  }
+  try {
+/*@egen*/
+  (
+    ( BlockStatement() )*/*@bgen(jjtree)*/
+        {
+          jjtree.closeNodeScope(jjtn001, true);
+          jjtc001 = false;
+          jjtreeCloseNodeScope(jjtn001);
+        }
+/*@egen*/
+        {
+	  jjtn001.node_scope = ns;
+	}
+  )/*@bgen(jjtree)*/
+  } catch (Throwable jjte001) {
+    if (jjtc001) {
+      jjtree.clearNodeScope(jjtn001);
+      jjtc001 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte001 instanceof RuntimeException) {
+      throw (RuntimeException)jjte001;
+    }
+    if (jjte001 instanceof ParseException) {
+      throw (ParseException)jjte001;
+    }
+    throw (Error)jjte001;
+  } finally {
+    if (jjtc001) {
+      jjtree.closeNodeScope(jjtn001, true);
+      jjtreeCloseNodeScope(jjtn001);
+    }
+  }
+/*@egen*/                
+  "}"
+
+  "{"/*@bgen(jjtree) BNFNodeScope */
+  {
+    ASTBNFNodeScope jjtn002 = new ASTBNFNodeScope(JJTBNFNODESCOPE);
+    boolean jjtc002 = true;
+    jjtree.openNodeScope(jjtn002);
+    jjtreeOpenNodeScope(jjtn002);
+  }
+  try {
+/*@egen*/
+  (
+    eu=expansion_choices(prod)/*@bgen(jjtree)*/
+        {
+          jjtree.closeNodeScope(jjtn002, true);
+          jjtc002 = false;
+          jjtreeCloseNodeScope(jjtn002);
+        }
+/*@egen*/
+        {
+	  jjtn002.node_scope = ns;
+	  jjtn002.expansion_unit = eu;
+	}
+  )/*@bgen(jjtree)*/
+  } catch (Throwable jjte002) {
+    if (jjtc002) {
+      jjtree.clearNodeScope(jjtn002);
+      jjtc002 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte002 instanceof RuntimeException) {
+      throw (RuntimeException)jjte002;
+    }
+    if (jjte002 instanceof ParseException) {
+      throw (ParseException)jjte002;
+    }
+    throw (Error)jjte002;
+  } finally {
+    if (jjtc002) {
+      jjtree.closeNodeScope(jjtn002, true);
+      jjtreeCloseNodeScope(jjtn002);
+    }
+  }
+/*@egen*/              
+ "}"/*@bgen(jjtree)*/
+        {
+          jjtree.closeNodeScope(jjtn000, true);
+          jjtc000 = false;
+          jjtreeCloseNodeScope(jjtn000);
+        }
+/*@egen*/
+        {
+	  JJTreeGlobals.productions.put(prod.name, prod);
+	}/*@bgen(jjtree)*/
+        } catch (Throwable jjte000) {
+          if (jjtc000) {
+            jjtree.clearNodeScope(jjtn000);
+            jjtc000 = false;
+          } else {
+            jjtree.popNode();
+          }
+          if (jjte000 instanceof RuntimeException) {
+            throw (RuntimeException)jjte000;
+          }
+          if (jjte000 instanceof ParseException) {
+            throw (ParseException)jjte000;
+          }
+          throw (Error)jjte000;
+        } finally {
+          if (jjtc000) {
+            jjtree.closeNodeScope(jjtn000, true);
+            jjtreeCloseNodeScope(jjtn000);
+          }
+        }
+/*@egen*/
+}
+
+void AccessModifier() :
+{}
+{
+	( "public" | "protected" | "private" )?
+}
+
+void regular_expr_production()     :
+	{/*@bgen(jjtree) RE */
+  ASTRE jjtn000 = new ASTRE(JJTRE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/
+	}
+{/*@bgen(jjtree) RE */
+  try {
+/*@egen*/
+  [
+    LOOKAHEAD(2) "<" "*" ">"
+  |
+    "<" <IDENTIFIER> ( "," <IDENTIFIER> )* ">"
+  ]
+  regexpr_kind() [ "[" "IGNORE_CASE" "]" ] ":"
+  "{" regexpr_spec() ( "|" regexpr_spec() )* "}"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      jjtreeCloseNodeScope(jjtn000);
+    }
+  }
+/*@egen*/
+}
+
+void token_manager_decls()             :
+	{/*@bgen(jjtree) TokenDecls */
+  ASTTokenDecls jjtn000 = new ASTTokenDecls(JJTTOKENDECLS);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/
+	}
+{/*@bgen(jjtree) TokenDecls */
+  try {
+/*@egen*/
+  "TOKEN_MGR_DECLS" ":"
+  {
+    if (!isJavaLanguage) {
+      getNextToken(); // eat { 
+      eatUptoCloseBrace();
+      getNextToken(); // eat } 
+    } 
+  } 
+  [ ClassOrInterfaceBody() ]/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      jjtreeCloseNodeScope(jjtn000);
+    }
+  }
+/*@egen*/
+}
+
+void regexpr_kind() :
+	{
+	}
+{
+  "TOKEN"
+|
+  "SPECIAL_TOKEN"
+|
+  "SKIP"
+|
+  "MORE"
+}
+
+void regexpr_spec()         :
+{/*@bgen(jjtree) RESpec */
+  ASTRESpec jjtn000 = new ASTRESpec(JJTRESPEC);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) RESpec */
+  try {
+/*@egen*/
+  regular_expression()
+  [ Block() ]
+  [ ":" <IDENTIFIER> ]/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      jjtreeCloseNodeScope(jjtn000);
+    }
+  }
+/*@egen*/
+}
+
+JJTreeNode expansion_choices(ASTProduction p)                :
+	{/*@bgen(jjtree) #BNFChoice(> 1) */
+  ASTBNFChoice jjtn000 = new ASTBNFChoice(JJTBNFCHOICE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/
+	}
+{/*@bgen(jjtree) #BNFChoice(> 1) */
+  try {
+/*@egen*/
+  expansion(p) ( "|" expansion(p) )*/*@bgen(jjtree)*/
+        {
+          jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
+          jjtc000 = false;
+          jjtreeCloseNodeScope(jjtn000);
+        }
+/*@egen*/
+        {
+	  return (JJTreeNode)jjtree.peekNode();
+	}/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
+      jjtreeCloseNodeScope(jjtn000);
+    }
+  }
+/*@egen*/
+}
+
+void expansion(ASTProduction p)                  :
+	{/*@bgen(jjtree) #BNFSequence(> 1) */
+          ASTBNFSequence jjtn000 = new ASTBNFSequence(JJTBNFSEQUENCE);
+          boolean jjtc000 = true;
+          jjtree.openNodeScope(jjtn000);
+          jjtreeOpenNodeScope(jjtn000);
+/*@egen*/
+	  JJTreeNode eu;
+	  ASTNodeDescriptor nd = null;
+	}
+{/*@bgen(jjtree) #BNFSequence(> 1) */
+  try {
+/*@egen*/
+  (
+    LOOKAHEAD(1)/*@bgen(jjtree) BNFLookahead */
+    {
+      ASTBNFLookahead jjtn001 = new ASTBNFLookahead(JJTBNFLOOKAHEAD);
+      boolean jjtc001 = true;
+      jjtree.openNodeScope(jjtn001);
+      jjtreeOpenNodeScope(jjtn001);
+    }
+    try {
+/*@egen*/
+    ( "LOOKAHEAD" "(" local_lookahead(p) ")" )/*@bgen(jjtree)*/
+    } catch (Throwable jjte001) {
+      if (jjtc001) {
+        jjtree.clearNodeScope(jjtn001);
+        jjtc001 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte001 instanceof RuntimeException) {
+        throw (RuntimeException)jjte001;
+      }
+      if (jjte001 instanceof ParseException) {
+        throw (ParseException)jjte001;
+      }
+      throw (Error)jjte001;
+    } finally {
+      if (jjtc001) {
+        jjtree.closeNodeScope(jjtn001, true);
+        jjtreeCloseNodeScope(jjtn001);
+      }
+    }
+/*@egen*/              
+  )?
+  (
+   LOOKAHEAD(0, { notTailOfExpansionUnit() } )/*@bgen(jjtree) #ExpansionNodeScope(> 1) */
+   {
+     ASTExpansionNodeScope jjtn002 = new ASTExpansionNodeScope(JJTEXPANSIONNODESCOPE);
+     boolean jjtc002 = true;
+     jjtree.openNodeScope(jjtn002);
+     jjtreeOpenNodeScope(jjtn002);
+   }
+   try {
+/*@egen*/
+   (
+     eu=expansion_unit(p)
+     [ nd=node_descriptor() ]/*@bgen(jjtree)*/
+        {
+          jjtree.closeNodeScope(jjtn002, jjtree.nodeArity() > 1);
+          jjtc002 = false;
+          jjtreeCloseNodeScope(jjtn002);
+        }
+/*@egen*/
+        {
+	  if (jjtree.nodeCreated()) {
+	    jjtn002.node_scope = new NodeScope(p, nd);
+	    jjtn002.expansion_unit = eu;
+	  }
+	}
+   )/*@bgen(jjtree)*/
+   } catch (Throwable jjte002) {
+     if (jjtc002) {
+       jjtree.clearNodeScope(jjtn002);
+       jjtc002 = false;
+     } else {
+       jjtree.popNode();
+     }
+     if (jjte002 instanceof RuntimeException) {
+       throw (RuntimeException)jjte002;
+     }
+     if (jjte002 instanceof ParseException) {
+       throw (ParseException)jjte002;
+     }
+     throw (Error)jjte002;
+   } finally {
+     if (jjtc002) {
+       jjtree.closeNodeScope(jjtn002, jjtree.nodeArity() > 1);
+       jjtreeCloseNodeScope(jjtn002);
+     }
+   }
+/*@egen*/                        
+  )+/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
+      jjtreeCloseNodeScope(jjtn000);
+    }
+  }
+/*@egen*/
+}
+
+void local_lookahead(ASTProduction p) :
+	{
+	  boolean commaAtEnd = false, emptyLA = true;
+	}
+{
+  [
+    /*
+     * The lookahead of 1 is to turn off the warning message that lets
+     * us know that an expansion choice can also start with an integer
+     * literal because a primary expression can do the same.  But we
+     * know that this is what we want.
+     */
+    LOOKAHEAD(1)
+    IntegerLiteral()
+	{
+	  emptyLA = false;
+	}
+  ]
+  [ LOOKAHEAD(0, { !emptyLA && (getToken(1).kind != RPAREN) } )
+    ","
+	{
+	  commaAtEnd = true;
+	}
+  ]
+  [ LOOKAHEAD(0, { getToken(1).kind != RPAREN && getToken(1).kind != LBRACE } )
+    expansion_choices(p)
+	{
+	  emptyLA = false; commaAtEnd = false;
+	}
+  ]
+  [ LOOKAHEAD(0, { !emptyLA && !commaAtEnd && (getToken(1).kind != RPAREN) } )
+    ","
+	{
+	  commaAtEnd = true;
+	}
+  ]
+  [ LOOKAHEAD(0, { emptyLA || commaAtEnd } )
+    "{"
+    {
+      if (!isJavaLanguage) {
+        eatUptoCloseBrace();
+      }
+    }
+    [ Expression() ] "}"
+  ]
+}
+
+JJTreeNode expansion_unit(ASTProduction p) :
+	{
+	  Token t;
+	}
+{
+(
+  LOOKAHEAD(1)/*@bgen(jjtree) BNFLookahead */
+  {
+    ASTBNFLookahead jjtn001 = new ASTBNFLookahead(JJTBNFLOOKAHEAD);
+    boolean jjtc001 = true;
+    jjtree.openNodeScope(jjtn001);
+    jjtreeOpenNodeScope(jjtn001);
+  }
+  try {
+/*@egen*/
+  /*
+   * We give this priority over primary expressions which use LOOKAHEAD as the
+   * name of its identifier.
+   */
+  (
+    "LOOKAHEAD" "(" local_lookahead(p) ")"
+  )/*@bgen(jjtree)*/
+  } catch (Throwable jjte001) {
+    if (jjtc001) {
+      jjtree.clearNodeScope(jjtn001);
+      jjtc001 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte001 instanceof RuntimeException) {
+      throw (RuntimeException)jjte001;
+    }
+    if (jjte001 instanceof ParseException) {
+      throw (ParseException)jjte001;
+    }
+    throw (Error)jjte001;
+  } finally {
+    if (jjtc001) {
+      jjtree.closeNodeScope(jjtn001, true);
+      jjtreeCloseNodeScope(jjtn001);
+    }
+  }
+/*@egen*/              
+|/*@bgen(jjtree) BNFAction */
+  {
+    ASTBNFAction jjtn002 = new ASTBNFAction(JJTBNFACTION);
+    boolean jjtc002 = true;
+    jjtree.openNodeScope(jjtn002);
+    jjtreeOpenNodeScope(jjtn002);
+  }
+  try {
+/*@egen*/
+  Block()/*@bgen(jjtree)*/
+  } catch (Throwable jjte002) {
+    if (jjtc002) {
+      jjtree.clearNodeScope(jjtn002);
+      jjtc002 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte002 instanceof RuntimeException) {
+      throw (RuntimeException)jjte002;
+    }
+    if (jjte002 instanceof ParseException) {
+      throw (ParseException)jjte002;
+    }
+    throw (Error)jjte002;
+  } finally {
+    if (jjtc002) {
+      jjtree.closeNodeScope(jjtn002, true);
+      jjtreeCloseNodeScope(jjtn002);
+    }
+  }
+/*@egen*/           
+|/*@bgen(jjtree) BNFZeroOrOne */
+  {
+    ASTBNFZeroOrOne jjtn003 = new ASTBNFZeroOrOne(JJTBNFZEROORONE);
+    boolean jjtc003 = true;
+    jjtree.openNodeScope(jjtn003);
+    jjtreeOpenNodeScope(jjtn003);
+  }
+  try {
+/*@egen*/
+  (
+    "[" expansion_choices(p) "]"
+  )/*@bgen(jjtree)*/
+  } catch (Throwable jjte003) {
+    if (jjtc003) {
+      jjtree.clearNodeScope(jjtn003);
+      jjtc003 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte003 instanceof RuntimeException) {
+      throw (RuntimeException)jjte003;
+    }
+    if (jjte003 instanceof ParseException) {
+      throw (ParseException)jjte003;
+    }
+    throw (Error)jjte003;
+  } finally {
+    if (jjtc003) {
+      jjtree.closeNodeScope(jjtn003, true);
+      jjtreeCloseNodeScope(jjtn003);
+    }
+  }
+/*@egen*/              
+|/*@bgen(jjtree) BNFTryBlock */
+  {
+    ASTBNFTryBlock jjtn004 = new ASTBNFTryBlock(JJTBNFTRYBLOCK);
+    boolean jjtc004 = true;
+    jjtree.openNodeScope(jjtn004);
+    jjtreeOpenNodeScope(jjtn004);
+  }
+  try {
+/*@egen*/
+  (
+    "try" "{"
+    {
+      if (!isJavaLanguage) {
+        eatUptoCloseBrace();
+      }
+    }
+    [ expansion_choices(p) ]
+    "}"
+    ( "catch" "(" Name() <IDENTIFIER> ")" Block() )*
+    [ "finally" Block() ]
+  )/*@bgen(jjtree)*/
+  } catch (Throwable jjte004) {
+    if (jjtc004) {
+      jjtree.clearNodeScope(jjtn004);
+      jjtc004 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte004 instanceof RuntimeException) {
+      throw (RuntimeException)jjte004;
+    }
+    if (jjte004 instanceof ParseException) {
+      throw (ParseException)jjte004;
+    }
+    throw (Error)jjte004;
+  } finally {
+    if (jjtc004) {
+      jjtree.closeNodeScope(jjtn004, true);
+      jjtreeCloseNodeScope(jjtn004);
+    }
+  }
+/*@egen*/             
+|
+  LOOKAHEAD( identifier() | StringLiteral() | "<" | PrimaryExpression() "=" )/*@bgen(jjtree) #BNFAssignment(> 1) */
+{
+  ASTBNFAssignment jjtn006 = new ASTBNFAssignment(JJTBNFASSIGNMENT);
+  boolean jjtc006 = true;
+  jjtree.openNodeScope(jjtn006);
+  jjtreeOpenNodeScope(jjtn006);
+}
+try {
+/*@egen*/
+(
+  [
+    LOOKAHEAD(PrimaryExpression() "=")
+    PrimaryExpression() "="
+  ]
+  (
+    regular_expression() [ "." t=<IDENTIFIER>  ]
+  |/*@bgen(jjtree) BNFNonTerminal */
+    {
+      ASTBNFNonTerminal jjtn005 = new ASTBNFNonTerminal(JJTBNFNONTERMINAL);
+      boolean jjtc005 = true;
+      jjtree.openNodeScope(jjtn005);
+      jjtreeOpenNodeScope(jjtn005);
+    }
+    try {
+/*@egen*/ ( identifier() Arguments() )/*@bgen(jjtree)*/
+    } catch (Throwable jjte005) {
+      if (jjtc005) {
+        jjtree.clearNodeScope(jjtn005);
+        jjtc005 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte005 instanceof RuntimeException) {
+        throw (RuntimeException)jjte005;
+      }
+      if (jjte005 instanceof ParseException) {
+        throw (ParseException)jjte005;
+      }
+      throw (Error)jjte005;
+    } finally {
+      if (jjtc005) {
+        jjtree.closeNodeScope(jjtn005, true);
+        jjtreeCloseNodeScope(jjtn005);
+      }
+    }
+/*@egen*/                
+  )
+	
+)/*@bgen(jjtree)*/
+} catch (Throwable jjte006) {
+  if (jjtc006) {
+    jjtree.clearNodeScope(jjtn006);
+    jjtc006 = false;
+  } else {
+    jjtree.popNode();
+  }
+  if (jjte006 instanceof RuntimeException) {
+    throw (RuntimeException)jjte006;
+  }
+  if (jjte006 instanceof ParseException) {
+    throw (ParseException)jjte006;
+  }
+  throw (Error)jjte006;
+} finally {
+  if (jjtc006) {
+    jjtree.closeNodeScope(jjtn006, jjtree.nodeArity() > 1);
+    jjtreeCloseNodeScope(jjtn006);
+  }
+}
+/*@egen*/                   
+|
+  t="(" expansion_choices(p) ")"
+  (/*@bgen(jjtree) #BNFOneOrMore( 1) */
+    {
+      ASTBNFOneOrMore jjtn007 = new ASTBNFOneOrMore(JJTBNFONEORMORE);
+      boolean jjtc007 = true;
+      jjtree.openNodeScope(jjtn007);
+      jjtreeOpenNodeScope(jjtn007);
+    }
+    try {
+/*@egen*/
+    "+"/*@bgen(jjtree)*/
+    } finally {
+      if (jjtc007) {
+        jjtree.closeNodeScope(jjtn007,  1);
+        jjtreeCloseNodeScope(jjtn007);
+      }
+    }
+/*@egen*/
+                      
+  |/*@bgen(jjtree) #BNFZeroOrMore( 1) */
+    {
+      ASTBNFZeroOrMore jjtn008 = new ASTBNFZeroOrMore(JJTBNFZEROORMORE);
+      boolean jjtc008 = true;
+      jjtree.openNodeScope(jjtn008);
+      jjtreeOpenNodeScope(jjtn008);
+    }
+    try {
+/*@egen*/
+    "*"/*@bgen(jjtree)*/
+    } finally {
+      if (jjtc008) {
+        jjtree.closeNodeScope(jjtn008,  1);
+        jjtreeCloseNodeScope(jjtn008);
+      }
+    }
+/*@egen*/
+                       
+  |/*@bgen(jjtree) #BNFZeroOrOne( 1) */
+    {
+      ASTBNFZeroOrOne jjtn009 = new ASTBNFZeroOrOne(JJTBNFZEROORONE);
+      boolean jjtc009 = true;
+      jjtree.openNodeScope(jjtn009);
+      jjtreeOpenNodeScope(jjtn009);
+    }
+    try {
+/*@egen*/
+    "?"/*@bgen(jjtree)*/
+    } finally {
+      if (jjtc009) {
+        jjtree.closeNodeScope(jjtn009,  1);
+        jjtreeCloseNodeScope(jjtn009);
+      }
+    }
+/*@egen*/
+                      
+  |/*@bgen(jjtree) #BNFParenthesized( 1) */
+    {
+      ASTBNFParenthesized jjtn010 = new ASTBNFParenthesized(JJTBNFPARENTHESIZED);
+      boolean jjtc010 = true;
+      jjtree.openNodeScope(jjtn010);
+      jjtreeOpenNodeScope(jjtn010);
+    }
+    try {
+/*@egen*//*@bgen(jjtree)*/
+    {
+      jjtree.closeNodeScope(jjtn010,  1);
+      jjtc010 = false;
+      jjtreeCloseNodeScope(jjtn010);
+    }
+/*@egen*/
+    {}/*@bgen(jjtree)*/
+    } finally {
+      if (jjtc010) {
+        jjtree.closeNodeScope(jjtn010,  1);
+        jjtreeCloseNodeScope(jjtn010);
+      }
+    }
+/*@egen*/
+                          
+  )
+	{
+	  ((JJTreeNode)jjtree.peekNode()).setFirstToken(t);
+	}
+)
+        {
+	  return (JJTreeNode)jjtree.peekNode();
+	}
+}
+
+void regular_expression() :
+	{
+	}
+{/*@bgen(jjtree) REStringLiteral */
+  {
+    ASTREStringLiteral jjtn001 = new ASTREStringLiteral(JJTRESTRINGLITERAL);
+    boolean jjtc001 = true;
+    jjtree.openNodeScope(jjtn001);
+    jjtreeOpenNodeScope(jjtn001);
+  }
+  try {
+/*@egen*/
+  StringLiteral()/*@bgen(jjtree)*/
+  } catch (Throwable jjte001) {
+    if (jjtc001) {
+      jjtree.clearNodeScope(jjtn001);
+      jjtc001 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte001 instanceof RuntimeException) {
+      throw (RuntimeException)jjte001;
+    }
+    if (jjte001 instanceof ParseException) {
+      throw (ParseException)jjte001;
+    }
+    throw (Error)jjte001;
+  } finally {
+    if (jjtc001) {
+      jjtree.closeNodeScope(jjtn001, true);
+      jjtreeCloseNodeScope(jjtn001);
+    }
+  }
+/*@egen*/                 
+|
+  LOOKAHEAD(3)/*@bgen(jjtree) RENamed */
+  {
+    ASTRENamed jjtn002 = new ASTRENamed(JJTRENAMED);
+    boolean jjtc002 = true;
+    jjtree.openNodeScope(jjtn002);
+    jjtreeOpenNodeScope(jjtn002);
+  }
+  try {
+/*@egen*/
+  (
+    "<" [ [ "#" ] identifier() ":" ] complex_regular_expression_choices() ">"
+  )/*@bgen(jjtree)*/
+  } catch (Throwable jjte002) {
+    if (jjtc002) {
+      jjtree.clearNodeScope(jjtn002);
+      jjtc002 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte002 instanceof RuntimeException) {
+      throw (RuntimeException)jjte002;
+    }
+    if (jjte002 instanceof ParseException) {
+      throw (ParseException)jjte002;
+    }
+    throw (Error)jjte002;
+  } finally {
+    if (jjtc002) {
+      jjtree.closeNodeScope(jjtn002, true);
+      jjtreeCloseNodeScope(jjtn002);
+    }
+  }
+/*@egen*/         
+|
+  LOOKAHEAD(2)/*@bgen(jjtree) REReference */
+  {
+    ASTREReference jjtn003 = new ASTREReference(JJTREREFERENCE);
+    boolean jjtc003 = true;
+    jjtree.openNodeScope(jjtn003);
+    jjtreeOpenNodeScope(jjtn003);
+  }
+  try {
+/*@egen*/
+  (
+    "<" identifier() ">"
+  )/*@bgen(jjtree)*/
+  } catch (Throwable jjte003) {
+    if (jjtc003) {
+      jjtree.clearNodeScope(jjtn003);
+      jjtc003 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte003 instanceof RuntimeException) {
+      throw (RuntimeException)jjte003;
+    }
+    if (jjte003 instanceof ParseException) {
+      throw (ParseException)jjte003;
+    }
+    throw (Error)jjte003;
+  } finally {
+    if (jjtc003) {
+      jjtree.closeNodeScope(jjtn003, true);
+      jjtreeCloseNodeScope(jjtn003);
+    }
+  }
+/*@egen*/             
+|/*@bgen(jjtree) REEOF */
+  {
+    ASTREEOF jjtn004 = new ASTREEOF(JJTREEOF);
+    boolean jjtc004 = true;
+    jjtree.openNodeScope(jjtn004);
+    jjtreeOpenNodeScope(jjtn004);
+  }
+  try {
+/*@egen*/
+  (
+    "<" "EOF" ">"
+  )/*@bgen(jjtree)*/
+  } finally {
+    if (jjtc004) {
+      jjtree.closeNodeScope(jjtn004, true);
+      jjtreeCloseNodeScope(jjtn004);
+    }
+  }
+/*@egen*/       
+}
+
+void complex_regular_expression_choices()               :
+{/*@bgen(jjtree) #REChoice(> 1) */
+  ASTREChoice jjtn000 = new ASTREChoice(JJTRECHOICE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) #REChoice(> 1) */
+  try {
+/*@egen*/
+  complex_regular_expression() ( "|" complex_regular_expression() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
+      jjtreeCloseNodeScope(jjtn000);
+    }
+  }
+/*@egen*/
+}
+
+void complex_regular_expression()                 :
+{/*@bgen(jjtree) #RESequence(> 1) */
+  ASTRESequence jjtn000 = new ASTRESequence(JJTRESEQUENCE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) #RESequence(> 1) */
+  try {
+/*@egen*/
+  ( complex_regular_expression_unit() )+/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
+      jjtreeCloseNodeScope(jjtn000);
+    }
+  }
+/*@egen*/
+}
+
+void complex_regular_expression_unit() :
+	{
+	  Token t;
+	}
+{/*@bgen(jjtree) REStringLiteral */
+  {
+    ASTREStringLiteral jjtn001 = new ASTREStringLiteral(JJTRESTRINGLITERAL);
+    boolean jjtc001 = true;
+    jjtree.openNodeScope(jjtn001);
+    jjtreeOpenNodeScope(jjtn001);
+  }
+  try {
+/*@egen*/
+  StringLiteral()/*@bgen(jjtree)*/
+  } catch (Throwable jjte001) {
+    if (jjtc001) {
+      jjtree.clearNodeScope(jjtn001);
+      jjtc001 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte001 instanceof RuntimeException) {
+      throw (RuntimeException)jjte001;
+    }
+    if (jjte001 instanceof ParseException) {
+      throw (ParseException)jjte001;
+    }
+    throw (Error)jjte001;
+  } finally {
+    if (jjtc001) {
+      jjtree.closeNodeScope(jjtn001, true);
+      jjtreeCloseNodeScope(jjtn001);
+    }
+  }
+/*@egen*/                 
+|/*@bgen(jjtree) REReference */
+  {
+    ASTREReference jjtn002 = new ASTREReference(JJTREREFERENCE);
+    boolean jjtc002 = true;
+    jjtree.openNodeScope(jjtn002);
+    jjtreeOpenNodeScope(jjtn002);
+  }
+  try {
+/*@egen*/
+  ( "<" identifier() ">" )/*@bgen(jjtree)*/
+  } catch (Throwable jjte002) {
+    if (jjtc002) {
+      jjtree.clearNodeScope(jjtn002);
+      jjtc002 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte002 instanceof RuntimeException) {
+      throw (RuntimeException)jjte002;
+    }
+    if (jjte002 instanceof ParseException) {
+      throw (ParseException)jjte002;
+    }
+    throw (Error)jjte002;
+  } finally {
+    if (jjtc002) {
+      jjtree.closeNodeScope(jjtn002, true);
+      jjtreeCloseNodeScope(jjtn002);
+    }
+  }
+/*@egen*/             
+|
+  character_list()
+|
+  t="(" complex_regular_expression_choices() ")"
+  (/*@bgen(jjtree) #REOneOrMore( 1) */
+    {
+      ASTREOneOrMore jjtn003 = new ASTREOneOrMore(JJTREONEORMORE);
+      boolean jjtc003 = true;
+      jjtree.openNodeScope(jjtn003);
+      jjtreeOpenNodeScope(jjtn003);
+    }
+    try {
+/*@egen*/
+    "+"/*@bgen(jjtree)*/
+    } finally {
+      if (jjtc003) {
+        jjtree.closeNodeScope(jjtn003,  1);
+        jjtreeCloseNodeScope(jjtn003);
+      }
+    }
+/*@egen*/
+                     
+  |/*@bgen(jjtree) #REZeroOrMore( 1) */
+    {
+      ASTREZeroOrMore jjtn004 = new ASTREZeroOrMore(JJTREZEROORMORE);
+      boolean jjtc004 = true;
+      jjtree.openNodeScope(jjtn004);
+      jjtreeOpenNodeScope(jjtn004);
+    }
+    try {
+/*@egen*/
+    "*"/*@bgen(jjtree)*/
+    } finally {
+      if (jjtc004) {
+        jjtree.closeNodeScope(jjtn004,  1);
+        jjtreeCloseNodeScope(jjtn004);
+      }
+    }
+/*@egen*/
+                      
+  |/*@bgen(jjtree) #REZeroOrOne( 1) */
+    {
+      ASTREZeroOrOne jjtn005 = new ASTREZeroOrOne(JJTREZEROORONE);
+      boolean jjtc005 = true;
+      jjtree.openNodeScope(jjtn005);
+      jjtreeOpenNodeScope(jjtn005);
+    }
+    try {
+/*@egen*/
+    "?"/*@bgen(jjtree)*/
+    } finally {
+      if (jjtc005) {
+        jjtree.closeNodeScope(jjtn005,  1);
+        jjtreeCloseNodeScope(jjtn005);
+      }
+    }
+/*@egen*/
+                     
+  |  "{" IntegerLiteral() [ ","  [ IntegerLiteral() ] ]/*@bgen(jjtree) #RRepetitionRange( 1) */
+                                                        {
+                                                          ASTRRepetitionRange jjtn006 = new ASTRRepetitionRange(JJTRREPETITIONRANGE);
+                                                          boolean jjtc006 = true;
+                                                          jjtree.openNodeScope(jjtn006);
+                                                          jjtreeOpenNodeScope(jjtn006);
+                                                        }
+                                                        try {
+/*@egen*/ "}"/*@bgen(jjtree)*/
+                                                        } finally {
+                                                          if (jjtc006) {
+                                                            jjtree.closeNodeScope(jjtn006,  1);
+                                                            jjtreeCloseNodeScope(jjtn006);
+                                                          }
+                                                        }
+/*@egen*/
+                        
+  |/*@bgen(jjtree) #REParenthesized( 1) */
+    {
+      ASTREParenthesized jjtn007 = new ASTREParenthesized(JJTREPARENTHESIZED);
+      boolean jjtc007 = true;
+      jjtree.openNodeScope(jjtn007);
+      jjtreeOpenNodeScope(jjtn007);
+    }
+    try {
+/*@egen*//*@bgen(jjtree)*/
+    {
+      jjtree.closeNodeScope(jjtn007,  1);
+      jjtc007 = false;
+      jjtreeCloseNodeScope(jjtn007);
+    }
+/*@egen*/
+    {}/*@bgen(jjtree)*/
+    } finally {
+      if (jjtc007) {
+        jjtree.closeNodeScope(jjtn007,  1);
+        jjtreeCloseNodeScope(jjtn007);
+      }
+    }
+/*@egen*/
+                         
+  )
+	{
+	  ((JJTreeNode)jjtree.peekNode()).setFirstToken(t);
+	}
+}
+
+void character_list()             :
+{/*@bgen(jjtree) RECharList */
+  ASTRECharList jjtn000 = new ASTRECharList(JJTRECHARLIST);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) RECharList */
+  try {
+/*@egen*/
+  [ "~" ] "[" [ character_descriptor() ( "," character_descriptor() )* ] "]"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      jjtreeCloseNodeScope(jjtn000);
+    }
+  }
+/*@egen*/
+}
+
+void character_descriptor()                 :
+{/*@bgen(jjtree) CharDescriptor */
+  ASTCharDescriptor jjtn000 = new ASTCharDescriptor(JJTCHARDESCRIPTOR);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) CharDescriptor */
+  try {
+/*@egen*/
+  StringLiteral() [ "-" StringLiteral() ]/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      jjtreeCloseNodeScope(jjtn000);
+    }
+  }
+/*@egen*/
+}
+
+Token identifier() :
+{
+  Token t;
+}
+{
+  t=<IDENTIFIER>
+                {
+		  return t;
+		}
+}
+
+
+/**********************************************
+ * THE JJTREE PRODUCTIONS START HERE          *
+ **********************************************/
+
+ASTNodeDescriptor node_descriptor()                 :
+{/*@bgen(jjtree) NodeDescriptor */
+  ASTNodeDescriptor jjtn000 = new ASTNodeDescriptor(JJTNODEDESCRIPTOR);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/
+  Token t = null;
+  String s = null;
+}
+{/*@bgen(jjtree) NodeDescriptor */
+  try {
+/*@egen*/
+  "#"
+  (
+    s=Name()
+                   {
+                     jjtn000.name = s;
+		   }
+  | t=<VOID>
+                   {
+                     jjtn000.name = t.image;
+		   }
+  )
+  [
+   LOOKAHEAD(1)
+   "("
+      [ ">"
+                   {
+		     jjtn000.isGT = true;
+		   }
+      ]
+      node_descriptor_expression()
+	           {
+		     jjtn000.expression =
+		       (ASTNodeDescriptorExpression)jjtree.peekNode();
+		   }
+   ")"
+  ]/*@bgen(jjtree)*/
+                   {
+                     jjtree.closeNodeScope(jjtn000, true);
+                     jjtc000 = false;
+                     jjtreeCloseNodeScope(jjtn000);
+                   }
+/*@egen*/
+                   {
+		     jjtn000.setNodeIdValue();
+		     return jjtn000;
+		   }/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      jjtreeCloseNodeScope(jjtn000);
+    }
+  }
+/*@egen*/
+}
+
+
+JAVACODE
+void node_descriptor_expression()                          
+{/*@bgen(jjtree) NodeDescriptorExpression */
+ASTNodeDescriptorExpression jjtn000 = new ASTNodeDescriptorExpression(JJTNODEDESCRIPTOREXPRESSION);
+boolean jjtc000 = true;
+jjtree.openNodeScope(jjtn000);
+jjtreeOpenNodeScope(jjtn000);
+try {
+/*@egen*/
+  Token tok;
+  int nesting = 1;
+  while (true) {
+    tok = getToken(1);
+    if (tok.kind == 0) {
+      throw new ParseException();
+    }
+    if (tok.kind == LPAREN) nesting++;
+    if (tok.kind == RPAREN) {
+      nesting--;
+      if (nesting == 0) break;
+    }
+    tok = getNextToken();
+  }/*@bgen(jjtree)*/
+} finally {
+  if (jjtc000) {
+    jjtree.closeNodeScope(jjtn000, true);
+    jjtreeCloseNodeScope(jjtn000);
+  }
+}
+/*@egen*/
+}
+
+
+
+/**********************************************
+ * THE JAVA GRAMMAR SPECIFICATION STARTS HERE *
+ **********************************************/
+
+/*
+ * The Java grammar is modified to use sequences of tokens
+ * for the missing tokens - those that include "<<" and ">>".
+ */
+
+/*
+ * The following production defines Java identifiers - it
+ * includes the reserved words of JavaCC also.
+ */
+
+String JavaIdentifier() :
+{}
+{
+(  <IDENTIFIER>
+| "LOOKAHEAD"
+| "IGNORE_CASE"
+| "PARSER_BEGIN"
+| "PARSER_END"
+| "JAVACODE"
+| "TOKEN"
+| "SPECIAL_TOKEN"
+| "MORE"
+| "SKIP"
+| "TOKEN_MGR_DECLS"
+| "EOF"
+)
+                {
+		  return token.image;
+		}
+}
+
+/*
+ * Program structuring syntax follows.
+ */
+
+void CompilationUnit() :
+{}
+{
+  [ LOOKAHEAD( ( Annotation() )* "package" ) PackageDeclaration() ]
+  { JJTreeGlobals.parserImports = getToken(1); }
+  ( ImportDeclaration() )*
+  ( TypeDeclaration() )*
+}
+
+void PackageDeclaration() :
+{
+  String s;
+}
+{
+  Modifiers() "package" s=Name() ";"
+                {
+		  JJTreeGlobals.packageName = s;
+		}
+}
+
+void ImportDeclaration() :
+{}
+{
+  "import" [ "static" ] Name() [ "." "*" ] ";"
+}
+
+/*
+ * Modifiers. We match all modifiers in a single rule to reduce the chances of
+ * syntax errors for simple modifier mistakes. It will also enable us to give
+ * better error messages.
+ */
+
+void Modifiers():
+{}
+{
+ (
+  LOOKAHEAD(2)
+  (
+   "public"
+  |
+   "static"
+  |
+   "protected"
+  |
+   "private"
+  |
+   "final"
+  |
+   "abstract"
+  |
+   "synchronized"
+  |
+   "native"
+  |
+   "transient"
+  |
+   "volatile"
+  |
+   "strictfp"
+  |
+   Annotation()
+  )
+ )*
+}
+
+/*
+ * Declaration syntax follows.
+ */
+void TypeDeclaration():
+{
+   ;
+}
+{
+  ";"
+|
+  Modifiers()
+  (
+     ClassOrInterfaceDeclaration()
+   |
+     EnumDeclaration()
+   |
+     AnnotationTypeDeclaration()
+  )
+}
+
+
+void ClassOrInterfaceDeclaration():
+{
+  Token t = null;
+  String s;
+}
+{
+  ( "class" | "interface" )
+  s=JavaIdentifier()
+  [ TypeParameters() ]
+  [ ExtendsList() ]
+  [ { t = getToken(1); } ImplementsList() ]
+                {
+		  if (s.equals(JJTreeGlobals.parserName)) {
+		    if (t != null) {
+		      JJTreeGlobals.parserImplements = t;
+		    } else {
+		      JJTreeGlobals.parserImplements = getToken(1);
+		    }
+		    JJTreeGlobals.parserClassBodyStart = getToken(1);
+		  }
+		}
+  ClassOrInterfaceBody()
+}
+
+void ExtendsList():
+{}
+{
+   "extends" ClassOrInterfaceType()
+   ( "," ClassOrInterfaceType() )*
+}
+
+void ImplementsList():
+{}
+{
+   "implements" ClassOrInterfaceType()
+   ( "," ClassOrInterfaceType() )*
+}
+
+void EnumDeclaration():
+{}
+{
+  "enum" JavaIdentifier()
+  [ ImplementsList() ]
+  EnumBody()
+}
+
+void EnumBody():
+{}
+{
+   "{"
+   [ EnumConstant() ( LOOKAHEAD(2) "," EnumConstant() )* ]
+   [ "," ]
+   [ ";" ( ClassOrInterfaceBodyDeclaration() )* ]
+   "}"
+}
+
+void EnumConstant():
+{}
+{
+  Modifiers() JavaIdentifier() [ Arguments() ] [ ClassOrInterfaceBody() ]
+}
+
+void TypeParameters():
+{}
+{
+   "<" TypeParameter() ( "," TypeParameter() )* ">"
+}
+
+void TypeParameter():
+{}
+{
+   JavaIdentifier() [ TypeBound() ]
+}
+
+void TypeBound():
+{}
+{
+   "extends" ClassOrInterfaceType() ( "&" ClassOrInterfaceType() )*
+}
+
+void ClassOrInterfaceBody():
+/*
+ * Parsing this fills "tokens" with all tokens of the block
+ * excluding the braces at each end.
+ */
+{}
+{
+  "{"
+  ( ClassOrInterfaceBodyDeclaration() )*
+  "}"
+}
+
+void ClassOrInterfaceBodyDeclaration():
+{}
+{
+  LOOKAHEAD(2)
+  Initializer()
+|
+  Modifiers() // Just get all the modifiers out of the way. If you want to do
+              // more checks, pass the modifiers down to the member
+  (
+      ClassOrInterfaceDeclaration()
+    |
+      EnumDeclaration()
+    |
+      LOOKAHEAD( [ TypeParameters() ] JavaIdentifier() "(" )
+      ConstructorDeclaration()
+    |
+      LOOKAHEAD( Type() JavaIdentifier() ( "[" "]" )* ( "," | "=" | ";" ) )
+      FieldDeclaration()
+    |
+      MethodDeclaration()
+  )
+|
+  ";"
+}
+
+void FieldDeclaration():
+{}
+{
+  // Modifiers are already matched in the caller
+  Type() VariableDeclarator() ( "," VariableDeclarator() )* ";"
+}
+
+void VariableDeclarator():
+{}
+{
+  VariableDeclaratorId() [ "=" VariableInitializer() ]
+}
+
+void VariableDeclaratorId():
+{}
+{
+  JavaIdentifier() ( "[" "]" )*
+}
+
+void VariableInitializer():
+{}
+{
+  ArrayInitializer()
+|
+  Expression()
+}
+
+void ArrayInitializer():
+{}
+{
+  "{" [ VariableInitializer() ( LOOKAHEAD(2) "," VariableInitializer() )* ] [ "," ] "}"
+}
+
+void MethodDeclaration():
+{}
+{
+  // Modifiers already matched in the caller!
+  [ TypeParameters() ]
+  ResultType()
+  MethodDeclarator() [ "throws" NameList() ]
+  ( Block() | ";" )
+}
+
+void MethodDeclarator():
+{}
+{
+  JavaIdentifier() FormalParameters() ( "[" "]" )*
+}
+
+void FormalParameters() :
+/*
+ * Parsing this fills "tokens" with all tokens of the formal
+ * parameters excluding the parentheses at each end.
+ */
+{}
+{
+  "("
+  [ FormalParameter() ( "," FormalParameter() )* ]
+  ")"
+}
+
+void FormalParameter():
+{}
+{
+  Modifiers() Type() [ "&" | "*" | "..." ] VariableDeclaratorId()
+}
+
+void ConstructorDeclaration():
+{}
+{
+  [ TypeParameters() ]
+  // Modifiers matched in the caller
+  JavaIdentifier() FormalParameters() [ "throws" NameList() ]
+  "{"
+    [ LOOKAHEAD(ExplicitConstructorInvocation()) ExplicitConstructorInvocation() ]
+    ( BlockStatement() )*
+  "}"
+}
+
+void ExplicitConstructorInvocation():
+{}
+{
+  LOOKAHEAD("this" Arguments() ";")
+  "this" Arguments() ";"
+|
+  [ LOOKAHEAD(2) PrimaryExpression() "." ] "super" Arguments() ";"
+}
+
+void Initializer():
+{}
+{
+  [ "static" ] Block()
+}
+
+
+/*
+ * Type, name and expression syntax follows.
+ */
+
+void Type():
+{}
+{
+   LOOKAHEAD(2) ReferenceType()
+ |
+   PrimitiveType()
+}
+
+void ReferenceType():
+{}
+{
+   PrimitiveType() ( LOOKAHEAD(2) "[" "]" )+
+  |
+   ( [ Template() ] ClassOrInterfaceType() ) ( LOOKAHEAD(2) "[" "]" )*
+}
+
+void Template():
+{}
+{
+	"template" "<"
+		TemplatePack() ( "," TemplatePack() )*  
+	">" 
+}
+
+void TemplatePack():
+{}
+{
+	TemplateBase() ["..."] <IDENTIFIER> 
+}
+
+void TemplateBase():
+{}
+{
+	("class" | "typename")
+}
+
+
+void ClassOrInterfaceType():
+{}
+{
+  JavaIdentifier() [ LOOKAHEAD(2) TypeArguments() ]
+  ( LOOKAHEAD(2) ( "." | "::" ) JavaIdentifier() [ LOOKAHEAD(2) TypeArguments() ] )*
+}
+
+void TypeArguments():
+{}
+{
+   "<" TypeArgument() ( "," TypeArgument() [ "..." ] )* ">"
+}
+
+void TypeArgument():
+{}
+{
+   ReferenceType()
+ |
+   "?" [ WildcardBounds() ]
+}
+
+void WildcardBounds():
+{}
+{
+   "extends" ReferenceType()
+ |
+   "super" ReferenceType()
+}
+
+
+void PrimitiveType():
+{}
+{
+  "boolean"
+|
+  "char"
+|
+  "byte"
+|
+  "short"
+|
+  "int"
+|
+  "long"
+|
+  "float"
+|
+  "double"
+}
+
+
+void ResultType() :
+{}
+{
+(
+  "void" [ "*" ]
+|
+  [ "const" ] Type() [ "*" | "&" ]
+)
+}
+
+String Name() :
+/*
+ * A lookahead of 2 is required below since "Name" can be followed
+ * by a ".*" when used in the context of an "ImportDeclaration".
+ */
+{
+  String s, ss;
+}
+{
+  s=JavaIdentifier()
+  ( LOOKAHEAD(2) "." ss=JavaIdentifier() { s += "." + ss; } )*
+                {
+		  return s;
+		}
+}
+
+void NameList():
+{}
+{
+  Name() ( "," Name() )*
+}
+
+
+/*
+ * Expression syntax follows.
+ */
+
+void Expression() :
+/*
+ * This expansion has been written this way instead of:
+ *   Assignment() | ConditionalExpression()
+ * for performance reasons.
+ * However, it is a weakening of the grammar for it allows the LHS of
+ * assignments to be any conditional expression whereas it can only be
+ * a primary expression.  Consider adding a semantic predicate to work
+ * around this.
+ */
+{}
+{
+  ConditionalExpression()
+  [
+	LOOKAHEAD(2)
+    AssignmentOperator() Expression()
+  ]
+}
+
+
+void AssignmentOperator():
+{}
+{
+  "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|="
+}
+
+void ConditionalExpression():
+{}
+{
+  ConditionalOrExpression() [ "?" Expression() ":" Expression() ]
+}
+
+void ConditionalOrExpression():
+{}
+{
+  ConditionalAndExpression() ( "||" ConditionalAndExpression() )*
+}
+
+void ConditionalAndExpression():
+{}
+{
+  InclusiveOrExpression() ( "&&" InclusiveOrExpression() )*
+}
+
+void InclusiveOrExpression():
+{}
+{
+  ExclusiveOrExpression() ( "|" ExclusiveOrExpression() )*
+}
+
+void ExclusiveOrExpression():
+{}
+{
+  AndExpression() ( "^" AndExpression() )*
+}
+
+void AndExpression():
+{}
+{
+  EqualityExpression() ( "&" EqualityExpression() )*
+}
+
+void EqualityExpression():
+{}
+{
+  InstanceOfExpression() ( ( "==" | "!=" ) InstanceOfExpression() )*
+}
+
+void InstanceOfExpression():
+{}
+{
+  RelationalExpression() [ "instanceof" Type() ]
+}
+
+void RelationalExpression():
+{}
+{
+  ShiftExpression() ( ( "<" | ">" | "<=" | ">=" ) ShiftExpression() )*
+}
+
+void ShiftExpression():
+{}
+{
+  AdditiveExpression() ( ( "<<" | RSIGNEDSHIFT() | RUNSIGNEDSHIFT() ) AdditiveExpression() )*
+}
+
+void AdditiveExpression():
+{}
+{
+  MultiplicativeExpression() ( ( "+" | "-" ) MultiplicativeExpression() )*
+}
+
+void MultiplicativeExpression():
+{}
+{
+  UnaryExpression() ( ( "*" | "/" | "%" ) UnaryExpression() )*
+}
+
+void UnaryExpression():
+{}
+{
+  ( "+" | "-" ) UnaryExpression()
+|
+  PreIncrementExpression()
+|
+  PreDecrementExpression()
+|
+  UnaryExpressionNotPlusMinus()
+}
+
+void PreIncrementExpression():
+{}
+{
+  "++" PrimaryExpression()
+}
+
+void PreDecrementExpression():
+{}
+{
+  "--" PrimaryExpression()
+}
+
+void UnaryExpressionNotPlusMinus():
+{}
+{
+  ( "~" | "!" ) UnaryExpression()
+|
+  LOOKAHEAD( CastLookahead() )
+  CastExpression()
+|
+  PostfixExpression()
+}
+
+// This production is to determine lookahead only.  The LOOKAHEAD specifications
+// below are not used, but they are there just to indicate that we know about
+// this.
+void CastLookahead():
+{}
+{
+  LOOKAHEAD(2)
+  "(" PrimitiveType()
+|
+  LOOKAHEAD("(" Type() "[")
+  "(" Type() "[" "]"
+|
+  "(" Type() ")" ( "~" | "!" | "(" | JavaIdentifier() | "this" | "super" | "new" | Literal() )
+}
+
+void PostfixExpression():
+{}
+{
+  PrimaryExpression() [ "++" | "--" ]
+}
+
+void CastExpression():
+{}
+{
+  LOOKAHEAD("(" PrimitiveType())
+  "(" Type() ")" UnaryExpression()
+|
+  "(" Type() ")" UnaryExpressionNotPlusMinus()
+}
+
+void PrimaryExpression()                   :
+{/*@bgen(jjtree) PrimaryExpression */
+  ASTPrimaryExpression jjtn000 = new ASTPrimaryExpression(JJTPRIMARYEXPRESSION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) PrimaryExpression */
+  try {
+/*@egen*/
+  PrimaryPrefix() ( LOOKAHEAD(2) PrimarySuffix() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      jjtreeCloseNodeScope(jjtn000);
+    }
+  }
+/*@egen*/
+}
+
+void MemberSelector():
+{}
+{
+  "." TypeArguments() JavaIdentifier()
+}
+
+void PrimaryPrefix():
+{}
+{
+  Literal()
+|
+  "this"
+|
+  "super" "." JavaIdentifier()
+|
+  "(" Expression() ")"
+|
+  AllocationExpression()
+|
+  LOOKAHEAD( ResultType() "." "class" )
+  ResultType() "." "class"
+|
+  Name()
+}
+
+void PrimarySuffix():
+{}
+{
+  LOOKAHEAD(2)
+  "." "this"
+|
+  LOOKAHEAD(2)
+  "." AllocationExpression()
+|
+  LOOKAHEAD(3)
+  MemberSelector()
+|
+  "[" Expression() "]"
+|
+  "." JavaIdentifier()
+|
+  Arguments()
+}
+
+void Literal():
+{}
+{
+  <INTEGER_LITERAL>
+|
+  <FLOATING_POINT_LITERAL>
+|
+  <CHARACTER_LITERAL>
+|
+  <STRING_LITERAL>
+|
+  BooleanLiteral()
+|
+  NullLiteral()
+}
+
+Token IntegerLiteral() :
+{
+  Token t;
+}
+{
+  t=<INTEGER_LITERAL>
+                {
+		  return t;
+		}
+}
+
+Token BooleanLiteral() :
+{
+  Token t;
+}
+{
+  t="true"
+                {
+		  return t;
+		}
+|
+  t="false"
+                {
+		  return t;
+		}
+}
+
+Token StringLiteral() :
+{
+  Token t;
+}
+{
+  t=<STRING_LITERAL>
+                {
+		  return t;
+		}
+}
+
+void NullLiteral() :
+{}
+{
+  "null"
+}
+
+void Arguments() :
+/*
+ * Parsing this fills "tokens" with all tokens of the arguments
+ * excluding the parentheses at each end.
+*/
+{}
+{
+  "("
+  [ ArgumentList() ]
+  ")"
+}
+
+void ArgumentList():
+{}
+{
+  Expression() ( "," Expression() )*
+}
+
+void AllocationExpression():
+{}
+{
+  LOOKAHEAD(2)
+  "new" PrimitiveType() ArrayDimsAndInits()
+|
+  "new" ClassOrInterfaceType() [ TypeArguments() ]
+    (
+      ArrayDimsAndInits()
+    |
+      Arguments() [ ClassOrInterfaceBody() ]
+    )
+}
+
+/*
+ * The third LOOKAHEAD specification below is to parse to PrimarySuffix
+ * if there is an expression between the "[...]".
+ */
+void ArrayDimsAndInits():
+{}
+{
+  LOOKAHEAD(2)
+  ( LOOKAHEAD(2) "[" Expression() "]" )+ ( LOOKAHEAD(2) "[" "]" )*
+|
+  ( "[" "]" )+ ArrayInitializer()
+}
+
+
+/*
+ * Statement syntax follows.
+ */
+
+void Statement():
+{}
+{
+  LOOKAHEAD(2)
+  LabeledStatement()
+|
+  AssertStatement()
+|
+  Block()
+|
+  EmptyStatement()
+|
+  StatementExpression() ";"
+|
+  SwitchStatement()
+|
+  IfStatement()
+|
+  WhileStatement()
+|
+  DoStatement()
+|
+  ForStatement()
+|
+  BreakStatement()
+|
+  ContinueStatement()
+|
+  ReturnStatement()
+|
+  ThrowStatement()
+|
+  SynchronizedStatement()
+|
+  TryStatement()
+}
+
+void AssertStatement():
+{}
+{
+  "assert" Expression() [ ":" Expression() ] ";"
+}
+
+void LabeledStatement():
+{}
+{
+  JavaIdentifier() ":" Statement()
+}
+
+void Block() :
+/*
+ * Parsing this fills "tokens" with all tokens of the block
+ * excluding the braces at each end.
+ */
+{}
+{
+  "{"
+    {
+      if (!isJavaLanguage) {
+        eatUptoCloseBrace();
+      }
+    }
+  ( BlockStatement() )*
+  "}"
+}
+
+void BlockStatement():
+{}
+{
+  LOOKAHEAD( Modifiers() Type() JavaIdentifier() )
+  LocalVariableDeclaration() ";"
+|
+  Statement()
+|
+  ClassOrInterfaceDeclaration( )
+}
+
+void LocalVariableDeclaration():
+{}
+{
+  Modifiers() Type() VariableDeclarator() ( "," VariableDeclarator() )*
+}
+
+void EmptyStatement():
+{}
+{
+  ";"
+}
+
+void StatementExpression():
+/*
+ * The last expansion of this production accepts more than the legal
+ * Java expansions for StatementExpression.  This expansion does not
+ * use PostfixExpression for performance reasons.
+ */
+{}
+{
+  PreIncrementExpression()
+|
+  PreDecrementExpression()
+|
+  PrimaryExpression()
+  [
+    "++"
+  |
+    "--"
+  |
+    AssignmentOperator() Expression()
+  ]
+}
+
+void SwitchStatement():
+{}
+{
+  "switch" "(" Expression() ")" "{"
+    ( SwitchLabel() ( BlockStatement() )* )*
+  "}"
+}
+
+void SwitchLabel():
+{}
+{
+  "case" Expression() ":"
+|
+  "default" ":"
+}
+
+void IfStatement():
+/*
+ * The disambiguating algorithm of JavaCC automatically binds dangling
+ * else's to the innermost if statement.  The LOOKAHEAD specification
+ * is to tell JavaCC that we know what we are doing.
+ */
+{}
+{
+  "if" "(" Expression() ")" Statement() [ LOOKAHEAD(1) "else" Statement() ]
+}
+
+void WhileStatement():
+{}
+{
+  "while" "(" Expression() ")" Statement()
+}
+
+void DoStatement():
+{}
+{
+  "do" Statement() "while" "(" Expression() ")" ";"
+}
+
+void ForStatement():
+{}
+{
+  "for" "("
+
+  (
+      LOOKAHEAD(Modifiers() Type() JavaIdentifier() ":")
+      Modifiers() Type() JavaIdentifier() ":" Expression()
+    |
+     [ ForInit() ] ";" [ Expression() ] ";" [ ForUpdate() ]
+  )
+
+  ")" Statement()
+}
+
+void ForInit():
+{}
+{
+  LOOKAHEAD( Modifiers() Type() JavaIdentifier() )
+  LocalVariableDeclaration()
+|
+  StatementExpressionList()
+}
+
+void StatementExpressionList():
+{}
+{
+  StatementExpression() ( "," StatementExpression() )*
+}
+
+void ForUpdate():
+{}
+{
+  StatementExpressionList()
+}
+
+void BreakStatement():
+{}
+{
+  "break" [ JavaIdentifier() ] ";"
+}
+
+void ContinueStatement():
+{}
+{
+  "continue" [ JavaIdentifier() ] ";"
+}
+
+void ReturnStatement() :
+{}
+{
+  "return" [ Expression() ] ";"
+}
+
+void ThrowStatement() :
+{}
+{
+  "throw" Expression() ";"
+}
+
+void SynchronizedStatement():
+{}
+{
+  "synchronized" "(" Expression() ")" Block()
+}
+
+void TryStatement():
+/*
+ * Semantic check required here to make sure that at least one
+ * finally/catch is present.
+ */
+{}
+{
+  "try" Block()
+  ( "catch" "(" FormalParameter() ")" Block() )*
+  [ "finally" Block() ]
+}
+
+/* We use productions to match >>>, >> and > so that we can keep the
+ * type declaration syntax with generics clean
+ */
+
+void RUNSIGNEDSHIFT():
+{}
+{
+  ( LOOKAHEAD({ getToken(1).kind == GT &&
+                ((Token.GTToken)getToken(1)).realKind == RUNSIGNEDSHIFT} )
+   ">" ">" ">"
+  )
+}
+
+void RSIGNEDSHIFT():
+{}
+{
+  ( LOOKAHEAD({ getToken(1).kind == GT &&
+                ((Token.GTToken)getToken(1)).realKind == RSIGNEDSHIFT} )
+  ">" ">"
+  )
+}
+
+/* Annotation syntax follows. */
+
+void Annotation():
+{}
+{
+   LOOKAHEAD( "@" Name() "(" ( JavaIdentifier() "=" | ")" ))
+   NormalAnnotation()
+ |
+   LOOKAHEAD( "@" Name() "(" )
+   SingleMemberAnnotation()
+ |
+   MarkerAnnotation()
+}
+
+void NormalAnnotation():
+{}
+{
+   "@" Name() "(" [ MemberValuePairs() ] ")"
+}
+
+void MarkerAnnotation():
+{}
+{
+  "@" Name()
+}
+
+void SingleMemberAnnotation():
+{}
+{
+  "@" Name() "(" MemberValue() ")"
+}
+
+void MemberValuePairs():
+{}
+{
+   MemberValuePair() ( "," MemberValuePair() )*
+}
+
+void MemberValuePair():
+{}
+{
+    JavaIdentifier() "=" MemberValue()
+}
+
+void MemberValue():
+{}
+{
+   Annotation()
+ |
+   MemberValueArrayInitializer()
+ |
+   ConditionalExpression()
+}
+
+void  MemberValueArrayInitializer():
+{}
+{
+  "{" MemberValue() ( LOOKAHEAD(2) "," MemberValue() )* [ "," ] "}"
+}
+
+
+/* Annotation Types. */
+
+void AnnotationTypeDeclaration():
+{}
+{
+  "@" "interface" JavaIdentifier() AnnotationTypeBody()
+}
+
+void AnnotationTypeBody():
+{}
+{
+  "{" ( AnnotationTypeMemberDeclaration() )* "}"
+}
+
+void AnnotationTypeMemberDeclaration():
+{}
+{
+ Modifiers()
+ (
+   LOOKAHEAD(Type() JavaIdentifier() "(")
+   Type() JavaIdentifier() "(" ")" [ DefaultValue() ] ";"
+  |
+   ClassOrInterfaceDeclaration()
+  |
+   EnumDeclaration()
+  |
+   AnnotationTypeDeclaration()
+  |
+   FieldDeclaration()
+ )
+ |
+   ( ";" )
+}
+
+void DefaultValue():
+{}
+{
+  "default" MemberValue()
+}
+
+/* IDENTIFIERS */
+
+TOKEN :
+{
+  < IDENTIFIER: <LETTER> (<PART_LETTER>)* >
+|
+  < #LETTER:
+      [  // all chars for which Character.isIdentifierStart is true
+         "$",
+         "A"-"Z",
+         "_",
+         "a"-"z",
+         "\u00a2"-"\u00a5",
+         "\u00aa",
+         "\u00b5",
+         "\u00ba",
+         "\u00c0"-"\u00d6",
+         "\u00d8"-"\u00f6",
+         "\u00f8"-"\u021f",
+         "\u0222"-"\u0233",
+         "\u0250"-"\u02ad",
+         "\u02b0"-"\u02b8",
+         "\u02bb"-"\u02c1",
+         "\u02d0"-"\u02d1",
+         "\u02e0"-"\u02e4",
+         "\u02ee",
+         "\u037a",
+         "\u0386",
+         "\u0388"-"\u038a",
+         "\u038c",
+         "\u038e"-"\u03a1",
+         "\u03a3"-"\u03ce",
+         "\u03d0"-"\u03d7",
+         "\u03da"-"\u03f3",
+         "\u0400"-"\u0481",
+         "\u048c"-"\u04c4",
+         "\u04c7"-"\u04c8",
+         "\u04cb"-"\u04cc",
+         "\u04d0"-"\u04f5",
+         "\u04f8"-"\u04f9",
+         "\u0531"-"\u0556",
+         "\u0559",
+         "\u0561"-"\u0587",
+         "\u05d0"-"\u05ea",
+         "\u05f0"-"\u05f2",
+         "\u0621"-"\u063a",
+         "\u0640"-"\u064a",
+         "\u0671"-"\u06d3",
+         "\u06d5",
+         "\u06e5"-"\u06e6",
+         "\u06fa"-"\u06fc",
+         "\u0710",
+         "\u0712"-"\u072c",
+         "\u0780"-"\u07a5",
+         "\u0905"-"\u0939",
+         "\u093d",
+         "\u0950",
+         "\u0958"-"\u0961",
+         "\u0985"-"\u098c",
+         "\u098f"-"\u0990",
+         "\u0993"-"\u09a8",
+         "\u09aa"-"\u09b0",
+         "\u09b2",
+         "\u09b6"-"\u09b9",
+         "\u09dc"-"\u09dd",
+         "\u09df"-"\u09e1",
+         "\u09f0"-"\u09f3",
+         "\u0a05"-"\u0a0a",
+         "\u0a0f"-"\u0a10",
+         "\u0a13"-"\u0a28",
+         "\u0a2a"-"\u0a30",
+         "\u0a32"-"\u0a33",
+         "\u0a35"-"\u0a36",
+         "\u0a38"-"\u0a39",
+         "\u0a59"-"\u0a5c",
+         "\u0a5e",
+         "\u0a72"-"\u0a74",
+         "\u0a85"-"\u0a8b",
+         "\u0a8d",
+         "\u0a8f"-"\u0a91",
+         "\u0a93"-"\u0aa8",
+         "\u0aaa"-"\u0ab0",
+         "\u0ab2"-"\u0ab3",
+         "\u0ab5"-"\u0ab9",
+         "\u0abd",
+         "\u0ad0",
+         "\u0ae0",
+         "\u0b05"-"\u0b0c",
+         "\u0b0f"-"\u0b10",
+         "\u0b13"-"\u0b28",
+         "\u0b2a"-"\u0b30",
+         "\u0b32"-"\u0b33",
+         "\u0b36"-"\u0b39",
+         "\u0b3d",
+         "\u0b5c"-"\u0b5d",
+         "\u0b5f"-"\u0b61",
+         "\u0b85"-"\u0b8a",
+         "\u0b8e"-"\u0b90",
+         "\u0b92"-"\u0b95",
+         "\u0b99"-"\u0b9a",
+         "\u0b9c",
+         "\u0b9e"-"\u0b9f",
+         "\u0ba3"-"\u0ba4",
+         "\u0ba8"-"\u0baa",
+         "\u0bae"-"\u0bb5",
+         "\u0bb7"-"\u0bb9",
+         "\u0c05"-"\u0c0c",
+         "\u0c0e"-"\u0c10",
+         "\u0c12"-"\u0c28",
+         "\u0c2a"-"\u0c33",
+         "\u0c35"-"\u0c39",
+         "\u0c60"-"\u0c61",
+         "\u0c85"-"\u0c8c",
+         "\u0c8e"-"\u0c90",
+         "\u0c92"-"\u0ca8",
+         "\u0caa"-"\u0cb3",
+         "\u0cb5"-"\u0cb9",
+         "\u0cde",
+         "\u0ce0"-"\u0ce1",
+         "\u0d05"-"\u0d0c",
+         "\u0d0e"-"\u0d10",
+         "\u0d12"-"\u0d28",
+         "\u0d2a"-"\u0d39",
+         "\u0d60"-"\u0d61",
+         "\u0d85"-"\u0d96",
+         "\u0d9a"-"\u0db1",
+         "\u0db3"-"\u0dbb",
+         "\u0dbd",
+         "\u0dc0"-"\u0dc6",
+         "\u0e01"-"\u0e30",
+         "\u0e32"-"\u0e33",
+         "\u0e3f"-"\u0e46",
+         "\u0e81"-"\u0e82",
+         "\u0e84",
+         "\u0e87"-"\u0e88",
+         "\u0e8a",
+         "\u0e8d",
+         "\u0e94"-"\u0e97",
+         "\u0e99"-"\u0e9f",
+         "\u0ea1"-"\u0ea3",
+         "\u0ea5",
+         "\u0ea7",
+         "\u0eaa"-"\u0eab",
+         "\u0ead"-"\u0eb0",
+         "\u0eb2"-"\u0eb3",
+         "\u0ebd",
+         "\u0ec0"-"\u0ec4",
+         "\u0ec6",
+         "\u0edc"-"\u0edd",
+         "\u0f00",
+         "\u0f40"-"\u0f47",
+         "\u0f49"-"\u0f6a",
+         "\u0f88"-"\u0f8b",
+         "\u1000"-"\u1021",
+         "\u1023"-"\u1027",
+         "\u1029"-"\u102a",
+         "\u1050"-"\u1055",
+         "\u10a0"-"\u10c5",
+         "\u10d0"-"\u10f6",
+         "\u1100"-"\u1159",
+         "\u115f"-"\u11a2",
+         "\u11a8"-"\u11f9",
+         "\u1200"-"\u1206",
+         "\u1208"-"\u1246",
+         "\u1248",
+         "\u124a"-"\u124d",
+         "\u1250"-"\u1256",
+         "\u1258",
+         "\u125a"-"\u125d",
+         "\u1260"-"\u1286",
+         "\u1288",
+         "\u128a"-"\u128d",
+         "\u1290"-"\u12ae",
+         "\u12b0",
+         "\u12b2"-"\u12b5",
+         "\u12b8"-"\u12be",
+         "\u12c0",
+         "\u12c2"-"\u12c5",
+         "\u12c8"-"\u12ce",
+         "\u12d0"-"\u12d6",
+         "\u12d8"-"\u12ee",
+         "\u12f0"-"\u130e",
+         "\u1310",
+         "\u1312"-"\u1315",
+         "\u1318"-"\u131e",
+         "\u1320"-"\u1346",
+         "\u1348"-"\u135a",
+         "\u13a0"-"\u13f4",
+         "\u1401"-"\u166c",
+         "\u166f"-"\u1676",
+         "\u1681"-"\u169a",
+         "\u16a0"-"\u16ea",
+         "\u1780"-"\u17b3",
+         "\u17db",
+         "\u1820"-"\u1877",
+         "\u1880"-"\u18a8",
+         "\u1e00"-"\u1e9b",
+         "\u1ea0"-"\u1ef9",
+         "\u1f00"-"\u1f15",
+         "\u1f18"-"\u1f1d",
+         "\u1f20"-"\u1f45",
+         "\u1f48"-"\u1f4d",
+         "\u1f50"-"\u1f57",
+         "\u1f59",
+         "\u1f5b",
+         "\u1f5d",
+         "\u1f5f"-"\u1f7d",
+         "\u1f80"-"\u1fb4",
+         "\u1fb6"-"\u1fbc",
+         "\u1fbe",
+         "\u1fc2"-"\u1fc4",
+         "\u1fc6"-"\u1fcc",
+         "\u1fd0"-"\u1fd3",
+         "\u1fd6"-"\u1fdb",
+         "\u1fe0"-"\u1fec",
+         "\u1ff2"-"\u1ff4",
+         "\u1ff6"-"\u1ffc",
+         "\u203f"-"\u2040",
+         "\u207f",
+         "\u20a0"-"\u20af",
+         "\u2102",
+         "\u2107",
+         "\u210a"-"\u2113",
+         "\u2115",
+         "\u2119"-"\u211d",
+         "\u2124",
+         "\u2126",
+         "\u2128",
+         "\u212a"-"\u212d",
+         "\u212f"-"\u2131",
+         "\u2133"-"\u2139",
+         "\u2160"-"\u2183",
+         "\u3005"-"\u3007",
+         "\u3021"-"\u3029",
+         "\u3031"-"\u3035",
+         "\u3038"-"\u303a",
+         "\u3041"-"\u3094",
+         "\u309d"-"\u309e",
+         "\u30a1"-"\u30fe",
+         "\u3105"-"\u312c",
+         "\u3131"-"\u318e",
+         "\u31a0"-"\u31b7",
+         "\u3400"-"\u4db5",
+         "\u4e00"-"\u9fa5",
+         "\ua000"-"\ua48c",
+         "\uac00"-"\ud7a3",
+         "\uf900"-"\ufa2d",
+         "\ufb00"-"\ufb06",
+         "\ufb13"-"\ufb17",
+         "\ufb1d",
+         "\ufb1f"-"\ufb28",
+         "\ufb2a"-"\ufb36",
+         "\ufb38"-"\ufb3c",
+         "\ufb3e",
+         "\ufb40"-"\ufb41",
+         "\ufb43"-"\ufb44",
+         "\ufb46"-"\ufbb1",
+         "\ufbd3"-"\ufd3d",
+         "\ufd50"-"\ufd8f",
+         "\ufd92"-"\ufdc7",
+         "\ufdf0"-"\ufdfb",
+         "\ufe33"-"\ufe34",
+         "\ufe4d"-"\ufe4f",
+         "\ufe69",
+         "\ufe70"-"\ufe72",
+         "\ufe74",
+         "\ufe76"-"\ufefc",
+         "\uff04",
+         "\uff21"-"\uff3a",
+         "\uff3f",
+         "\uff41"-"\uff5a",
+         "\uff65"-"\uffbe",
+         "\uffc2"-"\uffc7",
+         "\uffca"-"\uffcf",
+         "\uffd2"-"\uffd7",
+         "\uffda"-"\uffdc",
+         "\uffe0"-"\uffe1",
+         "\uffe5"-"\uffe6"
+      ]
+  >
+|
+  < #PART_LETTER:
+      [  // all chars for which Character.isIdentifierPart is true
+         "\u0000"-"\u0008",
+         "\u000e"-"\u001b",
+         "$",
+         "0"-"9",
+         "A"-"Z",
+         "_",
+         "a"-"z",
+         "\u007f"-"\u009f",
+         "\u00a2"-"\u00a5",
+         "\u00aa",
+         "\u00b5",
+         "\u00ba",
+         "\u00c0"-"\u00d6",
+         "\u00d8"-"\u00f6",
+         "\u00f8"-"\u021f",
+         "\u0222"-"\u0233",
+         "\u0250"-"\u02ad",
+         "\u02b0"-"\u02b8",
+         "\u02bb"-"\u02c1",
+         "\u02d0"-"\u02d1",
+         "\u02e0"-"\u02e4",
+         "\u02ee",
+         "\u0300"-"\u034e",
+         "\u0360"-"\u0362",
+         "\u037a",
+         "\u0386",
+         "\u0388"-"\u038a",
+         "\u038c",
+         "\u038e"-"\u03a1",
+         "\u03a3"-"\u03ce",
+         "\u03d0"-"\u03d7",
+         "\u03da"-"\u03f3",
+         "\u0400"-"\u0481",
+         "\u0483"-"\u0486",
+         "\u048c"-"\u04c4",
+         "\u04c7"-"\u04c8",
+         "\u04cb"-"\u04cc",
+         "\u04d0"-"\u04f5",
+         "\u04f8"-"\u04f9",
+         "\u0531"-"\u0556",
+         "\u0559",
+         "\u0561"-"\u0587",
+         "\u0591"-"\u05a1",
+         "\u05a3"-"\u05b9",
+         "\u05bb"-"\u05bd",
+         "\u05bf",
+         "\u05c1"-"\u05c2",
+         "\u05c4",
+         "\u05d0"-"\u05ea",
+         "\u05f0"-"\u05f2",
+         "\u0621"-"\u063a",
+         "\u0640"-"\u0655",
+         "\u0660"-"\u0669",
+         "\u0670"-"\u06d3",
+         "\u06d5"-"\u06dc",
+         "\u06df"-"\u06e8",
+         "\u06ea"-"\u06ed",
+         "\u06f0"-"\u06fc",
+         "\u070f"-"\u072c",
+         "\u0730"-"\u074a",
+         "\u0780"-"\u07b0",
+         "\u0901"-"\u0903",
+         "\u0905"-"\u0939",
+         "\u093c"-"\u094d",
+         "\u0950"-"\u0954",
+         "\u0958"-"\u0963",
+         "\u0966"-"\u096f",
+         "\u0981"-"\u0983",
+         "\u0985"-"\u098c",
+         "\u098f"-"\u0990",
+         "\u0993"-"\u09a8",
+         "\u09aa"-"\u09b0",
+         "\u09b2",
+         "\u09b6"-"\u09b9",
+         "\u09bc",
+         "\u09be"-"\u09c4",
+         "\u09c7"-"\u09c8",
+         "\u09cb"-"\u09cd",
+         "\u09d7",
+         "\u09dc"-"\u09dd",
+         "\u09df"-"\u09e3",
+         "\u09e6"-"\u09f3",
+         "\u0a02",
+         "\u0a05"-"\u0a0a",
+         "\u0a0f"-"\u0a10",
+         "\u0a13"-"\u0a28",
+         "\u0a2a"-"\u0a30",
+         "\u0a32"-"\u0a33",
+         "\u0a35"-"\u0a36",
+         "\u0a38"-"\u0a39",
+         "\u0a3c",
+         "\u0a3e"-"\u0a42",
+         "\u0a47"-"\u0a48",
+         "\u0a4b"-"\u0a4d",
+         "\u0a59"-"\u0a5c",
+         "\u0a5e",
+         "\u0a66"-"\u0a74",
+         "\u0a81"-"\u0a83",
+         "\u0a85"-"\u0a8b",
+         "\u0a8d",
+         "\u0a8f"-"\u0a91",
+         "\u0a93"-"\u0aa8",
+         "\u0aaa"-"\u0ab0",
+         "\u0ab2"-"\u0ab3",
+         "\u0ab5"-"\u0ab9",
+         "\u0abc"-"\u0ac5",
+         "\u0ac7"-"\u0ac9",
+         "\u0acb"-"\u0acd",
+         "\u0ad0",
+         "\u0ae0",
+         "\u0ae6"-"\u0aef",
+         "\u0b01"-"\u0b03",
+         "\u0b05"-"\u0b0c",
+         "\u0b0f"-"\u0b10",
+         "\u0b13"-"\u0b28",
+         "\u0b2a"-"\u0b30",
+         "\u0b32"-"\u0b33",
+         "\u0b36"-"\u0b39",
+         "\u0b3c"-"\u0b43",
+         "\u0b47"-"\u0b48",
+         "\u0b4b"-"\u0b4d",
+         "\u0b56"-"\u0b57",
+         "\u0b5c"-"\u0b5d",
+         "\u0b5f"-"\u0b61",
+         "\u0b66"-"\u0b6f",
+         "\u0b82"-"\u0b83",
+         "\u0b85"-"\u0b8a",
+         "\u0b8e"-"\u0b90",
+         "\u0b92"-"\u0b95",
+         "\u0b99"-"\u0b9a",
+         "\u0b9c",
+         "\u0b9e"-"\u0b9f",
+         "\u0ba3"-"\u0ba4",
+         "\u0ba8"-"\u0baa",
+         "\u0bae"-"\u0bb5",
+         "\u0bb7"-"\u0bb9",
+         "\u0bbe"-"\u0bc2",
+         "\u0bc6"-"\u0bc8",
+         "\u0bca"-"\u0bcd",
+         "\u0bd7",
+         "\u0be7"-"\u0bef",
+         "\u0c01"-"\u0c03",
+         "\u0c05"-"\u0c0c",
+         "\u0c0e"-"\u0c10",
+         "\u0c12"-"\u0c28",
+         "\u0c2a"-"\u0c33",
+         "\u0c35"-"\u0c39",
+         "\u0c3e"-"\u0c44",
+         "\u0c46"-"\u0c48",
+         "\u0c4a"-"\u0c4d",
+         "\u0c55"-"\u0c56",
+         "\u0c60"-"\u0c61",
+         "\u0c66"-"\u0c6f",
+         "\u0c82"-"\u0c83",
+         "\u0c85"-"\u0c8c",
+         "\u0c8e"-"\u0c90",
+         "\u0c92"-"\u0ca8",
+         "\u0caa"-"\u0cb3",
+         "\u0cb5"-"\u0cb9",
+         "\u0cbe"-"\u0cc4",
+         "\u0cc6"-"\u0cc8",
+         "\u0cca"-"\u0ccd",
+         "\u0cd5"-"\u0cd6",
+         "\u0cde",
+         "\u0ce0"-"\u0ce1",
+         "\u0ce6"-"\u0cef",
+         "\u0d02"-"\u0d03",
+         "\u0d05"-"\u0d0c",
+         "\u0d0e"-"\u0d10",
+         "\u0d12"-"\u0d28",
+         "\u0d2a"-"\u0d39",
+         "\u0d3e"-"\u0d43",
+         "\u0d46"-"\u0d48",
+         "\u0d4a"-"\u0d4d",
+         "\u0d57",
+         "\u0d60"-"\u0d61",
+         "\u0d66"-"\u0d6f",
+         "\u0d82"-"\u0d83",
+         "\u0d85"-"\u0d96",
+         "\u0d9a"-"\u0db1",
+         "\u0db3"-"\u0dbb",
+         "\u0dbd",
+         "\u0dc0"-"\u0dc6",
+         "\u0dca",
+         "\u0dcf"-"\u0dd4",
+         "\u0dd6",
+         "\u0dd8"-"\u0ddf",
+         "\u0df2"-"\u0df3",
+         "\u0e01"-"\u0e3a",
+         "\u0e3f"-"\u0e4e",
+         "\u0e50"-"\u0e59",
+         "\u0e81"-"\u0e82",
+         "\u0e84",
+         "\u0e87"-"\u0e88",
+         "\u0e8a",
+         "\u0e8d",
+         "\u0e94"-"\u0e97",
+         "\u0e99"-"\u0e9f",
+         "\u0ea1"-"\u0ea3",
+         "\u0ea5",
+         "\u0ea7",
+         "\u0eaa"-"\u0eab",
+         "\u0ead"-"\u0eb9",
+         "\u0ebb"-"\u0ebd",
+         "\u0ec0"-"\u0ec4",
+         "\u0ec6",
+         "\u0ec8"-"\u0ecd",
+         "\u0ed0"-"\u0ed9",
+         "\u0edc"-"\u0edd",
+         "\u0f00",
+         "\u0f18"-"\u0f19",
+         "\u0f20"-"\u0f29",
+         "\u0f35",
+         "\u0f37",
+         "\u0f39",
+         "\u0f3e"-"\u0f47",
+         "\u0f49"-"\u0f6a",
+         "\u0f71"-"\u0f84",
+         "\u0f86"-"\u0f8b",
+         "\u0f90"-"\u0f97",
+         "\u0f99"-"\u0fbc",
+         "\u0fc6",
+         "\u1000"-"\u1021",
+         "\u1023"-"\u1027",
+         "\u1029"-"\u102a",
+         "\u102c"-"\u1032",
+         "\u1036"-"\u1039",
+         "\u1040"-"\u1049",
+         "\u1050"-"\u1059",
+         "\u10a0"-"\u10c5",
+         "\u10d0"-"\u10f6",
+         "\u1100"-"\u1159",
+         "\u115f"-"\u11a2",
+         "\u11a8"-"\u11f9",
+         "\u1200"-"\u1206",
+         "\u1208"-"\u1246",
+         "\u1248",
+         "\u124a"-"\u124d",
+         "\u1250"-"\u1256",
+         "\u1258",
+         "\u125a"-"\u125d",
+         "\u1260"-"\u1286",
+         "\u1288",
+         "\u128a"-"\u128d",
+         "\u1290"-"\u12ae",
+         "\u12b0",
+         "\u12b2"-"\u12b5",
+         "\u12b8"-"\u12be",
+         "\u12c0",
+         "\u12c2"-"\u12c5",
+         "\u12c8"-"\u12ce",
+         "\u12d0"-"\u12d6",
+         "\u12d8"-"\u12ee",
+         "\u12f0"-"\u130e",
+         "\u1310",
+         "\u1312"-"\u1315",
+         "\u1318"-"\u131e",
+         "\u1320"-"\u1346",
+         "\u1348"-"\u135a",
+         "\u1369"-"\u1371",
+         "\u13a0"-"\u13f4",
+         "\u1401"-"\u166c",
+         "\u166f"-"\u1676",
+         "\u1681"-"\u169a",
+         "\u16a0"-"\u16ea",
+         "\u1780"-"\u17d3",
+         "\u17db",
+         "\u17e0"-"\u17e9",
+         "\u180b"-"\u180e",
+         "\u1810"-"\u1819",
+         "\u1820"-"\u1877",
+         "\u1880"-"\u18a9",
+         "\u1e00"-"\u1e9b",
+         "\u1ea0"-"\u1ef9",
+         "\u1f00"-"\u1f15",
+         "\u1f18"-"\u1f1d",
+         "\u1f20"-"\u1f45",
+         "\u1f48"-"\u1f4d",
+         "\u1f50"-"\u1f57",
+         "\u1f59",
+         "\u1f5b",
+         "\u1f5d",
+         "\u1f5f"-"\u1f7d",
+         "\u1f80"-"\u1fb4",
+         "\u1fb6"-"\u1fbc",
+         "\u1fbe",
+         "\u1fc2"-"\u1fc4",
+         "\u1fc6"-"\u1fcc",
+         "\u1fd0"-"\u1fd3",
+         "\u1fd6"-"\u1fdb",
+         "\u1fe0"-"\u1fec",
+         "\u1ff2"-"\u1ff4",
+         "\u1ff6"-"\u1ffc",
+         "\u200c"-"\u200f",
+         "\u202a"-"\u202e",
+         "\u203f"-"\u2040",
+         "\u206a"-"\u206f",
+         "\u207f",
+         "\u20a0"-"\u20af",
+         "\u20d0"-"\u20dc",
+         "\u20e1",
+         "\u2102",
+         "\u2107",
+         "\u210a"-"\u2113",
+         "\u2115",
+         "\u2119"-"\u211d",
+         "\u2124",
+         "\u2126",
+         "\u2128",
+         "\u212a"-"\u212d",
+         "\u212f"-"\u2131",
+         "\u2133"-"\u2139",
+         "\u2160"-"\u2183",
+         "\u3005"-"\u3007",
+         "\u3021"-"\u302f",
+         "\u3031"-"\u3035",
+         "\u3038"-"\u303a",
+         "\u3041"-"\u3094",
+         "\u3099"-"\u309a",
+         "\u309d"-"\u309e",
+         "\u30a1"-"\u30fe",
+         "\u3105"-"\u312c",
+         "\u3131"-"\u318e",
+         "\u31a0"-"\u31b7",
+         "\u3400"-"\u4db5",
+         "\u4e00"-"\u9fa5",
+         "\ua000"-"\ua48c",
+         "\uac00"-"\ud7a3",
+         "\uf900"-"\ufa2d",
+         "\ufb00"-"\ufb06",
+         "\ufb13"-"\ufb17",
+         "\ufb1d"-"\ufb28",
+         "\ufb2a"-"\ufb36",
+         "\ufb38"-"\ufb3c",
+         "\ufb3e",
+         "\ufb40"-"\ufb41",
+         "\ufb43"-"\ufb44",
+         "\ufb46"-"\ufbb1",
+         "\ufbd3"-"\ufd3d",
+         "\ufd50"-"\ufd8f",
+         "\ufd92"-"\ufdc7",
+         "\ufdf0"-"\ufdfb",
+         "\ufe20"-"\ufe23",
+         "\ufe33"-"\ufe34",
+         "\ufe4d"-"\ufe4f",
+         "\ufe69",
+         "\ufe70"-"\ufe72",
+         "\ufe74",
+         "\ufe76"-"\ufefc",
+         "\ufeff",
+         "\uff04",
+         "\uff10"-"\uff19",
+         "\uff21"-"\uff3a",
+         "\uff3f",
+         "\uff41"-"\uff5a",
+         "\uff65"-"\uffbe",
+         "\uffc2"-"\uffc7",
+         "\uffca"-"\uffcf",
+         "\uffd2"-"\uffd7",
+         "\uffda"-"\uffdc",
+         "\uffe0"-"\uffe1",
+         "\uffe5"-"\uffe6",
+         "\ufff9"-"\ufffb"
+      ]
+  >
+}
diff --git a/generated/org/javacc/jjtree/JJTreeParser.java b/generated/org/javacc/jjtree/JJTreeParser.java
new file mode 100644
index 00000000..63595df4
--- /dev/null
+++ b/generated/org/javacc/jjtree/JJTreeParser.java
@@ -0,0 +1,9674 @@
+/* Generated By:JJTree&JavaCC: Do not edit this line. JJTreeParser.java */
+package org.javacc.jjtree;
+
+public class JJTreeParser/*@bgen(jjtree)*/implements JJTreeParserTreeConstants, JJTreeParserConstants {/*@bgen(jjtree)*/
+  protected JJTJJTreeParserState jjtree = new JJTJJTreeParserState();
+  void jjtreeOpenNodeScope(Node n)
+  {
+        ((JJTreeNode)n).setFirstToken(getToken(1));
+  }
+
+  void jjtreeCloseNodeScope(Node n)
+  {
+        ((JJTreeNode)n).setLastToken(getToken(0));
+  }
+
+
+  /**
+   * Returns true if the next token is not in the FOLLOW list of "expansion".
+   * It is used to decide when the end of an "expansion" has been reached.
+   */
+  private boolean notTailOfExpansionUnit() {
+    Token t;
+    t = getToken(1);
+    if (t.kind == BIT_OR || t.kind == COMMA || t.kind == RPAREN || t.kind == RBRACE || t.kind == RBRACKET) return false;
+    return true;
+  }
+
+  protected boolean isJavaLanguage = true;
+
+  private void eatUptoCloseBrace() {
+    int b = 1;
+    while(getToken(1).kind != RBRACE || --b != 0) {
+      if (getToken(1).kind == EOF) break;
+      if (getNextToken().kind == LBRACE) b++;
+    }
+  }
+
+/************************************************
+ * THE JAVACC GRAMMAR SPECIFICATION STARTS HERE *
+ ************************************************/
+  final public void javacc_input() throws ParseException {
+         /*@bgen(jjtree) Grammar */
+          ASTGrammar jjtn000 = new ASTGrammar(JJTGRAMMAR);
+          boolean jjtc000 = true;
+          jjtree.openNodeScope(jjtn000);
+          jjtreeOpenNodeScope(jjtn000);Token t;
+    try {
+      javacc_options();
+    // TODO :: CBA --  Require Unification of output language specific processing into a single Enum class
+    isJavaLanguage = JJTreeOptions.isOutputLanguageJava();
+    ASTCompilationUnit jjtn001 = new ASTCompilationUnit(JJTCOMPILATIONUNIT);
+    boolean jjtc001 = true;
+    jjtree.openNodeScope(jjtn001);
+    jjtreeOpenNodeScope(jjtn001);
+      try {
+        jj_consume_token(_PARSER_BEGIN);
+        jj_consume_token(LPAREN);
+        t = identifier();
+        jj_consume_token(RPAREN);
+          JJTreeGlobals.parserName = t.image;
+
+          if (!isJavaLanguage) {
+            while(getToken(1).kind != _PARSER_END) {
+              getNextToken();
+            }
+          }
+        CompilationUnit();
+        jj_consume_token(_PARSER_END);
+        jj_consume_token(LPAREN);
+        identifier();
+        jj_consume_token(RPAREN);
+          jjtree.closeNodeScope(jjtn001,  true);
+          jjtc001 = false;
+          jjtreeCloseNodeScope(jjtn001);
+          if (JJTreeOptions.getNodePackage().equals("")) {
+            JJTreeGlobals.nodePackageName = JJTreeGlobals.packageName;
+          } else {
+            JJTreeGlobals.nodePackageName = JJTreeOptions.getNodePackage();
+          }
+      } catch (Throwable jjte001) {
+    if (jjtc001) {
+      jjtree.clearNodeScope(jjtn001);
+      jjtc001 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte001 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte001;}
+    }
+    if (jjte001 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte001;}
+    }
+    {if (true) throw (Error)jjte001;}
+      } finally {
+    if (jjtc001) {
+      jjtree.closeNodeScope(jjtn001,  true);
+      jjtreeCloseNodeScope(jjtn001);
+    }
+      }
+    ASTProductions jjtn002 = new ASTProductions(JJTPRODUCTIONS);
+    boolean jjtc002 = true;
+    jjtree.openNodeScope(jjtn002);
+    jjtreeOpenNodeScope(jjtn002);
+      try {
+        label_1:
+        while (true) {
+          production();
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case _LOOKAHEAD:
+          case _IGNORE_CASE:
+          case _PARSER_BEGIN:
+          case _PARSER_END:
+          case _JAVACODE:
+          case _TOKEN:
+          case _SPECIAL_TOKEN:
+          case _MORE:
+          case _SKIP:
+          case _TOKEN_MGR_DECLS:
+          case _EOF:
+          case BOOLEAN:
+          case BYTE:
+          case CHAR:
+          case CONST:
+          case DOUBLE:
+          case FLOAT:
+          case INT:
+          case LONG:
+          case PRIVATE:
+          case PROTECTED:
+          case PUBLIC:
+          case SHORT:
+          case VOID:
+          case LT:
+          case 132:
+          case IDENTIFIER:
+            ;
+            break;
+          default:
+            jj_la1[0] = jj_gen;
+            break label_1;
+          }
+        }
+      } catch (Throwable jjte002) {
+    if (jjtc002) {
+      jjtree.clearNodeScope(jjtn002);
+      jjtc002 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte002 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte002;}
+    }
+    if (jjte002 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte002;}
+    }
+    {if (true) throw (Error)jjte002;}
+      } finally {
+    if (jjtc002) {
+      jjtree.closeNodeScope(jjtn002, true);
+      jjtreeCloseNodeScope(jjtn002);
+    }
+      }
+      jj_consume_token(0);
+    } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      jjtreeCloseNodeScope(jjtn000);
+    }
+    }
+  }
+
+  final public void javacc_options() throws ParseException {
+    if (getToken(1).image.equals("options")) {
+                                                          ASTOptions jjtn001 = new ASTOptions(JJTOPTIONS);
+                                                          boolean jjtc001 = true;
+                                                          jjtree.openNodeScope(jjtn001);
+                                                          jjtreeOpenNodeScope(jjtn001);
+      try {
+        jj_consume_token(IDENTIFIER);
+        jj_consume_token(LBRACE);
+        label_2:
+        while (true) {
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case _LOOKAHEAD:
+          case _IGNORE_CASE:
+          case STATIC:
+          case IDENTIFIER:
+            ;
+            break;
+          default:
+            jj_la1[1] = jj_gen;
+            break label_2;
+          }
+          option_binding();
+        }
+        jj_consume_token(RBRACE);
+      } catch (Throwable jjte001) {
+                                                          if (jjtc001) {
+                                                            jjtree.clearNodeScope(jjtn001);
+                                                            jjtc001 = false;
+                                                          } else {
+                                                            jjtree.popNode();
+                                                          }
+                                                          if (jjte001 instanceof RuntimeException) {
+                                                            {if (true) throw (RuntimeException)jjte001;}
+                                                          }
+                                                          if (jjte001 instanceof ParseException) {
+                                                            {if (true) throw (ParseException)jjte001;}
+                                                          }
+                                                          {if (true) throw (Error)jjte001;}
+      } finally {
+                                                          if (jjtc001) {
+                                                            jjtree.closeNodeScope(jjtn001, true);
+                                                            jjtreeCloseNodeScope(jjtn001);
+                                                          }
+      }
+    } else {
+      ;
+    }
+          JJTreeOptions.normalize();
+  }
+
+  final public void option_binding() throws ParseException {
+         /*@bgen(jjtree) OptionBinding */
+          ASTOptionBinding jjtn000 = new ASTOptionBinding(JJTOPTIONBINDING);
+          boolean jjtc000 = true;
+          jjtree.openNodeScope(jjtn000);
+          jjtreeOpenNodeScope(jjtn000);Token o, v;
+    try {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case IDENTIFIER:
+        o = jj_consume_token(IDENTIFIER);
+        break;
+      case _LOOKAHEAD:
+        o = jj_consume_token(_LOOKAHEAD);
+        break;
+      case _IGNORE_CASE:
+        o = jj_consume_token(_IGNORE_CASE);
+        break;
+      case STATIC:
+        o = jj_consume_token(STATIC);
+        break;
+      default:
+        jj_la1[2] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      jj_consume_token(ASSIGN);
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case INTEGER_LITERAL:
+        v = IntegerLiteral();
+          JJTreeOptions.setInputFileOption(o, v, o.image, Integer.valueOf(v.image));
+          jjtn000.initialize(o.image, v.image);
+        break;
+      case FALSE:
+      case TRUE:
+        v = BooleanLiteral();
+          JJTreeOptions.setInputFileOption(o, v, o.image,
+                                     Boolean.valueOf(v.image));
+          jjtn000.initialize(o.image, v.image);
+        break;
+      case STRING_LITERAL:
+        v = StringLiteral();
+          String vs = TokenUtils.remove_escapes_and_quotes(v, v.image);
+          JJTreeOptions.setInputFileOption(o, v, o.image, (Object)vs);
+          jjtn000.initialize(o.image, vs);
+        break;
+      default:
+        jj_la1[3] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      jjtreeCloseNodeScope(jjtn000);
+    }
+    }
+  }
+
+  final public void production() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case _JAVACODE:
+      javacode_production();
+      break;
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case LT:
+      regular_expr_production();
+      break;
+    case _TOKEN_MGR_DECLS:
+      token_manager_decls();
+      break;
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _EOF:
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case CONST:
+    case DOUBLE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case PRIVATE:
+    case PROTECTED:
+    case PUBLIC:
+    case SHORT:
+    case VOID:
+    case 132:
+    case IDENTIFIER:
+      bnf_production();
+      break;
+    default:
+      jj_la1[4] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void javacode_production() throws ParseException {
+         /*@bgen(jjtree) Javacode */
+          ASTJavacode jjtn000 = new ASTJavacode(JJTJAVACODE);
+          boolean jjtc000 = true;
+          jjtree.openNodeScope(jjtn000);
+          jjtreeOpenNodeScope(jjtn000);Token t1, t2;
+          ASTJavacode prod;
+          ASTNodeDescriptor nd = null;
+          String n;
+    try {
+          prod = jjtn000;
+      jj_consume_token(_JAVACODE);
+      AccessModifier();
+      ResultType();
+      t1 = identifier();
+      FormalParameters();
+    if (!isJavaLanguage) {
+      while(getToken(1).kind != LBRACE) {
+        getNextToken();
+      }
+    }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case THROWS:
+        jj_consume_token(THROWS);
+        n = Name();
+          prod.throws_list.addElement(n);
+        label_3:
+        while (true) {
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case COMMA:
+            ;
+            break;
+          default:
+            jj_la1[5] = jj_gen;
+            break label_3;
+          }
+          jj_consume_token(COMMA);
+          n = Name();
+          prod.throws_list.addElement(n);
+        }
+        break;
+      default:
+        jj_la1[6] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case HASH:
+        nd = node_descriptor();
+        break;
+      default:
+        jj_la1[7] = jj_gen;
+        ;
+      }
+      // This is really a Block()
+          t2 = jj_consume_token(LBRACE);
+          prod.name = t1.image;
+          prod.stmBeginLoc = t2;
+          if (!isJavaLanguage) {
+            eatUptoCloseBrace();
+          }
+      ASTJavacodeBody jjtn001 = new ASTJavacodeBody(JJTJAVACODEBODY);
+      boolean jjtc001 = true;
+      jjtree.openNodeScope(jjtn001);
+      jjtreeOpenNodeScope(jjtn001);
+      try {
+        label_4:
+        while (true) {
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case _LOOKAHEAD:
+          case _IGNORE_CASE:
+          case _PARSER_BEGIN:
+          case _PARSER_END:
+          case _JAVACODE:
+          case _TOKEN:
+          case _SPECIAL_TOKEN:
+          case _MORE:
+          case _SKIP:
+          case _TOKEN_MGR_DECLS:
+          case _EOF:
+          case ABSTRACT:
+          case BOOLEAN:
+          case BREAK:
+          case BYTE:
+          case CHAR:
+          case CLASS:
+          case CONST:
+          case CONTINUE:
+          case DO:
+          case DOUBLE:
+          case FALSE:
+          case FINAL:
+          case FLOAT:
+          case FOR:
+          case IF:
+          case INT:
+          case INTERFACE:
+          case LONG:
+          case NATIVE:
+          case NEW:
+          case NULL:
+          case PRIVATE:
+          case PROTECTED:
+          case PUBLIC:
+          case RETURN:
+          case SHORT:
+          case STATIC:
+          case SUPER:
+          case SWITCH:
+          case SYNCHRONIZED:
+          case THIS:
+          case THROW:
+          case TRANSIENT:
+          case TRUE:
+          case TRY:
+          case VOID:
+          case VOLATILE:
+          case WHILE:
+          case INTEGER_LITERAL:
+          case FLOATING_POINT_LITERAL:
+          case CHARACTER_LITERAL:
+          case STRING_LITERAL:
+          case LPAREN:
+          case LBRACE:
+          case SEMICOLON:
+          case INCR:
+          case DECR:
+          case 129:
+          case 132:
+          case 138:
+          case 139:
+          case IDENTIFIER:
+            ;
+            break;
+          default:
+            jj_la1[8] = jj_gen;
+            break label_4;
+          }
+          BlockStatement();
+        }
+          jjtree.closeNodeScope(jjtn001, true);
+          jjtc001 = false;
+          jjtreeCloseNodeScope(jjtn001);
+          jjtn001.node_scope = new NodeScope(prod, nd);
+      } catch (Throwable jjte001) {
+      if (jjtc001) {
+        jjtree.clearNodeScope(jjtn001);
+        jjtc001 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte001 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte001;}
+      }
+      if (jjte001 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte001;}
+      }
+      {if (true) throw (Error)jjte001;}
+      } finally {
+      if (jjtc001) {
+        jjtree.closeNodeScope(jjtn001, true);
+        jjtreeCloseNodeScope(jjtn001);
+      }
+      }
+      jj_consume_token(RBRACE);
+          jjtree.closeNodeScope(jjtn000, true);
+          jjtc000 = false;
+          jjtreeCloseNodeScope(jjtn000);
+          JJTreeGlobals.productions.put(prod.name, prod);
+    } catch (Throwable jjte000) {
+          if (jjtc000) {
+            jjtree.clearNodeScope(jjtn000);
+            jjtc000 = false;
+          } else {
+            jjtree.popNode();
+          }
+          if (jjte000 instanceof RuntimeException) {
+            {if (true) throw (RuntimeException)jjte000;}
+          }
+          if (jjte000 instanceof ParseException) {
+            {if (true) throw (ParseException)jjte000;}
+          }
+          {if (true) throw (Error)jjte000;}
+    } finally {
+          if (jjtc000) {
+            jjtree.closeNodeScope(jjtn000, true);
+            jjtreeCloseNodeScope(jjtn000);
+          }
+    }
+  }
+
+  final public void bnf_production() throws ParseException {
+         /*@bgen(jjtree) BNF */
+          ASTBNF jjtn000 = new ASTBNF(JJTBNF);
+          boolean jjtc000 = true;
+          jjtree.openNodeScope(jjtn000);
+          jjtreeOpenNodeScope(jjtn000);Token t1, t2;
+          ASTBNF prod;
+          ASTNodeDescriptor nd = null;
+          NodeScope ns;
+          JJTreeNode eu;
+          String n;
+    try {
+          prod = jjtn000;
+      AccessModifier();
+      ResultType();
+      t1 = identifier();
+      FormalParameters();
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case THROWS:
+        jj_consume_token(THROWS);
+        n = Name();
+          prod.throws_list.addElement(n);
+        label_5:
+        while (true) {
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case COMMA:
+            ;
+            break;
+          default:
+            jj_la1[9] = jj_gen;
+            break label_5;
+          }
+          jj_consume_token(COMMA);
+          n = Name();
+          prod.throws_list.addElement(n);
+        }
+        break;
+      default:
+        jj_la1[10] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case HASH:
+        nd = node_descriptor();
+        break;
+      default:
+        jj_la1[11] = jj_gen;
+        ;
+      }
+      jj_consume_token(COLON);
+      // This is really a Block()
+        t2 = jj_consume_token(LBRACE);
+          prod.name = t1.image;
+          prod.declBeginLoc = t2;
+          ns = new NodeScope(prod, nd);
+          if (!isJavaLanguage) {
+            eatUptoCloseBrace();
+          }
+    ASTBNFDeclaration jjtn001 = new ASTBNFDeclaration(JJTBNFDECLARATION);
+    boolean jjtc001 = true;
+    jjtree.openNodeScope(jjtn001);
+    jjtreeOpenNodeScope(jjtn001);
+      try {
+        label_6:
+        while (true) {
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case _LOOKAHEAD:
+          case _IGNORE_CASE:
+          case _PARSER_BEGIN:
+          case _PARSER_END:
+          case _JAVACODE:
+          case _TOKEN:
+          case _SPECIAL_TOKEN:
+          case _MORE:
+          case _SKIP:
+          case _TOKEN_MGR_DECLS:
+          case _EOF:
+          case ABSTRACT:
+          case BOOLEAN:
+          case BREAK:
+          case BYTE:
+          case CHAR:
+          case CLASS:
+          case CONST:
+          case CONTINUE:
+          case DO:
+          case DOUBLE:
+          case FALSE:
+          case FINAL:
+          case FLOAT:
+          case FOR:
+          case IF:
+          case INT:
+          case INTERFACE:
+          case LONG:
+          case NATIVE:
+          case NEW:
+          case NULL:
+          case PRIVATE:
+          case PROTECTED:
+          case PUBLIC:
+          case RETURN:
+          case SHORT:
+          case STATIC:
+          case SUPER:
+          case SWITCH:
+          case SYNCHRONIZED:
+          case THIS:
+          case THROW:
+          case TRANSIENT:
+          case TRUE:
+          case TRY:
+          case VOID:
+          case VOLATILE:
+          case WHILE:
+          case INTEGER_LITERAL:
+          case FLOATING_POINT_LITERAL:
+          case CHARACTER_LITERAL:
+          case STRING_LITERAL:
+          case LPAREN:
+          case LBRACE:
+          case SEMICOLON:
+          case INCR:
+          case DECR:
+          case 129:
+          case 132:
+          case 138:
+          case 139:
+          case IDENTIFIER:
+            ;
+            break;
+          default:
+            jj_la1[12] = jj_gen;
+            break label_6;
+          }
+          BlockStatement();
+        }
+          jjtree.closeNodeScope(jjtn001, true);
+          jjtc001 = false;
+          jjtreeCloseNodeScope(jjtn001);
+          jjtn001.node_scope = ns;
+      } catch (Throwable jjte001) {
+    if (jjtc001) {
+      jjtree.clearNodeScope(jjtn001);
+      jjtc001 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte001 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte001;}
+    }
+    if (jjte001 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte001;}
+    }
+    {if (true) throw (Error)jjte001;}
+      } finally {
+    if (jjtc001) {
+      jjtree.closeNodeScope(jjtn001, true);
+      jjtreeCloseNodeScope(jjtn001);
+    }
+      }
+      jj_consume_token(RBRACE);
+      jj_consume_token(LBRACE);
+    ASTBNFNodeScope jjtn002 = new ASTBNFNodeScope(JJTBNFNODESCOPE);
+    boolean jjtc002 = true;
+    jjtree.openNodeScope(jjtn002);
+    jjtreeOpenNodeScope(jjtn002);
+      try {
+        eu = expansion_choices(prod);
+          jjtree.closeNodeScope(jjtn002, true);
+          jjtc002 = false;
+          jjtreeCloseNodeScope(jjtn002);
+          jjtn002.node_scope = ns;
+          jjtn002.expansion_unit = eu;
+      } catch (Throwable jjte002) {
+    if (jjtc002) {
+      jjtree.clearNodeScope(jjtn002);
+      jjtc002 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte002 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte002;}
+    }
+    if (jjte002 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte002;}
+    }
+    {if (true) throw (Error)jjte002;}
+      } finally {
+    if (jjtc002) {
+      jjtree.closeNodeScope(jjtn002, true);
+      jjtreeCloseNodeScope(jjtn002);
+    }
+      }
+      jj_consume_token(RBRACE);
+          jjtree.closeNodeScope(jjtn000, true);
+          jjtc000 = false;
+          jjtreeCloseNodeScope(jjtn000);
+          JJTreeGlobals.productions.put(prod.name, prod);
+    } catch (Throwable jjte000) {
+          if (jjtc000) {
+            jjtree.clearNodeScope(jjtn000);
+            jjtc000 = false;
+          } else {
+            jjtree.popNode();
+          }
+          if (jjte000 instanceof RuntimeException) {
+            {if (true) throw (RuntimeException)jjte000;}
+          }
+          if (jjte000 instanceof ParseException) {
+            {if (true) throw (ParseException)jjte000;}
+          }
+          {if (true) throw (Error)jjte000;}
+    } finally {
+          if (jjtc000) {
+            jjtree.closeNodeScope(jjtn000, true);
+            jjtreeCloseNodeScope(jjtn000);
+          }
+    }
+  }
+
+  final public void AccessModifier() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case PRIVATE:
+    case PROTECTED:
+    case PUBLIC:
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case PUBLIC:
+        jj_consume_token(PUBLIC);
+        break;
+      case PROTECTED:
+        jj_consume_token(PROTECTED);
+        break;
+      case PRIVATE:
+        jj_consume_token(PRIVATE);
+        break;
+      default:
+        jj_la1[13] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      break;
+    default:
+      jj_la1[14] = jj_gen;
+      ;
+    }
+  }
+
+  final public void regular_expr_production() throws ParseException {
+         /*@bgen(jjtree) RE */
+  ASTRE jjtn000 = new ASTRE(JJTRE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LT:
+        if (jj_2_1(2)) {
+          jj_consume_token(LT);
+          jj_consume_token(STAR);
+          jj_consume_token(GT);
+        } else {
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case LT:
+            jj_consume_token(LT);
+            jj_consume_token(IDENTIFIER);
+            label_7:
+            while (true) {
+              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+              case COMMA:
+                ;
+                break;
+              default:
+                jj_la1[15] = jj_gen;
+                break label_7;
+              }
+              jj_consume_token(COMMA);
+              jj_consume_token(IDENTIFIER);
+            }
+            jj_consume_token(GT);
+            break;
+          default:
+            jj_la1[16] = jj_gen;
+            jj_consume_token(-1);
+            throw new ParseException();
+          }
+        }
+        break;
+      default:
+        jj_la1[17] = jj_gen;
+        ;
+      }
+      regexpr_kind();
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LBRACKET:
+        jj_consume_token(LBRACKET);
+        jj_consume_token(_IGNORE_CASE);
+        jj_consume_token(RBRACKET);
+        break;
+      default:
+        jj_la1[18] = jj_gen;
+        ;
+      }
+      jj_consume_token(COLON);
+      jj_consume_token(LBRACE);
+      regexpr_spec();
+      label_8:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case BIT_OR:
+          ;
+          break;
+        default:
+          jj_la1[19] = jj_gen;
+          break label_8;
+        }
+        jj_consume_token(BIT_OR);
+        regexpr_spec();
+      }
+      jj_consume_token(RBRACE);
+    } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      jjtreeCloseNodeScope(jjtn000);
+    }
+    }
+  }
+
+  final public void token_manager_decls() throws ParseException {
+         /*@bgen(jjtree) TokenDecls */
+  ASTTokenDecls jjtn000 = new ASTTokenDecls(JJTTOKENDECLS);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(_TOKEN_MGR_DECLS);
+      jj_consume_token(COLON);
+    if (!isJavaLanguage) {
+      getNextToken(); // eat { 
+      eatUptoCloseBrace();
+      getNextToken(); // eat } 
+    }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LBRACE:
+        ClassOrInterfaceBody();
+        break;
+      default:
+        jj_la1[20] = jj_gen;
+        ;
+      }
+    } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      jjtreeCloseNodeScope(jjtn000);
+    }
+    }
+  }
+
+  final public void regexpr_kind() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case _TOKEN:
+      jj_consume_token(_TOKEN);
+      break;
+    case _SPECIAL_TOKEN:
+      jj_consume_token(_SPECIAL_TOKEN);
+      break;
+    case _SKIP:
+      jj_consume_token(_SKIP);
+      break;
+    case _MORE:
+      jj_consume_token(_MORE);
+      break;
+    default:
+      jj_la1[21] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void regexpr_spec() throws ParseException {
+ /*@bgen(jjtree) RESpec */
+  ASTRESpec jjtn000 = new ASTRESpec(JJTRESPEC);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      regular_expression();
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LBRACE:
+        Block();
+        break;
+      default:
+        jj_la1[22] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COLON:
+        jj_consume_token(COLON);
+        jj_consume_token(IDENTIFIER);
+        break;
+      default:
+        jj_la1[23] = jj_gen;
+        ;
+      }
+    } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      jjtreeCloseNodeScope(jjtn000);
+    }
+    }
+  }
+
+  final public JJTreeNode expansion_choices(ASTProduction p) throws ParseException {
+         /*@bgen(jjtree) #BNFChoice(> 1) */
+  ASTBNFChoice jjtn000 = new ASTBNFChoice(JJTBNFCHOICE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      expansion(p);
+      label_9:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case BIT_OR:
+          ;
+          break;
+        default:
+          jj_la1[24] = jj_gen;
+          break label_9;
+        }
+        jj_consume_token(BIT_OR);
+        expansion(p);
+      }
+          jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
+          jjtc000 = false;
+          jjtreeCloseNodeScope(jjtn000);
+          {if (true) return (JJTreeNode)jjtree.peekNode();}
+    } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
+      jjtreeCloseNodeScope(jjtn000);
+    }
+    }
+    throw new Error("Missing return statement in function");
+  }
+
+  final public void expansion(ASTProduction p) throws ParseException {
+         /*@bgen(jjtree) #BNFSequence(> 1) */
+          ASTBNFSequence jjtn000 = new ASTBNFSequence(JJTBNFSEQUENCE);
+          boolean jjtc000 = true;
+          jjtree.openNodeScope(jjtn000);
+          jjtreeOpenNodeScope(jjtn000);JJTreeNode eu;
+          ASTNodeDescriptor nd = null;
+    try {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case _LOOKAHEAD:
+      ASTBNFLookahead jjtn001 = new ASTBNFLookahead(JJTBNFLOOKAHEAD);
+      boolean jjtc001 = true;
+      jjtree.openNodeScope(jjtn001);
+      jjtreeOpenNodeScope(jjtn001);
+        try {
+          jj_consume_token(_LOOKAHEAD);
+          jj_consume_token(LPAREN);
+          local_lookahead(p);
+          jj_consume_token(RPAREN);
+        } catch (Throwable jjte001) {
+      if (jjtc001) {
+        jjtree.clearNodeScope(jjtn001);
+        jjtc001 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte001 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte001;}
+      }
+      if (jjte001 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte001;}
+      }
+      {if (true) throw (Error)jjte001;}
+        } finally {
+      if (jjtc001) {
+        jjtree.closeNodeScope(jjtn001, true);
+        jjtreeCloseNodeScope(jjtn001);
+      }
+        }
+        break;
+      default:
+        jj_la1[25] = jj_gen;
+        ;
+      }
+      label_10:
+      while (true) {
+     ASTExpansionNodeScope jjtn002 = new ASTExpansionNodeScope(JJTEXPANSIONNODESCOPE);
+     boolean jjtc002 = true;
+     jjtree.openNodeScope(jjtn002);
+     jjtreeOpenNodeScope(jjtn002);
+        try {
+          eu = expansion_unit(p);
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case HASH:
+            nd = node_descriptor();
+            break;
+          default:
+            jj_la1[26] = jj_gen;
+            ;
+          }
+          jjtree.closeNodeScope(jjtn002, jjtree.nodeArity() > 1);
+          jjtc002 = false;
+          jjtreeCloseNodeScope(jjtn002);
+          if (jjtree.nodeCreated()) {
+            jjtn002.node_scope = new NodeScope(p, nd);
+            jjtn002.expansion_unit = eu;
+          }
+        } catch (Throwable jjte002) {
+     if (jjtc002) {
+       jjtree.clearNodeScope(jjtn002);
+       jjtc002 = false;
+     } else {
+       jjtree.popNode();
+     }
+     if (jjte002 instanceof RuntimeException) {
+       {if (true) throw (RuntimeException)jjte002;}
+     }
+     if (jjte002 instanceof ParseException) {
+       {if (true) throw (ParseException)jjte002;}
+     }
+     {if (true) throw (Error)jjte002;}
+        } finally {
+     if (jjtc002) {
+       jjtree.closeNodeScope(jjtn002, jjtree.nodeArity() > 1);
+       jjtreeCloseNodeScope(jjtn002);
+     }
+        }
+        if (notTailOfExpansionUnit()) {
+          ;
+        } else {
+          break label_10;
+        }
+      }
+    } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
+      jjtreeCloseNodeScope(jjtn000);
+    }
+    }
+  }
+
+  final public void local_lookahead(ASTProduction p) throws ParseException {
+          boolean commaAtEnd = false, emptyLA = true;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case INTEGER_LITERAL:
+      IntegerLiteral();
+          emptyLA = false;
+      break;
+    default:
+      jj_la1[27] = jj_gen;
+      ;
+    }
+    if (!emptyLA && (getToken(1).kind != RPAREN)) {
+      jj_consume_token(COMMA);
+          commaAtEnd = true;
+    } else {
+      ;
+    }
+    if (getToken(1).kind != RPAREN && getToken(1).kind != LBRACE) {
+      expansion_choices(p);
+          emptyLA = false; commaAtEnd = false;
+    } else {
+      ;
+    }
+    if (!emptyLA && !commaAtEnd && (getToken(1).kind != RPAREN)) {
+      jj_consume_token(COMMA);
+          commaAtEnd = true;
+    } else {
+      ;
+    }
+    if (emptyLA || commaAtEnd) {
+      jj_consume_token(LBRACE);
+      if (!isJavaLanguage) {
+        eatUptoCloseBrace();
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case _LOOKAHEAD:
+      case _IGNORE_CASE:
+      case _PARSER_BEGIN:
+      case _PARSER_END:
+      case _JAVACODE:
+      case _TOKEN:
+      case _SPECIAL_TOKEN:
+      case _MORE:
+      case _SKIP:
+      case _TOKEN_MGR_DECLS:
+      case _EOF:
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case CONST:
+      case DOUBLE:
+      case FALSE:
+      case FLOAT:
+      case INT:
+      case LONG:
+      case NEW:
+      case NULL:
+      case SHORT:
+      case SUPER:
+      case THIS:
+      case TRUE:
+      case VOID:
+      case INTEGER_LITERAL:
+      case FLOATING_POINT_LITERAL:
+      case CHARACTER_LITERAL:
+      case STRING_LITERAL:
+      case LPAREN:
+      case BANG:
+      case TILDE:
+      case INCR:
+      case DECR:
+      case PLUS:
+      case MINUS:
+      case 132:
+      case IDENTIFIER:
+        Expression();
+        break;
+      default:
+        jj_la1[28] = jj_gen;
+        ;
+      }
+      jj_consume_token(RBRACE);
+    } else {
+      ;
+    }
+  }
+
+  final public JJTreeNode expansion_unit(ASTProduction p) throws ParseException {
+          Token t;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case _LOOKAHEAD:
+    ASTBNFLookahead jjtn001 = new ASTBNFLookahead(JJTBNFLOOKAHEAD);
+    boolean jjtc001 = true;
+    jjtree.openNodeScope(jjtn001);
+    jjtreeOpenNodeScope(jjtn001);
+      try {
+        jj_consume_token(_LOOKAHEAD);
+        jj_consume_token(LPAREN);
+        local_lookahead(p);
+        jj_consume_token(RPAREN);
+      } catch (Throwable jjte001) {
+    if (jjtc001) {
+      jjtree.clearNodeScope(jjtn001);
+      jjtc001 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte001 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte001;}
+    }
+    if (jjte001 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte001;}
+    }
+    {if (true) throw (Error)jjte001;}
+      } finally {
+    if (jjtc001) {
+      jjtree.closeNodeScope(jjtn001, true);
+      jjtreeCloseNodeScope(jjtn001);
+    }
+      }
+      break;
+    case LBRACE:
+    ASTBNFAction jjtn002 = new ASTBNFAction(JJTBNFACTION);
+    boolean jjtc002 = true;
+    jjtree.openNodeScope(jjtn002);
+    jjtreeOpenNodeScope(jjtn002);
+      try {
+        Block();
+      } catch (Throwable jjte002) {
+    if (jjtc002) {
+      jjtree.clearNodeScope(jjtn002);
+      jjtc002 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte002 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte002;}
+    }
+    if (jjte002 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte002;}
+    }
+    {if (true) throw (Error)jjte002;}
+      } finally {
+    if (jjtc002) {
+      jjtree.closeNodeScope(jjtn002, true);
+      jjtreeCloseNodeScope(jjtn002);
+    }
+      }
+      break;
+    case LBRACKET:
+    ASTBNFZeroOrOne jjtn003 = new ASTBNFZeroOrOne(JJTBNFZEROORONE);
+    boolean jjtc003 = true;
+    jjtree.openNodeScope(jjtn003);
+    jjtreeOpenNodeScope(jjtn003);
+      try {
+        jj_consume_token(LBRACKET);
+        expansion_choices(p);
+        jj_consume_token(RBRACKET);
+      } catch (Throwable jjte003) {
+    if (jjtc003) {
+      jjtree.clearNodeScope(jjtn003);
+      jjtc003 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte003 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte003;}
+    }
+    if (jjte003 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte003;}
+    }
+    {if (true) throw (Error)jjte003;}
+      } finally {
+    if (jjtc003) {
+      jjtree.closeNodeScope(jjtn003, true);
+      jjtreeCloseNodeScope(jjtn003);
+    }
+      }
+      break;
+    case TRY:
+    ASTBNFTryBlock jjtn004 = new ASTBNFTryBlock(JJTBNFTRYBLOCK);
+    boolean jjtc004 = true;
+    jjtree.openNodeScope(jjtn004);
+    jjtreeOpenNodeScope(jjtn004);
+      try {
+        jj_consume_token(TRY);
+        jj_consume_token(LBRACE);
+      if (!isJavaLanguage) {
+        eatUptoCloseBrace();
+      }
+        if (jj_2_2(1)) {
+          expansion_choices(p);
+        } else {
+          ;
+        }
+        jj_consume_token(RBRACE);
+        label_11:
+        while (true) {
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case CATCH:
+            ;
+            break;
+          default:
+            jj_la1[29] = jj_gen;
+            break label_11;
+          }
+          jj_consume_token(CATCH);
+          jj_consume_token(LPAREN);
+          Name();
+          jj_consume_token(IDENTIFIER);
+          jj_consume_token(RPAREN);
+          Block();
+        }
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case FINALLY:
+          jj_consume_token(FINALLY);
+          Block();
+          break;
+        default:
+          jj_la1[30] = jj_gen;
+          ;
+        }
+      } catch (Throwable jjte004) {
+    if (jjtc004) {
+      jjtree.clearNodeScope(jjtn004);
+      jjtc004 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte004 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte004;}
+    }
+    if (jjte004 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte004;}
+    }
+    {if (true) throw (Error)jjte004;}
+      } finally {
+    if (jjtc004) {
+      jjtree.closeNodeScope(jjtn004, true);
+      jjtreeCloseNodeScope(jjtn004);
+    }
+      }
+      break;
+    default:
+      jj_la1[34] = jj_gen;
+      if (jj_2_4(2147483647)) {
+  ASTBNFAssignment jjtn006 = new ASTBNFAssignment(JJTBNFASSIGNMENT);
+  boolean jjtc006 = true;
+  jjtree.openNodeScope(jjtn006);
+  jjtreeOpenNodeScope(jjtn006);
+        try {
+          if (jj_2_3(2147483647)) {
+            PrimaryExpression();
+            jj_consume_token(ASSIGN);
+          } else {
+            ;
+          }
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case STRING_LITERAL:
+          case LT:
+            regular_expression();
+            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+            case DOT:
+              jj_consume_token(DOT);
+              t = jj_consume_token(IDENTIFIER);
+              break;
+            default:
+              jj_la1[31] = jj_gen;
+              ;
+            }
+            break;
+          case IDENTIFIER:
+      ASTBNFNonTerminal jjtn005 = new ASTBNFNonTerminal(JJTBNFNONTERMINAL);
+      boolean jjtc005 = true;
+      jjtree.openNodeScope(jjtn005);
+      jjtreeOpenNodeScope(jjtn005);
+            try {
+              identifier();
+              Arguments();
+            } catch (Throwable jjte005) {
+      if (jjtc005) {
+        jjtree.clearNodeScope(jjtn005);
+        jjtc005 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte005 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte005;}
+      }
+      if (jjte005 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte005;}
+      }
+      {if (true) throw (Error)jjte005;}
+            } finally {
+      if (jjtc005) {
+        jjtree.closeNodeScope(jjtn005, true);
+        jjtreeCloseNodeScope(jjtn005);
+      }
+            }
+            break;
+          default:
+            jj_la1[32] = jj_gen;
+            jj_consume_token(-1);
+            throw new ParseException();
+          }
+        } catch (Throwable jjte006) {
+  if (jjtc006) {
+    jjtree.clearNodeScope(jjtn006);
+    jjtc006 = false;
+  } else {
+    jjtree.popNode();
+  }
+  if (jjte006 instanceof RuntimeException) {
+    {if (true) throw (RuntimeException)jjte006;}
+  }
+  if (jjte006 instanceof ParseException) {
+    {if (true) throw (ParseException)jjte006;}
+  }
+  {if (true) throw (Error)jjte006;}
+        } finally {
+  if (jjtc006) {
+    jjtree.closeNodeScope(jjtn006, jjtree.nodeArity() > 1);
+    jjtreeCloseNodeScope(jjtn006);
+  }
+        }
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case LPAREN:
+          t = jj_consume_token(LPAREN);
+          expansion_choices(p);
+          jj_consume_token(RPAREN);
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case PLUS:
+      ASTBNFOneOrMore jjtn007 = new ASTBNFOneOrMore(JJTBNFONEORMORE);
+      boolean jjtc007 = true;
+      jjtree.openNodeScope(jjtn007);
+      jjtreeOpenNodeScope(jjtn007);
+            try {
+              jj_consume_token(PLUS);
+            } finally {
+      if (jjtc007) {
+        jjtree.closeNodeScope(jjtn007,  1);
+        jjtreeCloseNodeScope(jjtn007);
+      }
+            }
+            break;
+          case STAR:
+      ASTBNFZeroOrMore jjtn008 = new ASTBNFZeroOrMore(JJTBNFZEROORMORE);
+      boolean jjtc008 = true;
+      jjtree.openNodeScope(jjtn008);
+      jjtreeOpenNodeScope(jjtn008);
+            try {
+              jj_consume_token(STAR);
+            } finally {
+      if (jjtc008) {
+        jjtree.closeNodeScope(jjtn008,  1);
+        jjtreeCloseNodeScope(jjtn008);
+      }
+            }
+            break;
+          case HOOK:
+      ASTBNFZeroOrOne jjtn009 = new ASTBNFZeroOrOne(JJTBNFZEROORONE);
+      boolean jjtc009 = true;
+      jjtree.openNodeScope(jjtn009);
+      jjtreeOpenNodeScope(jjtn009);
+            try {
+              jj_consume_token(HOOK);
+            } finally {
+      if (jjtc009) {
+        jjtree.closeNodeScope(jjtn009,  1);
+        jjtreeCloseNodeScope(jjtn009);
+      }
+            }
+            break;
+          default:
+            jj_la1[33] = jj_gen;
+      ASTBNFParenthesized jjtn010 = new ASTBNFParenthesized(JJTBNFPARENTHESIZED);
+      boolean jjtc010 = true;
+      jjtree.openNodeScope(jjtn010);
+      jjtreeOpenNodeScope(jjtn010);
+            try {
+      jjtree.closeNodeScope(jjtn010,  1);
+      jjtc010 = false;
+      jjtreeCloseNodeScope(jjtn010);
+
+            } finally {
+      if (jjtc010) {
+        jjtree.closeNodeScope(jjtn010,  1);
+        jjtreeCloseNodeScope(jjtn010);
+      }
+            }
+          }
+          ((JJTreeNode)jjtree.peekNode()).setFirstToken(t);
+          break;
+        default:
+          jj_la1[35] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+    }
+          {if (true) return (JJTreeNode)jjtree.peekNode();}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public void regular_expression() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case STRING_LITERAL:
+    ASTREStringLiteral jjtn001 = new ASTREStringLiteral(JJTRESTRINGLITERAL);
+    boolean jjtc001 = true;
+    jjtree.openNodeScope(jjtn001);
+    jjtreeOpenNodeScope(jjtn001);
+      try {
+        StringLiteral();
+      } catch (Throwable jjte001) {
+    if (jjtc001) {
+      jjtree.clearNodeScope(jjtn001);
+      jjtc001 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte001 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte001;}
+    }
+    if (jjte001 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte001;}
+    }
+    {if (true) throw (Error)jjte001;}
+      } finally {
+    if (jjtc001) {
+      jjtree.closeNodeScope(jjtn001, true);
+      jjtreeCloseNodeScope(jjtn001);
+    }
+      }
+      break;
+    default:
+      jj_la1[38] = jj_gen;
+      if (jj_2_5(3)) {
+    ASTRENamed jjtn002 = new ASTRENamed(JJTRENAMED);
+    boolean jjtc002 = true;
+    jjtree.openNodeScope(jjtn002);
+    jjtreeOpenNodeScope(jjtn002);
+        try {
+          jj_consume_token(LT);
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case HASH:
+          case IDENTIFIER:
+            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+            case HASH:
+              jj_consume_token(HASH);
+              break;
+            default:
+              jj_la1[36] = jj_gen;
+              ;
+            }
+            identifier();
+            jj_consume_token(COLON);
+            break;
+          default:
+            jj_la1[37] = jj_gen;
+            ;
+          }
+          complex_regular_expression_choices();
+          jj_consume_token(GT);
+        } catch (Throwable jjte002) {
+    if (jjtc002) {
+      jjtree.clearNodeScope(jjtn002);
+      jjtc002 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte002 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte002;}
+    }
+    if (jjte002 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte002;}
+    }
+    {if (true) throw (Error)jjte002;}
+        } finally {
+    if (jjtc002) {
+      jjtree.closeNodeScope(jjtn002, true);
+      jjtreeCloseNodeScope(jjtn002);
+    }
+        }
+      } else if (jj_2_6(2)) {
+    ASTREReference jjtn003 = new ASTREReference(JJTREREFERENCE);
+    boolean jjtc003 = true;
+    jjtree.openNodeScope(jjtn003);
+    jjtreeOpenNodeScope(jjtn003);
+        try {
+          jj_consume_token(LT);
+          identifier();
+          jj_consume_token(GT);
+        } catch (Throwable jjte003) {
+    if (jjtc003) {
+      jjtree.clearNodeScope(jjtn003);
+      jjtc003 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte003 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte003;}
+    }
+    if (jjte003 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte003;}
+    }
+    {if (true) throw (Error)jjte003;}
+        } finally {
+    if (jjtc003) {
+      jjtree.closeNodeScope(jjtn003, true);
+      jjtreeCloseNodeScope(jjtn003);
+    }
+        }
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case LT:
+    ASTREEOF jjtn004 = new ASTREEOF(JJTREEOF);
+    boolean jjtc004 = true;
+    jjtree.openNodeScope(jjtn004);
+    jjtreeOpenNodeScope(jjtn004);
+          try {
+            jj_consume_token(LT);
+            jj_consume_token(_EOF);
+            jj_consume_token(GT);
+          } finally {
+    if (jjtc004) {
+      jjtree.closeNodeScope(jjtn004, true);
+      jjtreeCloseNodeScope(jjtn004);
+    }
+          }
+          break;
+        default:
+          jj_la1[39] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+    }
+  }
+
+  final public void complex_regular_expression_choices() throws ParseException {
+ /*@bgen(jjtree) #REChoice(> 1) */
+  ASTREChoice jjtn000 = new ASTREChoice(JJTRECHOICE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      complex_regular_expression();
+      label_12:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case BIT_OR:
+          ;
+          break;
+        default:
+          jj_la1[40] = jj_gen;
+          break label_12;
+        }
+        jj_consume_token(BIT_OR);
+        complex_regular_expression();
+      }
+    } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
+      jjtreeCloseNodeScope(jjtn000);
+    }
+    }
+  }
+
+  final public void complex_regular_expression() throws ParseException {
+ /*@bgen(jjtree) #RESequence(> 1) */
+  ASTRESequence jjtn000 = new ASTRESequence(JJTRESEQUENCE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      label_13:
+      while (true) {
+        complex_regular_expression_unit();
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case STRING_LITERAL:
+        case LPAREN:
+        case LBRACKET:
+        case LT:
+        case TILDE:
+          ;
+          break;
+        default:
+          jj_la1[41] = jj_gen;
+          break label_13;
+        }
+      }
+    } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
+      jjtreeCloseNodeScope(jjtn000);
+    }
+    }
+  }
+
+  final public void complex_regular_expression_unit() throws ParseException {
+          Token t;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case STRING_LITERAL:
+    ASTREStringLiteral jjtn001 = new ASTREStringLiteral(JJTRESTRINGLITERAL);
+    boolean jjtc001 = true;
+    jjtree.openNodeScope(jjtn001);
+    jjtreeOpenNodeScope(jjtn001);
+      try {
+        StringLiteral();
+      } catch (Throwable jjte001) {
+    if (jjtc001) {
+      jjtree.clearNodeScope(jjtn001);
+      jjtc001 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte001 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte001;}
+    }
+    if (jjte001 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte001;}
+    }
+    {if (true) throw (Error)jjte001;}
+      } finally {
+    if (jjtc001) {
+      jjtree.closeNodeScope(jjtn001, true);
+      jjtreeCloseNodeScope(jjtn001);
+    }
+      }
+      break;
+    case LT:
+    ASTREReference jjtn002 = new ASTREReference(JJTREREFERENCE);
+    boolean jjtc002 = true;
+    jjtree.openNodeScope(jjtn002);
+    jjtreeOpenNodeScope(jjtn002);
+      try {
+        jj_consume_token(LT);
+        identifier();
+        jj_consume_token(GT);
+      } catch (Throwable jjte002) {
+    if (jjtc002) {
+      jjtree.clearNodeScope(jjtn002);
+      jjtc002 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte002 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte002;}
+    }
+    if (jjte002 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte002;}
+    }
+    {if (true) throw (Error)jjte002;}
+      } finally {
+    if (jjtc002) {
+      jjtree.closeNodeScope(jjtn002, true);
+      jjtreeCloseNodeScope(jjtn002);
+    }
+      }
+      break;
+    case LBRACKET:
+    case TILDE:
+      character_list();
+      break;
+    case LPAREN:
+      t = jj_consume_token(LPAREN);
+      complex_regular_expression_choices();
+      jj_consume_token(RPAREN);
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case PLUS:
+      ASTREOneOrMore jjtn003 = new ASTREOneOrMore(JJTREONEORMORE);
+      boolean jjtc003 = true;
+      jjtree.openNodeScope(jjtn003);
+      jjtreeOpenNodeScope(jjtn003);
+        try {
+          jj_consume_token(PLUS);
+        } finally {
+      if (jjtc003) {
+        jjtree.closeNodeScope(jjtn003,  1);
+        jjtreeCloseNodeScope(jjtn003);
+      }
+        }
+        break;
+      case STAR:
+      ASTREZeroOrMore jjtn004 = new ASTREZeroOrMore(JJTREZEROORMORE);
+      boolean jjtc004 = true;
+      jjtree.openNodeScope(jjtn004);
+      jjtreeOpenNodeScope(jjtn004);
+        try {
+          jj_consume_token(STAR);
+        } finally {
+      if (jjtc004) {
+        jjtree.closeNodeScope(jjtn004,  1);
+        jjtreeCloseNodeScope(jjtn004);
+      }
+        }
+        break;
+      case HOOK:
+      ASTREZeroOrOne jjtn005 = new ASTREZeroOrOne(JJTREZEROORONE);
+      boolean jjtc005 = true;
+      jjtree.openNodeScope(jjtn005);
+      jjtreeOpenNodeScope(jjtn005);
+        try {
+          jj_consume_token(HOOK);
+        } finally {
+      if (jjtc005) {
+        jjtree.closeNodeScope(jjtn005,  1);
+        jjtreeCloseNodeScope(jjtn005);
+      }
+        }
+        break;
+      case LBRACE:
+        jj_consume_token(LBRACE);
+        IntegerLiteral();
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case COMMA:
+          jj_consume_token(COMMA);
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case INTEGER_LITERAL:
+            IntegerLiteral();
+            break;
+          default:
+            jj_la1[42] = jj_gen;
+            ;
+          }
+          break;
+        default:
+          jj_la1[43] = jj_gen;
+          ;
+        }
+                                                          ASTRRepetitionRange jjtn006 = new ASTRRepetitionRange(JJTRREPETITIONRANGE);
+                                                          boolean jjtc006 = true;
+                                                          jjtree.openNodeScope(jjtn006);
+                                                          jjtreeOpenNodeScope(jjtn006);
+        try {
+          jj_consume_token(RBRACE);
+        } finally {
+                                                          if (jjtc006) {
+                                                            jjtree.closeNodeScope(jjtn006,  1);
+                                                            jjtreeCloseNodeScope(jjtn006);
+                                                          }
+        }
+        break;
+      default:
+        jj_la1[44] = jj_gen;
+      ASTREParenthesized jjtn007 = new ASTREParenthesized(JJTREPARENTHESIZED);
+      boolean jjtc007 = true;
+      jjtree.openNodeScope(jjtn007);
+      jjtreeOpenNodeScope(jjtn007);
+        try {
+      jjtree.closeNodeScope(jjtn007,  1);
+      jjtc007 = false;
+      jjtreeCloseNodeScope(jjtn007);
+
+        } finally {
+      if (jjtc007) {
+        jjtree.closeNodeScope(jjtn007,  1);
+        jjtreeCloseNodeScope(jjtn007);
+      }
+        }
+      }
+          ((JJTreeNode)jjtree.peekNode()).setFirstToken(t);
+      break;
+    default:
+      jj_la1[45] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void character_list() throws ParseException {
+ /*@bgen(jjtree) RECharList */
+  ASTRECharList jjtn000 = new ASTRECharList(JJTRECHARLIST);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case TILDE:
+        jj_consume_token(TILDE);
+        break;
+      default:
+        jj_la1[46] = jj_gen;
+        ;
+      }
+      jj_consume_token(LBRACKET);
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case STRING_LITERAL:
+        character_descriptor();
+        label_14:
+        while (true) {
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case COMMA:
+            ;
+            break;
+          default:
+            jj_la1[47] = jj_gen;
+            break label_14;
+          }
+          jj_consume_token(COMMA);
+          character_descriptor();
+        }
+        break;
+      default:
+        jj_la1[48] = jj_gen;
+        ;
+      }
+      jj_consume_token(RBRACKET);
+    } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      jjtreeCloseNodeScope(jjtn000);
+    }
+    }
+  }
+
+  final public void character_descriptor() throws ParseException {
+ /*@bgen(jjtree) CharDescriptor */
+  ASTCharDescriptor jjtn000 = new ASTCharDescriptor(JJTCHARDESCRIPTOR);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      StringLiteral();
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case MINUS:
+        jj_consume_token(MINUS);
+        StringLiteral();
+        break;
+      default:
+        jj_la1[49] = jj_gen;
+        ;
+      }
+    } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      jjtreeCloseNodeScope(jjtn000);
+    }
+    }
+  }
+
+  final public Token identifier() throws ParseException {
+  Token t;
+    t = jj_consume_token(IDENTIFIER);
+                  {if (true) return t;}
+    throw new Error("Missing return statement in function");
+  }
+
+/**********************************************
+ * THE JJTREE PRODUCTIONS START HERE          *
+ **********************************************/
+  final public ASTNodeDescriptor node_descriptor() throws ParseException {
+ /*@bgen(jjtree) NodeDescriptor */
+  ASTNodeDescriptor jjtn000 = new ASTNodeDescriptor(JJTNODEDESCRIPTOR);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);Token t = null;
+  String s = null;
+    try {
+      jj_consume_token(HASH);
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case _LOOKAHEAD:
+      case _IGNORE_CASE:
+      case _PARSER_BEGIN:
+      case _PARSER_END:
+      case _JAVACODE:
+      case _TOKEN:
+      case _SPECIAL_TOKEN:
+      case _MORE:
+      case _SKIP:
+      case _TOKEN_MGR_DECLS:
+      case _EOF:
+      case IDENTIFIER:
+        s = Name();
+                     jjtn000.name = s;
+        break;
+      case VOID:
+        t = jj_consume_token(VOID);
+                     jjtn000.name = t.image;
+        break;
+      default:
+        jj_la1[50] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LPAREN:
+        jj_consume_token(LPAREN);
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case GT:
+          jj_consume_token(GT);
+                     jjtn000.isGT = true;
+          break;
+        default:
+          jj_la1[51] = jj_gen;
+          ;
+        }
+        node_descriptor_expression();
+                     jjtn000.expression =
+                       (ASTNodeDescriptorExpression)jjtree.peekNode();
+        jj_consume_token(RPAREN);
+        break;
+      default:
+        jj_la1[52] = jj_gen;
+        ;
+      }
+                     jjtree.closeNodeScope(jjtn000, true);
+                     jjtc000 = false;
+                     jjtreeCloseNodeScope(jjtn000);
+                     jjtn000.setNodeIdValue();
+                     {if (true) return jjtn000;}
+    } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      jjtreeCloseNodeScope(jjtn000);
+    }
+    }
+    throw new Error("Missing return statement in function");
+  }
+
+  void node_descriptor_expression() throws ParseException {
+ /*@bgen(jjtree) NodeDescriptorExpression */
+ASTNodeDescriptorExpression jjtn000 = new ASTNodeDescriptorExpression(JJTNODEDESCRIPTOREXPRESSION);
+boolean jjtc000 = true;
+jjtree.openNodeScope(jjtn000);
+jjtreeOpenNodeScope(jjtn000);
+try {Token tok;
+  int nesting = 1;
+  while (true) {
+    tok = getToken(1);
+    if (tok.kind == 0) {
+      throw new ParseException();
+    }
+    if (tok.kind == LPAREN) nesting++;
+    if (tok.kind == RPAREN) {
+      nesting--;
+      if (nesting == 0) break;
+    }
+    tok = getNextToken();
+  }/*@bgen(jjtree)*/
+} finally {
+  if (jjtc000) {
+    jjtree.closeNodeScope(jjtn000, true);
+    jjtreeCloseNodeScope(jjtn000);
+  }
+}
+  }
+
+/**********************************************
+ * THE JAVA GRAMMAR SPECIFICATION STARTS HERE *
+ **********************************************/
+
+/*
+ * The Java grammar is modified to use sequences of tokens
+ * for the missing tokens - those that include "<<" and ">>".
+ */
+
+/*
+ * The following production defines Java identifiers - it
+ * includes the reserved words of JavaCC also.
+ */
+  final public String JavaIdentifier() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case IDENTIFIER:
+      jj_consume_token(IDENTIFIER);
+      break;
+    case _LOOKAHEAD:
+      jj_consume_token(_LOOKAHEAD);
+      break;
+    case _IGNORE_CASE:
+      jj_consume_token(_IGNORE_CASE);
+      break;
+    case _PARSER_BEGIN:
+      jj_consume_token(_PARSER_BEGIN);
+      break;
+    case _PARSER_END:
+      jj_consume_token(_PARSER_END);
+      break;
+    case _JAVACODE:
+      jj_consume_token(_JAVACODE);
+      break;
+    case _TOKEN:
+      jj_consume_token(_TOKEN);
+      break;
+    case _SPECIAL_TOKEN:
+      jj_consume_token(_SPECIAL_TOKEN);
+      break;
+    case _MORE:
+      jj_consume_token(_MORE);
+      break;
+    case _SKIP:
+      jj_consume_token(_SKIP);
+      break;
+    case _TOKEN_MGR_DECLS:
+      jj_consume_token(_TOKEN_MGR_DECLS);
+      break;
+    case _EOF:
+      jj_consume_token(_EOF);
+      break;
+    default:
+      jj_la1[53] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+                  {if (true) return token.image;}
+    throw new Error("Missing return statement in function");
+  }
+
+/*
+ * Program structuring syntax follows.
+ */
+  final public void CompilationUnit() throws ParseException {
+    if (jj_2_7(2147483647)) {
+      PackageDeclaration();
+    } else {
+      ;
+    }
+    JJTreeGlobals.parserImports = getToken(1);
+    label_15:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case IMPORT:
+        ;
+        break;
+      default:
+        jj_la1[54] = jj_gen;
+        break label_15;
+      }
+      ImportDeclaration();
+    }
+    label_16:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case ABSTRACT:
+      case CLASS:
+      case FINAL:
+      case INTERFACE:
+      case NATIVE:
+      case PRIVATE:
+      case PROTECTED:
+      case PUBLIC:
+      case STATIC:
+      case SYNCHRONIZED:
+      case TRANSIENT:
+      case VOLATILE:
+      case SEMICOLON:
+      case 129:
+      case 130:
+      case 139:
+        ;
+        break;
+      default:
+        jj_la1[55] = jj_gen;
+        break label_16;
+      }
+      TypeDeclaration();
+    }
+  }
+
+  final public void PackageDeclaration() throws ParseException {
+  String s;
+    Modifiers();
+    jj_consume_token(PACKAGE);
+    s = Name();
+    jj_consume_token(SEMICOLON);
+                  JJTreeGlobals.packageName = s;
+  }
+
+  final public void ImportDeclaration() throws ParseException {
+    jj_consume_token(IMPORT);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case STATIC:
+      jj_consume_token(STATIC);
+      break;
+    default:
+      jj_la1[56] = jj_gen;
+      ;
+    }
+    Name();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case DOT:
+      jj_consume_token(DOT);
+      jj_consume_token(STAR);
+      break;
+    default:
+      jj_la1[57] = jj_gen;
+      ;
+    }
+    jj_consume_token(SEMICOLON);
+  }
+
+/*
+ * Modifiers. We match all modifiers in a single rule to reduce the chances of
+ * syntax errors for simple modifier mistakes. It will also enable us to give
+ * better error messages.
+ */
+  final public void Modifiers() throws ParseException {
+    label_17:
+    while (true) {
+      if (jj_2_8(2)) {
+        ;
+      } else {
+        break label_17;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case PUBLIC:
+        jj_consume_token(PUBLIC);
+        break;
+      case STATIC:
+        jj_consume_token(STATIC);
+        break;
+      case PROTECTED:
+        jj_consume_token(PROTECTED);
+        break;
+      case PRIVATE:
+        jj_consume_token(PRIVATE);
+        break;
+      case FINAL:
+        jj_consume_token(FINAL);
+        break;
+      case ABSTRACT:
+        jj_consume_token(ABSTRACT);
+        break;
+      case SYNCHRONIZED:
+        jj_consume_token(SYNCHRONIZED);
+        break;
+      case NATIVE:
+        jj_consume_token(NATIVE);
+        break;
+      case TRANSIENT:
+        jj_consume_token(TRANSIENT);
+        break;
+      case VOLATILE:
+        jj_consume_token(VOLATILE);
+        break;
+      case 129:
+        jj_consume_token(129);
+        break;
+      case 139:
+        Annotation();
+        break;
+      default:
+        jj_la1[58] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+/*
+ * Declaration syntax follows.
+ */
+  final public void TypeDeclaration() throws ParseException {
+   ;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case SEMICOLON:
+      jj_consume_token(SEMICOLON);
+      break;
+    case ABSTRACT:
+    case CLASS:
+    case FINAL:
+    case INTERFACE:
+    case NATIVE:
+    case PRIVATE:
+    case PROTECTED:
+    case PUBLIC:
+    case STATIC:
+    case SYNCHRONIZED:
+    case TRANSIENT:
+    case VOLATILE:
+    case 129:
+    case 130:
+    case 139:
+      Modifiers();
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case CLASS:
+      case INTERFACE:
+        ClassOrInterfaceDeclaration();
+        break;
+      case 130:
+        EnumDeclaration();
+        break;
+      case 139:
+        AnnotationTypeDeclaration();
+        break;
+      default:
+        jj_la1[59] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      break;
+    default:
+      jj_la1[60] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void ClassOrInterfaceDeclaration() throws ParseException {
+  Token t = null;
+  String s;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case CLASS:
+      jj_consume_token(CLASS);
+      break;
+    case INTERFACE:
+      jj_consume_token(INTERFACE);
+      break;
+    default:
+      jj_la1[61] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    s = JavaIdentifier();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case LT:
+      TypeParameters();
+      break;
+    default:
+      jj_la1[62] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case EXTENDS:
+      ExtendsList();
+      break;
+    default:
+      jj_la1[63] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case IMPLEMENTS:
+      t = getToken(1);
+      ImplementsList();
+      break;
+    default:
+      jj_la1[64] = jj_gen;
+      ;
+    }
+                  if (s.equals(JJTreeGlobals.parserName)) {
+                    if (t != null) {
+                      JJTreeGlobals.parserImplements = t;
+                    } else {
+                      JJTreeGlobals.parserImplements = getToken(1);
+                    }
+                    JJTreeGlobals.parserClassBodyStart = getToken(1);
+                  }
+    ClassOrInterfaceBody();
+  }
+
+  final public void ExtendsList() throws ParseException {
+    jj_consume_token(EXTENDS);
+    ClassOrInterfaceType();
+    label_18:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[65] = jj_gen;
+        break label_18;
+      }
+      jj_consume_token(COMMA);
+      ClassOrInterfaceType();
+    }
+  }
+
+  final public void ImplementsList() throws ParseException {
+    jj_consume_token(IMPLEMENTS);
+    ClassOrInterfaceType();
+    label_19:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[66] = jj_gen;
+        break label_19;
+      }
+      jj_consume_token(COMMA);
+      ClassOrInterfaceType();
+    }
+  }
+
+  final public void EnumDeclaration() throws ParseException {
+    jj_consume_token(130);
+    JavaIdentifier();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case IMPLEMENTS:
+      ImplementsList();
+      break;
+    default:
+      jj_la1[67] = jj_gen;
+      ;
+    }
+    EnumBody();
+  }
+
+  final public void EnumBody() throws ParseException {
+    jj_consume_token(LBRACE);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _JAVACODE:
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case _TOKEN_MGR_DECLS:
+    case _EOF:
+    case ABSTRACT:
+    case FINAL:
+    case NATIVE:
+    case PRIVATE:
+    case PROTECTED:
+    case PUBLIC:
+    case STATIC:
+    case SYNCHRONIZED:
+    case TRANSIENT:
+    case VOLATILE:
+    case 129:
+    case 139:
+    case IDENTIFIER:
+      EnumConstant();
+      label_20:
+      while (true) {
+        if (jj_2_9(2)) {
+          ;
+        } else {
+          break label_20;
+        }
+        jj_consume_token(COMMA);
+        EnumConstant();
+      }
+      break;
+    default:
+      jj_la1[68] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case COMMA:
+      jj_consume_token(COMMA);
+      break;
+    default:
+      jj_la1[69] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case SEMICOLON:
+      jj_consume_token(SEMICOLON);
+      label_21:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case _LOOKAHEAD:
+        case _IGNORE_CASE:
+        case _PARSER_BEGIN:
+        case _PARSER_END:
+        case _JAVACODE:
+        case _TOKEN:
+        case _SPECIAL_TOKEN:
+        case _MORE:
+        case _SKIP:
+        case _TOKEN_MGR_DECLS:
+        case _EOF:
+        case ABSTRACT:
+        case BOOLEAN:
+        case BYTE:
+        case CHAR:
+        case CLASS:
+        case CONST:
+        case DOUBLE:
+        case FINAL:
+        case FLOAT:
+        case INT:
+        case INTERFACE:
+        case LONG:
+        case NATIVE:
+        case PRIVATE:
+        case PROTECTED:
+        case PUBLIC:
+        case SHORT:
+        case STATIC:
+        case SYNCHRONIZED:
+        case TRANSIENT:
+        case VOID:
+        case VOLATILE:
+        case LBRACE:
+        case SEMICOLON:
+        case LT:
+        case 129:
+        case 130:
+        case 132:
+        case 139:
+        case IDENTIFIER:
+          ;
+          break;
+        default:
+          jj_la1[70] = jj_gen;
+          break label_21;
+        }
+        ClassOrInterfaceBodyDeclaration();
+      }
+      break;
+    default:
+      jj_la1[71] = jj_gen;
+      ;
+    }
+    jj_consume_token(RBRACE);
+  }
+
+  final public void EnumConstant() throws ParseException {
+    Modifiers();
+    JavaIdentifier();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case LPAREN:
+      Arguments();
+      break;
+    default:
+      jj_la1[72] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case LBRACE:
+      ClassOrInterfaceBody();
+      break;
+    default:
+      jj_la1[73] = jj_gen;
+      ;
+    }
+  }
+
+  final public void TypeParameters() throws ParseException {
+    jj_consume_token(LT);
+    TypeParameter();
+    label_22:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[74] = jj_gen;
+        break label_22;
+      }
+      jj_consume_token(COMMA);
+      TypeParameter();
+    }
+    jj_consume_token(GT);
+  }
+
+  final public void TypeParameter() throws ParseException {
+    JavaIdentifier();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case EXTENDS:
+      TypeBound();
+      break;
+    default:
+      jj_la1[75] = jj_gen;
+      ;
+    }
+  }
+
+  final public void TypeBound() throws ParseException {
+    jj_consume_token(EXTENDS);
+    ClassOrInterfaceType();
+    label_23:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case BIT_AND:
+        ;
+        break;
+      default:
+        jj_la1[76] = jj_gen;
+        break label_23;
+      }
+      jj_consume_token(BIT_AND);
+      ClassOrInterfaceType();
+    }
+  }
+
+  final public void ClassOrInterfaceBody() throws ParseException {
+    jj_consume_token(LBRACE);
+    label_24:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case _LOOKAHEAD:
+      case _IGNORE_CASE:
+      case _PARSER_BEGIN:
+      case _PARSER_END:
+      case _JAVACODE:
+      case _TOKEN:
+      case _SPECIAL_TOKEN:
+      case _MORE:
+      case _SKIP:
+      case _TOKEN_MGR_DECLS:
+      case _EOF:
+      case ABSTRACT:
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case CLASS:
+      case CONST:
+      case DOUBLE:
+      case FINAL:
+      case FLOAT:
+      case INT:
+      case INTERFACE:
+      case LONG:
+      case NATIVE:
+      case PRIVATE:
+      case PROTECTED:
+      case PUBLIC:
+      case SHORT:
+      case STATIC:
+      case SYNCHRONIZED:
+      case TRANSIENT:
+      case VOID:
+      case VOLATILE:
+      case LBRACE:
+      case SEMICOLON:
+      case LT:
+      case 129:
+      case 130:
+      case 132:
+      case 139:
+      case IDENTIFIER:
+        ;
+        break;
+      default:
+        jj_la1[77] = jj_gen;
+        break label_24;
+      }
+      ClassOrInterfaceBodyDeclaration();
+    }
+    jj_consume_token(RBRACE);
+  }
+
+  final public void ClassOrInterfaceBodyDeclaration() throws ParseException {
+    if (jj_2_12(2)) {
+      Initializer();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case _LOOKAHEAD:
+      case _IGNORE_CASE:
+      case _PARSER_BEGIN:
+      case _PARSER_END:
+      case _JAVACODE:
+      case _TOKEN:
+      case _SPECIAL_TOKEN:
+      case _MORE:
+      case _SKIP:
+      case _TOKEN_MGR_DECLS:
+      case _EOF:
+      case ABSTRACT:
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case CLASS:
+      case CONST:
+      case DOUBLE:
+      case FINAL:
+      case FLOAT:
+      case INT:
+      case INTERFACE:
+      case LONG:
+      case NATIVE:
+      case PRIVATE:
+      case PROTECTED:
+      case PUBLIC:
+      case SHORT:
+      case STATIC:
+      case SYNCHRONIZED:
+      case TRANSIENT:
+      case VOID:
+      case VOLATILE:
+      case LT:
+      case 129:
+      case 130:
+      case 132:
+      case 139:
+      case IDENTIFIER:
+        Modifiers();
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case CLASS:
+        case INTERFACE:
+          ClassOrInterfaceDeclaration();
+          break;
+        case 130:
+          EnumDeclaration();
+          break;
+        default:
+          jj_la1[78] = jj_gen;
+          if (jj_2_10(2147483647)) {
+            ConstructorDeclaration();
+          } else if (jj_2_11(2147483647)) {
+            FieldDeclaration();
+          } else {
+            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+            case _LOOKAHEAD:
+            case _IGNORE_CASE:
+            case _PARSER_BEGIN:
+            case _PARSER_END:
+            case _JAVACODE:
+            case _TOKEN:
+            case _SPECIAL_TOKEN:
+            case _MORE:
+            case _SKIP:
+            case _TOKEN_MGR_DECLS:
+            case _EOF:
+            case BOOLEAN:
+            case BYTE:
+            case CHAR:
+            case CONST:
+            case DOUBLE:
+            case FLOAT:
+            case INT:
+            case LONG:
+            case SHORT:
+            case VOID:
+            case LT:
+            case 132:
+            case IDENTIFIER:
+              MethodDeclaration();
+              break;
+            default:
+              jj_la1[79] = jj_gen;
+              jj_consume_token(-1);
+              throw new ParseException();
+            }
+          }
+        }
+        break;
+      case SEMICOLON:
+        jj_consume_token(SEMICOLON);
+        break;
+      default:
+        jj_la1[80] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void FieldDeclaration() throws ParseException {
+    Type();
+    VariableDeclarator();
+    label_25:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[81] = jj_gen;
+        break label_25;
+      }
+      jj_consume_token(COMMA);
+      VariableDeclarator();
+    }
+    jj_consume_token(SEMICOLON);
+  }
+
+  final public void VariableDeclarator() throws ParseException {
+    VariableDeclaratorId();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case ASSIGN:
+      jj_consume_token(ASSIGN);
+      VariableInitializer();
+      break;
+    default:
+      jj_la1[82] = jj_gen;
+      ;
+    }
+  }
+
+  final public void VariableDeclaratorId() throws ParseException {
+    JavaIdentifier();
+    label_26:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LBRACKET:
+        ;
+        break;
+      default:
+        jj_la1[83] = jj_gen;
+        break label_26;
+      }
+      jj_consume_token(LBRACKET);
+      jj_consume_token(RBRACKET);
+    }
+  }
+
+  final public void VariableInitializer() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case LBRACE:
+      ArrayInitializer();
+      break;
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _JAVACODE:
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case _TOKEN_MGR_DECLS:
+    case _EOF:
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case CONST:
+    case DOUBLE:
+    case FALSE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case NEW:
+    case NULL:
+    case SHORT:
+    case SUPER:
+    case THIS:
+    case TRUE:
+    case VOID:
+    case INTEGER_LITERAL:
+    case FLOATING_POINT_LITERAL:
+    case CHARACTER_LITERAL:
+    case STRING_LITERAL:
+    case LPAREN:
+    case BANG:
+    case TILDE:
+    case INCR:
+    case DECR:
+    case PLUS:
+    case MINUS:
+    case 132:
+    case IDENTIFIER:
+      Expression();
+      break;
+    default:
+      jj_la1[84] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void ArrayInitializer() throws ParseException {
+    jj_consume_token(LBRACE);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _JAVACODE:
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case _TOKEN_MGR_DECLS:
+    case _EOF:
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case CONST:
+    case DOUBLE:
+    case FALSE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case NEW:
+    case NULL:
+    case SHORT:
+    case SUPER:
+    case THIS:
+    case TRUE:
+    case VOID:
+    case INTEGER_LITERAL:
+    case FLOATING_POINT_LITERAL:
+    case CHARACTER_LITERAL:
+    case STRING_LITERAL:
+    case LPAREN:
+    case LBRACE:
+    case BANG:
+    case TILDE:
+    case INCR:
+    case DECR:
+    case PLUS:
+    case MINUS:
+    case 132:
+    case IDENTIFIER:
+      VariableInitializer();
+      label_27:
+      while (true) {
+        if (jj_2_13(2)) {
+          ;
+        } else {
+          break label_27;
+        }
+        jj_consume_token(COMMA);
+        VariableInitializer();
+      }
+      break;
+    default:
+      jj_la1[85] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case COMMA:
+      jj_consume_token(COMMA);
+      break;
+    default:
+      jj_la1[86] = jj_gen;
+      ;
+    }
+    jj_consume_token(RBRACE);
+  }
+
+  final public void MethodDeclaration() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case LT:
+      TypeParameters();
+      break;
+    default:
+      jj_la1[87] = jj_gen;
+      ;
+    }
+    ResultType();
+    MethodDeclarator();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case THROWS:
+      jj_consume_token(THROWS);
+      NameList();
+      break;
+    default:
+      jj_la1[88] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case LBRACE:
+      Block();
+      break;
+    case SEMICOLON:
+      jj_consume_token(SEMICOLON);
+      break;
+    default:
+      jj_la1[89] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void MethodDeclarator() throws ParseException {
+    JavaIdentifier();
+    FormalParameters();
+    label_28:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LBRACKET:
+        ;
+        break;
+      default:
+        jj_la1[90] = jj_gen;
+        break label_28;
+      }
+      jj_consume_token(LBRACKET);
+      jj_consume_token(RBRACKET);
+    }
+  }
+
+  final public void FormalParameters() throws ParseException {
+    jj_consume_token(LPAREN);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _JAVACODE:
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case _TOKEN_MGR_DECLS:
+    case _EOF:
+    case ABSTRACT:
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case DOUBLE:
+    case FINAL:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case NATIVE:
+    case PRIVATE:
+    case PROTECTED:
+    case PUBLIC:
+    case SHORT:
+    case STATIC:
+    case SYNCHRONIZED:
+    case TRANSIENT:
+    case VOLATILE:
+    case 129:
+    case 132:
+    case 139:
+    case IDENTIFIER:
+      FormalParameter();
+      label_29:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case COMMA:
+          ;
+          break;
+        default:
+          jj_la1[91] = jj_gen;
+          break label_29;
+        }
+        jj_consume_token(COMMA);
+        FormalParameter();
+      }
+      break;
+    default:
+      jj_la1[92] = jj_gen;
+      ;
+    }
+    jj_consume_token(RPAREN);
+  }
+
+  final public void FormalParameter() throws ParseException {
+    Modifiers();
+    Type();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case STAR:
+    case BIT_AND:
+    case 131:
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case BIT_AND:
+        jj_consume_token(BIT_AND);
+        break;
+      case STAR:
+        jj_consume_token(STAR);
+        break;
+      case 131:
+        jj_consume_token(131);
+        break;
+      default:
+        jj_la1[93] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      break;
+    default:
+      jj_la1[94] = jj_gen;
+      ;
+    }
+    VariableDeclaratorId();
+  }
+
+  final public void ConstructorDeclaration() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case LT:
+      TypeParameters();
+      break;
+    default:
+      jj_la1[95] = jj_gen;
+      ;
+    }
+    JavaIdentifier();
+    FormalParameters();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case THROWS:
+      jj_consume_token(THROWS);
+      NameList();
+      break;
+    default:
+      jj_la1[96] = jj_gen;
+      ;
+    }
+    jj_consume_token(LBRACE);
+    if (jj_2_14(2147483647)) {
+      ExplicitConstructorInvocation();
+    } else {
+      ;
+    }
+    label_30:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case _LOOKAHEAD:
+      case _IGNORE_CASE:
+      case _PARSER_BEGIN:
+      case _PARSER_END:
+      case _JAVACODE:
+      case _TOKEN:
+      case _SPECIAL_TOKEN:
+      case _MORE:
+      case _SKIP:
+      case _TOKEN_MGR_DECLS:
+      case _EOF:
+      case ABSTRACT:
+      case BOOLEAN:
+      case BREAK:
+      case BYTE:
+      case CHAR:
+      case CLASS:
+      case CONST:
+      case CONTINUE:
+      case DO:
+      case DOUBLE:
+      case FALSE:
+      case FINAL:
+      case FLOAT:
+      case FOR:
+      case IF:
+      case INT:
+      case INTERFACE:
+      case LONG:
+      case NATIVE:
+      case NEW:
+      case NULL:
+      case PRIVATE:
+      case PROTECTED:
+      case PUBLIC:
+      case RETURN:
+      case SHORT:
+      case STATIC:
+      case SUPER:
+      case SWITCH:
+      case SYNCHRONIZED:
+      case THIS:
+      case THROW:
+      case TRANSIENT:
+      case TRUE:
+      case TRY:
+      case VOID:
+      case VOLATILE:
+      case WHILE:
+      case INTEGER_LITERAL:
+      case FLOATING_POINT_LITERAL:
+      case CHARACTER_LITERAL:
+      case STRING_LITERAL:
+      case LPAREN:
+      case LBRACE:
+      case SEMICOLON:
+      case INCR:
+      case DECR:
+      case 129:
+      case 132:
+      case 138:
+      case 139:
+      case IDENTIFIER:
+        ;
+        break;
+      default:
+        jj_la1[97] = jj_gen;
+        break label_30;
+      }
+      BlockStatement();
+    }
+    jj_consume_token(RBRACE);
+  }
+
+  final public void ExplicitConstructorInvocation() throws ParseException {
+    if (jj_2_16(2147483647)) {
+      jj_consume_token(THIS);
+      Arguments();
+      jj_consume_token(SEMICOLON);
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case _LOOKAHEAD:
+      case _IGNORE_CASE:
+      case _PARSER_BEGIN:
+      case _PARSER_END:
+      case _JAVACODE:
+      case _TOKEN:
+      case _SPECIAL_TOKEN:
+      case _MORE:
+      case _SKIP:
+      case _TOKEN_MGR_DECLS:
+      case _EOF:
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case CONST:
+      case DOUBLE:
+      case FALSE:
+      case FLOAT:
+      case INT:
+      case LONG:
+      case NEW:
+      case NULL:
+      case SHORT:
+      case SUPER:
+      case THIS:
+      case TRUE:
+      case VOID:
+      case INTEGER_LITERAL:
+      case FLOATING_POINT_LITERAL:
+      case CHARACTER_LITERAL:
+      case STRING_LITERAL:
+      case LPAREN:
+      case 132:
+      case IDENTIFIER:
+        if (jj_2_15(2)) {
+          PrimaryExpression();
+          jj_consume_token(DOT);
+        } else {
+          ;
+        }
+        jj_consume_token(SUPER);
+        Arguments();
+        jj_consume_token(SEMICOLON);
+        break;
+      default:
+        jj_la1[98] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void Initializer() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case STATIC:
+      jj_consume_token(STATIC);
+      break;
+    default:
+      jj_la1[99] = jj_gen;
+      ;
+    }
+    Block();
+  }
+
+/*
+ * Type, name and expression syntax follows.
+ */
+  final public void Type() throws ParseException {
+    if (jj_2_17(2)) {
+      ReferenceType();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case DOUBLE:
+      case FLOAT:
+      case INT:
+      case LONG:
+      case SHORT:
+        PrimitiveType();
+        break;
+      default:
+        jj_la1[100] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void ReferenceType() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case DOUBLE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case SHORT:
+      PrimitiveType();
+      label_31:
+      while (true) {
+        jj_consume_token(LBRACKET);
+        jj_consume_token(RBRACKET);
+        if (jj_2_18(2)) {
+          ;
+        } else {
+          break label_31;
+        }
+      }
+      break;
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _JAVACODE:
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case _TOKEN_MGR_DECLS:
+    case _EOF:
+    case 132:
+    case IDENTIFIER:
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case 132:
+        Template();
+        break;
+      default:
+        jj_la1[101] = jj_gen;
+        ;
+      }
+      ClassOrInterfaceType();
+      label_32:
+      while (true) {
+        if (jj_2_19(2)) {
+          ;
+        } else {
+          break label_32;
+        }
+        jj_consume_token(LBRACKET);
+        jj_consume_token(RBRACKET);
+      }
+      break;
+    default:
+      jj_la1[102] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void Template() throws ParseException {
+    jj_consume_token(132);
+    jj_consume_token(LT);
+    TemplatePack();
+    label_33:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[103] = jj_gen;
+        break label_33;
+      }
+      jj_consume_token(COMMA);
+      TemplatePack();
+    }
+    jj_consume_token(GT);
+  }
+
+  final public void TemplatePack() throws ParseException {
+    TemplateBase();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case 131:
+      jj_consume_token(131);
+      break;
+    default:
+      jj_la1[104] = jj_gen;
+      ;
+    }
+    jj_consume_token(IDENTIFIER);
+  }
+
+  final public void TemplateBase() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case CLASS:
+      jj_consume_token(CLASS);
+      break;
+    case 133:
+      jj_consume_token(133);
+      break;
+    default:
+      jj_la1[105] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void ClassOrInterfaceType() throws ParseException {
+    JavaIdentifier();
+    if (jj_2_20(2)) {
+      TypeArguments();
+    } else {
+      ;
+    }
+    label_34:
+    while (true) {
+      if (jj_2_21(2)) {
+        ;
+      } else {
+        break label_34;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case DOT:
+        jj_consume_token(DOT);
+        break;
+      case DOUBLECOLON:
+        jj_consume_token(DOUBLECOLON);
+        break;
+      default:
+        jj_la1[106] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      JavaIdentifier();
+      if (jj_2_22(2)) {
+        TypeArguments();
+      } else {
+        ;
+      }
+    }
+  }
+
+  final public void TypeArguments() throws ParseException {
+    jj_consume_token(LT);
+    TypeArgument();
+    label_35:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[107] = jj_gen;
+        break label_35;
+      }
+      jj_consume_token(COMMA);
+      TypeArgument();
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case 131:
+        jj_consume_token(131);
+        break;
+      default:
+        jj_la1[108] = jj_gen;
+        ;
+      }
+    }
+    jj_consume_token(GT);
+  }
+
+  final public void TypeArgument() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _JAVACODE:
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case _TOKEN_MGR_DECLS:
+    case _EOF:
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case DOUBLE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case SHORT:
+    case 132:
+    case IDENTIFIER:
+      ReferenceType();
+      break;
+    case HOOK:
+      jj_consume_token(HOOK);
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case EXTENDS:
+      case SUPER:
+        WildcardBounds();
+        break;
+      default:
+        jj_la1[109] = jj_gen;
+        ;
+      }
+      break;
+    default:
+      jj_la1[110] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void WildcardBounds() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case EXTENDS:
+      jj_consume_token(EXTENDS);
+      ReferenceType();
+      break;
+    case SUPER:
+      jj_consume_token(SUPER);
+      ReferenceType();
+      break;
+    default:
+      jj_la1[111] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void PrimitiveType() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case BOOLEAN:
+      jj_consume_token(BOOLEAN);
+      break;
+    case CHAR:
+      jj_consume_token(CHAR);
+      break;
+    case BYTE:
+      jj_consume_token(BYTE);
+      break;
+    case SHORT:
+      jj_consume_token(SHORT);
+      break;
+    case INT:
+      jj_consume_token(INT);
+      break;
+    case LONG:
+      jj_consume_token(LONG);
+      break;
+    case FLOAT:
+      jj_consume_token(FLOAT);
+      break;
+    case DOUBLE:
+      jj_consume_token(DOUBLE);
+      break;
+    default:
+      jj_la1[112] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void ResultType() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case VOID:
+      jj_consume_token(VOID);
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case STAR:
+        jj_consume_token(STAR);
+        break;
+      default:
+        jj_la1[113] = jj_gen;
+        ;
+      }
+      break;
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _JAVACODE:
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case _TOKEN_MGR_DECLS:
+    case _EOF:
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case CONST:
+    case DOUBLE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case SHORT:
+    case 132:
+    case IDENTIFIER:
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case CONST:
+        jj_consume_token(CONST);
+        break;
+      default:
+        jj_la1[114] = jj_gen;
+        ;
+      }
+      Type();
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case STAR:
+      case BIT_AND:
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case STAR:
+          jj_consume_token(STAR);
+          break;
+        case BIT_AND:
+          jj_consume_token(BIT_AND);
+          break;
+        default:
+          jj_la1[115] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+        break;
+      default:
+        jj_la1[116] = jj_gen;
+        ;
+      }
+      break;
+    default:
+      jj_la1[117] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public String Name() throws ParseException {
+  String s, ss;
+    s = JavaIdentifier();
+    label_36:
+    while (true) {
+      if (jj_2_23(2)) {
+        ;
+      } else {
+        break label_36;
+      }
+      jj_consume_token(DOT);
+      ss = JavaIdentifier();
+                                           s += "." + ss;
+    }
+                  {if (true) return s;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public void NameList() throws ParseException {
+    Name();
+    label_37:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[118] = jj_gen;
+        break label_37;
+      }
+      jj_consume_token(COMMA);
+      Name();
+    }
+  }
+
+/*
+ * Expression syntax follows.
+ */
+  final public void Expression() throws ParseException {
+    ConditionalExpression();
+    if (jj_2_24(2)) {
+      AssignmentOperator();
+      Expression();
+    } else {
+      ;
+    }
+  }
+
+  final public void AssignmentOperator() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case ASSIGN:
+      jj_consume_token(ASSIGN);
+      break;
+    case STARASSIGN:
+      jj_consume_token(STARASSIGN);
+      break;
+    case SLASHASSIGN:
+      jj_consume_token(SLASHASSIGN);
+      break;
+    case REMASSIGN:
+      jj_consume_token(REMASSIGN);
+      break;
+    case PLUSASSIGN:
+      jj_consume_token(PLUSASSIGN);
+      break;
+    case MINUSASSIGN:
+      jj_consume_token(MINUSASSIGN);
+      break;
+    case 134:
+      jj_consume_token(134);
+      break;
+    case 135:
+      jj_consume_token(135);
+      break;
+    case 136:
+      jj_consume_token(136);
+      break;
+    case ANDASSIGN:
+      jj_consume_token(ANDASSIGN);
+      break;
+    case XORASSIGN:
+      jj_consume_token(XORASSIGN);
+      break;
+    case ORASSIGN:
+      jj_consume_token(ORASSIGN);
+      break;
+    default:
+      jj_la1[119] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void ConditionalExpression() throws ParseException {
+    ConditionalOrExpression();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case HOOK:
+      jj_consume_token(HOOK);
+      Expression();
+      jj_consume_token(COLON);
+      Expression();
+      break;
+    default:
+      jj_la1[120] = jj_gen;
+      ;
+    }
+  }
+
+  final public void ConditionalOrExpression() throws ParseException {
+    ConditionalAndExpression();
+    label_38:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case SC_OR:
+        ;
+        break;
+      default:
+        jj_la1[121] = jj_gen;
+        break label_38;
+      }
+      jj_consume_token(SC_OR);
+      ConditionalAndExpression();
+    }
+  }
+
+  final public void ConditionalAndExpression() throws ParseException {
+    InclusiveOrExpression();
+    label_39:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case SC_AND:
+        ;
+        break;
+      default:
+        jj_la1[122] = jj_gen;
+        break label_39;
+      }
+      jj_consume_token(SC_AND);
+      InclusiveOrExpression();
+    }
+  }
+
+  final public void InclusiveOrExpression() throws ParseException {
+    ExclusiveOrExpression();
+    label_40:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case BIT_OR:
+        ;
+        break;
+      default:
+        jj_la1[123] = jj_gen;
+        break label_40;
+      }
+      jj_consume_token(BIT_OR);
+      ExclusiveOrExpression();
+    }
+  }
+
+  final public void ExclusiveOrExpression() throws ParseException {
+    AndExpression();
+    label_41:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case XOR:
+        ;
+        break;
+      default:
+        jj_la1[124] = jj_gen;
+        break label_41;
+      }
+      jj_consume_token(XOR);
+      AndExpression();
+    }
+  }
+
+  final public void AndExpression() throws ParseException {
+    EqualityExpression();
+    label_42:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case BIT_AND:
+        ;
+        break;
+      default:
+        jj_la1[125] = jj_gen;
+        break label_42;
+      }
+      jj_consume_token(BIT_AND);
+      EqualityExpression();
+    }
+  }
+
+  final public void EqualityExpression() throws ParseException {
+    InstanceOfExpression();
+    label_43:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case EQ:
+      case NE:
+        ;
+        break;
+      default:
+        jj_la1[126] = jj_gen;
+        break label_43;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case EQ:
+        jj_consume_token(EQ);
+        break;
+      case NE:
+        jj_consume_token(NE);
+        break;
+      default:
+        jj_la1[127] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      InstanceOfExpression();
+    }
+  }
+
+  final public void InstanceOfExpression() throws ParseException {
+    RelationalExpression();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case INSTANCEOF:
+      jj_consume_token(INSTANCEOF);
+      Type();
+      break;
+    default:
+      jj_la1[128] = jj_gen;
+      ;
+    }
+  }
+
+  final public void RelationalExpression() throws ParseException {
+    ShiftExpression();
+    label_44:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LT:
+      case LE:
+      case GE:
+      case GT:
+        ;
+        break;
+      default:
+        jj_la1[129] = jj_gen;
+        break label_44;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LT:
+        jj_consume_token(LT);
+        break;
+      case GT:
+        jj_consume_token(GT);
+        break;
+      case LE:
+        jj_consume_token(LE);
+        break;
+      case GE:
+        jj_consume_token(GE);
+        break;
+      default:
+        jj_la1[130] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      ShiftExpression();
+    }
+  }
+
+  final public void ShiftExpression() throws ParseException {
+    AdditiveExpression();
+    label_45:
+    while (true) {
+      if (jj_2_25(1)) {
+        ;
+      } else {
+        break label_45;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case 137:
+        jj_consume_token(137);
+        break;
+      default:
+        jj_la1[131] = jj_gen;
+        if (jj_2_26(1)) {
+          RSIGNEDSHIFT();
+        } else if (jj_2_27(1)) {
+          RUNSIGNEDSHIFT();
+        } else {
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+      AdditiveExpression();
+    }
+  }
+
+  final public void AdditiveExpression() throws ParseException {
+    MultiplicativeExpression();
+    label_46:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case PLUS:
+      case MINUS:
+        ;
+        break;
+      default:
+        jj_la1[132] = jj_gen;
+        break label_46;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case PLUS:
+        jj_consume_token(PLUS);
+        break;
+      case MINUS:
+        jj_consume_token(MINUS);
+        break;
+      default:
+        jj_la1[133] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      MultiplicativeExpression();
+    }
+  }
+
+  final public void MultiplicativeExpression() throws ParseException {
+    UnaryExpression();
+    label_47:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case STAR:
+      case SLASH:
+      case REM:
+        ;
+        break;
+      default:
+        jj_la1[134] = jj_gen;
+        break label_47;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case STAR:
+        jj_consume_token(STAR);
+        break;
+      case SLASH:
+        jj_consume_token(SLASH);
+        break;
+      case REM:
+        jj_consume_token(REM);
+        break;
+      default:
+        jj_la1[135] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      UnaryExpression();
+    }
+  }
+
+  final public void UnaryExpression() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case PLUS:
+    case MINUS:
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case PLUS:
+        jj_consume_token(PLUS);
+        break;
+      case MINUS:
+        jj_consume_token(MINUS);
+        break;
+      default:
+        jj_la1[136] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      UnaryExpression();
+      break;
+    case INCR:
+      PreIncrementExpression();
+      break;
+    case DECR:
+      PreDecrementExpression();
+      break;
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _JAVACODE:
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case _TOKEN_MGR_DECLS:
+    case _EOF:
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case CONST:
+    case DOUBLE:
+    case FALSE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case NEW:
+    case NULL:
+    case SHORT:
+    case SUPER:
+    case THIS:
+    case TRUE:
+    case VOID:
+    case INTEGER_LITERAL:
+    case FLOATING_POINT_LITERAL:
+    case CHARACTER_LITERAL:
+    case STRING_LITERAL:
+    case LPAREN:
+    case BANG:
+    case TILDE:
+    case 132:
+    case IDENTIFIER:
+      UnaryExpressionNotPlusMinus();
+      break;
+    default:
+      jj_la1[137] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void PreIncrementExpression() throws ParseException {
+    jj_consume_token(INCR);
+    PrimaryExpression();
+  }
+
+  final public void PreDecrementExpression() throws ParseException {
+    jj_consume_token(DECR);
+    PrimaryExpression();
+  }
+
+  final public void UnaryExpressionNotPlusMinus() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case BANG:
+    case TILDE:
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case TILDE:
+        jj_consume_token(TILDE);
+        break;
+      case BANG:
+        jj_consume_token(BANG);
+        break;
+      default:
+        jj_la1[138] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      UnaryExpression();
+      break;
+    default:
+      jj_la1[139] = jj_gen;
+      if (jj_2_28(2147483647)) {
+        CastExpression();
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case _LOOKAHEAD:
+        case _IGNORE_CASE:
+        case _PARSER_BEGIN:
+        case _PARSER_END:
+        case _JAVACODE:
+        case _TOKEN:
+        case _SPECIAL_TOKEN:
+        case _MORE:
+        case _SKIP:
+        case _TOKEN_MGR_DECLS:
+        case _EOF:
+        case BOOLEAN:
+        case BYTE:
+        case CHAR:
+        case CONST:
+        case DOUBLE:
+        case FALSE:
+        case FLOAT:
+        case INT:
+        case LONG:
+        case NEW:
+        case NULL:
+        case SHORT:
+        case SUPER:
+        case THIS:
+        case TRUE:
+        case VOID:
+        case INTEGER_LITERAL:
+        case FLOATING_POINT_LITERAL:
+        case CHARACTER_LITERAL:
+        case STRING_LITERAL:
+        case LPAREN:
+        case 132:
+        case IDENTIFIER:
+          PostfixExpression();
+          break;
+        default:
+          jj_la1[140] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+    }
+  }
+
+// This production is to determine lookahead only.  The LOOKAHEAD specifications
+// below are not used, but they are there just to indicate that we know about
+// this.
+  final public void CastLookahead() throws ParseException {
+    if (jj_2_29(2)) {
+      jj_consume_token(LPAREN);
+      PrimitiveType();
+    } else if (jj_2_30(2147483647)) {
+      jj_consume_token(LPAREN);
+      Type();
+      jj_consume_token(LBRACKET);
+      jj_consume_token(RBRACKET);
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LPAREN:
+        jj_consume_token(LPAREN);
+        Type();
+        jj_consume_token(RPAREN);
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case TILDE:
+          jj_consume_token(TILDE);
+          break;
+        case BANG:
+          jj_consume_token(BANG);
+          break;
+        case LPAREN:
+          jj_consume_token(LPAREN);
+          break;
+        case _LOOKAHEAD:
+        case _IGNORE_CASE:
+        case _PARSER_BEGIN:
+        case _PARSER_END:
+        case _JAVACODE:
+        case _TOKEN:
+        case _SPECIAL_TOKEN:
+        case _MORE:
+        case _SKIP:
+        case _TOKEN_MGR_DECLS:
+        case _EOF:
+        case IDENTIFIER:
+          JavaIdentifier();
+          break;
+        case THIS:
+          jj_consume_token(THIS);
+          break;
+        case SUPER:
+          jj_consume_token(SUPER);
+          break;
+        case NEW:
+          jj_consume_token(NEW);
+          break;
+        case FALSE:
+        case NULL:
+        case TRUE:
+        case INTEGER_LITERAL:
+        case FLOATING_POINT_LITERAL:
+        case CHARACTER_LITERAL:
+        case STRING_LITERAL:
+          Literal();
+          break;
+        default:
+          jj_la1[141] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+        break;
+      default:
+        jj_la1[142] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void PostfixExpression() throws ParseException {
+    PrimaryExpression();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case INCR:
+    case DECR:
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case INCR:
+        jj_consume_token(INCR);
+        break;
+      case DECR:
+        jj_consume_token(DECR);
+        break;
+      default:
+        jj_la1[143] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      break;
+    default:
+      jj_la1[144] = jj_gen;
+      ;
+    }
+  }
+
+  final public void CastExpression() throws ParseException {
+    if (jj_2_31(2147483647)) {
+      jj_consume_token(LPAREN);
+      Type();
+      jj_consume_token(RPAREN);
+      UnaryExpression();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LPAREN:
+        jj_consume_token(LPAREN);
+        Type();
+        jj_consume_token(RPAREN);
+        UnaryExpressionNotPlusMinus();
+        break;
+      default:
+        jj_la1[145] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void PrimaryExpression() throws ParseException {
+ /*@bgen(jjtree) PrimaryExpression */
+  ASTPrimaryExpression jjtn000 = new ASTPrimaryExpression(JJTPRIMARYEXPRESSION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      PrimaryPrefix();
+      label_48:
+      while (true) {
+        if (jj_2_32(2)) {
+          ;
+        } else {
+          break label_48;
+        }
+        PrimarySuffix();
+      }
+    } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      jjtreeCloseNodeScope(jjtn000);
+    }
+    }
+  }
+
+  final public void MemberSelector() throws ParseException {
+    jj_consume_token(DOT);
+    TypeArguments();
+    JavaIdentifier();
+  }
+
+  final public void PrimaryPrefix() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case FALSE:
+    case NULL:
+    case TRUE:
+    case INTEGER_LITERAL:
+    case FLOATING_POINT_LITERAL:
+    case CHARACTER_LITERAL:
+    case STRING_LITERAL:
+      Literal();
+      break;
+    case THIS:
+      jj_consume_token(THIS);
+      break;
+    case SUPER:
+      jj_consume_token(SUPER);
+      jj_consume_token(DOT);
+      JavaIdentifier();
+      break;
+    case LPAREN:
+      jj_consume_token(LPAREN);
+      Expression();
+      jj_consume_token(RPAREN);
+      break;
+    case NEW:
+      AllocationExpression();
+      break;
+    default:
+      jj_la1[146] = jj_gen;
+      if (jj_2_33(2147483647)) {
+        ResultType();
+        jj_consume_token(DOT);
+        jj_consume_token(CLASS);
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case _LOOKAHEAD:
+        case _IGNORE_CASE:
+        case _PARSER_BEGIN:
+        case _PARSER_END:
+        case _JAVACODE:
+        case _TOKEN:
+        case _SPECIAL_TOKEN:
+        case _MORE:
+        case _SKIP:
+        case _TOKEN_MGR_DECLS:
+        case _EOF:
+        case IDENTIFIER:
+          Name();
+          break;
+        default:
+          jj_la1[147] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+    }
+  }
+
+  final public void PrimarySuffix() throws ParseException {
+    if (jj_2_34(2)) {
+      jj_consume_token(DOT);
+      jj_consume_token(THIS);
+    } else if (jj_2_35(2)) {
+      jj_consume_token(DOT);
+      AllocationExpression();
+    } else if (jj_2_36(3)) {
+      MemberSelector();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LBRACKET:
+        jj_consume_token(LBRACKET);
+        Expression();
+        jj_consume_token(RBRACKET);
+        break;
+      case DOT:
+        jj_consume_token(DOT);
+        JavaIdentifier();
+        break;
+      case LPAREN:
+        Arguments();
+        break;
+      default:
+        jj_la1[148] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void Literal() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case INTEGER_LITERAL:
+      jj_consume_token(INTEGER_LITERAL);
+      break;
+    case FLOATING_POINT_LITERAL:
+      jj_consume_token(FLOATING_POINT_LITERAL);
+      break;
+    case CHARACTER_LITERAL:
+      jj_consume_token(CHARACTER_LITERAL);
+      break;
+    case STRING_LITERAL:
+      jj_consume_token(STRING_LITERAL);
+      break;
+    case FALSE:
+    case TRUE:
+      BooleanLiteral();
+      break;
+    case NULL:
+      NullLiteral();
+      break;
+    default:
+      jj_la1[149] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public Token IntegerLiteral() throws ParseException {
+  Token t;
+    t = jj_consume_token(INTEGER_LITERAL);
+                  {if (true) return t;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Token BooleanLiteral() throws ParseException {
+  Token t;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case TRUE:
+      t = jj_consume_token(TRUE);
+                  {if (true) return t;}
+      break;
+    case FALSE:
+      t = jj_consume_token(FALSE);
+                  {if (true) return t;}
+      break;
+    default:
+      jj_la1[150] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Token StringLiteral() throws ParseException {
+  Token t;
+    t = jj_consume_token(STRING_LITERAL);
+                  {if (true) return t;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public void NullLiteral() throws ParseException {
+    jj_consume_token(NULL);
+  }
+
+  final public void Arguments() throws ParseException {
+    jj_consume_token(LPAREN);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _JAVACODE:
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case _TOKEN_MGR_DECLS:
+    case _EOF:
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case CONST:
+    case DOUBLE:
+    case FALSE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case NEW:
+    case NULL:
+    case SHORT:
+    case SUPER:
+    case THIS:
+    case TRUE:
+    case VOID:
+    case INTEGER_LITERAL:
+    case FLOATING_POINT_LITERAL:
+    case CHARACTER_LITERAL:
+    case STRING_LITERAL:
+    case LPAREN:
+    case BANG:
+    case TILDE:
+    case INCR:
+    case DECR:
+    case PLUS:
+    case MINUS:
+    case 132:
+    case IDENTIFIER:
+      ArgumentList();
+      break;
+    default:
+      jj_la1[151] = jj_gen;
+      ;
+    }
+    jj_consume_token(RPAREN);
+  }
+
+  final public void ArgumentList() throws ParseException {
+    Expression();
+    label_49:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[152] = jj_gen;
+        break label_49;
+      }
+      jj_consume_token(COMMA);
+      Expression();
+    }
+  }
+
+  final public void AllocationExpression() throws ParseException {
+    if (jj_2_37(2)) {
+      jj_consume_token(NEW);
+      PrimitiveType();
+      ArrayDimsAndInits();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case NEW:
+        jj_consume_token(NEW);
+        ClassOrInterfaceType();
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case LT:
+          TypeArguments();
+          break;
+        default:
+          jj_la1[153] = jj_gen;
+          ;
+        }
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case LBRACKET:
+          ArrayDimsAndInits();
+          break;
+        case LPAREN:
+          Arguments();
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case LBRACE:
+            ClassOrInterfaceBody();
+            break;
+          default:
+            jj_la1[154] = jj_gen;
+            ;
+          }
+          break;
+        default:
+          jj_la1[155] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+        break;
+      default:
+        jj_la1[156] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+/*
+ * The third LOOKAHEAD specification below is to parse to PrimarySuffix
+ * if there is an expression between the "[...]".
+ */
+  final public void ArrayDimsAndInits() throws ParseException {
+    if (jj_2_40(2)) {
+      label_50:
+      while (true) {
+        jj_consume_token(LBRACKET);
+        Expression();
+        jj_consume_token(RBRACKET);
+        if (jj_2_38(2)) {
+          ;
+        } else {
+          break label_50;
+        }
+      }
+      label_51:
+      while (true) {
+        if (jj_2_39(2)) {
+          ;
+        } else {
+          break label_51;
+        }
+        jj_consume_token(LBRACKET);
+        jj_consume_token(RBRACKET);
+      }
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LBRACKET:
+        label_52:
+        while (true) {
+          jj_consume_token(LBRACKET);
+          jj_consume_token(RBRACKET);
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case LBRACKET:
+            ;
+            break;
+          default:
+            jj_la1[157] = jj_gen;
+            break label_52;
+          }
+        }
+        ArrayInitializer();
+        break;
+      default:
+        jj_la1[158] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+/*
+ * Statement syntax follows.
+ */
+  final public void Statement() throws ParseException {
+    if (jj_2_41(2)) {
+      LabeledStatement();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case 138:
+        AssertStatement();
+        break;
+      case LBRACE:
+        Block();
+        break;
+      case SEMICOLON:
+        EmptyStatement();
+        break;
+      case _LOOKAHEAD:
+      case _IGNORE_CASE:
+      case _PARSER_BEGIN:
+      case _PARSER_END:
+      case _JAVACODE:
+      case _TOKEN:
+      case _SPECIAL_TOKEN:
+      case _MORE:
+      case _SKIP:
+      case _TOKEN_MGR_DECLS:
+      case _EOF:
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case CONST:
+      case DOUBLE:
+      case FALSE:
+      case FLOAT:
+      case INT:
+      case LONG:
+      case NEW:
+      case NULL:
+      case SHORT:
+      case SUPER:
+      case THIS:
+      case TRUE:
+      case VOID:
+      case INTEGER_LITERAL:
+      case FLOATING_POINT_LITERAL:
+      case CHARACTER_LITERAL:
+      case STRING_LITERAL:
+      case LPAREN:
+      case INCR:
+      case DECR:
+      case 132:
+      case IDENTIFIER:
+        StatementExpression();
+        jj_consume_token(SEMICOLON);
+        break;
+      case SWITCH:
+        SwitchStatement();
+        break;
+      case IF:
+        IfStatement();
+        break;
+      case WHILE:
+        WhileStatement();
+        break;
+      case DO:
+        DoStatement();
+        break;
+      case FOR:
+        ForStatement();
+        break;
+      case BREAK:
+        BreakStatement();
+        break;
+      case CONTINUE:
+        ContinueStatement();
+        break;
+      case RETURN:
+        ReturnStatement();
+        break;
+      case THROW:
+        ThrowStatement();
+        break;
+      case SYNCHRONIZED:
+        SynchronizedStatement();
+        break;
+      case TRY:
+        TryStatement();
+        break;
+      default:
+        jj_la1[159] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void AssertStatement() throws ParseException {
+    jj_consume_token(138);
+    Expression();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case COLON:
+      jj_consume_token(COLON);
+      Expression();
+      break;
+    default:
+      jj_la1[160] = jj_gen;
+      ;
+    }
+    jj_consume_token(SEMICOLON);
+  }
+
+  final public void LabeledStatement() throws ParseException {
+    JavaIdentifier();
+    jj_consume_token(COLON);
+    Statement();
+  }
+
+  final public void Block() throws ParseException {
+    jj_consume_token(LBRACE);
+      if (!isJavaLanguage) {
+        eatUptoCloseBrace();
+      }
+    label_53:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case _LOOKAHEAD:
+      case _IGNORE_CASE:
+      case _PARSER_BEGIN:
+      case _PARSER_END:
+      case _JAVACODE:
+      case _TOKEN:
+      case _SPECIAL_TOKEN:
+      case _MORE:
+      case _SKIP:
+      case _TOKEN_MGR_DECLS:
+      case _EOF:
+      case ABSTRACT:
+      case BOOLEAN:
+      case BREAK:
+      case BYTE:
+      case CHAR:
+      case CLASS:
+      case CONST:
+      case CONTINUE:
+      case DO:
+      case DOUBLE:
+      case FALSE:
+      case FINAL:
+      case FLOAT:
+      case FOR:
+      case IF:
+      case INT:
+      case INTERFACE:
+      case LONG:
+      case NATIVE:
+      case NEW:
+      case NULL:
+      case PRIVATE:
+      case PROTECTED:
+      case PUBLIC:
+      case RETURN:
+      case SHORT:
+      case STATIC:
+      case SUPER:
+      case SWITCH:
+      case SYNCHRONIZED:
+      case THIS:
+      case THROW:
+      case TRANSIENT:
+      case TRUE:
+      case TRY:
+      case VOID:
+      case VOLATILE:
+      case WHILE:
+      case INTEGER_LITERAL:
+      case FLOATING_POINT_LITERAL:
+      case CHARACTER_LITERAL:
+      case STRING_LITERAL:
+      case LPAREN:
+      case LBRACE:
+      case SEMICOLON:
+      case INCR:
+      case DECR:
+      case 129:
+      case 132:
+      case 138:
+      case 139:
+      case IDENTIFIER:
+        ;
+        break;
+      default:
+        jj_la1[161] = jj_gen;
+        break label_53;
+      }
+      BlockStatement();
+    }
+    jj_consume_token(RBRACE);
+  }
+
+  final public void BlockStatement() throws ParseException {
+    if (jj_2_42(2147483647)) {
+      LocalVariableDeclaration();
+      jj_consume_token(SEMICOLON);
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case _LOOKAHEAD:
+      case _IGNORE_CASE:
+      case _PARSER_BEGIN:
+      case _PARSER_END:
+      case _JAVACODE:
+      case _TOKEN:
+      case _SPECIAL_TOKEN:
+      case _MORE:
+      case _SKIP:
+      case _TOKEN_MGR_DECLS:
+      case _EOF:
+      case BOOLEAN:
+      case BREAK:
+      case BYTE:
+      case CHAR:
+      case CONST:
+      case CONTINUE:
+      case DO:
+      case DOUBLE:
+      case FALSE:
+      case FLOAT:
+      case FOR:
+      case IF:
+      case INT:
+      case LONG:
+      case NEW:
+      case NULL:
+      case RETURN:
+      case SHORT:
+      case SUPER:
+      case SWITCH:
+      case SYNCHRONIZED:
+      case THIS:
+      case THROW:
+      case TRUE:
+      case TRY:
+      case VOID:
+      case WHILE:
+      case INTEGER_LITERAL:
+      case FLOATING_POINT_LITERAL:
+      case CHARACTER_LITERAL:
+      case STRING_LITERAL:
+      case LPAREN:
+      case LBRACE:
+      case SEMICOLON:
+      case INCR:
+      case DECR:
+      case 132:
+      case 138:
+      case IDENTIFIER:
+        Statement();
+        break;
+      case CLASS:
+      case INTERFACE:
+        ClassOrInterfaceDeclaration();
+        break;
+      default:
+        jj_la1[162] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void LocalVariableDeclaration() throws ParseException {
+    Modifiers();
+    Type();
+    VariableDeclarator();
+    label_54:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[163] = jj_gen;
+        break label_54;
+      }
+      jj_consume_token(COMMA);
+      VariableDeclarator();
+    }
+  }
+
+  final public void EmptyStatement() throws ParseException {
+    jj_consume_token(SEMICOLON);
+  }
+
+  final public void StatementExpression() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case INCR:
+      PreIncrementExpression();
+      break;
+    case DECR:
+      PreDecrementExpression();
+      break;
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _JAVACODE:
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case _TOKEN_MGR_DECLS:
+    case _EOF:
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case CONST:
+    case DOUBLE:
+    case FALSE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case NEW:
+    case NULL:
+    case SHORT:
+    case SUPER:
+    case THIS:
+    case TRUE:
+    case VOID:
+    case INTEGER_LITERAL:
+    case FLOATING_POINT_LITERAL:
+    case CHARACTER_LITERAL:
+    case STRING_LITERAL:
+    case LPAREN:
+    case 132:
+    case IDENTIFIER:
+      PrimaryExpression();
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case ASSIGN:
+      case INCR:
+      case DECR:
+      case PLUSASSIGN:
+      case MINUSASSIGN:
+      case STARASSIGN:
+      case SLASHASSIGN:
+      case ANDASSIGN:
+      case ORASSIGN:
+      case XORASSIGN:
+      case REMASSIGN:
+      case 134:
+      case 135:
+      case 136:
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case INCR:
+          jj_consume_token(INCR);
+          break;
+        case DECR:
+          jj_consume_token(DECR);
+          break;
+        case ASSIGN:
+        case PLUSASSIGN:
+        case MINUSASSIGN:
+        case STARASSIGN:
+        case SLASHASSIGN:
+        case ANDASSIGN:
+        case ORASSIGN:
+        case XORASSIGN:
+        case REMASSIGN:
+        case 134:
+        case 135:
+        case 136:
+          AssignmentOperator();
+          Expression();
+          break;
+        default:
+          jj_la1[164] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+        break;
+      default:
+        jj_la1[165] = jj_gen;
+        ;
+      }
+      break;
+    default:
+      jj_la1[166] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void SwitchStatement() throws ParseException {
+    jj_consume_token(SWITCH);
+    jj_consume_token(LPAREN);
+    Expression();
+    jj_consume_token(RPAREN);
+    jj_consume_token(LBRACE);
+    label_55:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case CASE:
+      case _DEFAULT:
+        ;
+        break;
+      default:
+        jj_la1[167] = jj_gen;
+        break label_55;
+      }
+      SwitchLabel();
+      label_56:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case _LOOKAHEAD:
+        case _IGNORE_CASE:
+        case _PARSER_BEGIN:
+        case _PARSER_END:
+        case _JAVACODE:
+        case _TOKEN:
+        case _SPECIAL_TOKEN:
+        case _MORE:
+        case _SKIP:
+        case _TOKEN_MGR_DECLS:
+        case _EOF:
+        case ABSTRACT:
+        case BOOLEAN:
+        case BREAK:
+        case BYTE:
+        case CHAR:
+        case CLASS:
+        case CONST:
+        case CONTINUE:
+        case DO:
+        case DOUBLE:
+        case FALSE:
+        case FINAL:
+        case FLOAT:
+        case FOR:
+        case IF:
+        case INT:
+        case INTERFACE:
+        case LONG:
+        case NATIVE:
+        case NEW:
+        case NULL:
+        case PRIVATE:
+        case PROTECTED:
+        case PUBLIC:
+        case RETURN:
+        case SHORT:
+        case STATIC:
+        case SUPER:
+        case SWITCH:
+        case SYNCHRONIZED:
+        case THIS:
+        case THROW:
+        case TRANSIENT:
+        case TRUE:
+        case TRY:
+        case VOID:
+        case VOLATILE:
+        case WHILE:
+        case INTEGER_LITERAL:
+        case FLOATING_POINT_LITERAL:
+        case CHARACTER_LITERAL:
+        case STRING_LITERAL:
+        case LPAREN:
+        case LBRACE:
+        case SEMICOLON:
+        case INCR:
+        case DECR:
+        case 129:
+        case 132:
+        case 138:
+        case 139:
+        case IDENTIFIER:
+          ;
+          break;
+        default:
+          jj_la1[168] = jj_gen;
+          break label_56;
+        }
+        BlockStatement();
+      }
+    }
+    jj_consume_token(RBRACE);
+  }
+
+  final public void SwitchLabel() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case CASE:
+      jj_consume_token(CASE);
+      Expression();
+      jj_consume_token(COLON);
+      break;
+    case _DEFAULT:
+      jj_consume_token(_DEFAULT);
+      jj_consume_token(COLON);
+      break;
+    default:
+      jj_la1[169] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void IfStatement() throws ParseException {
+    jj_consume_token(IF);
+    jj_consume_token(LPAREN);
+    Expression();
+    jj_consume_token(RPAREN);
+    Statement();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case ELSE:
+      jj_consume_token(ELSE);
+      Statement();
+      break;
+    default:
+      jj_la1[170] = jj_gen;
+      ;
+    }
+  }
+
+  final public void WhileStatement() throws ParseException {
+    jj_consume_token(WHILE);
+    jj_consume_token(LPAREN);
+    Expression();
+    jj_consume_token(RPAREN);
+    Statement();
+  }
+
+  final public void DoStatement() throws ParseException {
+    jj_consume_token(DO);
+    Statement();
+    jj_consume_token(WHILE);
+    jj_consume_token(LPAREN);
+    Expression();
+    jj_consume_token(RPAREN);
+    jj_consume_token(SEMICOLON);
+  }
+
+  final public void ForStatement() throws ParseException {
+    jj_consume_token(FOR);
+    jj_consume_token(LPAREN);
+    if (jj_2_43(2147483647)) {
+      Modifiers();
+      Type();
+      JavaIdentifier();
+      jj_consume_token(COLON);
+      Expression();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case _LOOKAHEAD:
+      case _IGNORE_CASE:
+      case _PARSER_BEGIN:
+      case _PARSER_END:
+      case _JAVACODE:
+      case _TOKEN:
+      case _SPECIAL_TOKEN:
+      case _MORE:
+      case _SKIP:
+      case _TOKEN_MGR_DECLS:
+      case _EOF:
+      case ABSTRACT:
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case CONST:
+      case DOUBLE:
+      case FALSE:
+      case FINAL:
+      case FLOAT:
+      case INT:
+      case LONG:
+      case NATIVE:
+      case NEW:
+      case NULL:
+      case PRIVATE:
+      case PROTECTED:
+      case PUBLIC:
+      case SHORT:
+      case STATIC:
+      case SUPER:
+      case SYNCHRONIZED:
+      case THIS:
+      case TRANSIENT:
+      case TRUE:
+      case VOID:
+      case VOLATILE:
+      case INTEGER_LITERAL:
+      case FLOATING_POINT_LITERAL:
+      case CHARACTER_LITERAL:
+      case STRING_LITERAL:
+      case LPAREN:
+      case SEMICOLON:
+      case INCR:
+      case DECR:
+      case 129:
+      case 132:
+      case 139:
+      case IDENTIFIER:
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case _LOOKAHEAD:
+        case _IGNORE_CASE:
+        case _PARSER_BEGIN:
+        case _PARSER_END:
+        case _JAVACODE:
+        case _TOKEN:
+        case _SPECIAL_TOKEN:
+        case _MORE:
+        case _SKIP:
+        case _TOKEN_MGR_DECLS:
+        case _EOF:
+        case ABSTRACT:
+        case BOOLEAN:
+        case BYTE:
+        case CHAR:
+        case CONST:
+        case DOUBLE:
+        case FALSE:
+        case FINAL:
+        case FLOAT:
+        case INT:
+        case LONG:
+        case NATIVE:
+        case NEW:
+        case NULL:
+        case PRIVATE:
+        case PROTECTED:
+        case PUBLIC:
+        case SHORT:
+        case STATIC:
+        case SUPER:
+        case SYNCHRONIZED:
+        case THIS:
+        case TRANSIENT:
+        case TRUE:
+        case VOID:
+        case VOLATILE:
+        case INTEGER_LITERAL:
+        case FLOATING_POINT_LITERAL:
+        case CHARACTER_LITERAL:
+        case STRING_LITERAL:
+        case LPAREN:
+        case INCR:
+        case DECR:
+        case 129:
+        case 132:
+        case 139:
+        case IDENTIFIER:
+          ForInit();
+          break;
+        default:
+          jj_la1[171] = jj_gen;
+          ;
+        }
+        jj_consume_token(SEMICOLON);
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case _LOOKAHEAD:
+        case _IGNORE_CASE:
+        case _PARSER_BEGIN:
+        case _PARSER_END:
+        case _JAVACODE:
+        case _TOKEN:
+        case _SPECIAL_TOKEN:
+        case _MORE:
+        case _SKIP:
+        case _TOKEN_MGR_DECLS:
+        case _EOF:
+        case BOOLEAN:
+        case BYTE:
+        case CHAR:
+        case CONST:
+        case DOUBLE:
+        case FALSE:
+        case FLOAT:
+        case INT:
+        case LONG:
+        case NEW:
+        case NULL:
+        case SHORT:
+        case SUPER:
+        case THIS:
+        case TRUE:
+        case VOID:
+        case INTEGER_LITERAL:
+        case FLOATING_POINT_LITERAL:
+        case CHARACTER_LITERAL:
+        case STRING_LITERAL:
+        case LPAREN:
+        case BANG:
+        case TILDE:
+        case INCR:
+        case DECR:
+        case PLUS:
+        case MINUS:
+        case 132:
+        case IDENTIFIER:
+          Expression();
+          break;
+        default:
+          jj_la1[172] = jj_gen;
+          ;
+        }
+        jj_consume_token(SEMICOLON);
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case _LOOKAHEAD:
+        case _IGNORE_CASE:
+        case _PARSER_BEGIN:
+        case _PARSER_END:
+        case _JAVACODE:
+        case _TOKEN:
+        case _SPECIAL_TOKEN:
+        case _MORE:
+        case _SKIP:
+        case _TOKEN_MGR_DECLS:
+        case _EOF:
+        case BOOLEAN:
+        case BYTE:
+        case CHAR:
+        case CONST:
+        case DOUBLE:
+        case FALSE:
+        case FLOAT:
+        case INT:
+        case LONG:
+        case NEW:
+        case NULL:
+        case SHORT:
+        case SUPER:
+        case THIS:
+        case TRUE:
+        case VOID:
+        case INTEGER_LITERAL:
+        case FLOATING_POINT_LITERAL:
+        case CHARACTER_LITERAL:
+        case STRING_LITERAL:
+        case LPAREN:
+        case INCR:
+        case DECR:
+        case 132:
+        case IDENTIFIER:
+          ForUpdate();
+          break;
+        default:
+          jj_la1[173] = jj_gen;
+          ;
+        }
+        break;
+      default:
+        jj_la1[174] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+    jj_consume_token(RPAREN);
+    Statement();
+  }
+
+  final public void ForInit() throws ParseException {
+    if (jj_2_44(2147483647)) {
+      LocalVariableDeclaration();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case _LOOKAHEAD:
+      case _IGNORE_CASE:
+      case _PARSER_BEGIN:
+      case _PARSER_END:
+      case _JAVACODE:
+      case _TOKEN:
+      case _SPECIAL_TOKEN:
+      case _MORE:
+      case _SKIP:
+      case _TOKEN_MGR_DECLS:
+      case _EOF:
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case CONST:
+      case DOUBLE:
+      case FALSE:
+      case FLOAT:
+      case INT:
+      case LONG:
+      case NEW:
+      case NULL:
+      case SHORT:
+      case SUPER:
+      case THIS:
+      case TRUE:
+      case VOID:
+      case INTEGER_LITERAL:
+      case FLOATING_POINT_LITERAL:
+      case CHARACTER_LITERAL:
+      case STRING_LITERAL:
+      case LPAREN:
+      case INCR:
+      case DECR:
+      case 132:
+      case IDENTIFIER:
+        StatementExpressionList();
+        break;
+      default:
+        jj_la1[175] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void StatementExpressionList() throws ParseException {
+    StatementExpression();
+    label_57:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[176] = jj_gen;
+        break label_57;
+      }
+      jj_consume_token(COMMA);
+      StatementExpression();
+    }
+  }
+
+  final public void ForUpdate() throws ParseException {
+    StatementExpressionList();
+  }
+
+  final public void BreakStatement() throws ParseException {
+    jj_consume_token(BREAK);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _JAVACODE:
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case _TOKEN_MGR_DECLS:
+    case _EOF:
+    case IDENTIFIER:
+      JavaIdentifier();
+      break;
+    default:
+      jj_la1[177] = jj_gen;
+      ;
+    }
+    jj_consume_token(SEMICOLON);
+  }
+
+  final public void ContinueStatement() throws ParseException {
+    jj_consume_token(CONTINUE);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _JAVACODE:
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case _TOKEN_MGR_DECLS:
+    case _EOF:
+    case IDENTIFIER:
+      JavaIdentifier();
+      break;
+    default:
+      jj_la1[178] = jj_gen;
+      ;
+    }
+    jj_consume_token(SEMICOLON);
+  }
+
+  final public void ReturnStatement() throws ParseException {
+    jj_consume_token(RETURN);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _JAVACODE:
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case _TOKEN_MGR_DECLS:
+    case _EOF:
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case CONST:
+    case DOUBLE:
+    case FALSE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case NEW:
+    case NULL:
+    case SHORT:
+    case SUPER:
+    case THIS:
+    case TRUE:
+    case VOID:
+    case INTEGER_LITERAL:
+    case FLOATING_POINT_LITERAL:
+    case CHARACTER_LITERAL:
+    case STRING_LITERAL:
+    case LPAREN:
+    case BANG:
+    case TILDE:
+    case INCR:
+    case DECR:
+    case PLUS:
+    case MINUS:
+    case 132:
+    case IDENTIFIER:
+      Expression();
+      break;
+    default:
+      jj_la1[179] = jj_gen;
+      ;
+    }
+    jj_consume_token(SEMICOLON);
+  }
+
+  final public void ThrowStatement() throws ParseException {
+    jj_consume_token(THROW);
+    Expression();
+    jj_consume_token(SEMICOLON);
+  }
+
+  final public void SynchronizedStatement() throws ParseException {
+    jj_consume_token(SYNCHRONIZED);
+    jj_consume_token(LPAREN);
+    Expression();
+    jj_consume_token(RPAREN);
+    Block();
+  }
+
+  final public void TryStatement() throws ParseException {
+    jj_consume_token(TRY);
+    Block();
+    label_58:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case CATCH:
+        ;
+        break;
+      default:
+        jj_la1[180] = jj_gen;
+        break label_58;
+      }
+      jj_consume_token(CATCH);
+      jj_consume_token(LPAREN);
+      FormalParameter();
+      jj_consume_token(RPAREN);
+      Block();
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case FINALLY:
+      jj_consume_token(FINALLY);
+      Block();
+      break;
+    default:
+      jj_la1[181] = jj_gen;
+      ;
+    }
+  }
+
+/* We use productions to match >>>, >> and > so that we can keep the
+ * type declaration syntax with generics clean
+ */
+  final public void RUNSIGNEDSHIFT() throws ParseException {
+    if (getToken(1).kind == GT &&
+                    ((Token.GTToken)getToken(1)).realKind == RUNSIGNEDSHIFT) {
+
+    } else {
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    jj_consume_token(GT);
+    jj_consume_token(GT);
+    jj_consume_token(GT);
+  }
+
+  final public void RSIGNEDSHIFT() throws ParseException {
+    if (getToken(1).kind == GT &&
+                    ((Token.GTToken)getToken(1)).realKind == RSIGNEDSHIFT) {
+
+    } else {
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    jj_consume_token(GT);
+    jj_consume_token(GT);
+  }
+
+/* Annotation syntax follows. */
+  final public void Annotation() throws ParseException {
+    if (jj_2_45(2147483647)) {
+      NormalAnnotation();
+    } else if (jj_2_46(2147483647)) {
+      SingleMemberAnnotation();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case 139:
+        MarkerAnnotation();
+        break;
+      default:
+        jj_la1[182] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void NormalAnnotation() throws ParseException {
+    jj_consume_token(139);
+    Name();
+    jj_consume_token(LPAREN);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _JAVACODE:
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case _TOKEN_MGR_DECLS:
+    case _EOF:
+    case IDENTIFIER:
+      MemberValuePairs();
+      break;
+    default:
+      jj_la1[183] = jj_gen;
+      ;
+    }
+    jj_consume_token(RPAREN);
+  }
+
+  final public void MarkerAnnotation() throws ParseException {
+    jj_consume_token(139);
+    Name();
+  }
+
+  final public void SingleMemberAnnotation() throws ParseException {
+    jj_consume_token(139);
+    Name();
+    jj_consume_token(LPAREN);
+    MemberValue();
+    jj_consume_token(RPAREN);
+  }
+
+  final public void MemberValuePairs() throws ParseException {
+    MemberValuePair();
+    label_59:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[184] = jj_gen;
+        break label_59;
+      }
+      jj_consume_token(COMMA);
+      MemberValuePair();
+    }
+  }
+
+  final public void MemberValuePair() throws ParseException {
+    JavaIdentifier();
+    jj_consume_token(ASSIGN);
+    MemberValue();
+  }
+
+  final public void MemberValue() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case 139:
+      Annotation();
+      break;
+    case LBRACE:
+      MemberValueArrayInitializer();
+      break;
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _JAVACODE:
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case _TOKEN_MGR_DECLS:
+    case _EOF:
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case CONST:
+    case DOUBLE:
+    case FALSE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case NEW:
+    case NULL:
+    case SHORT:
+    case SUPER:
+    case THIS:
+    case TRUE:
+    case VOID:
+    case INTEGER_LITERAL:
+    case FLOATING_POINT_LITERAL:
+    case CHARACTER_LITERAL:
+    case STRING_LITERAL:
+    case LPAREN:
+    case BANG:
+    case TILDE:
+    case INCR:
+    case DECR:
+    case PLUS:
+    case MINUS:
+    case 132:
+    case IDENTIFIER:
+      ConditionalExpression();
+      break;
+    default:
+      jj_la1[185] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void MemberValueArrayInitializer() throws ParseException {
+    jj_consume_token(LBRACE);
+    MemberValue();
+    label_60:
+    while (true) {
+      if (jj_2_47(2)) {
+        ;
+      } else {
+        break label_60;
+      }
+      jj_consume_token(COMMA);
+      MemberValue();
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case COMMA:
+      jj_consume_token(COMMA);
+      break;
+    default:
+      jj_la1[186] = jj_gen;
+      ;
+    }
+    jj_consume_token(RBRACE);
+  }
+
+/* Annotation Types. */
+  final public void AnnotationTypeDeclaration() throws ParseException {
+    jj_consume_token(139);
+    jj_consume_token(INTERFACE);
+    JavaIdentifier();
+    AnnotationTypeBody();
+  }
+
+  final public void AnnotationTypeBody() throws ParseException {
+    jj_consume_token(LBRACE);
+    label_61:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case _LOOKAHEAD:
+      case _IGNORE_CASE:
+      case _PARSER_BEGIN:
+      case _PARSER_END:
+      case _JAVACODE:
+      case _TOKEN:
+      case _SPECIAL_TOKEN:
+      case _MORE:
+      case _SKIP:
+      case _TOKEN_MGR_DECLS:
+      case _EOF:
+      case ABSTRACT:
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case CLASS:
+      case DOUBLE:
+      case FINAL:
+      case FLOAT:
+      case INT:
+      case INTERFACE:
+      case LONG:
+      case NATIVE:
+      case PRIVATE:
+      case PROTECTED:
+      case PUBLIC:
+      case SHORT:
+      case STATIC:
+      case SYNCHRONIZED:
+      case TRANSIENT:
+      case VOLATILE:
+      case SEMICOLON:
+      case 129:
+      case 130:
+      case 132:
+      case 139:
+      case IDENTIFIER:
+        ;
+        break;
+      default:
+        jj_la1[187] = jj_gen;
+        break label_61;
+      }
+      AnnotationTypeMemberDeclaration();
+    }
+    jj_consume_token(RBRACE);
+  }
+
+  final public void AnnotationTypeMemberDeclaration() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _JAVACODE:
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case _TOKEN_MGR_DECLS:
+    case _EOF:
+    case ABSTRACT:
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case CLASS:
+    case DOUBLE:
+    case FINAL:
+    case FLOAT:
+    case INT:
+    case INTERFACE:
+    case LONG:
+    case NATIVE:
+    case PRIVATE:
+    case PROTECTED:
+    case PUBLIC:
+    case SHORT:
+    case STATIC:
+    case SYNCHRONIZED:
+    case TRANSIENT:
+    case VOLATILE:
+    case 129:
+    case 130:
+    case 132:
+    case 139:
+    case IDENTIFIER:
+      Modifiers();
+      if (jj_2_48(2147483647)) {
+        Type();
+        JavaIdentifier();
+        jj_consume_token(LPAREN);
+        jj_consume_token(RPAREN);
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case _DEFAULT:
+          DefaultValue();
+          break;
+        default:
+          jj_la1[188] = jj_gen;
+          ;
+        }
+        jj_consume_token(SEMICOLON);
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case CLASS:
+        case INTERFACE:
+          ClassOrInterfaceDeclaration();
+          break;
+        case 130:
+          EnumDeclaration();
+          break;
+        case 139:
+          AnnotationTypeDeclaration();
+          break;
+        case _LOOKAHEAD:
+        case _IGNORE_CASE:
+        case _PARSER_BEGIN:
+        case _PARSER_END:
+        case _JAVACODE:
+        case _TOKEN:
+        case _SPECIAL_TOKEN:
+        case _MORE:
+        case _SKIP:
+        case _TOKEN_MGR_DECLS:
+        case _EOF:
+        case BOOLEAN:
+        case BYTE:
+        case CHAR:
+        case DOUBLE:
+        case FLOAT:
+        case INT:
+        case LONG:
+        case SHORT:
+        case 132:
+        case IDENTIFIER:
+          FieldDeclaration();
+          break;
+        default:
+          jj_la1[189] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+      break;
+    case SEMICOLON:
+      jj_consume_token(SEMICOLON);
+      break;
+    default:
+      jj_la1[190] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void DefaultValue() throws ParseException {
+    jj_consume_token(_DEFAULT);
+    MemberValue();
+  }
+
+  private boolean jj_2_1(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_1(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(0, xla); }
+  }
+
+  private boolean jj_2_2(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_2(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(1, xla); }
+  }
+
+  private boolean jj_2_3(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_3(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(2, xla); }
+  }
+
+  private boolean jj_2_4(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_4(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(3, xla); }
+  }
+
+  private boolean jj_2_5(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_5(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(4, xla); }
+  }
+
+  private boolean jj_2_6(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_6(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(5, xla); }
+  }
+
+  private boolean jj_2_7(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_7(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(6, xla); }
+  }
+
+  private boolean jj_2_8(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_8(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(7, xla); }
+  }
+
+  private boolean jj_2_9(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_9(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(8, xla); }
+  }
+
+  private boolean jj_2_10(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_10(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(9, xla); }
+  }
+
+  private boolean jj_2_11(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_11(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(10, xla); }
+  }
+
+  private boolean jj_2_12(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_12(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(11, xla); }
+  }
+
+  private boolean jj_2_13(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_13(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(12, xla); }
+  }
+
+  private boolean jj_2_14(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_14(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(13, xla); }
+  }
+
+  private boolean jj_2_15(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_15(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(14, xla); }
+  }
+
+  private boolean jj_2_16(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_16(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(15, xla); }
+  }
+
+  private boolean jj_2_17(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_17(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(16, xla); }
+  }
+
+  private boolean jj_2_18(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_18(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(17, xla); }
+  }
+
+  private boolean jj_2_19(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_19(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(18, xla); }
+  }
+
+  private boolean jj_2_20(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_20(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(19, xla); }
+  }
+
+  private boolean jj_2_21(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_21(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(20, xla); }
+  }
+
+  private boolean jj_2_22(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_22(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(21, xla); }
+  }
+
+  private boolean jj_2_23(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_23(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(22, xla); }
+  }
+
+  private boolean jj_2_24(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_24(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(23, xla); }
+  }
+
+  private boolean jj_2_25(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_25(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(24, xla); }
+  }
+
+  private boolean jj_2_26(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_26(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(25, xla); }
+  }
+
+  private boolean jj_2_27(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_27(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(26, xla); }
+  }
+
+  private boolean jj_2_28(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_28(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(27, xla); }
+  }
+
+  private boolean jj_2_29(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_29(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(28, xla); }
+  }
+
+  private boolean jj_2_30(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_30(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(29, xla); }
+  }
+
+  private boolean jj_2_31(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_31(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(30, xla); }
+  }
+
+  private boolean jj_2_32(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_32(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(31, xla); }
+  }
+
+  private boolean jj_2_33(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_33(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(32, xla); }
+  }
+
+  private boolean jj_2_34(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_34(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(33, xla); }
+  }
+
+  private boolean jj_2_35(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_35(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(34, xla); }
+  }
+
+  private boolean jj_2_36(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_36(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(35, xla); }
+  }
+
+  private boolean jj_2_37(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_37(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(36, xla); }
+  }
+
+  private boolean jj_2_38(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_38(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(37, xla); }
+  }
+
+  private boolean jj_2_39(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_39(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(38, xla); }
+  }
+
+  private boolean jj_2_40(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_40(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(39, xla); }
+  }
+
+  private boolean jj_2_41(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_41(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(40, xla); }
+  }
+
+  private boolean jj_2_42(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_42(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(41, xla); }
+  }
+
+  private boolean jj_2_43(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_43(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(42, xla); }
+  }
+
+  private boolean jj_2_44(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_44(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(43, xla); }
+  }
+
+  private boolean jj_2_45(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_45(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(44, xla); }
+  }
+
+  private boolean jj_2_46(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_46(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(45, xla); }
+  }
+
+  private boolean jj_2_47(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_47(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(46, xla); }
+  }
+
+  private boolean jj_2_48(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_48(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(47, xla); }
+  }
+
+  private boolean jj_3R_258() {
+    if (jj_scan_token(INCR)) return true;
+    if (jj_3R_63()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_170() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_183()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_184()) {
+    jj_scanpos = xsp;
+    if (jj_3R_185()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3_2() {
+    if (jj_3R_62()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_309() {
+    if (jj_3R_318()) return true;
+    return false;
+  }
+
+  private boolean jj_3_25() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(137)) {
+    jj_scanpos = xsp;
+    if (jj_3_26()) {
+    jj_scanpos = xsp;
+    if (jj_3_27()) return true;
+    }
+    }
+    if (jj_3R_272()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_308() {
+    if (jj_3R_259()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_307() {
+    if (jj_3R_258()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_306() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(110)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(111)) return true;
+    }
+    if (jj_3R_296()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_296() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_306()) {
+    jj_scanpos = xsp;
+    if (jj_3R_307()) {
+    jj_scanpos = xsp;
+    if (jj_3R_308()) {
+    jj_scanpos = xsp;
+    if (jj_3R_309()) return true;
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_169() {
+    if (jj_scan_token(TRY)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_279() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(96)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(128)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(103)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(104)) return true;
+    }
+    }
+    }
+    if (jj_3R_265()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_273() {
+    if (jj_scan_token(INSTANCEOF)) return true;
+    if (jj_3R_75()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_278() {
+    if (jj_3R_296()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_319()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_168() {
+    if (jj_scan_token(LBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_167() {
+    if (jj_3R_106()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_266() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(102)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(105)) return true;
+    }
+    if (jj_3R_254()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_272() {
+    if (jj_3R_278()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_310()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_166() {
+    if (jj_scan_token(_LOOKAHEAD)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_265() {
+    if (jj_3R_272()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_25()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_261() {
+    if (jj_scan_token(BIT_AND)) return true;
+    if (jj_3R_246()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_155() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_166()) {
+    jj_scanpos = xsp;
+    if (jj_3R_167()) {
+    jj_scanpos = xsp;
+    if (jj_3R_168()) {
+    jj_scanpos = xsp;
+    if (jj_3R_169()) {
+    jj_scanpos = xsp;
+    if (jj_3R_170()) {
+    jj_scanpos = xsp;
+    if (jj_3R_171()) return true;
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_260() {
+    if (jj_3R_265()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_279()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_247() {
+    if (jj_scan_token(BIT_OR)) return true;
+    if (jj_3R_198()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_254() {
+    if (jj_3R_260()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_273()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_255() {
+    if (jj_scan_token(XOR)) return true;
+    if (jj_3R_225()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_228() {
+    if (jj_scan_token(SC_AND)) return true;
+    if (jj_3R_182()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_246() {
+    if (jj_3R_254()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_266()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_202() {
+    if (jj_scan_token(SC_OR)) return true;
+    if (jj_3R_165()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_225() {
+    if (jj_3R_246()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_261()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_187() {
+    if (jj_scan_token(HOOK)) return true;
+    if (jj_3R_84()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_84()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_198() {
+    if (jj_3R_225()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_255()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_182() {
+    if (jj_3R_198()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_247()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_165() {
+    if (jj_3R_182()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_228()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_150() {
+    if (jj_3R_165()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_202()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_115() {
+    if (jj_3R_150()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_187()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_83() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(95)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(120)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(121)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(125)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(118)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(119)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(134)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(135)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(136)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(122)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(124)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(123)) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3_24() {
+    if (jj_3R_83()) return true;
+    if (jj_3R_84()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_130() {
+    if (jj_3R_155()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_129() {
+    if (jj_scan_token(_LOOKAHEAD)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_98() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_129()) jj_scanpos = xsp;
+    if (jj_3R_130()) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_130()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_84() {
+    if (jj_3R_115()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_24()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_316() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_95()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_62() {
+    if (jj_3R_98()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_302() {
+    if (jj_3R_95()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_316()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_153() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(112)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(114)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3_23() {
+    if (jj_scan_token(DOT)) return true;
+    if (jj_3R_74()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_95() {
+    if (jj_3R_74()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_23()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_124() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(32)) jj_scanpos = xsp;
+    if (jj_3R_75()) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_153()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_123() {
+    if (jj_scan_token(VOID)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(112)) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3_22() {
+    if (jj_3R_82()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_90() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_123()) {
+    jj_scanpos = xsp;
+    if (jj_3R_124()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3_1() {
+    if (jj_scan_token(LT)) return true;
+    if (jj_scan_token(STAR)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_88() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(25)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(30)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(27)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(60)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(49)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(51)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(42)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(36)) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_205() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_114()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(131)) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_264() {
+    if (jj_scan_token(SUPER)) return true;
+    if (jj_3R_81()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_250() {
+    if (jj_3R_257()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_257() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_263()) {
+    jj_scanpos = xsp;
+    if (jj_3R_264()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_263() {
+    if (jj_scan_token(EXTENDS)) return true;
+    if (jj_3R_81()) return true;
+    return false;
+  }
+
+  private boolean jj_3_20() {
+    if (jj_3R_82()) return true;
+    return false;
+  }
+
+  private boolean jj_3_19() {
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_149() {
+    if (jj_scan_token(HOOK)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_250()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_148() {
+    if (jj_3R_81()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_114() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_148()) {
+    jj_scanpos = xsp;
+    if (jj_3R_149()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_210() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_209()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_82() {
+    if (jj_scan_token(LT)) return true;
+    if (jj_3R_114()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_205()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(GT)) return true;
+    return false;
+  }
+
+  private boolean jj_3_21() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(93)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(101)) return true;
+    }
+    if (jj_3R_74()) return true;
+    xsp = jj_scanpos;
+    if (jj_3_22()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_147() {
+    if (jj_3R_74()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_20()) jj_scanpos = xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_21()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_232() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(31)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(133)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_209() {
+    if (jj_3R_232()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(131)) jj_scanpos = xsp;
+    if (jj_scan_token(IDENTIFIER)) return true;
+    return false;
+  }
+
+  private boolean jj_3_18() {
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_164() {
+    if (jj_scan_token(132)) return true;
+    if (jj_scan_token(LT)) return true;
+    if (jj_3R_209()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_210()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(GT)) return true;
+    return false;
+  }
+
+  private boolean jj_3_48() {
+    if (jj_3R_75()) return true;
+    if (jj_3R_74()) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_146() {
+    if (jj_3R_164()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_113() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_146()) jj_scanpos = xsp;
+    if (jj_3R_147()) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_19()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_112() {
+    if (jj_3R_88()) return true;
+    Token xsp;
+    if (jj_3_18()) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_18()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_81() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_112()) {
+    jj_scanpos = xsp;
+    if (jj_3R_113()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_287() {
+    if (jj_scan_token(THROWS)) return true;
+    if (jj_3R_302()) return true;
+    return false;
+  }
+
+  private boolean jj_3_47() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_97()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_105() {
+    if (jj_3R_88()) return true;
+    return false;
+  }
+
+  private boolean jj_3_17() {
+    if (jj_3R_81()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_75() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_17()) {
+    jj_scanpos = xsp;
+    if (jj_3R_105()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3_16() {
+    if (jj_scan_token(THIS)) return true;
+    if (jj_3R_80()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_77() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(61)) jj_scanpos = xsp;
+    if (jj_3R_106()) return true;
+    return false;
+  }
+
+  private boolean jj_3_14() {
+    if (jj_3R_79()) return true;
+    return false;
+  }
+
+  private boolean jj_3_15() {
+    if (jj_3R_63()) return true;
+    if (jj_scan_token(DOT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_154() {
+    if (jj_scan_token(LBRACE)) return true;
+    if (jj_3R_97()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_47()) { jj_scanpos = xsp; break; }
+    }
+    xsp = jj_scanpos;
+    if (jj_scan_token(92)) jj_scanpos = xsp;
+    if (jj_scan_token(RBRACE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_208() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_207()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_322() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(114)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(112)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(131)) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_110() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_15()) jj_scanpos = xsp;
+    if (jj_scan_token(SUPER)) return true;
+    if (jj_3R_80()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_305() {
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_109() {
+    if (jj_scan_token(THIS)) return true;
+    if (jj_3R_80()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_79() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_109()) {
+    jj_scanpos = xsp;
+    if (jj_3R_110()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_128() {
+    if (jj_3R_115()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_127() {
+    if (jj_3R_154()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_315() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_314()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_289() {
+    if (jj_3R_162()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_288() {
+    if (jj_3R_79()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_126() {
+    if (jj_3R_103()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_97() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_126()) {
+    jj_scanpos = xsp;
+    if (jj_3R_127()) {
+    jj_scanpos = xsp;
+    if (jj_3R_128()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_207() {
+    if (jj_3R_74()) return true;
+    if (jj_scan_token(ASSIGN)) return true;
+    if (jj_3R_97()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_285() {
+    if (jj_3R_104()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_275() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_285()) jj_scanpos = xsp;
+    if (jj_3R_74()) return true;
+    if (jj_3R_286()) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_287()) jj_scanpos = xsp;
+    if (jj_scan_token(LBRACE)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_288()) jj_scanpos = xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_289()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(RBRACE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_193() {
+    if (jj_3R_207()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_208()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_177() {
+    if (jj_3R_193()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_314() {
+    if (jj_3R_94()) return true;
+    if (jj_3R_75()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_322()) jj_scanpos = xsp;
+    if (jj_3R_303()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_96() {
+    if (jj_3R_74()) return true;
+    if (jj_scan_token(ASSIGN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_294() {
+    if (jj_scan_token(THROWS)) return true;
+    if (jj_3R_302()) return true;
+    return false;
+  }
+
+  private boolean jj_3_13() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_78()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_301() {
+    if (jj_3R_314()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_315()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_159() {
+    if (jj_scan_token(139)) return true;
+    if (jj_3R_95()) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_97()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_286() {
+    if (jj_scan_token(LPAREN)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_301()) jj_scanpos = xsp;
+    if (jj_scan_token(RPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_160() {
+    if (jj_scan_token(139)) return true;
+    if (jj_3R_95()) return true;
+    return false;
+  }
+
+  private boolean jj_3_46() {
+    if (jj_scan_token(139)) return true;
+    if (jj_3R_95()) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_158() {
+    if (jj_scan_token(139)) return true;
+    if (jj_3R_95()) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_177()) jj_scanpos = xsp;
+    if (jj_scan_token(RPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3_45() {
+    if (jj_scan_token(139)) return true;
+    if (jj_3R_95()) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_96()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(86)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_293() {
+    if (jj_3R_74()) return true;
+    if (jj_3R_286()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_305()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_295() {
+    if (jj_3R_106()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_140() {
+    if (jj_3R_160()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_292() {
+    if (jj_3R_104()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_139() {
+    if (jj_3R_159()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_277() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_292()) jj_scanpos = xsp;
+    if (jj_3R_90()) return true;
+    if (jj_3R_293()) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_294()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_295()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(91)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_248() {
+    if (jj_3R_78()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_13()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_138() {
+    if (jj_3R_158()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_116() {
+    return false;
+  }
+
+  private boolean jj_3R_103() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_138()) {
+    jj_scanpos = xsp;
+    if (jj_3R_139()) {
+    jj_scanpos = xsp;
+    if (jj_3R_140()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_317() {
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_304() {
+    if (jj_scan_token(ASSIGN)) return true;
+    if (jj_3R_78()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_291() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_290()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_76() {
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_144() {
+    if (jj_scan_token(LBRACE)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_248()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(92)) jj_scanpos = xsp;
+    if (jj_scan_token(RBRACE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_117() {
+    return false;
+  }
+
+  private boolean jj_3R_108() {
+    if (jj_3R_84()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_85() {
+    jj_lookingAhead = true;
+    jj_semLA = getToken(1).kind == GT &&
+                ((Token.GTToken)getToken(1)).realKind == RSIGNEDSHIFT;
+    jj_lookingAhead = false;
+    if (!jj_semLA || jj_3R_116()) return true;
+    if (jj_scan_token(GT)) return true;
+    if (jj_scan_token(GT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_107() {
+    if (jj_3R_144()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_78() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_107()) {
+    jj_scanpos = xsp;
+    if (jj_3R_108()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_303() {
+    if (jj_3R_74()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_317()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_86() {
+    jj_lookingAhead = true;
+    jj_semLA = getToken(1).kind == GT &&
+                ((Token.GTToken)getToken(1)).realKind == RUNSIGNEDSHIFT;
+    jj_lookingAhead = false;
+    if (!jj_semLA || jj_3R_117()) return true;
+    if (jj_scan_token(GT)) return true;
+    if (jj_scan_token(GT)) return true;
+    if (jj_scan_token(GT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_290() {
+    if (jj_3R_303()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_304()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_340() {
+    if (jj_scan_token(FINALLY)) return true;
+    if (jj_3R_106()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_339() {
+    if (jj_scan_token(CATCH)) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_314()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_3R_106()) return true;
+    return false;
+  }
+
+  private boolean jj_3_11() {
+    if (jj_3R_75()) return true;
+    if (jj_3R_74()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_76()) { jj_scanpos = xsp; break; }
+    }
+    xsp = jj_scanpos;
+    if (jj_scan_token(92)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(95)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(91)) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_73() {
+    if (jj_3R_104()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_276() {
+    if (jj_3R_75()) return true;
+    if (jj_3R_290()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_291()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3_10() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_73()) jj_scanpos = xsp;
+    if (jj_3R_74()) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_245() {
+    if (jj_scan_token(TRY)) return true;
+    if (jj_3R_106()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_339()) { jj_scanpos = xsp; break; }
+    }
+    xsp = jj_scanpos;
+    if (jj_3R_340()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_271() {
+    if (jj_3R_277()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_194() {
+    if (jj_scan_token(BIT_AND)) return true;
+    if (jj_3R_147()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_270() {
+    if (jj_3R_276()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_244() {
+    if (jj_scan_token(SYNCHRONIZED)) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_84()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_3R_106()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_338() {
+    if (jj_3R_84()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_269() {
+    if (jj_3R_275()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_268() {
+    if (jj_3R_274()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_321() {
+    if (jj_3R_230()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_337() {
+    if (jj_3R_74()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_267() {
+    if (jj_3R_197()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_243() {
+    if (jj_scan_token(THROW)) return true;
+    if (jj_3R_84()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_346() {
+    if (jj_3R_352()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_356() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_234()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_262() {
+    if (jj_3R_94()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_267()) {
+    jj_scanpos = xsp;
+    if (jj_3R_268()) {
+    jj_scanpos = xsp;
+    if (jj_3R_269()) {
+    jj_scanpos = xsp;
+    if (jj_3R_270()) {
+    jj_scanpos = xsp;
+    if (jj_3R_271()) return true;
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_242() {
+    if (jj_scan_token(RETURN)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_338()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_336() {
+    if (jj_3R_74()) return true;
+    return false;
+  }
+
+  private boolean jj_3_12() {
+    if (jj_3R_77()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_256() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_12()) {
+    jj_scanpos = xsp;
+    if (jj_3R_262()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(91)) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_241() {
+    if (jj_scan_token(CONTINUE)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_337()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_161() {
+    if (jj_3R_178()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_320() {
+    if (jj_3R_80()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_249() {
+    if (jj_3R_256()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_142() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_141()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_230() {
+    if (jj_scan_token(LBRACE)) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_249()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(RBRACE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_240() {
+    if (jj_scan_token(BREAK)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_336()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_352() {
+    if (jj_3R_355()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_345() {
+    if (jj_3R_84()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_178() {
+    if (jj_scan_token(EXTENDS)) return true;
+    if (jj_3R_147()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_194()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3_44() {
+    if (jj_3R_94()) return true;
+    if (jj_3R_75()) return true;
+    if (jj_3R_74()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_355() {
+    if (jj_3R_234()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_356()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_333() {
+    if (jj_scan_token(ELSE)) return true;
+    if (jj_3R_196()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_141() {
+    if (jj_3R_74()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_161()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3_9() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_72()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_354() {
+    if (jj_3R_355()) return true;
+    return false;
+  }
+
+  private boolean jj_3_43() {
+    if (jj_3R_94()) return true;
+    if (jj_3R_75()) return true;
+    if (jj_3R_74()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_104() {
+    if (jj_scan_token(LT)) return true;
+    if (jj_3R_141()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_142()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(GT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_353() {
+    if (jj_3R_195()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_351() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_353()) {
+    jj_scanpos = xsp;
+    if (jj_3R_354()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_344() {
+    if (jj_3R_351()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_313() {
+    if (jj_3R_256()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_335() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_344()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_345()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_346()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_72() {
+    if (jj_3R_94()) return true;
+    if (jj_3R_74()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_320()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_321()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_334() {
+    if (jj_3R_94()) return true;
+    if (jj_3R_75()) return true;
+    if (jj_3R_74()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_84()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_300() {
+    if (jj_scan_token(SEMICOLON)) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_313()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_299() {
+    if (jj_3R_72()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_9()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_284() {
+    if (jj_scan_token(LBRACE)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_299()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(92)) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_300()) jj_scanpos = xsp;
+    if (jj_scan_token(RBRACE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_239() {
+    if (jj_scan_token(FOR)) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_334()) {
+    jj_scanpos = xsp;
+    if (jj_3R_335()) return true;
+    }
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_3R_196()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_283() {
+    if (jj_3R_298()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_238() {
+    if (jj_scan_token(DO)) return true;
+    if (jj_3R_196()) return true;
+    if (jj_scan_token(WHILE)) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_84()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_274() {
+    if (jj_scan_token(130)) return true;
+    if (jj_3R_74()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_283()) jj_scanpos = xsp;
+    if (jj_3R_284()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_312() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_147()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_237() {
+    if (jj_scan_token(WHILE)) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_84()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_3R_196()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_298() {
+    if (jj_scan_token(IMPLEMENTS)) return true;
+    if (jj_3R_147()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_312()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_343() {
+    if (jj_3R_162()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_236() {
+    if (jj_scan_token(IF)) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_84()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_3R_196()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_333()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_311() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_147()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_297() {
+    if (jj_scan_token(EXTENDS)) return true;
+    if (jj_3R_147()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_311()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_350() {
+    if (jj_scan_token(_DEFAULT)) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_349() {
+    if (jj_scan_token(CASE)) return true;
+    if (jj_3R_84()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_342() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_349()) {
+    jj_scanpos = xsp;
+    if (jj_3R_350()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_326() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_290()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_332() {
+    if (jj_3R_342()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_343()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_282() {
+    if (jj_3R_298()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_281() {
+    if (jj_3R_297()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_235() {
+    if (jj_scan_token(SWITCH)) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_84()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_scan_token(LBRACE)) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_332()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(RBRACE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_280() {
+    if (jj_3R_104()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_348() {
+    if (jj_3R_83()) return true;
+    if (jj_3R_84()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_197() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(31)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(50)) return true;
+    }
+    if (jj_3R_74()) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_280()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_281()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_282()) jj_scanpos = xsp;
+    if (jj_3R_230()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_341() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(108)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(109)) {
+    jj_scanpos = xsp;
+    if (jj_3R_348()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_253() {
+    if (jj_3R_63()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_341()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_252() {
+    if (jj_3R_259()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_234() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_251()) {
+    jj_scanpos = xsp;
+    if (jj_3R_252()) {
+    jj_scanpos = xsp;
+    if (jj_3R_253()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_251() {
+    if (jj_3R_258()) return true;
+    return false;
+  }
+
+  private boolean jj_3_42() {
+    if (jj_3R_94()) return true;
+    if (jj_3R_75()) return true;
+    if (jj_3R_74()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_195() {
+    if (jj_3R_94()) return true;
+    if (jj_3R_75()) return true;
+    if (jj_3R_290()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_326()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_71() {
+    if (jj_3R_103()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_181() {
+    if (jj_3R_197()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_180() {
+    if (jj_3R_196()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_162() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_179()) {
+    jj_scanpos = xsp;
+    if (jj_3R_180()) {
+    jj_scanpos = xsp;
+    if (jj_3R_181()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_179() {
+    if (jj_3R_195()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_331() {
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_84()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_143() {
+    if (jj_3R_162()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_106() {
+    if (jj_scan_token(LBRACE)) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_143()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(RBRACE)) return true;
+    return false;
+  }
+
+  private boolean jj_3_8() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(58)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(61)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(57)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(56)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(40)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(24)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(64)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(52)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(68)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(72)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(129)) {
+    jj_scanpos = xsp;
+    if (jj_3R_71()) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_94() {
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_8()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_93() {
+    if (jj_3R_74()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_196()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_233() {
+    if (jj_scan_token(138)) return true;
+    if (jj_3R_84()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_331()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_70() {
+    if (jj_3R_103()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_224() {
+    if (jj_3R_245()) return true;
+    return false;
+  }
+
+  private boolean jj_3_7() {
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_70()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(PACKAGE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_223() {
+    if (jj_3R_244()) return true;
+    return false;
+  }
+
+  private boolean jj_3_39() {
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_222() {
+    if (jj_3R_243()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_221() {
+    if (jj_3R_242()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_220() {
+    if (jj_3R_241()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_219() {
+    if (jj_3R_240()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_218() {
+    if (jj_3R_239()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_217() {
+    if (jj_3R_238()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_216() {
+    if (jj_3R_237()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_215() {
+    if (jj_3R_236()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_214() {
+    if (jj_3R_235()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_213() {
+    if (jj_3R_234()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_212() {
+    if (jj_3R_106()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_211() {
+    if (jj_3R_233()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_189() {
+    if (jj_3R_82()) return true;
+    return false;
+  }
+
+  private boolean jj_3_41() {
+    if (jj_3R_93()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_196() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_41()) {
+    jj_scanpos = xsp;
+    if (jj_3R_211()) {
+    jj_scanpos = xsp;
+    if (jj_3R_212()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(91)) {
+    jj_scanpos = xsp;
+    if (jj_3R_213()) {
+    jj_scanpos = xsp;
+    if (jj_3R_214()) {
+    jj_scanpos = xsp;
+    if (jj_3R_215()) {
+    jj_scanpos = xsp;
+    if (jj_3R_216()) {
+    jj_scanpos = xsp;
+    if (jj_3R_217()) {
+    jj_scanpos = xsp;
+    if (jj_3R_218()) {
+    jj_scanpos = xsp;
+    if (jj_3R_219()) {
+    jj_scanpos = xsp;
+    if (jj_3R_220()) {
+    jj_scanpos = xsp;
+    if (jj_3R_221()) {
+    jj_scanpos = xsp;
+    if (jj_3R_222()) {
+    jj_scanpos = xsp;
+    if (jj_3R_223()) {
+    jj_scanpos = xsp;
+    if (jj_3R_224()) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_204() {
+    if (jj_3R_230()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_229() {
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_74() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(140)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(1)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(2)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(3)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(4)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(5)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(6)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(7)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(8)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(9)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(10)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(11)) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3_38() {
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_3R_84()) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_203() {
+    Token xsp;
+    if (jj_3R_229()) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_229()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_3R_144()) return true;
+    return false;
+  }
+
+  private boolean jj_3_40() {
+    Token xsp;
+    if (jj_3_38()) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_38()) { jj_scanpos = xsp; break; }
+    }
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_39()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_188() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_40()) {
+    jj_scanpos = xsp;
+    if (jj_3R_203()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_191() {
+    if (jj_3R_80()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_204()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_163() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_84()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_190() {
+    if (jj_3R_188()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_125() {
+    if (jj_scan_token(NEW)) return true;
+    if (jj_3R_147()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_189()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_190()) {
+    jj_scanpos = xsp;
+    if (jj_3R_191()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_91() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_37()) {
+    jj_scanpos = xsp;
+    if (jj_3R_125()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3_37() {
+    if (jj_scan_token(NEW)) return true;
+    if (jj_3R_88()) return true;
+    if (jj_3R_188()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_145() {
+    if (jj_3R_84()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_163()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_111() {
+    if (jj_3R_145()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_80() {
+    if (jj_scan_token(LPAREN)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_111()) jj_scanpos = xsp;
+    if (jj_scan_token(RPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_100() {
+    if (jj_scan_token(STRING_LITERAL)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_201() {
+    if (jj_scan_token(FALSE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_186() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_200()) {
+    jj_scanpos = xsp;
+    if (jj_3R_201()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_200() {
+    if (jj_scan_token(TRUE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_69() {
+    if (jj_scan_token(IDENTIFIER)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_206() {
+    if (jj_3R_231()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_152() {
+    if (jj_3R_156()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_172() {
+    if (jj_3R_186()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_231() {
+    if (jj_3R_100()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_192() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(98)) jj_scanpos = xsp;
+    if (jj_scan_token(LBRACKET)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_206()) jj_scanpos = xsp;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_156() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(74)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(78)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(83)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(84)) {
+    jj_scanpos = xsp;
+    if (jj_3R_172()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(54)) return true;
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_122() {
+    if (jj_3R_80()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_121() {
+    if (jj_scan_token(DOT)) return true;
+    if (jj_3R_74()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_120() {
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_3R_84()) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_102() {
+    if (jj_scan_token(BIT_OR)) return true;
+    return false;
+  }
+
+  private boolean jj_3_36() {
+    if (jj_3R_92()) return true;
+    return false;
+  }
+
+  private boolean jj_3_35() {
+    if (jj_scan_token(DOT)) return true;
+    if (jj_3R_91()) return true;
+    return false;
+  }
+
+  private boolean jj_3_33() {
+    if (jj_3R_90()) return true;
+    if (jj_scan_token(DOT)) return true;
+    if (jj_scan_token(CLASS)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_89() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_34()) {
+    jj_scanpos = xsp;
+    if (jj_3_35()) {
+    jj_scanpos = xsp;
+    if (jj_3_36()) {
+    jj_scanpos = xsp;
+    if (jj_3R_120()) {
+    jj_scanpos = xsp;
+    if (jj_3R_121()) {
+    jj_scanpos = xsp;
+    if (jj_3R_122()) return true;
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3_34() {
+    if (jj_scan_token(DOT)) return true;
+    if (jj_scan_token(THIS)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_176() {
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_68()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_136() {
+    if (jj_3R_95()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_175() {
+    if (jj_3R_192()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_174() {
+    if (jj_scan_token(LT)) return true;
+    if (jj_3R_69()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_135() {
+    if (jj_3R_90()) return true;
+    if (jj_scan_token(DOT)) return true;
+    if (jj_scan_token(CLASS)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_157() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_173()) {
+    jj_scanpos = xsp;
+    if (jj_3R_174()) {
+    jj_scanpos = xsp;
+    if (jj_3R_175()) {
+    jj_scanpos = xsp;
+    if (jj_3R_176()) return true;
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_173() {
+    if (jj_3R_100()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_134() {
+    if (jj_3R_91()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_133() {
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_84()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3_32() {
+    if (jj_3R_89()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_132() {
+    if (jj_scan_token(SUPER)) return true;
+    if (jj_scan_token(DOT)) return true;
+    if (jj_3R_74()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_137() {
+    if (jj_3R_157()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_151() {
+    if (jj_3R_74()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_101() {
+    Token xsp;
+    if (jj_3R_137()) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_137()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_131() {
+    if (jj_3R_156()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_99() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_131()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(65)) {
+    jj_scanpos = xsp;
+    if (jj_3R_132()) {
+    jj_scanpos = xsp;
+    if (jj_3R_133()) {
+    jj_scanpos = xsp;
+    if (jj_3R_134()) {
+    jj_scanpos = xsp;
+    if (jj_3R_135()) {
+    jj_scanpos = xsp;
+    if (jj_3R_136()) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_347() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(108)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(109)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_68() {
+    if (jj_3R_101()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_102()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_92() {
+    if (jj_scan_token(DOT)) return true;
+    if (jj_3R_82()) return true;
+    if (jj_3R_74()) return true;
+    return false;
+  }
+
+  private boolean jj_3_31() {
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_88()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_63() {
+    if (jj_3R_99()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_32()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_67() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(94)) jj_scanpos = xsp;
+    if (jj_3R_69()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_227() {
+    if (jj_scan_token(LT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_66() {
+    if (jj_3R_63()) return true;
+    if (jj_scan_token(ASSIGN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_330() {
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_75()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_3R_318()) return true;
+    return false;
+  }
+
+  private boolean jj_3_6() {
+    if (jj_scan_token(LT)) return true;
+    if (jj_3R_69()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_329() {
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_75()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_3R_296()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_327() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_329()) {
+    jj_scanpos = xsp;
+    if (jj_3R_330()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3_5() {
+    if (jj_scan_token(LT)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_67()) jj_scanpos = xsp;
+    if (jj_3R_68()) return true;
+    if (jj_scan_token(GT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_199() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_226()) {
+    jj_scanpos = xsp;
+    if (jj_3_5()) {
+    jj_scanpos = xsp;
+    if (jj_3_6()) {
+    jj_scanpos = xsp;
+    if (jj_3R_227()) return true;
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_226() {
+    if (jj_3R_100()) return true;
+    return false;
+  }
+
+  private boolean jj_3_30() {
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_75()) return true;
+    if (jj_scan_token(LBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_328() {
+    if (jj_3R_63()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_347()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_119() {
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_75()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(98)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(97)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(85)) {
+    jj_scanpos = xsp;
+    if (jj_3R_151()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(65)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(62)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(53)) {
+    jj_scanpos = xsp;
+    if (jj_3R_152()) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_118() {
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_75()) return true;
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_87() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_29()) {
+    jj_scanpos = xsp;
+    if (jj_3R_118()) {
+    jj_scanpos = xsp;
+    if (jj_3R_119()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3_29() {
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_88()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_65() {
+    if (jj_3R_100()) return true;
+    return false;
+  }
+
+  private boolean jj_3_28() {
+    if (jj_3R_87()) return true;
+    return false;
+  }
+
+  private boolean jj_3_27() {
+    if (jj_3R_86()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_325() {
+    if (jj_3R_328()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_324() {
+    if (jj_3R_327()) return true;
+    return false;
+  }
+
+  private boolean jj_3_3() {
+    if (jj_3R_63()) return true;
+    if (jj_scan_token(ASSIGN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_323() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(98)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(97)) return true;
+    }
+    if (jj_3R_296()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_318() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_323()) {
+    jj_scanpos = xsp;
+    if (jj_3R_324()) {
+    jj_scanpos = xsp;
+    if (jj_3R_325()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_171() {
+    if (jj_scan_token(LPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3_4() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_64()) {
+    jj_scanpos = xsp;
+    if (jj_3R_65()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(96)) {
+    jj_scanpos = xsp;
+    if (jj_3R_66()) return true;
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_64() {
+    if (jj_3R_69()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_185() {
+    if (jj_3R_69()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_184() {
+    if (jj_3R_199()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_259() {
+    if (jj_scan_token(DECR)) return true;
+    if (jj_3R_63()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_310() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(110)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(111)) return true;
+    }
+    if (jj_3R_278()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_183() {
+    if (jj_3R_63()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_319() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(112)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(113)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(117)) return true;
+    }
+    }
+    if (jj_3R_296()) return true;
+    return false;
+  }
+
+  private boolean jj_3_26() {
+    if (jj_3R_85()) return true;
+    return false;
+  }
+
+  /** Generated Token Manager. */
+  public JJTreeParserTokenManager token_source;
+  JavaCharStream jj_input_stream;
+  /** Current token. */
+  public Token token;
+  /** Next token. */
+  public Token jj_nt;
+  private int jj_ntk;
+  private Token jj_scanpos, jj_lastpos;
+  private int jj_la;
+  /** Whether we are looking ahead. */
+  private boolean jj_lookingAhead = false;
+  private boolean jj_semLA;
+  private int jj_gen;
+  final private int[] jj_la1 = new int[191];
+  static private int[] jj_la1_0;
+  static private int[] jj_la1_1;
+  static private int[] jj_la1_2;
+  static private int[] jj_la1_3;
+  static private int[] jj_la1_4;
+  static {
+      jj_la1_init_0();
+      jj_la1_init_1();
+      jj_la1_init_2();
+      jj_la1_init_3();
+      jj_la1_init_4();
+   }
+   private static void jj_la1_init_0() {
+      jj_la1_0 = new int[] {0x4a000ffe,0x6,0x6,0x0,0x4a000ffe,0x0,0x0,0x0,0xcf000ffe,0x0,0x0,0x0,0xcf000ffe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c0,0x0,0x0,0x0,0x2,0x0,0x0,0x4a000ffe,0x20000000,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffe,0x0,0x0,0xffe,0x0,0x81000000,0x0,0x0,0x1000000,0x80000000,0x81000000,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x1000ffe,0x0,0xcb000ffe,0x0,0x0,0x0,0x0,0x0,0x0,0xcb000ffe,0x80000000,0x4a000ffe,0xcb000ffe,0x0,0x0,0x0,0x4a000ffe,0x4a000ffe,0x0,0x0,0x0,0x0,0x0,0x0,0x4b000ffe,0x0,0x0,0x0,0x0,0xcf000ffe,0x4a000ffe,0x0,0x4a000000,0x0,0x4a000ffe,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x4a000ffe,0x0,0x4a000000,0x0,0x0,0x0,0x0,0x4a000ffe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4a000ffe,0x0,0x0,0x4a000ffe,0xffe,0x0,0x0,0x0,0x0,0x0,0xffe,0x0,0x0,0x0,0x4a000ffe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4e000ffe,0x0,0xcf000ffe,0xce000ffe,0x0,0x0,0x0,0x4a000ffe,0x10000000,0xcf000ffe,0x10000000,0x0,0x4b000ffe,0x4a000ffe,0x4a000ffe,0x4b000ffe,0x4a000ffe,0x0,0xffe,0xffe,0x4a000ffe,0x20000000,0x0,0x0,0xffe,0x0,0x4a000ffe,0x0,0xcb000ffe,0x0,0xca000ffe,0xcb000ffe,};
+   }
+   private static void jj_la1_init_1() {
+      jj_la1_1 = new int[] {0x170a0411,0x20000000,0x20000000,0x80,0x170a0411,0x0,0x0,0x0,0xff7e2d9b,0x0,0x0,0x0,0xff7e2d9b,0x7000000,0x7000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x506a0491,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x27140100,0x20000000,0x0,0x27100100,0x40000,0x27140100,0x40000,0x0,0x40,0x4000,0x0,0x0,0x4000,0x27100100,0x0,0x371e0511,0x0,0x0,0x0,0x0,0x40,0x0,0x371e0511,0x40000,0x100a0411,0x371e0511,0x0,0x0,0x0,0x506a0491,0x506a0491,0x0,0x0,0x0,0x0,0x0,0x0,0x371a0510,0x0,0x0,0x0,0x0,0xff7e2d9b,0x506a0491,0x20000000,0x100a0410,0x0,0x100a0410,0x0,0x0,0x0,0x0,0x0,0x0,0x40000040,0x100a0410,0x40000040,0x100a0410,0x0,0x1,0x0,0x0,0x100a0411,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x506a0491,0x0,0x0,0x506a0491,0x40600080,0x0,0x0,0x0,0x0,0x40600080,0x0,0x0,0x400080,0x80,0x506a0491,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0xd86a2c9b,0x0,0xff7e2d9b,0xd86e2c9b,0x0,0x0,0x0,0x506a0491,0x4,0xff7e2d9b,0x4,0x20,0x777a0591,0x506a0491,0x506a0491,0x777a0591,0x506a0491,0x0,0x0,0x0,0x506a0491,0x0,0x200,0x0,0x0,0x0,0x506a0491,0x0,0x371e0510,0x4,0x100e0410,0x371e0510,};
+   }
+   private static void jj_la1_init_2() {
+      jj_la1_2 = new int[] {0x80,0x0,0x0,0x100420,0x80,0x10000000,0x8,0x40000000,0x8b847f7,0x10000000,0x8,0x40000000,0x8b847f7,0x0,0x0,0x10000000,0x0,0x0,0x2000000,0x0,0x800000,0x0,0x800000,0x0,0x0,0x0,0x40000000,0x400,0x3844a2,0x0,0x0,0x20000000,0x100000,0x0,0x2800040,0x200000,0x40000000,0x40000000,0x100000,0x0,0x0,0x2300000,0x400,0x10000000,0x800000,0x2300000,0x0,0x10000000,0x100000,0x0,0x80,0x0,0x200000,0x0,0x0,0x8000111,0x0,0x20000000,0x111,0x0,0x8000111,0x0,0x0,0x0,0x0,0x10000000,0x10000000,0x0,0x111,0x10000000,0x8800191,0x8000000,0x200000,0x800000,0x10000000,0x0,0x0,0x8800191,0x0,0x80,0x8000191,0x10000000,0x80000000,0x2000000,0xb844a2,0xb844a2,0x10000000,0x0,0x8,0x8800000,0x2000000,0x10000000,0x111,0x0,0x0,0x0,0x8,0x8b847f7,0x3844a2,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x20000000,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x10000000,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3844a2,0x0,0x0,0x3844a2,0x384422,0x200000,0x0,0x0,0x200000,0x384422,0x0,0x22200000,0x184420,0x20,0x3844a2,0x10000000,0x0,0x800000,0x2200000,0x0,0x2000000,0x2000000,0x8b846e7,0x0,0x8b847f7,0x8b846e7,0x10000000,0x80000000,0x80000000,0x3844a2,0x0,0x8b847f7,0x0,0x0,0x3845b3,0x3844a2,0x3844a2,0x83845b3,0x3844a2,0x10000000,0x0,0x0,0x3844a2,0x0,0x0,0x0,0x0,0x10000000,0xb844a2,0x10000000,0x8000111,0x0,0x0,0x8000111,};
+   }
+   private static void jj_la1_init_3() {
+      jj_la1_3 = new int[] {0x1,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x3000,0x0,0x0,0x0,0x3000,0x0,0x0,0x0,0x1,0x1,0x0,0x80000,0x0,0x0,0x0,0x10,0x80000,0x0,0x0,0x0,0xf006,0x0,0x0,0x0,0x1,0x14008,0x0,0x0,0x0,0x0,0x0,0x1,0x80000,0x5,0x0,0x0,0x14008,0x5,0x4,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x40000,0x1,0x0,0x1,0x1,0x0,0x0,0x0,0xf006,0xf006,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x50000,0x50000,0x1,0x0,0x3000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x8,0x0,0x0,0x10000,0x0,0x50000,0x50000,0x0,0x0,0x3fc00000,0x8,0x400,0x800,0x80000,0x100000,0x40000,0x240,0x240,0x0,0x181,0x181,0x0,0xc000,0xc000,0x230000,0x230000,0xc000,0xf006,0x6,0x6,0x0,0x6,0x0,0x3000,0x3000,0x0,0x0,0x0,0x0,0x0,0x0,0xf006,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x3000,0x10,0x3000,0x3000,0x0,0x3fc03000,0x3fc03000,0x3000,0x0,0x3000,0x0,0x0,0x3000,0xf006,0x3000,0x3000,0x3000,0x0,0x0,0x0,0xf006,0x0,0x0,0x0,0x0,0x0,0xf006,0x0,0x0,0x0,0x0,0x0,};
+   }
+   private static void jj_la1_init_4() {
+      jj_la1_4 = new int[] {0x1010,0x1000,0x1000,0x0,0x1010,0x0,0x0,0x0,0x1c12,0x0,0x0,0x0,0x1c12,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1010,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x1,0x0,0x1000,0x0,0x806,0x0,0x0,0x802,0x804,0x806,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1802,0x0,0x1816,0x0,0x0,0x0,0x0,0x0,0x0,0x1816,0x4,0x1010,0x1816,0x0,0x0,0x0,0x1010,0x1010,0x0,0x0,0x0,0x0,0x0,0x0,0x1812,0x8,0x8,0x0,0x0,0x1c12,0x1010,0x0,0x0,0x10,0x1010,0x0,0x8,0x20,0x0,0x0,0x8,0x0,0x1010,0x0,0x0,0x0,0x0,0x0,0x0,0x1010,0x0,0x1c0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x200,0x0,0x0,0x0,0x0,0x0,0x1010,0x0,0x0,0x1010,0x1000,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x1010,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1410,0x0,0x1c12,0x1410,0x0,0x1c0,0x1c0,0x1010,0x0,0x1c12,0x0,0x0,0x1812,0x1010,0x1010,0x1812,0x1010,0x0,0x1000,0x1000,0x1010,0x0,0x0,0x800,0x1000,0x0,0x1810,0x0,0x1816,0x0,0x1814,0x1816,};
+   }
+  final private JJCalls[] jj_2_rtns = new JJCalls[48];
+  private boolean jj_rescan = false;
+  private int jj_gc = 0;
+
+  /** Constructor with InputStream. */
+  public JJTreeParser(java.io.InputStream stream) {
+     this(stream, null);
+  }
+  /** Constructor with InputStream and supplied encoding */
+  public JJTreeParser(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source = new JJTreeParserTokenManager(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 191; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream stream) {
+     ReInit(stream, null);
+  }
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jjtree.reset();
+    jj_gen = 0;
+    for (int i = 0; i < 191; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Constructor. */
+  public JJTreeParser(java.io.Reader stream) {
+    jj_input_stream = new JavaCharStream(stream, 1, 1);
+    token_source = new JJTreeParserTokenManager(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 191; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.Reader stream) {
+    jj_input_stream.ReInit(stream, 1, 1);
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jjtree.reset();
+    jj_gen = 0;
+    for (int i = 0; i < 191; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Constructor with generated Token Manager. */
+  public JJTreeParser(JJTreeParserTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 191; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Reinitialise. */
+  public void ReInit(JJTreeParserTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    jj_ntk = -1;
+    jjtree.reset();
+    jj_gen = 0;
+    for (int i = 0; i < 191; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  private Token jj_consume_token(int kind) throws ParseException {
+    Token oldToken;
+    if ((oldToken = token).next != null) token = token.next;
+    else token = token.next = token_source.getNextToken();
+    jj_ntk = -1;
+    if (token.kind == kind) {
+      jj_gen++;
+      if (++jj_gc > 100) {
+        jj_gc = 0;
+        for (int i = 0; i < jj_2_rtns.length; i++) {
+          JJCalls c = jj_2_rtns[i];
+          while (c != null) {
+            if (c.gen < jj_gen) c.first = null;
+            c = c.next;
+          }
+        }
+      }
+      return token;
+    }
+    token = oldToken;
+    jj_kind = kind;
+    throw generateParseException();
+  }
+
+  static private final class LookaheadSuccess extends java.lang.Error { }
+  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
+  private boolean jj_scan_token(int kind) {
+    if (jj_scanpos == jj_lastpos) {
+      jj_la--;
+      if (jj_scanpos.next == null) {
+        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
+      } else {
+        jj_lastpos = jj_scanpos = jj_scanpos.next;
+      }
+    } else {
+      jj_scanpos = jj_scanpos.next;
+    }
+    if (jj_rescan) {
+      int i = 0; Token tok = token;
+      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
+      if (tok != null) jj_add_error_token(kind, i);
+    }
+    if (jj_scanpos.kind != kind) return true;
+    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
+    return false;
+  }
+
+
+/** Get the next Token. */
+  final public Token getNextToken() {
+    if (token.next != null) token = token.next;
+    else token = token.next = token_source.getNextToken();
+    jj_ntk = -1;
+    jj_gen++;
+    return token;
+  }
+
+/** Get the specific Token. */
+  final public Token getToken(int index) {
+    Token t = jj_lookingAhead ? jj_scanpos : token;
+    for (int i = 0; i < index; i++) {
+      if (t.next != null) t = t.next;
+      else t = t.next = token_source.getNextToken();
+    }
+    return t;
+  }
+
+  private int jj_ntk() {
+    if ((jj_nt=token.next) == null)
+      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
+    else
+      return (jj_ntk = jj_nt.kind);
+  }
+
+  private java.util.List jj_expentries = new java.util.ArrayList();
+  private int[] jj_expentry;
+  private int jj_kind = -1;
+  private int[] jj_lasttokens = new int[100];
+  private int jj_endpos;
+
+  private void jj_add_error_token(int kind, int pos) {
+    if (pos >= 100) return;
+    if (pos == jj_endpos + 1) {
+      jj_lasttokens[jj_endpos++] = kind;
+    } else if (jj_endpos != 0) {
+      jj_expentry = new int[jj_endpos];
+      for (int i = 0; i < jj_endpos; i++) {
+        jj_expentry[i] = jj_lasttokens[i];
+      }
+      boolean exists = false;
+      for (java.util.Iterator it = jj_expentries.iterator(); it.hasNext();) {
+        int[] oldentry = (int[])(it.next());
+        if (oldentry.length == jj_expentry.length) {
+          exists = true;
+          for (int i = 0; i < jj_expentry.length; i++) {
+            if (oldentry[i] != jj_expentry[i]) {
+              exists = false;
+              break;
+            }
+          }
+          if (exists) break;
+        }
+      }
+      if (!exists) jj_expentries.add(jj_expentry);
+      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
+    }
+  }
+
+  /** Generate ParseException. */
+  public ParseException generateParseException() {
+    jj_expentries.clear();
+    boolean[] la1tokens = new boolean[143];
+    if (jj_kind >= 0) {
+      la1tokens[jj_kind] = true;
+      jj_kind = -1;
+    }
+    for (int i = 0; i < 191; i++) {
+      if (jj_la1[i] == jj_gen) {
+        for (int j = 0; j < 32; j++) {
+          if ((jj_la1_0[i] & (1<<j)) != 0) {
+            la1tokens[j] = true;
+          }
+          if ((jj_la1_1[i] & (1<<j)) != 0) {
+            la1tokens[32+j] = true;
+          }
+          if ((jj_la1_2[i] & (1<<j)) != 0) {
+            la1tokens[64+j] = true;
+          }
+          if ((jj_la1_3[i] & (1<<j)) != 0) {
+            la1tokens[96+j] = true;
+          }
+          if ((jj_la1_4[i] & (1<<j)) != 0) {
+            la1tokens[128+j] = true;
+          }
+        }
+      }
+    }
+    for (int i = 0; i < 143; i++) {
+      if (la1tokens[i]) {
+        jj_expentry = new int[1];
+        jj_expentry[0] = i;
+        jj_expentries.add(jj_expentry);
+      }
+    }
+    jj_endpos = 0;
+    jj_rescan_token();
+    jj_add_error_token(0, 0);
+    int[][] exptokseq = new int[jj_expentries.size()][];
+    for (int i = 0; i < jj_expentries.size(); i++) {
+      exptokseq[i] = (int[])jj_expentries.get(i);
+    }
+    return new ParseException(token, exptokseq, tokenImage);
+  }
+
+  /** Enable tracing. */
+  final public void enable_tracing() {
+  }
+
+  /** Disable tracing. */
+  final public void disable_tracing() {
+  }
+
+  private void jj_rescan_token() {
+    jj_rescan = true;
+    for (int i = 0; i < 48; i++) {
+    try {
+      JJCalls p = jj_2_rtns[i];
+      do {
+        if (p.gen > jj_gen) {
+          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
+          switch (i) {
+            case 0: jj_3_1(); break;
+            case 1: jj_3_2(); break;
+            case 2: jj_3_3(); break;
+            case 3: jj_3_4(); break;
+            case 4: jj_3_5(); break;
+            case 5: jj_3_6(); break;
+            case 6: jj_3_7(); break;
+            case 7: jj_3_8(); break;
+            case 8: jj_3_9(); break;
+            case 9: jj_3_10(); break;
+            case 10: jj_3_11(); break;
+            case 11: jj_3_12(); break;
+            case 12: jj_3_13(); break;
+            case 13: jj_3_14(); break;
+            case 14: jj_3_15(); break;
+            case 15: jj_3_16(); break;
+            case 16: jj_3_17(); break;
+            case 17: jj_3_18(); break;
+            case 18: jj_3_19(); break;
+            case 19: jj_3_20(); break;
+            case 20: jj_3_21(); break;
+            case 21: jj_3_22(); break;
+            case 22: jj_3_23(); break;
+            case 23: jj_3_24(); break;
+            case 24: jj_3_25(); break;
+            case 25: jj_3_26(); break;
+            case 26: jj_3_27(); break;
+            case 27: jj_3_28(); break;
+            case 28: jj_3_29(); break;
+            case 29: jj_3_30(); break;
+            case 30: jj_3_31(); break;
+            case 31: jj_3_32(); break;
+            case 32: jj_3_33(); break;
+            case 33: jj_3_34(); break;
+            case 34: jj_3_35(); break;
+            case 35: jj_3_36(); break;
+            case 36: jj_3_37(); break;
+            case 37: jj_3_38(); break;
+            case 38: jj_3_39(); break;
+            case 39: jj_3_40(); break;
+            case 40: jj_3_41(); break;
+            case 41: jj_3_42(); break;
+            case 42: jj_3_43(); break;
+            case 43: jj_3_44(); break;
+            case 44: jj_3_45(); break;
+            case 45: jj_3_46(); break;
+            case 46: jj_3_47(); break;
+            case 47: jj_3_48(); break;
+          }
+        }
+        p = p.next;
+      } while (p != null);
+      } catch(LookaheadSuccess ls) { }
+    }
+    jj_rescan = false;
+  }
+
+  private void jj_save(int index, int xla) {
+    JJCalls p = jj_2_rtns[index];
+    while (p.gen > jj_gen) {
+      if (p.next == null) { p = p.next = new JJCalls(); break; }
+      p = p.next;
+    }
+    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
+  }
+
+  static final class JJCalls {
+    int gen;
+    Token first;
+    int arg;
+    JJCalls next;
+  }
+
+}
diff --git a/generated/org/javacc/jjtree/JJTreeParserConstants.java b/generated/org/javacc/jjtree/JJTreeParserConstants.java
new file mode 100644
index 00000000..827132b3
--- /dev/null
+++ b/generated/org/javacc/jjtree/JJTreeParserConstants.java
@@ -0,0 +1,414 @@
+/* Generated By:JJTree&JavaCC: Do not edit this line. JJTreeParserConstants.java */
+package org.javacc.jjtree;
+
+
+/** 
+ * Token literal values and constants.
+ * Generated by org.javacc.parser.OtherFilesGen#start()
+ */
+public interface JJTreeParserConstants {
+
+  /** End of File. */
+  int EOF = 0;
+  /** RegularExpression Id. */
+  int _LOOKAHEAD = 1;
+  /** RegularExpression Id. */
+  int _IGNORE_CASE = 2;
+  /** RegularExpression Id. */
+  int _PARSER_BEGIN = 3;
+  /** RegularExpression Id. */
+  int _PARSER_END = 4;
+  /** RegularExpression Id. */
+  int _JAVACODE = 5;
+  /** RegularExpression Id. */
+  int _TOKEN = 6;
+  /** RegularExpression Id. */
+  int _SPECIAL_TOKEN = 7;
+  /** RegularExpression Id. */
+  int _MORE = 8;
+  /** RegularExpression Id. */
+  int _SKIP = 9;
+  /** RegularExpression Id. */
+  int _TOKEN_MGR_DECLS = 10;
+  /** RegularExpression Id. */
+  int _EOF = 11;
+  /** RegularExpression Id. */
+  int SINGLE_LINE_COMMENT = 20;
+  /** RegularExpression Id. */
+  int FORMAL_COMMENT = 21;
+  /** RegularExpression Id. */
+  int MULTI_LINE_COMMENT = 22;
+  /** RegularExpression Id. */
+  int ABSTRACT = 24;
+  /** RegularExpression Id. */
+  int BOOLEAN = 25;
+  /** RegularExpression Id. */
+  int BREAK = 26;
+  /** RegularExpression Id. */
+  int BYTE = 27;
+  /** RegularExpression Id. */
+  int CASE = 28;
+  /** RegularExpression Id. */
+  int CATCH = 29;
+  /** RegularExpression Id. */
+  int CHAR = 30;
+  /** RegularExpression Id. */
+  int CLASS = 31;
+  /** RegularExpression Id. */
+  int CONST = 32;
+  /** RegularExpression Id. */
+  int CONTINUE = 33;
+  /** RegularExpression Id. */
+  int _DEFAULT = 34;
+  /** RegularExpression Id. */
+  int DO = 35;
+  /** RegularExpression Id. */
+  int DOUBLE = 36;
+  /** RegularExpression Id. */
+  int ELSE = 37;
+  /** RegularExpression Id. */
+  int EXTENDS = 38;
+  /** RegularExpression Id. */
+  int FALSE = 39;
+  /** RegularExpression Id. */
+  int FINAL = 40;
+  /** RegularExpression Id. */
+  int FINALLY = 41;
+  /** RegularExpression Id. */
+  int FLOAT = 42;
+  /** RegularExpression Id. */
+  int FOR = 43;
+  /** RegularExpression Id. */
+  int GOTO = 44;
+  /** RegularExpression Id. */
+  int IF = 45;
+  /** RegularExpression Id. */
+  int IMPLEMENTS = 46;
+  /** RegularExpression Id. */
+  int IMPORT = 47;
+  /** RegularExpression Id. */
+  int INSTANCEOF = 48;
+  /** RegularExpression Id. */
+  int INT = 49;
+  /** RegularExpression Id. */
+  int INTERFACE = 50;
+  /** RegularExpression Id. */
+  int LONG = 51;
+  /** RegularExpression Id. */
+  int NATIVE = 52;
+  /** RegularExpression Id. */
+  int NEW = 53;
+  /** RegularExpression Id. */
+  int NULL = 54;
+  /** RegularExpression Id. */
+  int PACKAGE = 55;
+  /** RegularExpression Id. */
+  int PRIVATE = 56;
+  /** RegularExpression Id. */
+  int PROTECTED = 57;
+  /** RegularExpression Id. */
+  int PUBLIC = 58;
+  /** RegularExpression Id. */
+  int RETURN = 59;
+  /** RegularExpression Id. */
+  int SHORT = 60;
+  /** RegularExpression Id. */
+  int STATIC = 61;
+  /** RegularExpression Id. */
+  int SUPER = 62;
+  /** RegularExpression Id. */
+  int SWITCH = 63;
+  /** RegularExpression Id. */
+  int SYNCHRONIZED = 64;
+  /** RegularExpression Id. */
+  int THIS = 65;
+  /** RegularExpression Id. */
+  int THROW = 66;
+  /** RegularExpression Id. */
+  int THROWS = 67;
+  /** RegularExpression Id. */
+  int TRANSIENT = 68;
+  /** RegularExpression Id. */
+  int TRUE = 69;
+  /** RegularExpression Id. */
+  int TRY = 70;
+  /** RegularExpression Id. */
+  int VOID = 71;
+  /** RegularExpression Id. */
+  int VOLATILE = 72;
+  /** RegularExpression Id. */
+  int WHILE = 73;
+  /** RegularExpression Id. */
+  int INTEGER_LITERAL = 74;
+  /** RegularExpression Id. */
+  int DECIMAL_LITERAL = 75;
+  /** RegularExpression Id. */
+  int HEX_LITERAL = 76;
+  /** RegularExpression Id. */
+  int OCTAL_LITERAL = 77;
+  /** RegularExpression Id. */
+  int FLOATING_POINT_LITERAL = 78;
+  /** RegularExpression Id. */
+  int DECIMAL_FLOATING_POINT_LITERAL = 79;
+  /** RegularExpression Id. */
+  int DECIMAL_EXPONENT = 80;
+  /** RegularExpression Id. */
+  int HEXADECIMAL_FLOATING_POINT_LITERAL = 81;
+  /** RegularExpression Id. */
+  int HEXADECIMAL_EXPONENT = 82;
+  /** RegularExpression Id. */
+  int CHARACTER_LITERAL = 83;
+  /** RegularExpression Id. */
+  int STRING_LITERAL = 84;
+  /** RegularExpression Id. */
+  int LPAREN = 85;
+  /** RegularExpression Id. */
+  int RPAREN = 86;
+  /** RegularExpression Id. */
+  int LBRACE = 87;
+  /** RegularExpression Id. */
+  int RBRACE = 88;
+  /** RegularExpression Id. */
+  int LBRACKET = 89;
+  /** RegularExpression Id. */
+  int RBRACKET = 90;
+  /** RegularExpression Id. */
+  int SEMICOLON = 91;
+  /** RegularExpression Id. */
+  int COMMA = 92;
+  /** RegularExpression Id. */
+  int DOT = 93;
+  /** RegularExpression Id. */
+  int HASH = 94;
+  /** RegularExpression Id. */
+  int ASSIGN = 95;
+  /** RegularExpression Id. */
+  int LT = 96;
+  /** RegularExpression Id. */
+  int BANG = 97;
+  /** RegularExpression Id. */
+  int TILDE = 98;
+  /** RegularExpression Id. */
+  int HOOK = 99;
+  /** RegularExpression Id. */
+  int COLON = 100;
+  /** RegularExpression Id. */
+  int DOUBLECOLON = 101;
+  /** RegularExpression Id. */
+  int EQ = 102;
+  /** RegularExpression Id. */
+  int LE = 103;
+  /** RegularExpression Id. */
+  int GE = 104;
+  /** RegularExpression Id. */
+  int NE = 105;
+  /** RegularExpression Id. */
+  int SC_OR = 106;
+  /** RegularExpression Id. */
+  int SC_AND = 107;
+  /** RegularExpression Id. */
+  int INCR = 108;
+  /** RegularExpression Id. */
+  int DECR = 109;
+  /** RegularExpression Id. */
+  int PLUS = 110;
+  /** RegularExpression Id. */
+  int MINUS = 111;
+  /** RegularExpression Id. */
+  int STAR = 112;
+  /** RegularExpression Id. */
+  int SLASH = 113;
+  /** RegularExpression Id. */
+  int BIT_AND = 114;
+  /** RegularExpression Id. */
+  int BIT_OR = 115;
+  /** RegularExpression Id. */
+  int XOR = 116;
+  /** RegularExpression Id. */
+  int REM = 117;
+  /** RegularExpression Id. */
+  int PLUSASSIGN = 118;
+  /** RegularExpression Id. */
+  int MINUSASSIGN = 119;
+  /** RegularExpression Id. */
+  int STARASSIGN = 120;
+  /** RegularExpression Id. */
+  int SLASHASSIGN = 121;
+  /** RegularExpression Id. */
+  int ANDASSIGN = 122;
+  /** RegularExpression Id. */
+  int ORASSIGN = 123;
+  /** RegularExpression Id. */
+  int XORASSIGN = 124;
+  /** RegularExpression Id. */
+  int REMASSIGN = 125;
+  /** RegularExpression Id. */
+  int RUNSIGNEDSHIFT = 126;
+  /** RegularExpression Id. */
+  int RSIGNEDSHIFT = 127;
+  /** RegularExpression Id. */
+  int GT = 128;
+  /** RegularExpression Id. */
+  int IDENTIFIER = 140;
+  /** RegularExpression Id. */
+  int LETTER = 141;
+  /** RegularExpression Id. */
+  int PART_LETTER = 142;
+
+  /** Lexical state. */
+  int DEFAULT = 0;
+  /** Lexical state. */
+  int IN_SINGLE_LINE_COMMENT = 1;
+  /** Lexical state. */
+  int IN_FORMAL_COMMENT = 2;
+  /** Lexical state. */
+  int IN_MULTI_LINE_COMMENT = 3;
+
+  /** Literal token values. */
+  String[] tokenImage = {
+    "<EOF>",
+    "\"LOOKAHEAD\"",
+    "\"IGNORE_CASE\"",
+    "\"PARSER_BEGIN\"",
+    "\"PARSER_END\"",
+    "\"JAVACODE\"",
+    "\"TOKEN\"",
+    "\"SPECIAL_TOKEN\"",
+    "\"MORE\"",
+    "\"SKIP\"",
+    "\"TOKEN_MGR_DECLS\"",
+    "\"EOF\"",
+    "\" \"",
+    "\"\\t\"",
+    "\"\\n\"",
+    "\"\\r\"",
+    "\"\\f\"",
+    "\"//\"",
+    "<token of kind 18>",
+    "\"/*\"",
+    "<SINGLE_LINE_COMMENT>",
+    "\"*/\"",
+    "\"*/\"",
+    "<token of kind 23>",
+    "\"abstract\"",
+    "\"boolean\"",
+    "\"break\"",
+    "\"byte\"",
+    "\"case\"",
+    "\"catch\"",
+    "\"char\"",
+    "\"class\"",
+    "\"const\"",
+    "\"continue\"",
+    "\"default\"",
+    "\"do\"",
+    "\"double\"",
+    "\"else\"",
+    "\"extends\"",
+    "\"false\"",
+    "\"final\"",
+    "\"finally\"",
+    "\"float\"",
+    "\"for\"",
+    "\"goto\"",
+    "\"if\"",
+    "\"implements\"",
+    "\"import\"",
+    "\"instanceof\"",
+    "\"int\"",
+    "\"interface\"",
+    "\"long\"",
+    "\"native\"",
+    "\"new\"",
+    "\"null\"",
+    "\"package\"",
+    "\"private\"",
+    "\"protected\"",
+    "\"public\"",
+    "\"return\"",
+    "\"short\"",
+    "\"static\"",
+    "\"super\"",
+    "\"switch\"",
+    "\"synchronized\"",
+    "\"this\"",
+    "\"throw\"",
+    "\"throws\"",
+    "\"transient\"",
+    "\"true\"",
+    "\"try\"",
+    "\"void\"",
+    "\"volatile\"",
+    "\"while\"",
+    "<INTEGER_LITERAL>",
+    "<DECIMAL_LITERAL>",
+    "<HEX_LITERAL>",
+    "<OCTAL_LITERAL>",
+    "<FLOATING_POINT_LITERAL>",
+    "<DECIMAL_FLOATING_POINT_LITERAL>",
+    "<DECIMAL_EXPONENT>",
+    "<HEXADECIMAL_FLOATING_POINT_LITERAL>",
+    "<HEXADECIMAL_EXPONENT>",
+    "<CHARACTER_LITERAL>",
+    "<STRING_LITERAL>",
+    "\"(\"",
+    "\")\"",
+    "\"{\"",
+    "\"}\"",
+    "\"[\"",
+    "\"]\"",
+    "\";\"",
+    "\",\"",
+    "\".\"",
+    "\"#\"",
+    "\"=\"",
+    "\"<\"",
+    "\"!\"",
+    "\"~\"",
+    "\"?\"",
+    "\":\"",
+    "\"::\"",
+    "\"==\"",
+    "\"<=\"",
+    "\">=\"",
+    "\"!=\"",
+    "\"||\"",
+    "\"&&\"",
+    "\"++\"",
+    "\"--\"",
+    "\"+\"",
+    "\"-\"",
+    "\"*\"",
+    "\"/\"",
+    "\"&\"",
+    "\"|\"",
+    "\"^\"",
+    "\"%\"",
+    "\"+=\"",
+    "\"-=\"",
+    "\"*=\"",
+    "\"/=\"",
+    "\"&=\"",
+    "\"|=\"",
+    "\"^=\"",
+    "\"%=\"",
+    "\">>>\"",
+    "\">>\"",
+    "\">\"",
+    "\"strictfp\"",
+    "\"enum\"",
+    "\"...\"",
+    "\"template\"",
+    "\"typename\"",
+    "\"<<=\"",
+    "\">>=\"",
+    "\">>>=\"",
+    "\"<<\"",
+    "\"assert\"",
+    "\"@\"",
+    "<IDENTIFIER>",
+    "<LETTER>",
+    "<PART_LETTER>",
+  };
+
+}
diff --git a/generated/org/javacc/jjtree/JJTreeParserTokenManager.java b/generated/org/javacc/jjtree/JJTreeParserTokenManager.java
new file mode 100644
index 00000000..46e5674a
--- /dev/null
+++ b/generated/org/javacc/jjtree/JJTreeParserTokenManager.java
@@ -0,0 +1,2456 @@
+/* Generated By:JJTree&JavaCC: Do not edit this line. JJTreeParserTokenManager.java */
+package org.javacc.jjtree;
+
+/** Token Manager. */
+public class JJTreeParserTokenManager implements JJTreeParserConstants
+{
+
+  /** Debug output. */
+  public  java.io.PrintStream debugStream = System.out;
+  /** Set debug output. */
+  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
+private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1, long active2)
+{
+   switch (pos)
+   {
+      case 0:
+         if ((active0 & 0xa0000L) != 0L || (active1 & 0x202000000000000L) != 0L)
+            return 2;
+         if ((active1 & 0x20000000L) != 0L || (active2 & 0x8L) != 0L)
+            return 8;
+         if ((active0 & 0xffffffffff000ffeL) != 0L || (active1 & 0x3ffL) != 0L || (active2 & 0x436L) != 0L)
+         {
+            jjmatchedKind = 140;
+            return 32;
+         }
+         return -1;
+      case 1:
+         if ((active0 & 0x80000L) != 0L)
+            return 0;
+         if ((active0 & 0xffffdfe7ff000ffeL) != 0L || (active1 & 0x3ffL) != 0L || (active2 & 0x436L) != 0L)
+         {
+            if (jjmatchedPos != 1)
+            {
+               jjmatchedKind = 140;
+               jjmatchedPos = 1;
+            }
+            return 32;
+         }
+         if ((active0 & 0x201800000000L) != 0L)
+            return 32;
+         return -1;
+      case 2:
+         if ((active0 & 0xffd9d7f7ff0007feL) != 0L || (active1 & 0x3bfL) != 0L || (active2 & 0x436L) != 0L)
+         {
+            if (jjmatchedPos != 2)
+            {
+               jjmatchedKind = 140;
+               jjmatchedPos = 2;
+            }
+            return 32;
+         }
+         if ((active0 & 0x26080000000800L) != 0L || (active1 & 0x40L) != 0L)
+            return 32;
+         return -1;
+      case 3:
+         if ((active0 & 0xff95c7d7a70004feL) != 0L || (active1 & 0x31dL) != 0L || (active2 & 0x432L) != 0L)
+         {
+            jjmatchedKind = 140;
+            jjmatchedPos = 3;
+            return 32;
+         }
+         if ((active0 & 0x48102058000300L) != 0L || (active1 & 0xa2L) != 0L || (active2 & 0x4L) != 0L)
+            return 32;
+         return -1;
+      case 4:
+         if ((active0 & 0xaf95c056030000beL) != 0L || (active1 & 0x111L) != 0L || (active2 & 0x432L) != 0L)
+         {
+            if (jjmatchedPos != 4)
+            {
+               jjmatchedKind = 140;
+               jjmatchedPos = 4;
+            }
+            return 32;
+         }
+         if ((active0 & 0x50000781a4000440L) != 0L || (active1 & 0x20cL) != 0L)
+            return 32;
+         return -1;
+      case 5:
+         if ((active0 & 0x3854246030004beL) != 0L || (active1 & 0x111L) != 0L || (active2 & 0x32L) != 0L)
+         {
+            jjmatchedKind = 140;
+            jjmatchedPos = 5;
+            return 32;
+         }
+         if ((active0 & 0xac10801000000000L) != 0L || (active1 & 0x8L) != 0L || (active2 & 0x400L) != 0L)
+            return 32;
+         return -1;
+      case 6:
+         if ((active0 & 0x2054002010004beL) != 0L || (active1 & 0x111L) != 0L || (active2 & 0x32L) != 0L)
+         {
+            jjmatchedKind = 140;
+            jjmatchedPos = 6;
+            return 32;
+         }
+         if ((active0 & 0x180024402000000L) != 0L)
+            return 32;
+         return -1;
+      case 7:
+         if ((active0 & 0x20540000000049eL) != 0L || (active1 & 0x11L) != 0L)
+         {
+            jjmatchedKind = 140;
+            jjmatchedPos = 7;
+            return 32;
+         }
+         if ((active0 & 0x201000020L) != 0L || (active1 & 0x100L) != 0L || (active2 & 0x32L) != 0L)
+            return 32;
+         return -1;
+      case 8:
+         if ((active0 & 0x140000000049cL) != 0L || (active1 & 0x1L) != 0L)
+         {
+            jjmatchedKind = 140;
+            jjmatchedPos = 8;
+            return 32;
+         }
+         if ((active0 & 0x204000000000002L) != 0L || (active1 & 0x10L) != 0L)
+            return 32;
+         return -1;
+      case 9:
+         if ((active0 & 0x48cL) != 0L || (active1 & 0x1L) != 0L)
+         {
+            jjmatchedKind = 140;
+            jjmatchedPos = 9;
+            return 32;
+         }
+         if ((active0 & 0x1400000000010L) != 0L)
+            return 32;
+         return -1;
+      case 10:
+         if ((active0 & 0x488L) != 0L || (active1 & 0x1L) != 0L)
+         {
+            jjmatchedKind = 140;
+            jjmatchedPos = 10;
+            return 32;
+         }
+         if ((active0 & 0x4L) != 0L)
+            return 32;
+         return -1;
+      case 11:
+         if ((active0 & 0x480L) != 0L)
+         {
+            jjmatchedKind = 140;
+            jjmatchedPos = 11;
+            return 32;
+         }
+         if ((active0 & 0x8L) != 0L || (active1 & 0x1L) != 0L)
+            return 32;
+         return -1;
+      case 12:
+         if ((active0 & 0x400L) != 0L)
+         {
+            jjmatchedKind = 140;
+            jjmatchedPos = 12;
+            return 32;
+         }
+         if ((active0 & 0x80L) != 0L)
+            return 32;
+         return -1;
+      case 13:
+         if ((active0 & 0x400L) != 0L)
+         {
+            jjmatchedKind = 140;
+            jjmatchedPos = 13;
+            return 32;
+         }
+         return -1;
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_0(int pos, long active0, long active1, long active2)
+{
+   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0, active1, active2), pos + 1);
+}
+private int jjStopAtPos(int pos, int kind)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   return pos + 1;
+}
+private int jjStartNfaWithStates_0(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_0(state, pos + 1);
+}
+private int jjMoveStringLiteralDfa0_0()
+{
+   switch(curChar)
+   {
+      case 9:
+         return jjStopAtPos(0, 13);
+      case 10:
+         return jjStopAtPos(0, 14);
+      case 12:
+         return jjStopAtPos(0, 16);
+      case 13:
+         return jjStopAtPos(0, 15);
+      case 32:
+         return jjStopAtPos(0, 12);
+      case 33:
+         jjmatchedKind = 97;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x20000000000L, 0x0L);
+      case 35:
+         return jjStopAtPos(0, 94);
+      case 37:
+         jjmatchedKind = 117;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x2000000000000000L, 0x0L);
+      case 38:
+         jjmatchedKind = 114;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x400080000000000L, 0x0L);
+      case 40:
+         return jjStopAtPos(0, 85);
+      case 41:
+         return jjStopAtPos(0, 86);
+      case 42:
+         jjmatchedKind = 112;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x100000000000000L, 0x0L);
+      case 43:
+         jjmatchedKind = 110;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x40100000000000L, 0x0L);
+      case 44:
+         return jjStopAtPos(0, 92);
+      case 45:
+         jjmatchedKind = 111;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x80200000000000L, 0x0L);
+      case 46:
+         jjmatchedKind = 93;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x0L, 0x8L);
+      case 47:
+         jjmatchedKind = 113;
+         return jjMoveStringLiteralDfa1_0(0xa0000L, 0x200000000000000L, 0x0L);
+      case 58:
+         jjmatchedKind = 100;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x2000000000L, 0x0L);
+      case 59:
+         return jjStopAtPos(0, 91);
+      case 60:
+         jjmatchedKind = 96;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x8000000000L, 0x240L);
+      case 61:
+         jjmatchedKind = 95;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x4000000000L, 0x0L);
+      case 62:
+         jjmatchedKind = 128;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0xc000010000000000L, 0x180L);
+      case 63:
+         return jjStopAtPos(0, 99);
+      case 64:
+         return jjStopAtPos(0, 139);
+      case 69:
+         return jjMoveStringLiteralDfa1_0(0x800L, 0x0L, 0x0L);
+      case 73:
+         return jjMoveStringLiteralDfa1_0(0x4L, 0x0L, 0x0L);
+      case 74:
+         return jjMoveStringLiteralDfa1_0(0x20L, 0x0L, 0x0L);
+      case 76:
+         return jjMoveStringLiteralDfa1_0(0x2L, 0x0L, 0x0L);
+      case 77:
+         return jjMoveStringLiteralDfa1_0(0x100L, 0x0L, 0x0L);
+      case 80:
+         return jjMoveStringLiteralDfa1_0(0x18L, 0x0L, 0x0L);
+      case 83:
+         return jjMoveStringLiteralDfa1_0(0x280L, 0x0L, 0x0L);
+      case 84:
+         return jjMoveStringLiteralDfa1_0(0x440L, 0x0L, 0x0L);
+      case 91:
+         return jjStopAtPos(0, 89);
+      case 93:
+         return jjStopAtPos(0, 90);
+      case 94:
+         jjmatchedKind = 116;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x1000000000000000L, 0x0L);
+      case 97:
+         return jjMoveStringLiteralDfa1_0(0x1000000L, 0x0L, 0x400L);
+      case 98:
+         return jjMoveStringLiteralDfa1_0(0xe000000L, 0x0L, 0x0L);
+      case 99:
+         return jjMoveStringLiteralDfa1_0(0x3f0000000L, 0x0L, 0x0L);
+      case 100:
+         return jjMoveStringLiteralDfa1_0(0x1c00000000L, 0x0L, 0x0L);
+      case 101:
+         return jjMoveStringLiteralDfa1_0(0x6000000000L, 0x0L, 0x4L);
+      case 102:
+         return jjMoveStringLiteralDfa1_0(0xf8000000000L, 0x0L, 0x0L);
+      case 103:
+         return jjMoveStringLiteralDfa1_0(0x100000000000L, 0x0L, 0x0L);
+      case 105:
+         return jjMoveStringLiteralDfa1_0(0x7e00000000000L, 0x0L, 0x0L);
+      case 108:
+         return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L, 0x0L);
+      case 110:
+         return jjMoveStringLiteralDfa1_0(0x70000000000000L, 0x0L, 0x0L);
+      case 112:
+         return jjMoveStringLiteralDfa1_0(0x780000000000000L, 0x0L, 0x0L);
+      case 114:
+         return jjMoveStringLiteralDfa1_0(0x800000000000000L, 0x0L, 0x0L);
+      case 115:
+         return jjMoveStringLiteralDfa1_0(0xf000000000000000L, 0x1L, 0x2L);
+      case 116:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x7eL, 0x30L);
+      case 118:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x180L, 0x0L);
+      case 119:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x200L, 0x0L);
+      case 123:
+         return jjStopAtPos(0, 87);
+      case 124:
+         jjmatchedKind = 115;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x800040000000000L, 0x0L);
+      case 125:
+         return jjStopAtPos(0, 88);
+      case 126:
+         return jjStopAtPos(0, 98);
+      default :
+         return jjMoveNfa_0(3, 0);
+   }
+}
+private int jjMoveStringLiteralDfa1_0(long active0, long active1, long active2)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(0, active0, active1, active2);
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 38:
+         if ((active1 & 0x80000000000L) != 0L)
+            return jjStopAtPos(1, 107);
+         break;
+      case 42:
+         if ((active0 & 0x80000L) != 0L)
+            return jjStartNfaWithStates_0(1, 19, 0);
+         break;
+      case 43:
+         if ((active1 & 0x100000000000L) != 0L)
+            return jjStopAtPos(1, 108);
+         break;
+      case 45:
+         if ((active1 & 0x200000000000L) != 0L)
+            return jjStopAtPos(1, 109);
+         break;
+      case 46:
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0L, active2, 0x8L);
+      case 47:
+         if ((active0 & 0x20000L) != 0L)
+            return jjStopAtPos(1, 17);
+         break;
+      case 58:
+         if ((active1 & 0x2000000000L) != 0L)
+            return jjStopAtPos(1, 101);
+         break;
+      case 60:
+         if ((active2 & 0x200L) != 0L)
+         {
+            jjmatchedKind = 137;
+            jjmatchedPos = 1;
+         }
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0L, active2, 0x40L);
+      case 61:
+         if ((active1 & 0x4000000000L) != 0L)
+            return jjStopAtPos(1, 102);
+         else if ((active1 & 0x8000000000L) != 0L)
+            return jjStopAtPos(1, 103);
+         else if ((active1 & 0x10000000000L) != 0L)
+            return jjStopAtPos(1, 104);
+         else if ((active1 & 0x20000000000L) != 0L)
+            return jjStopAtPos(1, 105);
+         else if ((active1 & 0x40000000000000L) != 0L)
+            return jjStopAtPos(1, 118);
+         else if ((active1 & 0x80000000000000L) != 0L)
+            return jjStopAtPos(1, 119);
+         else if ((active1 & 0x100000000000000L) != 0L)
+            return jjStopAtPos(1, 120);
+         else if ((active1 & 0x200000000000000L) != 0L)
+            return jjStopAtPos(1, 121);
+         else if ((active1 & 0x400000000000000L) != 0L)
+            return jjStopAtPos(1, 122);
+         else if ((active1 & 0x800000000000000L) != 0L)
+            return jjStopAtPos(1, 123);
+         else if ((active1 & 0x1000000000000000L) != 0L)
+            return jjStopAtPos(1, 124);
+         else if ((active1 & 0x2000000000000000L) != 0L)
+            return jjStopAtPos(1, 125);
+         break;
+      case 62:
+         if ((active1 & 0x8000000000000000L) != 0L)
+         {
+            jjmatchedKind = 127;
+            jjmatchedPos = 1;
+         }
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x4000000000000000L, active2, 0x180L);
+      case 65:
+         return jjMoveStringLiteralDfa2_0(active0, 0x38L, active1, 0L, active2, 0L);
+      case 71:
+         return jjMoveStringLiteralDfa2_0(active0, 0x4L, active1, 0L, active2, 0L);
+      case 75:
+         return jjMoveStringLiteralDfa2_0(active0, 0x200L, active1, 0L, active2, 0L);
+      case 79:
+         return jjMoveStringLiteralDfa2_0(active0, 0xd42L, active1, 0L, active2, 0L);
+      case 80:
+         return jjMoveStringLiteralDfa2_0(active0, 0x80L, active1, 0L, active2, 0L);
+      case 97:
+         return jjMoveStringLiteralDfa2_0(active0, 0x90008030000000L, active1, 0L, active2, 0L);
+      case 98:
+         return jjMoveStringLiteralDfa2_0(active0, 0x1000000L, active1, 0L, active2, 0L);
+      case 101:
+         return jjMoveStringLiteralDfa2_0(active0, 0x820000400000000L, active1, 0L, active2, 0x10L);
+      case 102:
+         if ((active0 & 0x200000000000L) != 0L)
+            return jjStartNfaWithStates_0(1, 45, 32);
+         break;
+      case 104:
+         return jjMoveStringLiteralDfa2_0(active0, 0x1000000040000000L, active1, 0x20eL, active2, 0L);
+      case 105:
+         return jjMoveStringLiteralDfa2_0(active0, 0x30000000000L, active1, 0L, active2, 0L);
+      case 108:
+         return jjMoveStringLiteralDfa2_0(active0, 0x42080000000L, active1, 0L, active2, 0L);
+      case 109:
+         return jjMoveStringLiteralDfa2_0(active0, 0xc00000000000L, active1, 0L, active2, 0L);
+      case 110:
+         return jjMoveStringLiteralDfa2_0(active0, 0x7000000000000L, active1, 0L, active2, 0x4L);
+      case 111:
+         if ((active0 & 0x800000000L) != 0L)
+         {
+            jjmatchedKind = 35;
+            jjmatchedPos = 1;
+         }
+         return jjMoveStringLiteralDfa2_0(active0, 0x8181302000000L, active1, 0x180L, active2, 0L);
+      case 114:
+         return jjMoveStringLiteralDfa2_0(active0, 0x300000004000000L, active1, 0x70L, active2, 0L);
+      case 115:
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0L, active2, 0x400L);
+      case 116:
+         return jjMoveStringLiteralDfa2_0(active0, 0x2000000000000000L, active1, 0L, active2, 0x2L);
+      case 117:
+         return jjMoveStringLiteralDfa2_0(active0, 0x4440000000000000L, active1, 0L, active2, 0L);
+      case 119:
+         return jjMoveStringLiteralDfa2_0(active0, 0x8000000000000000L, active1, 0L, active2, 0L);
+      case 120:
+         return jjMoveStringLiteralDfa2_0(active0, 0x4000000000L, active1, 0L, active2, 0L);
+      case 121:
+         return jjMoveStringLiteralDfa2_0(active0, 0x8000000L, active1, 0x1L, active2, 0x20L);
+      case 124:
+         if ((active1 & 0x40000000000L) != 0L)
+            return jjStopAtPos(1, 106);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(0, active0, active1, active2);
+}
+private int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1, long old2, long active2)
+{
+   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
+      return jjStartNfa_0(0, old0, old1, old2); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(1, active0, active1, active2);
+      return 2;
+   }
+   switch(curChar)
+   {
+      case 46:
+         if ((active2 & 0x8L) != 0L)
+            return jjStopAtPos(2, 131);
+         break;
+      case 61:
+         if ((active2 & 0x40L) != 0L)
+            return jjStopAtPos(2, 134);
+         else if ((active2 & 0x80L) != 0L)
+            return jjStopAtPos(2, 135);
+         break;
+      case 62:
+         if ((active1 & 0x4000000000000000L) != 0L)
+         {
+            jjmatchedKind = 126;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0L, active2, 0x100L);
+      case 69:
+         return jjMoveStringLiteralDfa3_0(active0, 0x80L, active1, 0L, active2, 0L);
+      case 70:
+         if ((active0 & 0x800L) != 0L)
+            return jjStartNfaWithStates_0(2, 11, 32);
+         break;
+      case 73:
+         return jjMoveStringLiteralDfa3_0(active0, 0x200L, active1, 0L, active2, 0L);
+      case 75:
+         return jjMoveStringLiteralDfa3_0(active0, 0x440L, active1, 0L, active2, 0L);
+      case 78:
+         return jjMoveStringLiteralDfa3_0(active0, 0x4L, active1, 0L, active2, 0L);
+      case 79:
+         return jjMoveStringLiteralDfa3_0(active0, 0x2L, active1, 0L, active2, 0L);
+      case 82:
+         return jjMoveStringLiteralDfa3_0(active0, 0x118L, active1, 0L, active2, 0L);
+      case 86:
+         return jjMoveStringLiteralDfa3_0(active0, 0x20L, active1, 0L, active2, 0L);
+      case 97:
+         return jjMoveStringLiteralDfa3_0(active0, 0x20000000c0000000L, active1, 0x10L, active2, 0L);
+      case 98:
+         return jjMoveStringLiteralDfa3_0(active0, 0x400000000000000L, active1, 0L, active2, 0L);
+      case 99:
+         return jjMoveStringLiteralDfa3_0(active0, 0x80000000000000L, active1, 0L, active2, 0L);
+      case 101:
+         return jjMoveStringLiteralDfa3_0(active0, 0x4000000L, active1, 0L, active2, 0L);
+      case 102:
+         return jjMoveStringLiteralDfa3_0(active0, 0x400000000L, active1, 0L, active2, 0L);
+      case 105:
+         return jjMoveStringLiteralDfa3_0(active0, 0x8100000000000000L, active1, 0x282L, active2, 0L);
+      case 108:
+         return jjMoveStringLiteralDfa3_0(active0, 0x40008000000000L, active1, 0x100L, active2, 0L);
+      case 109:
+         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0L, active2, 0x10L);
+      case 110:
+         return jjMoveStringLiteralDfa3_0(active0, 0x8030300000000L, active1, 0x1L, active2, 0L);
+      case 111:
+         return jjMoveStringLiteralDfa3_0(active0, 0x1200040002000000L, active1, 0L, active2, 0L);
+      case 112:
+         return jjMoveStringLiteralDfa3_0(active0, 0x4000c00000000000L, active1, 0L, active2, 0x20L);
+      case 114:
+         if ((active0 & 0x80000000000L) != 0L)
+            return jjStartNfaWithStates_0(2, 43, 32);
+         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0xcL, active2, 0x2L);
+      case 115:
+         return jjMoveStringLiteralDfa3_0(active0, 0x1002011000000L, active1, 0L, active2, 0x400L);
+      case 116:
+         if ((active0 & 0x2000000000000L) != 0L)
+         {
+            jjmatchedKind = 49;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0x814104028000000L, active1, 0L, active2, 0L);
+      case 117:
+         return jjMoveStringLiteralDfa3_0(active0, 0x1000000000L, active1, 0x20L, active2, 0x4L);
+      case 119:
+         if ((active0 & 0x20000000000000L) != 0L)
+            return jjStartNfaWithStates_0(2, 53, 32);
+         break;
+      case 121:
+         if ((active1 & 0x40L) != 0L)
+            return jjStartNfaWithStates_0(2, 70, 32);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(1, active0, active1, active2);
+}
+private int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1, long old2, long active2)
+{
+   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
+      return jjStartNfa_0(1, old0, old1, old2); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(2, active0, active1, active2);
+      return 3;
+   }
+   switch(curChar)
+   {
+      case 61:
+         if ((active2 & 0x100L) != 0L)
+            return jjStopAtPos(3, 136);
+         break;
+      case 65:
+         return jjMoveStringLiteralDfa4_0(active0, 0x20L, active1, 0L, active2, 0L);
+      case 67:
+         return jjMoveStringLiteralDfa4_0(active0, 0x80L, active1, 0L, active2, 0L);
+      case 69:
+         if ((active0 & 0x100L) != 0L)
+            return jjStartNfaWithStates_0(3, 8, 32);
+         return jjMoveStringLiteralDfa4_0(active0, 0x440L, active1, 0L, active2, 0L);
+      case 75:
+         return jjMoveStringLiteralDfa4_0(active0, 0x2L, active1, 0L, active2, 0L);
+      case 79:
+         return jjMoveStringLiteralDfa4_0(active0, 0x4L, active1, 0L, active2, 0L);
+      case 80:
+         if ((active0 & 0x200L) != 0L)
+            return jjStartNfaWithStates_0(3, 9, 32);
+         break;
+      case 83:
+         return jjMoveStringLiteralDfa4_0(active0, 0x18L, active1, 0L, active2, 0L);
+      case 97:
+         return jjMoveStringLiteralDfa4_0(active0, 0x70404000000L, active1, 0x100L, active2, 0L);
+      case 98:
+         return jjMoveStringLiteralDfa4_0(active0, 0x1000000000L, active1, 0L, active2, 0L);
+      case 99:
+         return jjMoveStringLiteralDfa4_0(active0, 0x20000000L, active1, 0x1L, active2, 0L);
+      case 100:
+         if ((active1 & 0x80L) != 0L)
+            return jjStartNfaWithStates_0(3, 71, 32);
+         break;
+      case 101:
+         if ((active0 & 0x8000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 27, 32);
+         else if ((active0 & 0x10000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 28, 32);
+         else if ((active0 & 0x2000000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 37, 32);
+         else if ((active1 & 0x20L) != 0L)
+            return jjStartNfaWithStates_0(3, 69, 32);
+         return jjMoveStringLiteralDfa4_0(active0, 0x4004004000000000L, active1, 0L, active2, 0x420L);
+      case 103:
+         if ((active0 & 0x8000000000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 51, 32);
+         break;
+      case 105:
+         return jjMoveStringLiteralDfa4_0(active0, 0x10000000000000L, active1, 0L, active2, 0x2L);
+      case 107:
+         return jjMoveStringLiteralDfa4_0(active0, 0x80000000000000L, active1, 0L, active2, 0L);
+      case 108:
+         if ((active0 & 0x40000000000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 54, 32);
+         return jjMoveStringLiteralDfa4_0(active0, 0x400400002000000L, active1, 0x200L, active2, 0L);
+      case 109:
+         if ((active2 & 0x4L) != 0L)
+            return jjStartNfaWithStates_0(3, 130, 32);
+         break;
+      case 110:
+         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x10L, active2, 0L);
+      case 111:
+         if ((active0 & 0x100000000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 44, 32);
+         return jjMoveStringLiteralDfa4_0(active0, 0x800000000000L, active1, 0xcL, active2, 0L);
+      case 112:
+         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0L, active2, 0x10L);
+      case 114:
+         if ((active0 & 0x40000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 30, 32);
+         return jjMoveStringLiteralDfa4_0(active0, 0x1000000000000000L, active1, 0L, active2, 0L);
+      case 115:
+         if ((active1 & 0x2L) != 0L)
+            return jjStartNfaWithStates_0(3, 65, 32);
+         return jjMoveStringLiteralDfa4_0(active0, 0x8180000000L, active1, 0L, active2, 0L);
+      case 116:
+         return jjMoveStringLiteralDfa4_0(active0, 0xa201000201000000L, active1, 0L, active2, 0L);
+      case 117:
+         return jjMoveStringLiteralDfa4_0(active0, 0x800000000000000L, active1, 0L, active2, 0L);
+      case 118:
+         return jjMoveStringLiteralDfa4_0(active0, 0x100000000000000L, active1, 0L, active2, 0L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(2, active0, active1, active2);
+}
+private int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1, long old2, long active2)
+{
+   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
+      return jjStartNfa_0(2, old0, old1, old2); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(3, active0, active1, active2);
+      return 4;
+   }
+   switch(curChar)
+   {
+      case 65:
+         return jjMoveStringLiteralDfa5_0(active0, 0x2L, active1, 0L, active2, 0L);
+      case 67:
+         return jjMoveStringLiteralDfa5_0(active0, 0x20L, active1, 0L, active2, 0L);
+      case 69:
+         return jjMoveStringLiteralDfa5_0(active0, 0x18L, active1, 0L, active2, 0L);
+      case 73:
+         return jjMoveStringLiteralDfa5_0(active0, 0x80L, active1, 0L, active2, 0L);
+      case 78:
+         if ((active0 & 0x40L) != 0L)
+         {
+            jjmatchedKind = 6;
+            jjmatchedPos = 4;
+         }
+         return jjMoveStringLiteralDfa5_0(active0, 0x400L, active1, 0L, active2, 0L);
+      case 82:
+         return jjMoveStringLiteralDfa5_0(active0, 0x4L, active1, 0L, active2, 0L);
+      case 97:
+         return jjMoveStringLiteralDfa5_0(active0, 0x181000000000000L, active1, 0L, active2, 0L);
+      case 99:
+         return jjMoveStringLiteralDfa5_0(active0, 0x8000000000000000L, active1, 0L, active2, 0x2L);
+      case 101:
+         if ((active0 & 0x8000000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 39, 32);
+         else if ((active1 & 0x200L) != 0L)
+            return jjStartNfaWithStates_0(4, 73, 32);
+         return jjMoveStringLiteralDfa5_0(active0, 0x200400002000000L, active1, 0L, active2, 0L);
+      case 104:
+         if ((active0 & 0x20000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 29, 32);
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x1L, active2, 0L);
+      case 105:
+         return jjMoveStringLiteralDfa5_0(active0, 0x2400000200000000L, active1, 0L, active2, 0L);
+      case 107:
+         if ((active0 & 0x4000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 26, 32);
+         break;
+      case 108:
+         if ((active0 & 0x10000000000L) != 0L)
+         {
+            jjmatchedKind = 40;
+            jjmatchedPos = 4;
+         }
+         return jjMoveStringLiteralDfa5_0(active0, 0x21000000000L, active1, 0L, active2, 0x10L);
+      case 110:
+         return jjMoveStringLiteralDfa5_0(active0, 0x4000000000L, active1, 0L, active2, 0x20L);
+      case 114:
+         if ((active0 & 0x4000000000000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 62, 32);
+         return jjMoveStringLiteralDfa5_0(active0, 0x804800001000000L, active1, 0L, active2, 0x400L);
+      case 115:
+         if ((active0 & 0x80000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 31, 32);
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x10L, active2, 0L);
+      case 116:
+         if ((active0 & 0x100000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 32, 32);
+         else if ((active0 & 0x40000000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 42, 32);
+         else if ((active0 & 0x1000000000000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 60, 32);
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x100L, active2, 0L);
+      case 117:
+         return jjMoveStringLiteralDfa5_0(active0, 0x400000000L, active1, 0L, active2, 0L);
+      case 118:
+         return jjMoveStringLiteralDfa5_0(active0, 0x10000000000000L, active1, 0L, active2, 0L);
+      case 119:
+         if ((active1 & 0x4L) != 0L)
+         {
+            jjmatchedKind = 66;
+            jjmatchedPos = 4;
+         }
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x8L, active2, 0L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(3, active0, active1, active2);
+}
+private int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1, long old2, long active2)
+{
+   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
+      return jjStartNfa_0(3, old0, old1, old2); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(4, active0, active1, active2);
+      return 5;
+   }
+   switch(curChar)
+   {
+      case 65:
+         return jjMoveStringLiteralDfa6_0(active0, 0x80L, active1, 0L, active2, 0L);
+      case 69:
+         return jjMoveStringLiteralDfa6_0(active0, 0x4L, active1, 0L, active2, 0L);
+      case 72:
+         return jjMoveStringLiteralDfa6_0(active0, 0x2L, active1, 0L, active2, 0L);
+      case 79:
+         return jjMoveStringLiteralDfa6_0(active0, 0x20L, active1, 0L, active2, 0L);
+      case 82:
+         return jjMoveStringLiteralDfa6_0(active0, 0x18L, active1, 0L, active2, 0L);
+      case 95:
+         return jjMoveStringLiteralDfa6_0(active0, 0x400L, active1, 0L, active2, 0L);
+      case 97:
+         return jjMoveStringLiteralDfa6_0(active0, 0x3000000L, active1, 0L, active2, 0x30L);
+      case 99:
+         if ((active0 & 0x400000000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 58, 32);
+         else if ((active0 & 0x2000000000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 61, 32);
+         return jjMoveStringLiteralDfa6_0(active0, 0x200000000000000L, active1, 0L, active2, 0L);
+      case 100:
+         return jjMoveStringLiteralDfa6_0(active0, 0x4000000000L, active1, 0L, active2, 0L);
+      case 101:
+         if ((active0 & 0x1000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 36, 32);
+         else if ((active0 & 0x10000000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 52, 32);
+         break;
+      case 102:
+         return jjMoveStringLiteralDfa6_0(active0, 0x4000000000000L, active1, 0L, active2, 0L);
+      case 103:
+         return jjMoveStringLiteralDfa6_0(active0, 0x80000000000000L, active1, 0L, active2, 0L);
+      case 104:
+         if ((active0 & 0x8000000000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 63, 32);
+         break;
+      case 105:
+         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x110L, active2, 0L);
+      case 108:
+         return jjMoveStringLiteralDfa6_0(active0, 0x20400000000L, active1, 0L, active2, 0L);
+      case 109:
+         return jjMoveStringLiteralDfa6_0(active0, 0x400000000000L, active1, 0L, active2, 0L);
+      case 110:
+         if ((active0 & 0x800000000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 59, 32);
+         return jjMoveStringLiteralDfa6_0(active0, 0x1000200000000L, active1, 0L, active2, 0L);
+      case 114:
+         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x1L, active2, 0L);
+      case 115:
+         if ((active1 & 0x8L) != 0L)
+            return jjStartNfaWithStates_0(5, 67, 32);
+         break;
+      case 116:
+         if ((active0 & 0x800000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 47, 32);
+         else if ((active2 & 0x400L) != 0L)
+            return jjStartNfaWithStates_0(5, 138, 32);
+         return jjMoveStringLiteralDfa6_0(active0, 0x100000000000000L, active1, 0L, active2, 0x2L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(4, active0, active1, active2);
+}
+private int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1, long old2, long active2)
+{
+   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
+      return jjStartNfa_0(4, old0, old1, old2); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(5, active0, active1, active2);
+      return 6;
+   }
+   switch(curChar)
+   {
+      case 68:
+         return jjMoveStringLiteralDfa7_0(active0, 0x20L, active1, 0L, active2, 0L);
+      case 69:
+         return jjMoveStringLiteralDfa7_0(active0, 0x2L, active1, 0L, active2, 0L);
+      case 76:
+         return jjMoveStringLiteralDfa7_0(active0, 0x80L, active1, 0L, active2, 0L);
+      case 77:
+         return jjMoveStringLiteralDfa7_0(active0, 0x400L, active1, 0L, active2, 0L);
+      case 95:
+         return jjMoveStringLiteralDfa7_0(active0, 0x1cL, active1, 0L, active2, 0L);
+      case 97:
+         return jjMoveStringLiteralDfa7_0(active0, 0x4000000000000L, active1, 0L, active2, 0L);
+      case 99:
+         return jjMoveStringLiteralDfa7_0(active0, 0x1000001000000L, active1, 0L, active2, 0L);
+      case 101:
+         if ((active0 & 0x80000000000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 55, 32);
+         else if ((active0 & 0x100000000000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 56, 32);
+         return jjMoveStringLiteralDfa7_0(active0, 0x400000000000L, active1, 0x10L, active2, 0L);
+      case 102:
+         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0L, active2, 0x2L);
+      case 108:
+         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x100L, active2, 0L);
+      case 109:
+         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0L, active2, 0x20L);
+      case 110:
+         if ((active0 & 0x2000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 25, 32);
+         break;
+      case 111:
+         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x1L, active2, 0L);
+      case 115:
+         if ((active0 & 0x4000000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 38, 32);
+         break;
+      case 116:
+         if ((active0 & 0x400000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 34, 32);
+         return jjMoveStringLiteralDfa7_0(active0, 0x200000000000000L, active1, 0L, active2, 0x10L);
+      case 117:
+         return jjMoveStringLiteralDfa7_0(active0, 0x200000000L, active1, 0L, active2, 0L);
+      case 121:
+         if ((active0 & 0x20000000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 41, 32);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(5, active0, active1, active2);
+}
+private int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1, long old2, long active2)
+{
+   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
+      return jjStartNfa_0(5, old0, old1, old2); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(6, active0, active1, active2);
+      return 7;
+   }
+   switch(curChar)
+   {
+      case 65:
+         return jjMoveStringLiteralDfa8_0(active0, 0x2L, active1, 0L, active2, 0L);
+      case 66:
+         return jjMoveStringLiteralDfa8_0(active0, 0x8L, active1, 0L, active2, 0L);
+      case 67:
+         return jjMoveStringLiteralDfa8_0(active0, 0x4L, active1, 0L, active2, 0L);
+      case 69:
+         if ((active0 & 0x20L) != 0L)
+            return jjStartNfaWithStates_0(7, 5, 32);
+         return jjMoveStringLiteralDfa8_0(active0, 0x10L, active1, 0L, active2, 0L);
+      case 71:
+         return jjMoveStringLiteralDfa8_0(active0, 0x400L, active1, 0L, active2, 0L);
+      case 95:
+         return jjMoveStringLiteralDfa8_0(active0, 0x80L, active1, 0L, active2, 0L);
+      case 99:
+         return jjMoveStringLiteralDfa8_0(active0, 0x4000000000000L, active1, 0L, active2, 0L);
+      case 101:
+         if ((active0 & 0x200000000L) != 0L)
+            return jjStartNfaWithStates_0(7, 33, 32);
+         else if ((active1 & 0x100L) != 0L)
+            return jjStartNfaWithStates_0(7, 72, 32);
+         else if ((active2 & 0x10L) != 0L)
+            return jjStartNfaWithStates_0(7, 132, 32);
+         else if ((active2 & 0x20L) != 0L)
+            return jjStartNfaWithStates_0(7, 133, 32);
+         return jjMoveStringLiteralDfa8_0(active0, 0x201000000000000L, active1, 0L, active2, 0L);
+      case 110:
+         return jjMoveStringLiteralDfa8_0(active0, 0x400000000000L, active1, 0x11L, active2, 0L);
+      case 112:
+         if ((active2 & 0x2L) != 0L)
+            return jjStartNfaWithStates_0(7, 129, 32);
+         break;
+      case 116:
+         if ((active0 & 0x1000000L) != 0L)
+            return jjStartNfaWithStates_0(7, 24, 32);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(6, active0, active1, active2);
+}
+private int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1, long old2, long active2)
+{
+   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
+      return jjStartNfa_0(6, old0, old1, old2); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(7, active0, active1, 0L);
+      return 8;
+   }
+   switch(curChar)
+   {
+      case 65:
+         return jjMoveStringLiteralDfa9_0(active0, 0x4L, active1, 0L);
+      case 68:
+         if ((active0 & 0x2L) != 0L)
+            return jjStartNfaWithStates_0(8, 1, 32);
+         break;
+      case 69:
+         return jjMoveStringLiteralDfa9_0(active0, 0x8L, active1, 0L);
+      case 78:
+         return jjMoveStringLiteralDfa9_0(active0, 0x10L, active1, 0L);
+      case 82:
+         return jjMoveStringLiteralDfa9_0(active0, 0x400L, active1, 0L);
+      case 84:
+         return jjMoveStringLiteralDfa9_0(active0, 0x80L, active1, 0L);
+      case 100:
+         if ((active0 & 0x200000000000000L) != 0L)
+            return jjStartNfaWithStates_0(8, 57, 32);
+         break;
+      case 101:
+         if ((active0 & 0x4000000000000L) != 0L)
+            return jjStartNfaWithStates_0(8, 50, 32);
+         break;
+      case 105:
+         return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x1L);
+      case 111:
+         return jjMoveStringLiteralDfa9_0(active0, 0x1000000000000L, active1, 0L);
+      case 116:
+         if ((active1 & 0x10L) != 0L)
+            return jjStartNfaWithStates_0(8, 68, 32);
+         return jjMoveStringLiteralDfa9_0(active0, 0x400000000000L, active1, 0L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(7, active0, active1, 0L);
+}
+private int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1)
+{
+   if (((active0 &= old0) | (active1 &= old1)) == 0L)
+      return jjStartNfa_0(7, old0, old1, 0L);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(8, active0, active1, 0L);
+      return 9;
+   }
+   switch(curChar)
+   {
+      case 68:
+         if ((active0 & 0x10L) != 0L)
+            return jjStartNfaWithStates_0(9, 4, 32);
+         break;
+      case 71:
+         return jjMoveStringLiteralDfa10_0(active0, 0x8L, active1, 0L);
+      case 79:
+         return jjMoveStringLiteralDfa10_0(active0, 0x80L, active1, 0L);
+      case 83:
+         return jjMoveStringLiteralDfa10_0(active0, 0x4L, active1, 0L);
+      case 95:
+         return jjMoveStringLiteralDfa10_0(active0, 0x400L, active1, 0L);
+      case 102:
+         if ((active0 & 0x1000000000000L) != 0L)
+            return jjStartNfaWithStates_0(9, 48, 32);
+         break;
+      case 115:
+         if ((active0 & 0x400000000000L) != 0L)
+            return jjStartNfaWithStates_0(9, 46, 32);
+         break;
+      case 122:
+         return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x1L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(8, active0, active1, 0L);
+}
+private int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1)
+{
+   if (((active0 &= old0) | (active1 &= old1)) == 0L)
+      return jjStartNfa_0(8, old0, old1, 0L);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(9, active0, active1, 0L);
+      return 10;
+   }
+   switch(curChar)
+   {
+      case 68:
+         return jjMoveStringLiteralDfa11_0(active0, 0x400L, active1, 0L);
+      case 69:
+         if ((active0 & 0x4L) != 0L)
+            return jjStartNfaWithStates_0(10, 2, 32);
+         break;
+      case 73:
+         return jjMoveStringLiteralDfa11_0(active0, 0x8L, active1, 0L);
+      case 75:
+         return jjMoveStringLiteralDfa11_0(active0, 0x80L, active1, 0L);
+      case 101:
+         return jjMoveStringLiteralDfa11_0(active0, 0L, active1, 0x1L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(9, active0, active1, 0L);
+}
+private int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1)
+{
+   if (((active0 &= old0) | (active1 &= old1)) == 0L)
+      return jjStartNfa_0(9, old0, old1, 0L);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(10, active0, active1, 0L);
+      return 11;
+   }
+   switch(curChar)
+   {
+      case 69:
+         return jjMoveStringLiteralDfa12_0(active0, 0x480L, active1, 0L);
+      case 78:
+         if ((active0 & 0x8L) != 0L)
+            return jjStartNfaWithStates_0(11, 3, 32);
+         break;
+      case 100:
+         if ((active1 & 0x1L) != 0L)
+            return jjStartNfaWithStates_0(11, 64, 32);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(10, active0, active1, 0L);
+}
+private int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1)
+{
+   if (((active0 &= old0) | (active1 &= old1)) == 0L)
+      return jjStartNfa_0(10, old0, old1, 0L);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(11, active0, 0L, 0L);
+      return 12;
+   }
+   switch(curChar)
+   {
+      case 67:
+         return jjMoveStringLiteralDfa13_0(active0, 0x400L);
+      case 78:
+         if ((active0 & 0x80L) != 0L)
+            return jjStartNfaWithStates_0(12, 7, 32);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(11, active0, 0L, 0L);
+}
+private int jjMoveStringLiteralDfa13_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(11, old0, 0L, 0L);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(12, active0, 0L, 0L);
+      return 13;
+   }
+   switch(curChar)
+   {
+      case 76:
+         return jjMoveStringLiteralDfa14_0(active0, 0x400L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(12, active0, 0L, 0L);
+}
+private int jjMoveStringLiteralDfa14_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(12, old0, 0L, 0L);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(13, active0, 0L, 0L);
+      return 14;
+   }
+   switch(curChar)
+   {
+      case 83:
+         if ((active0 & 0x400L) != 0L)
+            return jjStartNfaWithStates_0(14, 10, 32);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(13, active0, 0L, 0L);
+}
+static final long[] jjbitVec0 = {
+   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+static final long[] jjbitVec2 = {
+   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+static final long[] jjbitVec3 = {
+   0xfff0000000200002L, 0xffffffffffffdfffL, 0xfffff00f7fffffffL, 0x12000000007fffffL
+};
+static final long[] jjbitVec4 = {
+   0x0L, 0x0L, 0x420043c00000000L, 0xff7fffffff7fffffL
+};
+static final long[] jjbitVec5 = {
+   0xffffcffffffffL, 0xffffffffffff0000L, 0xf9ff3fffffffffffL, 0x401f00030003L
+};
+static final long[] jjbitVec6 = {
+   0x0L, 0x400000000000000L, 0xfffffffbffffd740L, 0xffffffcff7fffL
+};
+static final long[] jjbitVec7 = {
+   0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffffff003L, 0x33fffffffff199fL
+};
+static final long[] jjbitVec8 = {
+   0xfffe000000000000L, 0xfffffffe027fffffL, 0xffL, 0x707ffffff0000L
+};
+static final long[] jjbitVec9 = {
+   0x7fffffe00000000L, 0xfffe0000000007ffL, 0xffffffffffffffffL, 0x1c000060002fffffL
+};
+static final long[] jjbitVec10 = {
+   0x1ffffffd0000L, 0x0L, 0x3fffffffffL, 0x0L
+};
+static final long[] jjbitVec11 = {
+   0x23ffffffffffffe0L, 0x3ff010000L, 0x3c5fdfffff99fe0L, 0xf0003b0000000L
+};
+static final long[] jjbitVec12 = {
+   0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100010000L
+};
+static final long[] jjbitVec13 = {
+   0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L
+};
+static final long[] jjbitVec14 = {
+   0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L
+};
+static final long[] jjbitVec15 = {
+   0x3fffdfffffddfe0L, 0x300000000L, 0x2ffbfffffc7fffe0L, 0x7fL
+};
+static final long[] jjbitVec16 = {
+   0x800dfffffffffffeL, 0x7fL, 0x200decaefef02596L, 0x3000005fL
+};
+static final long[] jjbitVec17 = {
+   0x1L, 0x7fffffffeffL, 0xf00L, 0x0L
+};
+static final long[] jjbitVec18 = {
+   0x6fbffffffffL, 0x3f0000L, 0xffffffff00000000L, 0x7fffffffff003fL
+};
+static final long[] jjbitVec19 = {
+   0xffffffffffffffffL, 0xffffffff83ffffffL, 0xffffff07ffffffffL, 0x3ffffffffffffffL
+};
+static final long[] jjbitVec20 = {
+   0xffffffffffffff7fL, 0xffffffff3d7f3d7fL, 0x7f3d7fffffff3d7fL, 0xffff7fffff7f7f3dL
+};
+static final long[] jjbitVec21 = {
+   0xffffffff7f3d7fffL, 0x7ffff7fL, 0xffffffff00000000L, 0x1fffffffffffffL
+};
+static final long[] jjbitVec22 = {
+   0xffffffffffffffffL, 0x7f9fffffffffffL, 0xffffffff07fffffeL, 0x7ffffffffffL
+};
+static final long[] jjbitVec23 = {
+   0x0L, 0x0L, 0xfffffffffffffL, 0x8000000L
+};
+static final long[] jjbitVec24 = {
+   0xffffffff00000000L, 0xffffffffffffffL, 0x1ffffffffffL, 0x0L
+};
+static final long[] jjbitVec25 = {
+   0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL
+};
+static final long[] jjbitVec26 = {
+   0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL
+};
+static final long[] jjbitVec27 = {
+   0x8000000000000000L, 0x8000000000000001L, 0xffff00000000L, 0x0L
+};
+static final long[] jjbitVec28 = {
+   0x3fbbd503e2ffc84L, 0xffffffff00000000L, 0xfL, 0x0L
+};
+static final long[] jjbitVec29 = {
+   0x73e03fe000000e0L, 0xfffffffffffffffeL, 0xfffffffe601fffffL, 0x7fffffffffffffffL
+};
+static final long[] jjbitVec30 = {
+   0xfffe1fffffffffe0L, 0xffffffffffffffffL, 0xffffff00007fffL, 0x0L
+};
+static final long[] jjbitVec31 = {
+   0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffffffL, 0x0L
+};
+static final long[] jjbitVec32 = {
+   0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L
+};
+static final long[] jjbitVec33 = {
+   0xffffffffffffffffL, 0xffffffffffffffffL, 0x1fffL, 0x0L
+};
+static final long[] jjbitVec34 = {
+   0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L
+};
+static final long[] jjbitVec35 = {
+   0x3fffffffffffL, 0x0L, 0x0L, 0x0L
+};
+static final long[] jjbitVec36 = {
+   0x5f7ffdffa0f8007fL, 0xffffffffffffffdbL, 0x3ffffffffffffL, 0xfffffffffff80000L
+};
+static final long[] jjbitVec37 = {
+   0x3fffffffffffffffL, 0xffffffffffff0000L, 0xfffffffffffcffffL, 0xfff0000000000ffL
+};
+static final long[] jjbitVec38 = {
+   0x18000000000000L, 0xffd702000000e000L, 0xffffffffffffffffL, 0x1fffffffffffffffL
+};
+static final long[] jjbitVec39 = {
+   0x87fffffe00000010L, 0xffffffe007fffffeL, 0x7fffffffffffffffL, 0x631cfcfcfcL
+};
+static final long[] jjbitVec40 = {
+   0x0L, 0x0L, 0x420043cffffffffL, 0xff7fffffff7fffffL
+};
+static final long[] jjbitVec41 = {
+   0xffffffffffffffffL, 0x400000700007fffL, 0xfffffffbffffd740L, 0xffffffcff7fffL
+};
+static final long[] jjbitVec42 = {
+   0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffffff07bL, 0x33fffffffff199fL
+};
+static final long[] jjbitVec43 = {
+   0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe00ffL, 0x707ffffff0016L
+};
+static final long[] jjbitVec44 = {
+   0x7fffffe00000000L, 0xffff03ff003fffffL, 0xffffffffffffffffL, 0x1fff3dff9fefffffL
+};
+static final long[] jjbitVec45 = {
+   0xffff1fffffff8000L, 0x7ffL, 0x1ffffffffffffL, 0x0L
+};
+static final long[] jjbitVec46 = {
+   0xf3ffffffffffffeeL, 0xffcfff1f3fffL, 0xd3c5fdfffff99feeL, 0xfffcfb080399fL
+};
+static final long[] jjbitVec47 = {
+   0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100013bbfL
+};
+static final long[] jjbitVec48 = {
+   0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L
+};
+static final long[] jjbitVec49 = {
+   0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL
+};
+static final long[] jjbitVec50 = {
+   0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x2ffbfffffc7fffecL, 0xc0000ff5f847fL
+};
+static final long[] jjbitVec51 = {
+   0x87fffffffffffffeL, 0x3ff7fffL, 0x3bffecaefef02596L, 0x33ff3f5fL
+};
+static final long[] jjbitVec52 = {
+   0xc2a003ff03000001L, 0xfffe07fffffffeffL, 0x1ffffffffeff0fdfL, 0x40L
+};
+static final long[] jjbitVec53 = {
+   0x3c7f6fbffffffffL, 0x3ff03ffL, 0xffffffff00000000L, 0x7fffffffff003fL
+};
+static final long[] jjbitVec54 = {
+   0xffffffff7f3d7fffL, 0x3fe0007ffff7fL, 0xffffffff00000000L, 0x1fffffffffffffL
+};
+static final long[] jjbitVec55 = {
+   0x0L, 0x0L, 0xffffffffffffffffL, 0x3ff080fffffL
+};
+static final long[] jjbitVec56 = {
+   0xffffffff03ff7800L, 0xffffffffffffffL, 0x3ffffffffffL, 0x0L
+};
+static final long[] jjbitVec57 = {
+   0x80007c000000f000L, 0x8000fc0000000001L, 0xffff00000000L, 0x21fff0000L
+};
+static final long[] jjbitVec58 = {
+   0x73efffe000000e0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x7fffffffffffffffL
+};
+static final long[] jjbitVec59 = {
+   0x5f7ffdffe0f8007fL, 0xffffffffffffffdbL, 0x3ffffffffffffL, 0xfffffffffff80000L
+};
+static final long[] jjbitVec60 = {
+   0x18000f00000000L, 0xffd702000000e000L, 0xffffffffffffffffL, 0x9fffffffffffffffL
+};
+static final long[] jjbitVec61 = {
+   0x87fffffe03ff0010L, 0xffffffe007fffffeL, 0x7fffffffffffffffL, 0xe0000631cfcfcfcL
+};
+private int jjMoveNfa_0(int startState, int curPos)
+{
+   //int[] nextStates; // not used
+   int startsAt = 0;
+   jjnewStateCnt = 65;
+   int i = 1;
+   jjstateSet[0] = startState;
+   //int j; // not used
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 3:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddStates(0, 6);
+                  else if (curChar == 36)
+                  {
+                     if (kind > 140)
+                        kind = 140;
+                     jjCheckNAdd(32);
+                  }
+                  else if (curChar == 34)
+                     jjCheckNAddStates(7, 9);
+                  else if (curChar == 39)
+                     jjAddStates(10, 11);
+                  else if (curChar == 46)
+                     jjCheckNAdd(8);
+                  else if (curChar == 47)
+                     jjstateSet[jjnewStateCnt++] = 2;
+                  if ((0x3fe000000000000L & l) != 0L)
+                  {
+                     if (kind > 74)
+                        kind = 74;
+                     jjCheckNAddTwoStates(5, 6);
+                  }
+                  else if (curChar == 48)
+                  {
+                     if (kind > 74)
+                        kind = 74;
+                     jjCheckNAddStates(12, 16);
+                  }
+                  break;
+               case 0:
+                  if (curChar == 42)
+                     jjstateSet[jjnewStateCnt++] = 1;
+                  break;
+               case 1:
+                  if ((0xffff7fffffffffffL & l) != 0L && kind > 18)
+                     kind = 18;
+                  break;
+               case 2:
+                  if (curChar == 42)
+                     jjstateSet[jjnewStateCnt++] = 0;
+                  break;
+               case 4:
+                  if ((0x3fe000000000000L & l) == 0L)
+                     break;
+                  if (kind > 74)
+                     kind = 74;
+                  jjCheckNAddTwoStates(5, 6);
+                  break;
+               case 5:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 74)
+                     kind = 74;
+                  jjCheckNAddTwoStates(5, 6);
+                  break;
+               case 7:
+                  if (curChar == 46)
+                     jjCheckNAdd(8);
+                  break;
+               case 8:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 78)
+                     kind = 78;
+                  jjCheckNAddStates(17, 19);
+                  break;
+               case 10:
+                  if ((0x280000000000L & l) != 0L)
+                     jjCheckNAdd(11);
+                  break;
+               case 11:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 78)
+                     kind = 78;
+                  jjCheckNAddTwoStates(11, 12);
+                  break;
+               case 13:
+                  if (curChar == 39)
+                     jjAddStates(10, 11);
+                  break;
+               case 14:
+                  if ((0xffffff7fffffdbffL & l) != 0L)
+                     jjCheckNAdd(15);
+                  break;
+               case 15:
+                  if (curChar == 39 && kind > 83)
+                     kind = 83;
+                  break;
+               case 17:
+                  if ((0x8400000000L & l) != 0L)
+                     jjCheckNAdd(15);
+                  break;
+               case 18:
+                  if ((0xff000000000000L & l) != 0L)
+                     jjCheckNAddTwoStates(19, 15);
+                  break;
+               case 19:
+                  if ((0xff000000000000L & l) != 0L)
+                     jjCheckNAdd(15);
+                  break;
+               case 20:
+                  if ((0xf000000000000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 21;
+                  break;
+               case 21:
+                  if ((0xff000000000000L & l) != 0L)
+                     jjCheckNAdd(19);
+                  break;
+               case 22:
+                  if (curChar == 34)
+                     jjCheckNAddStates(7, 9);
+                  break;
+               case 23:
+                  if ((0xfffffffbffffdbffL & l) != 0L)
+                     jjCheckNAddStates(7, 9);
+                  break;
+               case 25:
+                  if ((0x8400000000L & l) != 0L)
+                     jjCheckNAddStates(7, 9);
+                  break;
+               case 26:
+                  if (curChar == 34 && kind > 84)
+                     kind = 84;
+                  break;
+               case 27:
+                  if ((0xff000000000000L & l) != 0L)
+                     jjCheckNAddStates(20, 23);
+                  break;
+               case 28:
+                  if ((0xff000000000000L & l) != 0L)
+                     jjCheckNAddStates(7, 9);
+                  break;
+               case 29:
+                  if ((0xf000000000000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 30;
+                  break;
+               case 30:
+                  if ((0xff000000000000L & l) != 0L)
+                     jjCheckNAdd(28);
+                  break;
+               case 31:
+                  if (curChar != 36)
+                     break;
+                  if (kind > 140)
+                     kind = 140;
+                  jjCheckNAdd(32);
+                  break;
+               case 32:
+                  if ((0x3ff00100fffc1ffL & l) == 0L)
+                     break;
+                  if (kind > 140)
+                     kind = 140;
+                  jjCheckNAdd(32);
+                  break;
+               case 33:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddStates(0, 6);
+                  break;
+               case 34:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddStates(24, 26);
+                  break;
+               case 36:
+                  if ((0x280000000000L & l) != 0L)
+                     jjCheckNAdd(37);
+                  break;
+               case 37:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddTwoStates(37, 12);
+                  break;
+               case 38:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddTwoStates(38, 39);
+                  break;
+               case 40:
+                  if ((0x280000000000L & l) != 0L)
+                     jjCheckNAdd(41);
+                  break;
+               case 41:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 78)
+                     kind = 78;
+                  jjCheckNAddTwoStates(41, 12);
+                  break;
+               case 42:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddTwoStates(42, 43);
+                  break;
+               case 43:
+                  if (curChar != 46)
+                     break;
+                  if (kind > 78)
+                     kind = 78;
+                  jjCheckNAddStates(27, 29);
+                  break;
+               case 44:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 78)
+                     kind = 78;
+                  jjCheckNAddStates(27, 29);
+                  break;
+               case 46:
+                  if ((0x280000000000L & l) != 0L)
+                     jjCheckNAdd(47);
+                  break;
+               case 47:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 78)
+                     kind = 78;
+                  jjCheckNAddTwoStates(47, 12);
+                  break;
+               case 48:
+                  if (curChar != 48)
+                     break;
+                  if (kind > 74)
+                     kind = 74;
+                  jjCheckNAddStates(12, 16);
+                  break;
+               case 50:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 74)
+                     kind = 74;
+                  jjCheckNAddTwoStates(50, 6);
+                  break;
+               case 51:
+                  if ((0xff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 74)
+                     kind = 74;
+                  jjCheckNAddTwoStates(51, 6);
+                  break;
+               case 53:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjAddStates(30, 31);
+                  break;
+               case 54:
+                  if (curChar == 46)
+                     jjCheckNAdd(55);
+                  break;
+               case 55:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddTwoStates(55, 56);
+                  break;
+               case 57:
+                  if ((0x280000000000L & l) != 0L)
+                     jjCheckNAdd(58);
+                  break;
+               case 58:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 78)
+                     kind = 78;
+                  jjCheckNAddTwoStates(58, 12);
+                  break;
+               case 60:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddStates(32, 34);
+                  break;
+               case 61:
+                  if (curChar == 46)
+                     jjCheckNAdd(62);
+                  break;
+               case 63:
+                  if ((0x280000000000L & l) != 0L)
+                     jjCheckNAdd(64);
+                  break;
+               case 64:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 78)
+                     kind = 78;
+                  jjCheckNAddTwoStates(64, 12);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 3:
+                  if ((0x7fffffe87fffffeL & l) == 0L)
+                     break;
+                  if (kind > 140)
+                     kind = 140;
+                  jjCheckNAdd(32);
+                  break;
+               case 1:
+                  if (kind > 18)
+                     kind = 18;
+                  break;
+               case 6:
+                  if ((0x100000001000L & l) != 0L && kind > 74)
+                     kind = 74;
+                  break;
+               case 9:
+                  if ((0x2000000020L & l) != 0L)
+                     jjAddStates(35, 36);
+                  break;
+               case 12:
+                  if ((0x5000000050L & l) != 0L && kind > 78)
+                     kind = 78;
+                  break;
+               case 14:
+                  if ((0xffffffffefffffffL & l) != 0L)
+                     jjCheckNAdd(15);
+                  break;
+               case 16:
+                  if (curChar == 92)
+                     jjAddStates(37, 39);
+                  break;
+               case 17:
+                  if ((0x14404410000000L & l) != 0L)
+                     jjCheckNAdd(15);
+                  break;
+               case 23:
+                  if ((0xffffffffefffffffL & l) != 0L)
+                     jjCheckNAddStates(7, 9);
+                  break;
+               case 24:
+                  if (curChar == 92)
+                     jjAddStates(40, 42);
+                  break;
+               case 25:
+                  if ((0x14404410000000L & l) != 0L)
+                     jjCheckNAddStates(7, 9);
+                  break;
+               case 32:
+                  if ((0x87fffffe87fffffeL & l) == 0L)
+                     break;
+                  if (kind > 140)
+                     kind = 140;
+                  jjCheckNAdd(32);
+                  break;
+               case 35:
+                  if ((0x2000000020L & l) != 0L)
+                     jjAddStates(43, 44);
+                  break;
+               case 39:
+                  if ((0x2000000020L & l) != 0L)
+                     jjAddStates(45, 46);
+                  break;
+               case 45:
+                  if ((0x2000000020L & l) != 0L)
+                     jjAddStates(47, 48);
+                  break;
+               case 49:
+                  if ((0x100000001000000L & l) != 0L)
+                     jjCheckNAdd(50);
+                  break;
+               case 50:
+                  if ((0x7e0000007eL & l) == 0L)
+                     break;
+                  if (kind > 74)
+                     kind = 74;
+                  jjCheckNAddTwoStates(50, 6);
+                  break;
+               case 52:
+                  if ((0x100000001000000L & l) != 0L)
+                     jjCheckNAddTwoStates(53, 54);
+                  break;
+               case 53:
+                  if ((0x7e0000007eL & l) != 0L)
+                     jjCheckNAddTwoStates(53, 54);
+                  break;
+               case 55:
+                  if ((0x7e0000007eL & l) != 0L)
+                     jjAddStates(49, 50);
+                  break;
+               case 56:
+                  if ((0x1000000010000L & l) != 0L)
+                     jjAddStates(51, 52);
+                  break;
+               case 59:
+                  if ((0x100000001000000L & l) != 0L)
+                     jjCheckNAdd(60);
+                  break;
+               case 60:
+                  if ((0x7e0000007eL & l) != 0L)
+                     jjCheckNAddStates(32, 34);
+                  break;
+               case 62:
+                  if ((0x1000000010000L & l) != 0L)
+                     jjAddStates(53, 54);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 3:
+                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 140)
+                     kind = 140;
+                  jjCheckNAdd(32);
+                  break;
+               case 1:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 18)
+                     kind = 18;
+                  break;
+               case 14:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjstateSet[jjnewStateCnt++] = 15;
+                  break;
+               case 23:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjAddStates(7, 9);
+                  break;
+               case 32:
+                  if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 140)
+                     kind = 140;
+                  jjCheckNAdd(32);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 65 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private int jjMoveStringLiteralDfa0_3()
+{
+   switch(curChar)
+   {
+      case 42:
+         return jjMoveStringLiteralDfa1_3(0x400000L);
+      default :
+         return 1;
+   }
+}
+private int jjMoveStringLiteralDfa1_3(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 47:
+         if ((active0 & 0x400000L) != 0L)
+            return jjStopAtPos(1, 22);
+         break;
+      default :
+         return 2;
+   }
+   return 2;
+}
+private int jjMoveStringLiteralDfa0_1()
+{
+   return jjMoveNfa_1(0, 0);
+}
+private int jjMoveNfa_1(int startState, int curPos)
+{
+   //int[] nextStates; // not used
+   int startsAt = 0;
+   jjnewStateCnt = 3;
+   int i = 1;
+   jjstateSet[0] = startState;
+   //int j; // not used
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0x2400L & l) != 0L)
+                  {
+                     if (kind > 20)
+                        kind = 20;
+                  }
+                  if (curChar == 13)
+                     jjstateSet[jjnewStateCnt++] = 1;
+                  break;
+               case 1:
+                  if (curChar == 10 && kind > 20)
+                     kind = 20;
+                  break;
+               case 2:
+                  if (curChar == 13)
+                     jjstateSet[jjnewStateCnt++] = 1;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 3 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private int jjMoveStringLiteralDfa0_2()
+{
+   switch(curChar)
+   {
+      case 42:
+         return jjMoveStringLiteralDfa1_2(0x200000L);
+      default :
+         return 1;
+   }
+}
+private int jjMoveStringLiteralDfa1_2(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 47:
+         if ((active0 & 0x200000L) != 0L)
+            return jjStopAtPos(1, 21);
+         break;
+      default :
+         return 2;
+   }
+   return 2;
+}
+static final int[] jjnextStates = {
+   34, 35, 12, 38, 39, 42, 43, 23, 24, 26, 14, 16, 49, 51, 6, 52, 
+   59, 8, 9, 12, 23, 24, 28, 26, 34, 35, 12, 44, 45, 12, 53, 54, 
+   60, 61, 62, 10, 11, 17, 18, 20, 25, 27, 29, 36, 37, 40, 41, 46, 
+   47, 55, 56, 57, 58, 63, 64, 
+};
+private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
+{
+   switch(hiByte)
+   {
+      case 0:
+         return ((jjbitVec2[i2] & l2) != 0L);
+      default : 
+         if ((jjbitVec0[i1] & l1) != 0L)
+            return true;
+         return false;
+   }
+}
+private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2)
+{
+   switch(hiByte)
+   {
+      case 0:
+         return ((jjbitVec4[i2] & l2) != 0L);
+      case 2:
+         return ((jjbitVec5[i2] & l2) != 0L);
+      case 3:
+         return ((jjbitVec6[i2] & l2) != 0L);
+      case 4:
+         return ((jjbitVec7[i2] & l2) != 0L);
+      case 5:
+         return ((jjbitVec8[i2] & l2) != 0L);
+      case 6:
+         return ((jjbitVec9[i2] & l2) != 0L);
+      case 7:
+         return ((jjbitVec10[i2] & l2) != 0L);
+      case 9:
+         return ((jjbitVec11[i2] & l2) != 0L);
+      case 10:
+         return ((jjbitVec12[i2] & l2) != 0L);
+      case 11:
+         return ((jjbitVec13[i2] & l2) != 0L);
+      case 12:
+         return ((jjbitVec14[i2] & l2) != 0L);
+      case 13:
+         return ((jjbitVec15[i2] & l2) != 0L);
+      case 14:
+         return ((jjbitVec16[i2] & l2) != 0L);
+      case 15:
+         return ((jjbitVec17[i2] & l2) != 0L);
+      case 16:
+         return ((jjbitVec18[i2] & l2) != 0L);
+      case 17:
+         return ((jjbitVec19[i2] & l2) != 0L);
+      case 18:
+         return ((jjbitVec20[i2] & l2) != 0L);
+      case 19:
+         return ((jjbitVec21[i2] & l2) != 0L);
+      case 20:
+         return ((jjbitVec0[i2] & l2) != 0L);
+      case 22:
+         return ((jjbitVec22[i2] & l2) != 0L);
+      case 23:
+         return ((jjbitVec23[i2] & l2) != 0L);
+      case 24:
+         return ((jjbitVec24[i2] & l2) != 0L);
+      case 30:
+         return ((jjbitVec25[i2] & l2) != 0L);
+      case 31:
+         return ((jjbitVec26[i2] & l2) != 0L);
+      case 32:
+         return ((jjbitVec27[i2] & l2) != 0L);
+      case 33:
+         return ((jjbitVec28[i2] & l2) != 0L);
+      case 48:
+         return ((jjbitVec29[i2] & l2) != 0L);
+      case 49:
+         return ((jjbitVec30[i2] & l2) != 0L);
+      case 77:
+         return ((jjbitVec31[i2] & l2) != 0L);
+      case 159:
+         return ((jjbitVec32[i2] & l2) != 0L);
+      case 164:
+         return ((jjbitVec33[i2] & l2) != 0L);
+      case 215:
+         return ((jjbitVec34[i2] & l2) != 0L);
+      case 250:
+         return ((jjbitVec35[i2] & l2) != 0L);
+      case 251:
+         return ((jjbitVec36[i2] & l2) != 0L);
+      case 253:
+         return ((jjbitVec37[i2] & l2) != 0L);
+      case 254:
+         return ((jjbitVec38[i2] & l2) != 0L);
+      case 255:
+         return ((jjbitVec39[i2] & l2) != 0L);
+      default : 
+         if ((jjbitVec3[i1] & l1) != 0L)
+            return true;
+         return false;
+   }
+}
+private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2)
+{
+   switch(hiByte)
+   {
+      case 0:
+         return ((jjbitVec40[i2] & l2) != 0L);
+      case 2:
+         return ((jjbitVec5[i2] & l2) != 0L);
+      case 3:
+         return ((jjbitVec41[i2] & l2) != 0L);
+      case 4:
+         return ((jjbitVec42[i2] & l2) != 0L);
+      case 5:
+         return ((jjbitVec43[i2] & l2) != 0L);
+      case 6:
+         return ((jjbitVec44[i2] & l2) != 0L);
+      case 7:
+         return ((jjbitVec45[i2] & l2) != 0L);
+      case 9:
+         return ((jjbitVec46[i2] & l2) != 0L);
+      case 10:
+         return ((jjbitVec47[i2] & l2) != 0L);
+      case 11:
+         return ((jjbitVec48[i2] & l2) != 0L);
+      case 12:
+         return ((jjbitVec49[i2] & l2) != 0L);
+      case 13:
+         return ((jjbitVec50[i2] & l2) != 0L);
+      case 14:
+         return ((jjbitVec51[i2] & l2) != 0L);
+      case 15:
+         return ((jjbitVec52[i2] & l2) != 0L);
+      case 16:
+         return ((jjbitVec53[i2] & l2) != 0L);
+      case 17:
+         return ((jjbitVec19[i2] & l2) != 0L);
+      case 18:
+         return ((jjbitVec20[i2] & l2) != 0L);
+      case 19:
+         return ((jjbitVec54[i2] & l2) != 0L);
+      case 20:
+         return ((jjbitVec0[i2] & l2) != 0L);
+      case 22:
+         return ((jjbitVec22[i2] & l2) != 0L);
+      case 23:
+         return ((jjbitVec55[i2] & l2) != 0L);
+      case 24:
+         return ((jjbitVec56[i2] & l2) != 0L);
+      case 30:
+         return ((jjbitVec25[i2] & l2) != 0L);
+      case 31:
+         return ((jjbitVec26[i2] & l2) != 0L);
+      case 32:
+         return ((jjbitVec57[i2] & l2) != 0L);
+      case 33:
+         return ((jjbitVec28[i2] & l2) != 0L);
+      case 48:
+         return ((jjbitVec58[i2] & l2) != 0L);
+      case 49:
+         return ((jjbitVec30[i2] & l2) != 0L);
+      case 77:
+         return ((jjbitVec31[i2] & l2) != 0L);
+      case 159:
+         return ((jjbitVec32[i2] & l2) != 0L);
+      case 164:
+         return ((jjbitVec33[i2] & l2) != 0L);
+      case 215:
+         return ((jjbitVec34[i2] & l2) != 0L);
+      case 250:
+         return ((jjbitVec35[i2] & l2) != 0L);
+      case 251:
+         return ((jjbitVec59[i2] & l2) != 0L);
+      case 253:
+         return ((jjbitVec37[i2] & l2) != 0L);
+      case 254:
+         return ((jjbitVec60[i2] & l2) != 0L);
+      case 255:
+         return ((jjbitVec61[i2] & l2) != 0L);
+      default : 
+         if ((jjbitVec3[i1] & l1) != 0L)
+            return true;
+         return false;
+   }
+}
+
+/** Token literal values. */
+public static final String[] jjstrLiteralImages = {
+"", "\114\117\117\113\101\110\105\101\104", 
+"\111\107\116\117\122\105\137\103\101\123\105", "\120\101\122\123\105\122\137\102\105\107\111\116", 
+"\120\101\122\123\105\122\137\105\116\104", "\112\101\126\101\103\117\104\105", "\124\117\113\105\116", 
+"\123\120\105\103\111\101\114\137\124\117\113\105\116", "\115\117\122\105", "\123\113\111\120", 
+"\124\117\113\105\116\137\115\107\122\137\104\105\103\114\123", "\105\117\106", null, null, null, null, null, null, null, null, null, null, 
+null, null, "\141\142\163\164\162\141\143\164", "\142\157\157\154\145\141\156", 
+"\142\162\145\141\153", "\142\171\164\145", "\143\141\163\145", "\143\141\164\143\150", 
+"\143\150\141\162", "\143\154\141\163\163", "\143\157\156\163\164", 
+"\143\157\156\164\151\156\165\145", "\144\145\146\141\165\154\164", "\144\157", "\144\157\165\142\154\145", 
+"\145\154\163\145", "\145\170\164\145\156\144\163", "\146\141\154\163\145", 
+"\146\151\156\141\154", "\146\151\156\141\154\154\171", "\146\154\157\141\164", "\146\157\162", 
+"\147\157\164\157", "\151\146", "\151\155\160\154\145\155\145\156\164\163", 
+"\151\155\160\157\162\164", "\151\156\163\164\141\156\143\145\157\146", "\151\156\164", 
+"\151\156\164\145\162\146\141\143\145", "\154\157\156\147", "\156\141\164\151\166\145", "\156\145\167", 
+"\156\165\154\154", "\160\141\143\153\141\147\145", "\160\162\151\166\141\164\145", 
+"\160\162\157\164\145\143\164\145\144", "\160\165\142\154\151\143", "\162\145\164\165\162\156", 
+"\163\150\157\162\164", "\163\164\141\164\151\143", "\163\165\160\145\162", 
+"\163\167\151\164\143\150", "\163\171\156\143\150\162\157\156\151\172\145\144", "\164\150\151\163", 
+"\164\150\162\157\167", "\164\150\162\157\167\163", "\164\162\141\156\163\151\145\156\164", 
+"\164\162\165\145", "\164\162\171", "\166\157\151\144", "\166\157\154\141\164\151\154\145", 
+"\167\150\151\154\145", null, null, null, null, null, null, null, null, null, null, null, "\50", 
+"\51", "\173", "\175", "\133", "\135", "\73", "\54", "\56", "\43", "\75", "\74", 
+"\41", "\176", "\77", "\72", "\72\72", "\75\75", "\74\75", "\76\75", "\41\75", 
+"\174\174", "\46\46", "\53\53", "\55\55", "\53", "\55", "\52", "\57", "\46", "\174", 
+"\136", "\45", "\53\75", "\55\75", "\52\75", "\57\75", "\46\75", "\174\75", "\136\75", 
+"\45\75", "\76\76\76", "\76\76", "\76", "\163\164\162\151\143\164\146\160", 
+"\145\156\165\155", "\56\56\56", "\164\145\155\160\154\141\164\145", 
+"\164\171\160\145\156\141\155\145", "\74\74\75", "\76\76\75", "\76\76\76\75", "\74\74", 
+"\141\163\163\145\162\164", "\100", null, null, null, };
+
+/** Lexer state names. */
+public static final String[] lexStateNames = {
+   "DEFAULT", 
+   "IN_SINGLE_LINE_COMMENT", 
+   "IN_FORMAL_COMMENT", 
+   "IN_MULTI_LINE_COMMENT", 
+};
+
+/** Lex State array. */
+public static final int[] jjnewLexState = {
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 3, 0, 0, 0, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+};
+static final long[] jjtoToken = {
+   0xffffffffff000fffL, 0xfffffffffff847ffL, 0x1fffL, 
+};
+static final long[] jjtoSkip = {
+   0x71f000L, 0x0L, 0x0L, 
+};
+static final long[] jjtoSpecial = {
+   0x71f000L, 0x0L, 0x0L, 
+};
+static final long[] jjtoMore = {
+   0x8e0000L, 0x0L, 0x0L, 
+};
+protected JavaCharStream input_stream;
+private final int[] jjrounds = new int[65];
+private final int[] jjstateSet = new int[130];
+StringBuffer image;
+int jjimageLen;
+int lengthOfMatch;
+protected char curChar;
+/** Constructor. */
+public JJTreeParserTokenManager(JavaCharStream stream){
+   if (JavaCharStream.staticFlag)
+      throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
+   input_stream = stream;
+}
+
+/** Constructor. */
+public JJTreeParserTokenManager(JavaCharStream stream, int lexState){
+   this(stream);
+   SwitchTo(lexState);
+}
+
+/** Reinitialise parser. */
+public void ReInit(JavaCharStream stream)
+{
+   jjmatchedPos = jjnewStateCnt = 0;
+   curLexState = defaultLexState;
+   input_stream = stream;
+   ReInitRounds();
+}
+private void ReInitRounds()
+{
+   int i;
+   jjround = 0x80000001;
+   for (i = 65; i-- > 0;)
+      jjrounds[i] = 0x80000000;
+}
+
+/** Reinitialise parser. */
+public void ReInit(JavaCharStream stream, int lexState)
+{
+   ReInit(stream);
+   SwitchTo(lexState);
+}
+
+/** Switch to specified lex state. */
+public void SwitchTo(int lexState)
+{
+   if (lexState >= 4 || lexState < 0)
+      throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
+   else
+      curLexState = lexState;
+}
+
+protected Token jjFillToken()
+{
+   final Token t;
+   final String tokenImage;
+   final int beginLine;
+   final int endLine;
+   final int beginColumn;
+   final int endColumn;
+   String im = jjstrLiteralImages[jjmatchedKind];
+   tokenImage = (im == null) ? input_stream.GetImage() : im;
+   beginLine = input_stream.getBeginLine();
+   beginColumn = input_stream.getBeginColumn();
+   endLine = input_stream.getEndLine();
+   endColumn = input_stream.getEndColumn();
+   t = Token.newToken(jjmatchedKind, tokenImage);
+
+   t.beginLine = beginLine;
+   t.endLine = endLine;
+   t.beginColumn = beginColumn;
+   t.endColumn = endColumn;
+
+   return t;
+}
+
+int curLexState = 0;
+int defaultLexState = 0;
+int jjnewStateCnt;
+int jjround;
+int jjmatchedPos;
+int jjmatchedKind;
+
+/** Get the next Token. */
+public Token getNextToken() 
+{
+  //int kind;
+  Token specialToken = null;
+  Token matchedToken;
+  int curPos = 0;
+
+  EOFLoop :
+  for (;;)
+  {   
+   try   
+   {     
+      curChar = input_stream.BeginToken();
+   }     
+   catch(java.io.IOException e)
+   {        
+      jjmatchedKind = 0;
+      matchedToken = jjFillToken();
+      matchedToken.specialToken = specialToken;
+      return matchedToken;
+   }
+   image = null;
+   jjimageLen = 0;
+
+   for (;;)
+   {
+     switch(curLexState)
+     {
+       case 0:
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_0();
+         break;
+       case 1:
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_1();
+         if (jjmatchedPos == 0 && jjmatchedKind > 23)
+         {
+            jjmatchedKind = 23;
+         }
+         break;
+       case 2:
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_2();
+         if (jjmatchedPos == 0 && jjmatchedKind > 23)
+         {
+            jjmatchedKind = 23;
+         }
+         break;
+       case 3:
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_3();
+         if (jjmatchedPos == 0 && jjmatchedKind > 23)
+         {
+            jjmatchedKind = 23;
+         }
+         break;
+     }
+     if (jjmatchedKind != 0x7fffffff)
+     {
+        if (jjmatchedPos + 1 < curPos)
+           input_stream.backup(curPos - jjmatchedPos - 1);
+        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+        {
+           matchedToken = jjFillToken();
+           matchedToken.specialToken = specialToken;
+           TokenLexicalActions(matchedToken);
+       if (jjnewLexState[jjmatchedKind] != -1)
+         curLexState = jjnewLexState[jjmatchedKind];
+           return matchedToken;
+        }
+        else if ((jjtoSkip[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+        {
+           if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+           {
+              matchedToken = jjFillToken();
+              if (specialToken == null)
+                 specialToken = matchedToken;
+              else
+              {
+                 matchedToken.specialToken = specialToken;
+                 specialToken = (specialToken.next = matchedToken);
+              }
+              SkipLexicalActions(matchedToken);
+           }
+           else 
+              SkipLexicalActions(null);
+         if (jjnewLexState[jjmatchedKind] != -1)
+           curLexState = jjnewLexState[jjmatchedKind];
+           continue EOFLoop;
+        }
+        MoreLexicalActions();
+      if (jjnewLexState[jjmatchedKind] != -1)
+        curLexState = jjnewLexState[jjmatchedKind];
+        curPos = 0;
+        jjmatchedKind = 0x7fffffff;
+        try {
+           curChar = input_stream.readChar();
+           continue;
+        }
+        catch (java.io.IOException e1) { }
+     }
+     int error_line = input_stream.getEndLine();
+     int error_column = input_stream.getEndColumn();
+     String error_after = null;
+     boolean EOFSeen = false;
+     try { input_stream.readChar(); input_stream.backup(1); }
+     catch (java.io.IOException e1) {
+        EOFSeen = true;
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+        if (curChar == '\n' || curChar == '\r') {
+           error_line++;
+           error_column = 0;
+        }
+        else
+           error_column++;
+     }
+     if (!EOFSeen) {
+        input_stream.backup(1);
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+     }
+     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
+   }
+  }
+}
+
+void SkipLexicalActions(Token matchedToken)
+{
+   switch(jjmatchedKind)
+   {
+      default :
+         break;
+   }
+}
+void MoreLexicalActions()
+{
+   jjimageLen += (lengthOfMatch = jjmatchedPos + 1);
+   switch(jjmatchedKind)
+   {
+      case 18 :
+         if (image == null)
+            image = new StringBuffer();
+         image.append(input_stream.GetSuffix(jjimageLen));
+         jjimageLen = 0;
+                   input_stream.backup(1);
+         break;
+      default : 
+         break;
+   }
+}
+void TokenLexicalActions(Token matchedToken)
+{
+   switch(jjmatchedKind)
+   {
+      case 126 :
+        if (image == null)
+            image = new StringBuffer();
+        image.append(jjstrLiteralImages[126]);
+        lengthOfMatch = jjstrLiteralImages[126].length();
+     matchedToken.kind = GT;
+     ((Token.GTToken)matchedToken).realKind = RUNSIGNEDSHIFT;
+     input_stream.backup(2);
+     matchedToken.image = ">";
+         break;
+      case 127 :
+        if (image == null)
+            image = new StringBuffer();
+        image.append(jjstrLiteralImages[127]);
+        lengthOfMatch = jjstrLiteralImages[127].length();
+     matchedToken.kind = GT;
+     ((Token.GTToken)matchedToken).realKind = RSIGNEDSHIFT;
+     input_stream.backup(1);
+     matchedToken.image = ">";
+         break;
+      default : 
+         break;
+   }
+}
+private void jjCheckNAdd(int state)
+{
+   if (jjrounds[state] != jjround)
+   {
+      jjstateSet[jjnewStateCnt++] = state;
+      jjrounds[state] = jjround;
+   }
+}
+private void jjAddStates(int start, int end)
+{
+   do {
+      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
+   } while (start++ != end);
+}
+private void jjCheckNAddTwoStates(int state1, int state2)
+{
+   jjCheckNAdd(state1);
+   jjCheckNAdd(state2);
+}
+
+private void jjCheckNAddStates(int start, int end)
+{
+   do {
+      jjCheckNAdd(jjnextStates[start]);
+   } while (start++ != end);
+}
+
+}
diff --git a/generated/org/javacc/jjtree/JJTreeParserTreeConstants.java b/generated/org/javacc/jjtree/JJTreeParserTreeConstants.java
new file mode 100644
index 00000000..997e7ccd
--- /dev/null
+++ b/generated/org/javacc/jjtree/JJTreeParserTreeConstants.java
@@ -0,0 +1,95 @@
+/* Generated By:JavaCC: Do not edit this line. JJTreeParserTreeConstants.java Version 4.1d1 */
+package org.javacc.jjtree;
+
+public interface JJTreeParserTreeConstants
+{
+  public int JJTGRAMMAR = 0;
+  public int JJTCOMPILATIONUNIT = 1;
+  public int JJTPRODUCTIONS = 2;
+  public int JJTVOID = 3;
+  public int JJTOPTIONS = 4;
+  public int JJTOPTIONBINDING = 5;
+  public int JJTJAVACODE = 6;
+  public int JJTJAVACODEBODY = 7;
+  public int JJTBNF = 8;
+  public int JJTBNFDECLARATION = 9;
+  public int JJTBNFNODESCOPE = 10;
+  public int JJTRE = 11;
+  public int JJTTOKENDECLS = 12;
+  public int JJTRESPEC = 13;
+  public int JJTBNFCHOICE = 14;
+  public int JJTBNFSEQUENCE = 15;
+  public int JJTBNFLOOKAHEAD = 16;
+  public int JJTEXPANSIONNODESCOPE = 17;
+  public int JJTBNFACTION = 18;
+  public int JJTBNFZEROORONE = 19;
+  public int JJTBNFTRYBLOCK = 20;
+  public int JJTBNFNONTERMINAL = 21;
+  public int JJTBNFASSIGNMENT = 22;
+  public int JJTBNFONEORMORE = 23;
+  public int JJTBNFZEROORMORE = 24;
+  public int JJTBNFPARENTHESIZED = 25;
+  public int JJTRESTRINGLITERAL = 26;
+  public int JJTRENAMED = 27;
+  public int JJTREREFERENCE = 28;
+  public int JJTREEOF = 29;
+  public int JJTRECHOICE = 30;
+  public int JJTRESEQUENCE = 31;
+  public int JJTREONEORMORE = 32;
+  public int JJTREZEROORMORE = 33;
+  public int JJTREZEROORONE = 34;
+  public int JJTRREPETITIONRANGE = 35;
+  public int JJTREPARENTHESIZED = 36;
+  public int JJTRECHARLIST = 37;
+  public int JJTCHARDESCRIPTOR = 38;
+  public int JJTNODEDESCRIPTOR = 39;
+  public int JJTNODEDESCRIPTOREXPRESSION = 40;
+  public int JJTPRIMARYEXPRESSION = 41;
+
+
+  public String[] jjtNodeName = {
+    "Grammar",
+    "CompilationUnit",
+    "Productions",
+    "void",
+    "Options",
+    "OptionBinding",
+    "Javacode",
+    "JavacodeBody",
+    "BNF",
+    "BNFDeclaration",
+    "BNFNodeScope",
+    "RE",
+    "TokenDecls",
+    "RESpec",
+    "BNFChoice",
+    "BNFSequence",
+    "BNFLookahead",
+    "ExpansionNodeScope",
+    "BNFAction",
+    "BNFZeroOrOne",
+    "BNFTryBlock",
+    "BNFNonTerminal",
+    "BNFAssignment",
+    "BNFOneOrMore",
+    "BNFZeroOrMore",
+    "BNFParenthesized",
+    "REStringLiteral",
+    "RENamed",
+    "REReference",
+    "REEOF",
+    "REChoice",
+    "RESequence",
+    "REOneOrMore",
+    "REZeroOrMore",
+    "REZeroOrOne",
+    "RRepetitionRange",
+    "REParenthesized",
+    "RECharList",
+    "CharDescriptor",
+    "NodeDescriptor",
+    "NodeDescriptorExpression",
+    "PrimaryExpression",
+  };
+}
+/* JavaCC - OriginalChecksum=acc137f29730b2391cd3f185ef07cb6c (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/JavaCharStream.java b/generated/org/javacc/jjtree/JavaCharStream.java
new file mode 100644
index 00000000..47b311e1
--- /dev/null
+++ b/generated/org/javacc/jjtree/JavaCharStream.java
@@ -0,0 +1,616 @@
+/* Generated By:JavaCC: Do not edit this line. JavaCharStream.java Version 4.1 */
+/* JavaCCOptions:STATIC=false */
+package org.javacc.jjtree;
+
+/**
+ * An implementation of interface CharStream, where the stream is assumed to
+ * contain only ASCII characters (with java-like unicode escape processing).
+ */
+
+public class JavaCharStream
+{
+/** Whether parser is static. */
+  public static final boolean staticFlag = false;
+  static final int hexval(char c) throws java.io.IOException {
+    switch(c)
+    {
+       case '0' :
+          return 0;
+       case '1' :
+          return 1;
+       case '2' :
+          return 2;
+       case '3' :
+          return 3;
+       case '4' :
+          return 4;
+       case '5' :
+          return 5;
+       case '6' :
+          return 6;
+       case '7' :
+          return 7;
+       case '8' :
+          return 8;
+       case '9' :
+          return 9;
+
+       case 'a' :
+       case 'A' :
+          return 10;
+       case 'b' :
+       case 'B' :
+          return 11;
+       case 'c' :
+       case 'C' :
+          return 12;
+       case 'd' :
+       case 'D' :
+          return 13;
+       case 'e' :
+       case 'E' :
+          return 14;
+       case 'f' :
+       case 'F' :
+          return 15;
+    }
+
+    throw new java.io.IOException(); // Should never come here
+  }
+
+/** Position in buffer. */
+  public int bufpos = -1;
+  int bufsize;
+  int available;
+  int tokenBegin;
+  protected int bufline[];
+  protected int bufcolumn[];
+
+  protected int column = 0;
+  protected int line = 1;
+
+  protected boolean prevCharIsCR = false;
+  protected boolean prevCharIsLF = false;
+
+  protected java.io.Reader inputStream;
+
+  protected char[] nextCharBuf;
+  protected char[] buffer;
+  protected int maxNextCharInd = 0;
+  protected int nextCharInd = -1;
+  protected int inBuf = 0;
+  protected int tabSize = 8;
+
+  protected void setTabSize(int i) { tabSize = i; }
+  protected int getTabSize(int i) { return tabSize; }
+
+  protected void ExpandBuff(boolean wrapAround)
+  {
+     char[] newbuffer = new char[bufsize + 2048];
+     int newbufline[] = new int[bufsize + 2048];
+     int newbufcolumn[] = new int[bufsize + 2048];
+
+     try
+     {
+        if (wrapAround)
+        {
+           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+           System.arraycopy(buffer, 0, newbuffer,
+                                             bufsize - tokenBegin, bufpos);
+           buffer = newbuffer;
+
+           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+           System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
+           bufline = newbufline;
+
+           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+           System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
+           bufcolumn = newbufcolumn;
+
+           bufpos += (bufsize - tokenBegin);
+        }
+        else
+        {
+           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+           buffer = newbuffer;
+
+           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+           bufline = newbufline;
+
+           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+           bufcolumn = newbufcolumn;
+
+           bufpos -= tokenBegin;
+        }
+     }
+     catch (Throwable t)
+     {
+        throw new Error(t.getMessage());
+     }
+
+     available = (bufsize += 2048);
+     tokenBegin = 0;
+  }
+
+  protected void FillBuff() throws java.io.IOException
+  {
+     int i;
+     if (maxNextCharInd == 4096)
+        maxNextCharInd = nextCharInd = 0;
+
+     try {
+        if ((i = inputStream.read(nextCharBuf, maxNextCharInd,
+                                            4096 - maxNextCharInd)) == -1)
+        {
+           inputStream.close();
+           throw new java.io.IOException();
+        }
+        else
+           maxNextCharInd += i;
+        return;
+     }
+     catch(java.io.IOException e) {
+        if (bufpos != 0)
+        {
+           --bufpos;
+           backup(0);
+        }
+        else
+        {
+           bufline[bufpos] = line;
+           bufcolumn[bufpos] = column;
+        }
+        throw e;
+     }
+  }
+
+  protected char ReadByte() throws java.io.IOException
+  {
+     if (++nextCharInd >= maxNextCharInd)
+        FillBuff();
+
+     return nextCharBuf[nextCharInd];
+  }
+
+/** @return starting character for token. */
+  public char BeginToken() throws java.io.IOException
+  {     
+     if (inBuf > 0)
+     {
+        --inBuf;
+
+        if (++bufpos == bufsize)
+           bufpos = 0;
+
+        tokenBegin = bufpos;
+        return buffer[bufpos];
+     }
+
+     tokenBegin = 0;
+     bufpos = -1;
+
+     return readChar();
+  }     
+
+  protected void AdjustBuffSize()
+  {
+     if (available == bufsize)
+     {
+        if (tokenBegin > 2048)
+        {
+           bufpos = 0;
+           available = tokenBegin;
+        }
+        else
+           ExpandBuff(false);
+     }
+     else if (available > tokenBegin)
+        available = bufsize;
+     else if ((tokenBegin - available) < 2048)
+        ExpandBuff(true);
+     else
+        available = tokenBegin;
+  }
+
+  protected void UpdateLineColumn(char c)
+  {
+     column++;
+
+     if (prevCharIsLF)
+     {
+        prevCharIsLF = false;
+        line += (column = 1);
+     }
+     else if (prevCharIsCR)
+     {
+        prevCharIsCR = false;
+        if (c == '\n')
+        {
+           prevCharIsLF = true;
+        }
+        else
+           line += (column = 1);
+     }
+
+     switch (c)
+     {
+        case '\r' :
+           prevCharIsCR = true;
+           break;
+        case '\n' :
+           prevCharIsLF = true;
+           break;
+        case '\t' :
+           column--;
+           column += (tabSize - (column % tabSize));
+           break;
+        default :
+           break;
+     }
+
+     bufline[bufpos] = line;
+     bufcolumn[bufpos] = column;
+  }
+
+/** Read a character. */
+  public char readChar() throws java.io.IOException
+  {
+     if (inBuf > 0)
+     {
+        --inBuf;
+
+        if (++bufpos == bufsize)
+           bufpos = 0;
+
+        return buffer[bufpos];
+     }
+
+     char c;
+
+     if (++bufpos == available)
+        AdjustBuffSize();
+
+     if ((buffer[bufpos] = c = ReadByte()) == '\\')
+     {
+        UpdateLineColumn(c);
+
+        int backSlashCnt = 1;
+
+        for (;;) // Read all the backslashes
+        {
+           if (++bufpos == available)
+              AdjustBuffSize();
+
+           try
+           {
+              if ((buffer[bufpos] = c = ReadByte()) != '\\')
+              {
+                 UpdateLineColumn(c);
+                 // found a non-backslash char.
+                 if ((c == 'u') && ((backSlashCnt & 1) == 1))
+                 {
+                    if (--bufpos < 0)
+                       bufpos = bufsize - 1;
+
+                    break;
+                 }
+
+                 backup(backSlashCnt);
+                 return '\\';
+              }
+           }
+           catch(java.io.IOException e)
+           {
+              if (backSlashCnt > 1)
+                 backup(backSlashCnt-1);
+
+              return '\\';
+           }
+
+           UpdateLineColumn(c);
+           backSlashCnt++;
+        }
+
+        // Here, we have seen an odd number of backslash's followed by a 'u'
+        try
+        {
+           while ((c = ReadByte()) == 'u')
+              ++column;
+
+           buffer[bufpos] = c = (char)(hexval(c) << 12 |
+                                       hexval(ReadByte()) << 8 |
+                                       hexval(ReadByte()) << 4 |
+                                       hexval(ReadByte()));
+
+           column += 4;
+        }
+        catch(java.io.IOException e)
+        {
+           throw new Error("Invalid escape character at line " + line +
+                                         " column " + column + ".");
+        }
+
+        if (backSlashCnt == 1)
+           return c;
+        else
+        {
+           backup(backSlashCnt - 1);
+           return '\\';
+        }
+     }
+     else
+     {
+        UpdateLineColumn(c);
+        return c;
+     }
+  }
+
+  /**
+   * @deprecated 
+   * @see #getEndColumn
+   */
+
+  public int getColumn() {
+     return bufcolumn[bufpos];
+  }
+
+  /**
+   * @deprecated 
+   * @see #getEndLine
+   */
+
+  public int getLine() {
+     return bufline[bufpos];
+  }
+
+/** Get end column. */
+  public int getEndColumn() {
+     return bufcolumn[bufpos];
+  }
+
+/** Get end line. */
+  public int getEndLine() {
+     return bufline[bufpos];
+  }
+
+/** @return column of token start */
+  public int getBeginColumn() {
+     return bufcolumn[tokenBegin];
+  }
+
+/** @return line number of token start */
+  public int getBeginLine() {
+     return bufline[tokenBegin];
+  }
+
+/** Retreat. */
+  public void backup(int amount) {
+
+    inBuf += amount;
+    if ((bufpos -= amount) < 0)
+       bufpos += bufsize;
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.Reader dstream,
+                 int startline, int startcolumn, int buffersize)
+  {
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    available = bufsize = buffersize;
+    buffer = new char[buffersize];
+    bufline = new int[buffersize];
+    bufcolumn = new int[buffersize];
+    nextCharBuf = new char[4096];
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.Reader dstream,
+                                        int startline, int startcolumn)
+  {
+     this(dstream, startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.Reader dstream)
+  {
+     this(dstream, 1, 1, 4096);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.Reader dstream,
+                 int startline, int startcolumn, int buffersize)
+  {
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    if (buffer == null || buffersize != buffer.length)
+    {
+      available = bufsize = buffersize;
+      buffer = new char[buffersize];
+      bufline = new int[buffersize];
+      bufcolumn = new int[buffersize];
+      nextCharBuf = new char[4096];
+    }
+    prevCharIsLF = prevCharIsCR = false;
+    tokenBegin = inBuf = maxNextCharInd = 0;
+    nextCharInd = bufpos = -1;
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.Reader dstream,
+                                        int startline, int startcolumn)
+  {
+     ReInit(dstream, startline, startcolumn, 4096);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.Reader dstream)
+  {
+     ReInit(dstream, 1, 1, 4096);
+  }
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, String encoding, int startline,
+  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
+  {
+     this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+     this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, String encoding, int startline,
+                        int startcolumn) throws java.io.UnsupportedEncodingException
+  {
+     this(dstream, encoding, startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, int startline,
+                        int startcolumn)
+  {
+     this(dstream, startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
+  {
+     this(dstream, encoding, 1, 1, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream)
+  {
+     this(dstream, 1, 1, 4096);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
+  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
+  {
+     ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
+                     int startcolumn) throws java.io.UnsupportedEncodingException
+  {
+     ReInit(dstream, encoding, startline, startcolumn, 4096);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, int startline,
+                     int startcolumn)
+  {
+     ReInit(dstream, startline, startcolumn, 4096);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
+  {
+     ReInit(dstream, encoding, 1, 1, 4096);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream)
+  {
+     ReInit(dstream, 1, 1, 4096);
+  }
+
+  /** @return token image as String */
+  public String GetImage()
+  {
+     if (bufpos >= tokenBegin)
+        return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
+     else
+        return new String(buffer, tokenBegin, bufsize - tokenBegin) +
+                              new String(buffer, 0, bufpos + 1);
+  }
+
+  /** @return suffix */
+  public char[] GetSuffix(int len)
+  {
+     char[] ret = new char[len];
+
+     if ((bufpos + 1) >= len)
+        System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
+     else
+     {
+        System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
+                                                          len - bufpos - 1);
+        System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
+     }
+
+     return ret;
+  }
+
+  /** Set buffers back to null when finished. */
+  public void Done()
+  {
+     nextCharBuf = null;
+     buffer = null;
+     bufline = null;
+     bufcolumn = null;
+  }
+
+  /**
+   * Method to adjust line and column numbers for the start of a token.
+   */
+  public void adjustBeginLineColumn(int newLine, int newCol)
+  {
+     int start = tokenBegin;
+     int len;
+
+     if (bufpos >= tokenBegin)
+     {
+        len = bufpos - tokenBegin + inBuf + 1;
+     }
+     else
+     {
+        len = bufsize - tokenBegin + bufpos + 1 + inBuf;
+     }
+
+     int i = 0, j = 0, k = 0;
+     int nextColDiff = 0, columnDiff = 0;
+
+     while (i < len &&
+            bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
+     {
+        bufline[j] = newLine;
+        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
+        bufcolumn[j] = newCol + columnDiff;
+        columnDiff = nextColDiff;
+        i++;
+     } 
+
+     if (i < len)
+     {
+        bufline[j] = newLine++;
+        bufcolumn[j] = newCol + columnDiff;
+
+        while (i++ < len)
+        {
+           if (bufline[j = start % bufsize] != bufline[++start % bufsize])
+              bufline[j] = newLine++;
+           else
+              bufline[j] = newLine;
+        }
+     }
+
+     line = bufline[j];
+     column = bufcolumn[j];
+  }
+
+}
+/* JavaCC - OriginalChecksum=260201156af05e8d8257b1f8d20857f2 (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/Node.java b/generated/org/javacc/jjtree/Node.java
new file mode 100644
index 00000000..232f4a7b
--- /dev/null
+++ b/generated/org/javacc/jjtree/Node.java
@@ -0,0 +1,38 @@
+/* Generated By:JJTree: Do not edit this line. Node.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+/* All AST nodes must implement this interface.  It provides basic
+   machinery for constructing the parent and child relationships
+   between nodes. */
+
+public interface Node {
+
+  /** This method is called after the node has been made the current
+    node.  It indicates that child nodes can now be added to it. */
+  public void jjtOpen();
+
+  /** This method is called after all the child nodes have been
+    added. */
+  public void jjtClose();
+
+  /** This pair of methods are used to inform the node of its
+    parent. */
+  public void jjtSetParent(Node n);
+  public Node jjtGetParent();
+
+  /** This method tells the node to add its argument to the node's
+    list of children.  */
+  public void jjtAddChild(Node n, int i);
+
+  /** This method returns a child node.  The children are numbered
+     from zero, left to right. */
+  public Node jjtGetChild(int i);
+
+  /** Return the number of children the node has. */
+  public int jjtGetNumChildren();
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data);
+}
+/* JavaCC - OriginalChecksum=c6981bd15ab9efed181fd546e2e5c8fa (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/ParseException.java b/generated/org/javacc/jjtree/ParseException.java
new file mode 100644
index 00000000..fc06b791
--- /dev/null
+++ b/generated/org/javacc/jjtree/ParseException.java
@@ -0,0 +1,198 @@
+/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 4.1 */
+/* JavaCCOptions:KEEP_LINE_COL=null */
+package org.javacc.jjtree;
+
+/**
+ * This exception is thrown when parse errors are encountered.
+ * You can explicitly create objects of this exception type by
+ * calling the method generateParseException in the generated
+ * parser.
+ *
+ * You can modify this class to customize your error reporting
+ * mechanisms so long as you retain the public fields.
+ */
+public class ParseException extends Exception {
+
+  /**
+   * This constructor is used by the method "generateParseException"
+   * in the generated parser.  Calling this constructor generates
+   * a new object of this type with the fields "currentToken",
+   * "expectedTokenSequences", and "tokenImage" set.  The boolean
+   * flag "specialConstructor" is also set to true to indicate that
+   * this constructor was used to create this object.
+   * This constructor calls its super class with the empty string
+   * to force the "toString" method of parent class "Throwable" to
+   * print the error message in the form:
+   *     ParseException: <result of getMessage>
+   */
+  public ParseException(Token currentTokenVal,
+                        int[][] expectedTokenSequencesVal,
+                        String[] tokenImageVal
+                       )
+  {
+    super("");
+    specialConstructor = true;
+    currentToken = currentTokenVal;
+    expectedTokenSequences = expectedTokenSequencesVal;
+    tokenImage = tokenImageVal;
+  }
+
+  /**
+   * The following constructors are for use by you for whatever
+   * purpose you can think of.  Constructing the exception in this
+   * manner makes the exception behave in the normal way - i.e., as
+   * documented in the class "Throwable".  The fields "errorToken",
+   * "expectedTokenSequences", and "tokenImage" do not contain
+   * relevant information.  The JavaCC generated code does not use
+   * these constructors.
+   */
+
+  public ParseException() {
+    super();
+    specialConstructor = false;
+  }
+
+  /** Constructor with message. */
+  public ParseException(String message) {
+    super(message);
+    specialConstructor = false;
+  }
+
+  /**
+   * This variable determines which constructor was used to create
+   * this object and thereby affects the semantics of the
+   * "getMessage" method (see below).
+   */
+  protected boolean specialConstructor;
+
+  /**
+   * This is the last token that has been consumed successfully.  If
+   * this object has been created due to a parse error, the token
+   * followng this token will (therefore) be the first error token.
+   */
+  public Token currentToken;
+
+  /**
+   * Each entry in this array is an array of integers.  Each array
+   * of integers represents a sequence of tokens (by their ordinal
+   * values) that is expected at this point of the parse.
+   */
+  public int[][] expectedTokenSequences;
+
+  /**
+   * This is a reference to the "tokenImage" array of the generated
+   * parser within which the parse error occurred.  This array is
+   * defined in the generated ...Constants interface.
+   */
+  public String[] tokenImage;
+
+  /**
+   * This method has the standard behavior when this object has been
+   * created using the standard constructors.  Otherwise, it uses
+   * "currentToken" and "expectedTokenSequences" to generate a parse
+   * error message and returns it.  If this object has been created
+   * due to a parse error, and you do not catch it (it gets thrown
+   * from the parser), then this method is called during the printing
+   * of the final stack trace, and hence the correct error message
+   * gets displayed.
+   */
+  public String getMessage() {
+    if (!specialConstructor) {
+      return super.getMessage();
+    }
+    StringBuffer expected = new StringBuffer();
+    int maxSize = 0;
+    for (int i = 0; i < expectedTokenSequences.length; i++) {
+      if (maxSize < expectedTokenSequences[i].length) {
+        maxSize = expectedTokenSequences[i].length;
+      }
+      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
+        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(' ');
+      }
+      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
+        expected.append("...");
+      }
+      expected.append(eol).append("    ");
+    }
+    String retval = "Encountered \"";
+    Token tok = currentToken.next;
+    for (int i = 0; i < maxSize; i++) {
+      if (i != 0) retval += " ";
+      if (tok.kind == 0) {
+        retval += tokenImage[0];
+        break;
+      }
+      retval += " " + tokenImage[tok.kind];
+      retval += " \"";
+      retval += add_escapes(tok.image);
+      retval += " \"";
+      tok = tok.next; 
+    }
+    retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;
+    retval += "." + eol;
+    if (expectedTokenSequences.length == 1) {
+      retval += "Was expecting:" + eol + "    ";
+    } else {
+      retval += "Was expecting one of:" + eol + "    ";
+    }
+    retval += expected.toString();
+    return retval;
+  }
+
+  /**
+   * The end of line string for this machine.
+   */
+  protected String eol = System.getProperty("line.separator", "\n");
+ 
+  /**
+   * Used to convert raw characters to their escaped version
+   * when these raw version cannot be used as part of an ASCII
+   * string literal.
+   */
+  protected String add_escapes(String str) {
+      StringBuffer retval = new StringBuffer();
+      char ch;
+      for (int i = 0; i < str.length(); i++) {
+        switch (str.charAt(i))
+        {
+           case 0 :
+              continue;
+           case '\b':
+              retval.append("\\b");
+              continue;
+           case '\t':
+              retval.append("\\t");
+              continue;
+           case '\n':
+              retval.append("\\n");
+              continue;
+           case '\f':
+              retval.append("\\f");
+              continue;
+           case '\r':
+              retval.append("\\r");
+              continue;
+           case '\"':
+              retval.append("\\\"");
+              continue;
+           case '\'':
+              retval.append("\\\'");
+              continue;
+           case '\\':
+              retval.append("\\\\");
+              continue;
+           default:
+              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
+                 String s = "0000" + Integer.toString(ch, 16);
+                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
+              } else {
+                 retval.append(ch);
+              }
+              continue;
+        }
+      }
+      return retval.toString();
+   }
+
+}
+/* JavaCC - OriginalChecksum=83f32c5b11b120a4b6450777d73f7d17 (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/SimpleNode.java b/generated/org/javacc/jjtree/SimpleNode.java
new file mode 100644
index 00000000..076562bd
--- /dev/null
+++ b/generated/org/javacc/jjtree/SimpleNode.java
@@ -0,0 +1,92 @@
+/* Generated By:JJTree: Do not edit this line. SimpleNode.java Version 4.1 */
+/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY= */
+package org.javacc.jjtree;
+
+public class SimpleNode implements Node {
+  protected Node parent;
+  protected Node[] children;
+  protected int id;
+  protected Object value;
+  protected JJTreeParser parser;
+
+  public SimpleNode(int i) {
+    id = i;
+  }
+
+  public SimpleNode(JJTreeParser p, int i) {
+    this(i);
+    parser = p;
+  }
+
+  public void jjtOpen() {
+  }
+
+  public void jjtClose() {
+  }
+  
+  public void jjtSetParent(Node n) { parent = n; }
+  public Node jjtGetParent() { return parent; }
+
+  public void jjtAddChild(Node n, int i) {
+    if (children == null) {
+      children = new Node[i + 1];
+    } else if (i >= children.length) {
+      Node c[] = new Node[i + 1];
+      System.arraycopy(children, 0, c, 0, children.length);
+      children = c;
+    }
+    children[i] = n;
+  }
+
+  public Node jjtGetChild(int i) {
+    return children[i];
+  }
+
+  public int jjtGetNumChildren() {
+    return (children == null) ? 0 : children.length;
+  }
+
+  public void jjtSetValue(Object value) { this.value = value; }
+  public Object jjtGetValue() { return value; }
+
+  /** Accept the visitor. **/
+  public Object jjtAccept(JJTreeParserVisitor visitor, Object data) {
+    return visitor.visit(this, data);
+  }
+
+  /** Accept the visitor. **/
+  public Object childrenAccept(JJTreeParserVisitor visitor, Object data) {
+    if (children != null) {
+      for (int i = 0; i < children.length; ++i) {
+        children[i].jjtAccept(visitor, data);
+      }
+    }
+    return data;
+  }
+
+  /* You can override these two methods in subclasses of SimpleNode to
+     customize the way the node appears when the tree is dumped.  If
+     your output uses more than one line you should override
+     toString(String), otherwise overriding toString() is probably all
+     you need to do. */
+
+  public String toString() { return JJTreeParserTreeConstants.jjtNodeName[id]; }
+  public String toString(String prefix) { return prefix + toString(); }
+
+  /* Override this method if you want to customize how the node dumps
+     out its children. */
+
+  public void dump(String prefix) {
+    System.out.println(toString(prefix));
+    if (children != null) {
+      for (int i = 0; i < children.length; ++i) {
+  SimpleNode n = (SimpleNode)children[i];
+  if (n != null) {
+    n.dump(prefix + " ");
+  }
+      }
+    }
+  }
+}
+
+/* JavaCC - OriginalChecksum=348fb94a105e05090569813bdb389342 (do not edit this line) */
diff --git a/generated/org/javacc/jjtree/TokenMgrError.java b/generated/org/javacc/jjtree/TokenMgrError.java
new file mode 100644
index 00000000..b6d03527
--- /dev/null
+++ b/generated/org/javacc/jjtree/TokenMgrError.java
@@ -0,0 +1,140 @@
+/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 4.1 */
+/* JavaCCOptions: */
+package org.javacc.jjtree;
+
+/** Token Manager Error. */
+public class TokenMgrError extends Error
+{
+
+   /*
+    * Ordinals for various reasons why an Error of this type can be thrown.
+    */
+
+   /**
+    * Lexical error occurred.
+    */
+   static final int LEXICAL_ERROR = 0;
+
+   /**
+    * An attempt was made to create a second instance of a static token manager.
+    */
+   static final int STATIC_LEXER_ERROR = 1;
+
+   /**
+    * Tried to change to an invalid lexical state.
+    */
+   static final int INVALID_LEXICAL_STATE = 2;
+
+   /**
+    * Detected (and bailed out of) an infinite loop in the token manager.
+    */
+   static final int LOOP_DETECTED = 3;
+
+   /**
+    * Indicates the reason why the exception is thrown. It will have
+    * one of the above 4 values.
+    */
+   int errorCode;
+
+   /**
+    * Replaces unprintable characters by their escaped (or unicode escaped)
+    * equivalents in the given string
+    */
+   protected static final String addEscapes(String str) {
+      StringBuffer retval = new StringBuffer();
+      char ch;
+      for (int i = 0; i < str.length(); i++) {
+        switch (str.charAt(i))
+        {
+           case 0 :
+              continue;
+           case '\b':
+              retval.append("\\b");
+              continue;
+           case '\t':
+              retval.append("\\t");
+              continue;
+           case '\n':
+              retval.append("\\n");
+              continue;
+           case '\f':
+              retval.append("\\f");
+              continue;
+           case '\r':
+              retval.append("\\r");
+              continue;
+           case '\"':
+              retval.append("\\\"");
+              continue;
+           case '\'':
+              retval.append("\\\'");
+              continue;
+           case '\\':
+              retval.append("\\\\");
+              continue;
+           default:
+              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
+                 String s = "0000" + Integer.toString(ch, 16);
+                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
+              } else {
+                 retval.append(ch);
+              }
+              continue;
+        }
+      }
+      return retval.toString();
+   }
+
+   /**
+    * Returns a detailed message for the Error when it is thrown by the
+    * token manager to indicate a lexical error.
+    * Parameters : 
+    *    EOFSeen     : indicates if EOF caused the lexical error
+    *    curLexState : lexical state in which this error occurred
+    *    errorLine   : line number when the error occurred
+    *    errorColumn : column number when the error occurred
+    *    errorAfter  : prefix that was seen before this error occurred
+    *    curchar     : the offending character
+    * Note: You can customize the lexical error message by modifying this method.
+    */
+   protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
+      return("Lexical error at line " +
+           errorLine + ", column " +
+           errorColumn + ".  Encountered: " +
+           (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int)curChar + "), ") +
+           "after : \"" + addEscapes(errorAfter) + "\"");
+   }
+
+   /**
+    * You can also modify the body of this method to customize your error messages.
+    * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
+    * of end-users concern, so you can return something like : 
+    *
+    *     "Internal Error : Please file a bug report .... "
+    *
+    * from this method for such cases in the release version of your parser.
+    */
+   public String getMessage() {
+      return super.getMessage();
+   }
+
+   /*
+    * Constructors of various flavors follow.
+    */
+
+   /** No arg constructor. */
+   public TokenMgrError() {
+   }
+
+   /** Constructor with message and reason. */
+   public TokenMgrError(String message, int reason) {
+      super(message);
+      errorCode = reason;
+   }
+
+   /** Full Constructor. */
+   public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {
+      this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
+   }
+}
+/* JavaCC - OriginalChecksum=ab69320bdecdb2fbc3f6c1599f43dbd6 (do not edit this line) */
diff --git a/generated/org/javacc/parser/JavaCCParser.java b/generated/org/javacc/parser/JavaCCParser.java
new file mode 100644
index 00000000..340fb241
--- /dev/null
+++ b/generated/org/javacc/parser/JavaCCParser.java
@@ -0,0 +1,9468 @@
+/* Generated By:JavaCC: Do not edit this line. JavaCCParser.java */
+/**
+ * This file contains the code for JavaCCParser generated
+ * by JavaCCParser itself.
+ */
+
+package org.javacc.parser;
+
+import static org.javacc.parser.Options.*;
+
+import java.util.List;
+import java.util.ArrayList;
+
+public class JavaCCParser extends JavaCCParserInternals implements JavaCCParserConstants {
+
+  /**
+   * The name of the parser class.
+   */
+  String parser_class_name;
+
+  /**
+   * This flag is set to true when the part between PARSER_BEGIN and
+   * PARSER_END is being parsed.
+   */
+  boolean processing_cu = false;
+
+  /**
+   * The level of class nesting.
+   */
+  int class_nesting = 0;
+
+  /**
+   * This int variable is incremented while parsing local lookaheads.
+   * Hence it keeps track of *syntactic* lookahead nesting.
+   * This is used to provide warnings when actions and nested lookaheads
+   * are used in syntactic lookahead productions.  This is to prevent
+   * typos such as leaving out the comma in LOOKAHEAD( foo(), {check()} ).
+   */
+  int inLocalLA = 0;
+
+  /**
+   * Set to true when the parser is within an action.
+   */
+  boolean inAction = false;
+
+  /**
+   * This flag keeps track of whether or not return and throw
+   * statements have been patched during the parsing of a production.
+   * The value of this flag is assigned the field with the same
+   * name in BNFProduction.java.
+   */
+  boolean jumpPatched = false;
+
+  protected static boolean isJavaLanguage()
+  {
+    return language == Language.java;
+  }
+  protected static boolean isCppLanguage()
+  {
+    return language == Language.cpp;
+  }
+
+  /*
+   * Returns true if the next token is not in the FOLLOW list of "expansion".
+   * It is used to decide when the end of an "expansion" has been reached.
+   */
+  private boolean notTailOfExpansionUnit() {
+    Token t;
+    t = getToken(1);
+    if (t.kind == BIT_OR || t.kind == COMMA || t.kind == RPAREN || t.kind == RBRACE || t.kind == RBRACKET) return false;
+    return true;
+  }
+
+  /*
+   * return true if the token is allowed in a ResultType. Used to  mark a c++
+   * result type as an error for a java grammar
+   */
+  private boolean isAllowed(Token t)  {
+    if (isJavaLanguage() && (t.kind == STAR || t.kind == BIT_AND || t.kind == CONST))
+       return false;
+    else
+       return true;
+  }
+
+   /**
+    * Class to hold modifiers.
+    */
+   static public final class ModifierSet
+   {
+     /* Definitions of the bits in the modifiers field.  */
+     public static final int PUBLIC = 0x0001;
+     public static final int PROTECTED = 0x0002;
+     public static final int PRIVATE = 0x0004;
+     public static final int ABSTRACT = 0x0008;
+     public static final int STATIC = 0x0010;
+     public static final int FINAL = 0x0020;
+     public static final int SYNCHRONIZED = 0x0040;
+     public static final int NATIVE = 0x0080;
+     public static final int TRANSIENT = 0x0100;
+     public static final int VOLATILE = 0x0200;
+     public static final int STRICTFP = 0x1000;
+
+     /** A set of accessors that indicate whether the specified modifier
+         is in the set. */
+
+     public boolean isPublic(int modifiers)
+     {
+       return (modifiers & PUBLIC) != 0;
+     }
+
+     public boolean isProtected(int modifiers)
+     {
+       return (modifiers & PROTECTED) != 0;
+     }
+
+     public boolean isPrivate(int modifiers)
+     {
+       return (modifiers & PRIVATE) != 0;
+     }
+
+     public boolean isStatic(int modifiers)
+     {
+       return (modifiers & STATIC) != 0;
+     }
+
+     public boolean isAbstract(int modifiers)
+     {
+       return (modifiers & ABSTRACT) != 0;
+     }
+
+     public boolean isFinal(int modifiers)
+     {
+       return (modifiers & FINAL) != 0;
+     }
+
+     public boolean isNative(int modifiers)
+     {
+       return (modifiers & NATIVE) != 0;
+     }
+
+     public boolean isStrictfp(int modifiers)
+     {
+       return (modifiers & STRICTFP) != 0;
+     }
+
+     public boolean isSynchronized(int modifiers)
+     {
+       return (modifiers & SYNCHRONIZED) != 0;
+     }
+
+     public boolean isTransient(int modifiers)
+      {
+       return (modifiers & TRANSIENT) != 0;
+     }
+
+     public boolean isVolatile(int modifiers)
+     {
+       return (modifiers & VOLATILE) != 0;
+     }
+
+     /**
+      * Removes the given modifier.
+      */
+     static int removeModifier(int modifiers, int mod)
+     {
+        return modifiers & ~mod;
+     }
+   }
+
+   private void eatUptoCloseBrace(List tokens) {
+     int b = 1;
+     Token t;
+     while((t = getToken(1)).kind != RBRACE || --b != 0) {
+       if (tokens != null) {
+         tokens.add(t);
+       }
+       if (t.kind == EOF) break;
+       if (t.kind == LBRACE) b++;
+       getNextToken(); // eat it
+     }
+   }
+
+
+   private void eatUptoRParen(List tokens) {
+     int b = 1;
+     Token t;
+     while((t = getToken(1)).kind != RPAREN || --b != 0) {
+       if (tokens != null) {
+         tokens.add(t);
+       }
+       if (t.kind == EOF) break;
+       if (t.kind == LPAREN) b++;
+       getNextToken(); // eat it
+     }
+   }
+
+/************************************************
+ * THE JAVACC GRAMMAR SPECIFICATION STARTS HERE *
+ ************************************************/
+  final public void javacc_input() throws ParseException {
+          String id1, id2;
+          initialize();
+    javacc_options();
+
+    jj_consume_token(_PARSER_BEGIN);
+    jj_consume_token(LPAREN);
+    id1 = identifier();
+          addcuname(id1);
+    jj_consume_token(RPAREN);
+          processing_cu = true;
+          parser_class_name = id1;
+
+          if (!isJavaLanguage()) {
+            JavaCCGlobals.otherLanguageDeclTokenBeg = getToken(1);
+            while(getToken(1).kind != _PARSER_END) {
+              getNextToken();
+            }
+            JavaCCGlobals.otherLanguageDeclTokenEnd = getToken(1);
+          }
+    CompilationUnit();
+          processing_cu = false;
+    jj_consume_token(_PARSER_END);
+    jj_consume_token(LPAREN);
+    id2 = identifier();
+          compare(getToken(0), id1, id2);
+    jj_consume_token(RPAREN);
+    label_1:
+    while (true) {
+      production();
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case _JAVACODE:
+      case _CPPCODE:
+      case _TOKEN:
+      case _SPECIAL_TOKEN:
+      case _MORE:
+      case _SKIP:
+      case _TOKEN_MGR_DECLS:
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case CONST:
+      case DOUBLE:
+      case FLOAT:
+      case INT:
+      case LONG:
+      case PRIVATE:
+      case PROTECTED:
+      case PUBLIC:
+      case SHORT:
+      case VOID:
+      case TEMPLATE:
+      case LANGLE:
+      case DOUBLECOLON:
+      case IDENTIFIER:
+        ;
+        break;
+      default:
+        jj_la1[0] = jj_gen;
+        break label_1;
+      }
+    }
+    jj_consume_token(0);
+  }
+
+  final public void javacc_options() throws ParseException {
+    if (getToken(1).image.equals("options")) {
+      jj_consume_token(IDENTIFIER);
+      jj_consume_token(LBRACE);
+      label_2:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case _LOOKAHEAD:
+        case _IGNORE_CASE:
+        case _PARSER_BEGIN:
+        case STATIC:
+        case IDENTIFIER:
+          ;
+          break;
+        default:
+          jj_la1[1] = jj_gen;
+          break label_2;
+        }
+        option_binding();
+      }
+      jj_consume_token(RBRACE);
+    } else {
+      ;
+    }
+          Options.normalize();
+  }
+
+  final public void option_binding() throws ParseException {
+          String option_name;
+          int int_val;
+          boolean bool_val;
+          String string_val;
+          List<String > string_list;
+          Token t = getToken(1);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case IDENTIFIER:
+      jj_consume_token(IDENTIFIER);
+      break;
+    case _LOOKAHEAD:
+      jj_consume_token(_LOOKAHEAD);
+      break;
+    case _IGNORE_CASE:
+      jj_consume_token(_IGNORE_CASE);
+      break;
+    case STATIC:
+      jj_consume_token(STATIC);
+      break;
+    case _PARSER_BEGIN:
+      jj_consume_token(_PARSER_BEGIN);
+      break;
+    default:
+      jj_la1[2] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+          option_name = t.image;
+    jj_consume_token(ASSIGN);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case INTEGER_LITERAL:
+      int_val = IntegerLiteral();
+          Options.setInputFileOption(t, getToken(0), option_name, Integer.valueOf(int_val));
+      break;
+    case FALSE:
+    case TRUE:
+      bool_val = BooleanLiteral();
+          Options.setInputFileOption(t, getToken(0), option_name, Boolean.valueOf(bool_val));
+      break;
+    case STRING_LITERAL:
+      string_val = StringLiteral();
+          Options.setInputFileOption(t, getToken(0), option_name, string_val);
+      break;
+    case LPAREN:
+      string_list = StringList();
+          Options.setInputFileOption(t, getToken(0), option_name, string_list);
+      break;
+    default:
+      jj_la1[3] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    jj_consume_token(SEMICOLON);
+  }
+
+  final public List<String> StringList() throws ParseException {
+  List<String> strings = new ArrayList<String>(); String string;
+    jj_consume_token(LPAREN);
+    string = StringLiteral();
+          strings.add(string);
+    label_3:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[4] = jj_gen;
+        break label_3;
+      }
+      jj_consume_token(COMMA);
+      string = StringLiteral();
+          strings.add(string);
+    }
+    jj_consume_token(RPAREN);
+                  {if (true) return strings;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public void production() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case _JAVACODE:
+      javacode_production();
+      break;
+    case _CPPCODE:
+      cppcode_production();
+      break;
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case LANGLE:
+      regular_expr_production();
+      break;
+    case _TOKEN_MGR_DECLS:
+      token_manager_decls();
+      break;
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case CONST:
+    case DOUBLE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case PRIVATE:
+    case PROTECTED:
+    case PUBLIC:
+    case SHORT:
+    case VOID:
+    case TEMPLATE:
+    case DOUBLECOLON:
+    case IDENTIFIER:
+      bnf_production();
+      break;
+    default:
+      jj_la1[5] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void javacode_production() throws ParseException {
+          JavaCodeProduction p = new JavaCodeProduction();
+          String lhs;
+          Token t = getToken(1);
+          p.setFirstToken(t);
+          List excName;
+          p.setThrowsList(new ArrayList());
+          p.setLine(t.beginLine);
+          p.setColumn(t.beginColumn);
+    jj_consume_token(_JAVACODE);
+    AccessModifier(p);
+    ResultType(p.getReturnTypeTokens());
+    lhs = identifier();
+                          p.setLhs(lhs);
+    FormalParameters(p.getParameterListTokens());
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case THROWS:
+      jj_consume_token(THROWS);
+          excName = new ArrayList();
+      Name(excName);
+          p.getThrowsList().add(excName);
+      label_4:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case COMMA:
+          ;
+          break;
+        default:
+          jj_la1[6] = jj_gen;
+          break label_4;
+        }
+          excName = new ArrayList();
+        jj_consume_token(COMMA);
+        Name(excName);
+          p.getThrowsList().add(excName);
+      }
+      break;
+    default:
+      jj_la1[7] = jj_gen;
+      ;
+    }
+    Block(p.getCodeTokens());
+          p.setLastToken(getToken(0));
+          addproduction(p);
+  }
+
+  final public void cppcode_production() throws ParseException {
+          CppCodeProduction p = new CppCodeProduction();
+          String lhs;
+          Token t = getToken(1);
+          p.setFirstToken(t);
+          List excName;
+          p.setThrowsList(new ArrayList());
+          p.setLine(t.beginLine);
+          p.setColumn(t.beginColumn);
+    jj_consume_token(_CPPCODE);
+    AccessModifier(p);
+    ResultType(p.getReturnTypeTokens());
+    lhs = identifier();
+                          p.setLhs(lhs);
+    FormalParameters(p.getParameterListTokens());
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case THROWS:
+      jj_consume_token(THROWS);
+          excName = new ArrayList();
+      Name(excName);
+          p.getThrowsList().add(excName);
+      label_5:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case COMMA:
+          ;
+          break;
+        default:
+          jj_la1[8] = jj_gen;
+          break label_5;
+        }
+          excName = new ArrayList();
+        jj_consume_token(COMMA);
+        Name(excName);
+          p.getThrowsList().add(excName);
+      }
+      break;
+    default:
+      jj_la1[9] = jj_gen;
+      ;
+    }
+    Block(p.getCodeTokens());
+          p.setLastToken(getToken(0));
+          addproduction(p);
+  }
+
+  final public void bnf_production() throws ParseException {
+          BNFProduction p = new BNFProduction();
+          Container c = new Container();
+          Token t = getToken(1);
+          p.setFirstToken(t);
+          List excName;
+          String lhs;
+          p.setThrowsList(new ArrayList());
+          p.setLine(t.beginLine);
+          p.setColumn(t.beginColumn);
+          jumpPatched = false;
+    AccessModifier(p);
+    ResultType(p.getReturnTypeTokens());
+    lhs = identifier();
+                      p.setLhs(lhs);
+    FormalParameters(p.getParameterListTokens());
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case THROWS:
+      jj_consume_token(THROWS);
+          excName = new ArrayList();
+      Name(excName);
+          p.getThrowsList().add(excName);
+      label_6:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case COMMA:
+          ;
+          break;
+        default:
+          jj_la1[10] = jj_gen;
+          break label_6;
+        }
+          excName = new ArrayList();
+        jj_consume_token(COMMA);
+        Name(excName);
+          p.getThrowsList().add(excName);
+      }
+      break;
+    default:
+      jj_la1[11] = jj_gen;
+      ;
+    }
+    jj_consume_token(COLON);
+    Block(p.getDeclarationTokens());
+    jj_consume_token(LBRACE);
+    expansion_choices(c);
+    t = jj_consume_token(RBRACE);
+          p.setLastToken(t);
+          p.setJumpPatched(jumpPatched);
+          production_addexpansion(p, (Expansion)(c.member));
+          addproduction(p);
+  }
+
+  final public void AccessModifier(NormalProduction p) throws ParseException {
+          Token t = null;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case PRIVATE:
+    case PROTECTED:
+    case PUBLIC:
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case PUBLIC:
+        t = jj_consume_token(PUBLIC);
+        break;
+      case PROTECTED:
+        t = jj_consume_token(PROTECTED);
+        break;
+      case PRIVATE:
+        t = jj_consume_token(PRIVATE);
+        break;
+      default:
+        jj_la1[12] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      break;
+    default:
+      jj_la1[13] = jj_gen;
+      ;
+    }
+          if(t != null){
+            p.setAccessMod(t.image);
+          }
+  }
+
+  final public void regular_expr_production() throws ParseException {
+          TokenProduction p = new TokenProduction();
+          List states;
+          Token t = p.firstToken = getToken(1);
+          p.setLine(t.beginLine);
+          p.setColumn(t.beginColumn);
+          // set p.lexStates assuming there is no state spec.
+          // and then override if necessary.
+          p.lexStates = new String[] {"DEFAULT"};
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case LANGLE:
+      if (jj_2_1(2)) {
+        jj_consume_token(LANGLE);
+        jj_consume_token(STAR);
+        jj_consume_token(RANGLE);
+          p.lexStates = null;
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case LANGLE:
+          jj_consume_token(LANGLE);
+          states = new ArrayList();
+          t = jj_consume_token(IDENTIFIER);
+          states.add(t.image);
+          label_7:
+          while (true) {
+            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+            case COMMA:
+              ;
+              break;
+            default:
+              jj_la1[14] = jj_gen;
+              break label_7;
+            }
+            jj_consume_token(COMMA);
+            t = jj_consume_token(IDENTIFIER);
+          states.add(t.image);
+          }
+          jj_consume_token(RANGLE);
+          p.lexStates = new String[states.size()];
+          for (int i = 0; i < states.size(); i++) {
+            p.lexStates[i] = (String)states.get(i);
+          }
+          break;
+        default:
+          jj_la1[15] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+      break;
+    default:
+      jj_la1[16] = jj_gen;
+      ;
+    }
+    regexpr_kind(p);
+          if (p.kind != TokenProduction.TOKEN && Options.getUserTokenManager()) {
+            JavaCCErrors.warning(getToken(0), "Regular expression is being treated as if it were a TOKEN since option USER_TOKEN_MANAGER has been set to true.");
+          }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case LBRACKET:
+      jj_consume_token(LBRACKET);
+      t = jj_consume_token(_IGNORE_CASE);
+      jj_consume_token(RBRACKET);
+          p.ignoreCase = true;
+          if (Options.getUserTokenManager()) {
+            JavaCCErrors.warning(t, "Ignoring \"IGNORE_CASE\" specification since option USER_TOKEN_MANAGER has been set to true.");
+          }
+      break;
+    default:
+      jj_la1[17] = jj_gen;
+      ;
+    }
+    jj_consume_token(COLON);
+    jj_consume_token(LBRACE);
+    regexpr_spec(p);
+    label_8:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case BIT_OR:
+        ;
+        break;
+      default:
+        jj_la1[18] = jj_gen;
+        break label_8;
+      }
+      jj_consume_token(BIT_OR);
+      regexpr_spec(p);
+    }
+    t = jj_consume_token(RBRACE);
+          p.lastToken = t;
+          addregexpr(p);
+  }
+
+  final public void token_manager_decls() throws ParseException {
+          List decls = new ArrayList();
+          Token t;
+    t = jj_consume_token(_TOKEN_MGR_DECLS);
+    jj_consume_token(COLON);
+    if (!isJavaLanguage()) {
+      getNextToken(); // eat {
+      eatUptoCloseBrace(decls);
+      getNextToken(); // eat }
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case LBRACE:
+      ClassOrInterfaceBody(false, decls);
+      break;
+    default:
+      jj_la1[19] = jj_gen;
+      ;
+    }
+          add_token_manager_decls(t, decls);
+  }
+
+  final public void regexpr_kind(TokenProduction p) throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case _TOKEN:
+      jj_consume_token(_TOKEN);
+          p.kind = TokenProduction.TOKEN;
+      break;
+    case _SPECIAL_TOKEN:
+      jj_consume_token(_SPECIAL_TOKEN);
+          p.kind = TokenProduction.SPECIAL;
+      break;
+    case _SKIP:
+      jj_consume_token(_SKIP);
+          p.kind = TokenProduction.SKIP;
+      break;
+    case _MORE:
+      jj_consume_token(_MORE);
+          p.kind = TokenProduction.MORE;
+      break;
+    default:
+      jj_la1[20] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void regexpr_spec(TokenProduction p) throws ParseException {
+          Container c = new Container();
+          Action act = new Action();
+          Token t = null;
+          RegExprSpec res = new RegExprSpec();
+    regular_expression(c);
+          res.rexp = (RegularExpression)c.member;
+          res.rexp.tpContext = p;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case LBRACE:
+          t = getToken(1);
+      Block(act.getActionTokens());
+          if (Options.getUserTokenManager()) {
+            JavaCCErrors.warning(t, "Ignoring action in regular expression specification since option USER_TOKEN_MANAGER has been set to true.");
+          }
+          if (res.rexp.private_rexp) {
+            JavaCCErrors.parse_error(t, "Actions are not permitted on private (#) regular expressions.");
+          }
+      break;
+    default:
+      jj_la1[21] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case COLON:
+      jj_consume_token(COLON);
+      t = jj_consume_token(IDENTIFIER);
+          res.nextState = t.image;
+          if (res.rexp.private_rexp) {
+            JavaCCErrors.parse_error(t, "Lexical state changes are not permitted after private (#) regular expressions.");
+          }
+      break;
+    default:
+      jj_la1[22] = jj_gen;
+      ;
+    }
+          res.act = act;
+          res.nsTok = t;
+          p.respecs.add(res);
+  }
+
+  final public void expansion_choices(Container c1) throws ParseException {
+          boolean morethanone = false;
+          Choice ch = null; // unnecessary initialization to make Java compiler happy!
+          Container c2 = new Container();
+    expansion(c1);
+    label_9:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case BIT_OR:
+        ;
+        break;
+      default:
+        jj_la1[23] = jj_gen;
+        break label_9;
+      }
+      jj_consume_token(BIT_OR);
+      expansion(c2);
+          if (morethanone) {
+            ch.getChoices().add(c2.member);
+            ((Expansion)c2.member).parent = ch;
+          } else {
+            morethanone = true;
+            ch = new Choice((Expansion)c1.member);
+            ((Expansion)c1.member).parent = ch;
+            ch.getChoices().add(c2.member);
+            ((Expansion)c2.member).parent = ch;
+          }
+    }
+          if (morethanone) {
+            c1.member = ch;
+          }
+  }
+
+  final public void expansion(Container c1) throws ParseException {
+          Sequence seq = new Sequence();
+          Container c2 = new Container();
+          Lookahead la = new Lookahead();
+          Token t = getToken(1);
+          seq.setLine(t.beginLine);
+          seq.setColumn(t.beginColumn);
+          la.setLine(t.beginLine);
+          la.setColumn(t.beginColumn);
+          la.setAmount(Options.getLookahead());
+          la.setLaExpansion(null);
+          la.setExplicit(false);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case _LOOKAHEAD:
+      t = jj_consume_token(_LOOKAHEAD);
+      jj_consume_token(LPAREN);
+      la = local_lookahead();
+      jj_consume_token(RPAREN);
+          if (inLocalLA != 0 && la.getAmount() != 0) {
+            JavaCCErrors.warning(t, "Only semantic lookahead specifications within other lookahead specifications is considered.  Syntactic lookahead is ignored.");
+          }
+      break;
+    default:
+      jj_la1[24] = jj_gen;
+      ;
+    }
+          seq.units.add(la);
+    label_10:
+    while (true) {
+      expansion_unit(c2);
+          seq.units.add(c2.member);
+          ((Expansion)c2.member).parent = seq;
+          ((Expansion)c2.member).ordinal = seq.units.size()-1;
+      if (notTailOfExpansionUnit()) {
+        ;
+      } else {
+        break label_10;
+      }
+    }
+          if (la.getLaExpansion() == null) {
+            la.setLaExpansion(seq);
+          }
+          c1.member = seq;
+  }
+
+  final public Lookahead local_lookahead() throws ParseException {
+          Lookahead la = new Lookahead();
+          la.setExplicit(true);
+          Token t = getToken(1);
+          la.setLine(t.beginLine);
+          la.setColumn(t.beginColumn);
+          la.setLaExpansion(null);
+          Container c = new Container();
+          boolean commaAtEnd = false, emptyLA = true;
+          int laAmount;
+          inLocalLA++;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case INTEGER_LITERAL:
+      laAmount = IntegerLiteral();
+          emptyLA = false;
+          la.setAmount(laAmount);
+      break;
+    default:
+      jj_la1[25] = jj_gen;
+      ;
+    }
+    if (!emptyLA && (getToken(1).kind != RPAREN)) {
+      jj_consume_token(COMMA);
+          commaAtEnd = true;
+    } else {
+      ;
+    }
+    if (getToken(1).kind != RPAREN && getToken(1).kind != LBRACE) {
+      expansion_choices(c);
+          emptyLA = false; commaAtEnd = false;
+          la.setLaExpansion((Expansion)c.member);
+    } else {
+      ;
+    }
+    if (!emptyLA && !commaAtEnd && (getToken(1).kind != RPAREN)) {
+      jj_consume_token(COMMA);
+          commaAtEnd = true;
+    } else {
+      ;
+    }
+    if (emptyLA || commaAtEnd) {
+      jj_consume_token(LBRACE);
+          if (!isJavaLanguage()) {
+            int b = 0;
+            while(getToken(1).kind != RBRACE || --b > 0) {
+              t = getNextToken();
+              la.getActionTokens().add(t);
+              if (t.kind == LBRACE) b++;
+            }
+          }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case _LOOKAHEAD:
+      case _IGNORE_CASE:
+      case _PARSER_BEGIN:
+      case _PARSER_END:
+      case _JAVACODE:
+      case _TOKEN:
+      case _SPECIAL_TOKEN:
+      case _MORE:
+      case _SKIP:
+      case _TOKEN_MGR_DECLS:
+      case _EOF:
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case CONST:
+      case DOUBLE:
+      case FALSE:
+      case FLOAT:
+      case INT:
+      case LONG:
+      case NEW:
+      case NULL:
+      case SHORT:
+      case SUPER:
+      case THIS:
+      case TRUE:
+      case VOID:
+      case TEMPLATE:
+      case INTEGER_LITERAL:
+      case FLOATING_POINT_LITERAL:
+      case CHARACTER_LITERAL:
+      case STRING_LITERAL:
+      case LPAREN:
+      case BANG:
+      case TILDE:
+      case DOUBLECOLON:
+      case INCR:
+      case DECR:
+      case PLUS:
+      case MINUS:
+      case 139:
+      case 140:
+      case 141:
+      case 142:
+      case 143:
+      case 144:
+      case IDENTIFIER:
+        Expression(la.getActionTokens());
+        break;
+      default:
+        jj_la1[26] = jj_gen;
+        ;
+      }
+      jj_consume_token(RBRACE);
+          if (emptyLA) {
+            la.setAmount(0);
+          }
+    } else {
+      ;
+    }
+          inLocalLA--;
+          {if (true) return la;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public void expansion_unit(Container c) throws ParseException {
+          String name;
+          List lhsTokens = new ArrayList();
+          NonTerminal nt;
+          Action act;
+          Token t;
+          Lookahead la;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case _LOOKAHEAD:
+      /*
+         * We give this priority over primary expressions which use LOOKAHEAD as the
+         * name of its identifier.
+         */
+        t = jj_consume_token(_LOOKAHEAD);
+      jj_consume_token(LPAREN);
+      la = local_lookahead();
+      jj_consume_token(RPAREN);
+          // Now set the la_expansion field of la with a dummy
+          // expansion (we use EOF).
+          la.setLaExpansion(new REndOfFile());
+          // Create a singleton choice with an empty action.
+          Choice ch = new Choice(t);
+          Sequence seq = new Sequence(t, la);
+          la.parent = seq; la.ordinal = 0;
+          act = new Action();
+          act.setLine(t.beginLine);
+          act.setColumn(t.beginColumn);
+          seq.units.add(act);
+          act.parent = seq; act.ordinal = 1;
+          ch.getChoices().add(seq);
+          seq.parent = ch; seq.ordinal = 0;
+          if (la.getAmount() != 0) {
+            if (la.getActionTokens().size() != 0) {
+              JavaCCErrors.warning(t, "Encountered LOOKAHEAD(...) at a non-choice location.  Only semantic lookahead will be considered here.");
+            } else {
+              JavaCCErrors.warning(t, "Encountered LOOKAHEAD(...) at a non-choice location.  This will be ignored.");
+            }
+          }
+          c.member = ch;
+      break;
+    case LBRACE:
+          act = new Action();
+          t = getToken(1);
+          act.setLine(t.beginLine);
+          act.setColumn(t.beginColumn);
+          inAction = true;
+      Block(act.getActionTokens());
+          inAction = false;
+          if (inLocalLA != 0) {
+            JavaCCErrors.warning(t, "Action within lookahead specification will be ignored.");
+          }
+          c.member = act;
+      break;
+    case LBRACKET:
+      t = jj_consume_token(LBRACKET);
+      expansion_choices(c);
+      jj_consume_token(RBRACKET);
+          c.member = new ZeroOrOne(t, (Expansion)c.member);
+      break;
+    case TRY:
+          Container expch = new Container();
+          List types = new ArrayList();
+          List ids = new ArrayList();
+          List catchblks = new ArrayList();
+          List finallyblk = null;
+          List vec = new ArrayList();
+          Token t0;
+      t0 = jj_consume_token(TRY);
+      jj_consume_token(LBRACE);
+      expansion_choices(expch);
+      jj_consume_token(RBRACE);
+      label_11:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case CATCH:
+          ;
+          break;
+        default:
+          jj_la1[27] = jj_gen;
+          break label_11;
+        }
+        jj_consume_token(CATCH);
+        jj_consume_token(LPAREN);
+      if (!isJavaLanguage()) {
+        while (getToken(1).kind != RPAREN) getNextToken();
+      }
+      t = getToken(0);
+      t.kind = IDENTIFIER;
+      t.image = "...";
+        if (isJavaLanguage()) {
+          Name(vec);
+          t = jj_consume_token(IDENTIFIER);
+        } else {
+          ;
+        }
+        jj_consume_token(RPAREN);
+          types.add(vec);
+          ids.add(t);
+          vec = new ArrayList();
+          inAction = true;
+        Block(vec);
+          inAction = false;
+          catchblks.add(vec);
+          vec = new ArrayList();
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case FINALLY:
+          inAction = true;
+        jj_consume_token(FINALLY);
+        Block(vec);
+          inAction = false;
+          finallyblk = vec;
+        break;
+      default:
+        jj_la1[28] = jj_gen;
+        ;
+      }
+          makeTryBlock(t0, c, expch, types, ids, catchblks, finallyblk);
+      break;
+    default:
+      jj_la1[34] = jj_gen;
+      if (jj_2_4(2147483647)) {
+        if (jj_2_2(2147483647)) {
+          Token first = getToken(1);
+          PrimaryExpression();
+          Token last = getToken(0);
+          jj_consume_token(ASSIGN);
+          t = first;
+          while (true) {
+            lhsTokens.add(t);
+            if (t == last) break;
+            t = t.next;
+          }
+        } else {
+          ;
+        }
+        if (jj_2_3(2147483647)) {
+          t = getToken(1);
+          nt = new NonTerminal();
+          nt.setLine(t.beginLine);
+          nt.setColumn(t.beginColumn);
+          nt.setLhsTokens(lhsTokens);
+          name = identifier();
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case LANGLE:
+            TypeArguments(nt.getParametrizedTypeTokens());
+            break;
+          default:
+            jj_la1[29] = jj_gen;
+            ;
+          }
+          Arguments(nt.getArgumentTokens());
+          nt.setName(name);
+          c.member = nt;
+        } else {
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case STRING_LITERAL:
+          case LANGLE:
+            regular_expression(c);
+          ((RegularExpression)(c.member)).lhsTokens = lhsTokens;
+          add_inline_regexpr((RegularExpression)(c.member));
+            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+            case DOT:
+              jj_consume_token(DOT);
+              t = jj_consume_token(IDENTIFIER);
+                               ((RegularExpression)(c.member)).rhsToken = t;
+              break;
+            default:
+              jj_la1[30] = jj_gen;
+              ;
+            }
+            break;
+          default:
+            jj_la1[31] = jj_gen;
+            jj_consume_token(-1);
+            throw new ParseException();
+          }
+        }
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case LPAREN:
+          t = jj_consume_token(LPAREN);
+          expansion_choices(c);
+          jj_consume_token(RPAREN);
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case HOOK:
+          case PLUS:
+          case STAR:
+            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+            case PLUS:
+              jj_consume_token(PLUS);
+           c.member = new OneOrMore(t, (Expansion)c.member);
+              break;
+            case STAR:
+              jj_consume_token(STAR);
+           c.member = new ZeroOrMore(t, (Expansion)c.member);
+              break;
+            case HOOK:
+              jj_consume_token(HOOK);
+           c.member = new ZeroOrOne(t, (Expansion)c.member);
+              break;
+            default:
+              jj_la1[32] = jj_gen;
+              jj_consume_token(-1);
+              throw new ParseException();
+            }
+            break;
+          default:
+            jj_la1[33] = jj_gen;
+            ;
+          }
+          break;
+        default:
+          jj_la1[35] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+    }
+  }
+
+  final public void regular_expression(Container c) throws ParseException {
+          REndOfFile ef;
+          String image;
+          boolean private_rexp = false;
+          Token t = getToken(1);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case STRING_LITERAL:
+      image = StringLiteral();
+          c.member = new RStringLiteral(t, image);
+      break;
+    default:
+      jj_la1[38] = jj_gen;
+      if (jj_2_5(3)) {
+          image = "";
+        jj_consume_token(LANGLE);
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case 138:
+        case IDENTIFIER:
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case 138:
+            jj_consume_token(138);
+          private_rexp = true;
+            break;
+          default:
+            jj_la1[36] = jj_gen;
+            ;
+          }
+          image = identifier();
+          jj_consume_token(COLON);
+          break;
+        default:
+          jj_la1[37] = jj_gen;
+          ;
+        }
+        complex_regular_expression_choices(c);
+        jj_consume_token(RANGLE);
+          RegularExpression re;
+          if (c.member instanceof RJustName) {
+            RSequence seq = new RSequence();
+            seq.units.add(c.member);
+            re = seq;
+          } else {
+            re = (RegularExpression)c.member;
+          }
+          re.label = image;
+          re.private_rexp = private_rexp;
+          re.setLine(t.beginLine);
+          re.setColumn(t.beginColumn);
+          c.member = re;
+      } else if (jj_2_6(2)) {
+        jj_consume_token(LANGLE);
+        image = identifier();
+        jj_consume_token(RANGLE);
+          c.member = new RJustName(t, image);
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case LANGLE:
+          jj_consume_token(LANGLE);
+          jj_consume_token(_EOF);
+          jj_consume_token(RANGLE);
+          ef = new REndOfFile();
+          ef.setLine(t.beginLine);
+          ef.setColumn(t.beginColumn);
+          ef.ordinal = 0;
+          c.member = ef;
+          break;
+        default:
+          jj_la1[39] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+    }
+  }
+
+  final public void complex_regular_expression_choices(Container c1) throws ParseException {
+          boolean morethanone = false;
+          RChoice ch = null; // unnecessary initialization to make Java compiler happy!
+          Container c2 = new Container();
+    complex_regular_expression(c1);
+    label_12:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case BIT_OR:
+        ;
+        break;
+      default:
+        jj_la1[40] = jj_gen;
+        break label_12;
+      }
+      jj_consume_token(BIT_OR);
+      complex_regular_expression(c2);
+          if (morethanone) {
+            ch.getChoices().add(c2.member);
+          } else {
+            morethanone = true;
+            ch = new RChoice();
+            ch.setLine(((RegularExpression)c1.member).getLine());
+            ch.setColumn(((RegularExpression)c1.member).getColumn());
+            ch.getChoices().add(c1.member);
+            ch.getChoices().add(c2.member);
+          }
+    }
+          if (morethanone) {
+            c1.member = ch;
+          }
+  }
+
+  final public void complex_regular_expression(Container c1) throws ParseException {
+          int count = 0;
+          RSequence seq = null; // unnecessary initialization to make Java compiler happy!
+          Container c2 = new Container();
+    label_13:
+    while (true) {
+      complex_regular_expression_unit(c2);
+          count++;
+          if (count == 1) {
+            c1.member = c2.member; // if count does not go beyond 1, we are done.
+          } else if (count == 2) { // more than 1, so create a sequence.
+            seq = new RSequence();
+            seq.setLine(((RegularExpression)c1.member).getLine());
+            seq.setColumn(((RegularExpression)c1.member).getColumn());
+            seq.units.add(c1.member);
+            seq.units.add(c2.member);
+          } else {
+            seq.units.add(c2.member);
+          }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case STRING_LITERAL:
+      case LPAREN:
+      case LBRACKET:
+      case LANGLE:
+      case TILDE:
+        ;
+        break;
+      default:
+        jj_la1[41] = jj_gen;
+        break label_13;
+      }
+    }
+          if (count > 1) {
+            c1.member = seq;
+          }
+  }
+
+  final public void complex_regular_expression_unit(Container c) throws ParseException {
+          String image;
+          Token t = getToken(1);
+          int r1 = 0, r2 = -1;
+          boolean hasMax = false;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case STRING_LITERAL:
+      image = StringLiteral();
+          c.member = new RStringLiteral(t, image);
+      break;
+    case LANGLE:
+      jj_consume_token(LANGLE);
+      image = identifier();
+      jj_consume_token(RANGLE);
+          c.member = new RJustName(t, image);
+      break;
+    case LBRACKET:
+    case TILDE:
+      character_list(c);
+      break;
+    case LPAREN:
+      jj_consume_token(LPAREN);
+      complex_regular_expression_choices(c);
+      jj_consume_token(RPAREN);
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LBRACE:
+      case HOOK:
+      case PLUS:
+      case STAR:
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case PLUS:
+          jj_consume_token(PLUS);
+          c.member = new ROneOrMore(t, (RegularExpression)c.member);
+          break;
+        case STAR:
+          jj_consume_token(STAR);
+          c.member = new RZeroOrMore(t, (RegularExpression)c.member);
+          break;
+        case HOOK:
+          jj_consume_token(HOOK);
+          RZeroOrOne zorexp = new RZeroOrOne();
+          zorexp.setLine(t.beginLine);
+          zorexp.setColumn(t.beginColumn);
+          zorexp.regexpr = (RegularExpression)c.member;
+          c.member = zorexp;
+          break;
+        case LBRACE:
+          jj_consume_token(LBRACE);
+          r1 = IntegerLiteral();
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case COMMA:
+            jj_consume_token(COMMA);
+                 hasMax = true;
+            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+            case INTEGER_LITERAL:
+              r2 = IntegerLiteral();
+              break;
+            default:
+              jj_la1[42] = jj_gen;
+              ;
+            }
+            break;
+          default:
+            jj_la1[43] = jj_gen;
+            ;
+          }
+          jj_consume_token(RBRACE);
+          RRepetitionRange rrrexp = new RRepetitionRange();
+          rrrexp.setLine(t.beginLine);
+          rrrexp.setColumn(t.beginColumn);
+          rrrexp.min = r1;
+          rrrexp.max = r2;
+        rrrexp.hasMax = hasMax;
+          rrrexp.regexpr = (RegularExpression)c.member;
+          c.member = rrrexp;
+          break;
+        default:
+          jj_la1[44] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+        break;
+      default:
+        jj_la1[45] = jj_gen;
+        ;
+      }
+      break;
+    default:
+      jj_la1[46] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void character_list(Container c1) throws ParseException {
+          RCharacterList chlist = new RCharacterList();
+          Token t = getToken(1);
+          chlist.setLine(t.beginLine);
+          chlist.setColumn(t.beginColumn);
+          Container c2 = new Container();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case TILDE:
+      jj_consume_token(TILDE);
+          chlist.negated_list = true;
+      break;
+    default:
+      jj_la1[47] = jj_gen;
+      ;
+    }
+    jj_consume_token(LBRACKET);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case STRING_LITERAL:
+      character_descriptor(c2);
+          chlist.descriptors.add(c2.member);
+      label_14:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case COMMA:
+          ;
+          break;
+        default:
+          jj_la1[48] = jj_gen;
+          break label_14;
+        }
+        jj_consume_token(COMMA);
+        character_descriptor(c2);
+          chlist.descriptors.add(c2.member);
+      }
+      break;
+    default:
+      jj_la1[49] = jj_gen;
+      ;
+    }
+    jj_consume_token(RBRACKET);
+          c1.member = chlist;
+  }
+
+  final public void character_descriptor(Container c) throws ParseException {
+          char c1, c2 = ' '; // unnecessary initialization to make Java compiler happy!
+          boolean isrange = false;
+          String imageL, imageR;
+          Token t = getToken(1);
+    imageL = StringLiteral();
+          c1 = character_descriptor_assign(getToken(0), imageL);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case MINUS:
+      jj_consume_token(MINUS);
+      imageR = StringLiteral();
+          isrange = true;
+          c2 = character_descriptor_assign(getToken(0), imageR, imageL);
+      break;
+    default:
+      jj_la1[50] = jj_gen;
+      ;
+    }
+          if (isrange) {
+            CharacterRange cr = new CharacterRange();
+            cr.setLine(t.beginLine);
+            cr.setColumn(t.beginColumn);
+        cr.setLeft(c1);
+        cr.setRight(c2);
+            c.member = cr;
+          } else {
+            SingleCharacter sc = new SingleCharacter();
+            sc.setLine(t.beginLine);
+            sc.setColumn(t.beginColumn);
+            sc.ch = c1;
+            c.member = sc;
+          }
+  }
+
+  final public String identifier() throws ParseException {
+          Token t;
+    t = jj_consume_token(IDENTIFIER);
+          {if (true) return t.image;}
+    throw new Error("Missing return statement in function");
+  }
+
+/**********************************************
+ * THE JAVA GRAMMAR SPECIFICATION STARTS HERE *
+ **********************************************/
+
+/*
+ * The Java grammar is modified to use sequences of tokens
+ * for the missing tokens - those that include "<<" and ">>".
+ */
+
+/*
+ * The following production defines Java identifiers - it
+ * includes the reserved words of JavaCC also.
+ */
+  final public Token JavaIdentifier() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case IDENTIFIER:
+      jj_consume_token(IDENTIFIER);
+      break;
+    case _LOOKAHEAD:
+      jj_consume_token(_LOOKAHEAD);
+      break;
+    case _IGNORE_CASE:
+      jj_consume_token(_IGNORE_CASE);
+      break;
+    case _PARSER_BEGIN:
+      jj_consume_token(_PARSER_BEGIN);
+      break;
+    case _PARSER_END:
+      jj_consume_token(_PARSER_END);
+      break;
+    case _JAVACODE:
+      jj_consume_token(_JAVACODE);
+      break;
+    case _TOKEN:
+      jj_consume_token(_TOKEN);
+      break;
+    case _SPECIAL_TOKEN:
+      jj_consume_token(_SPECIAL_TOKEN);
+      break;
+    case _MORE:
+      jj_consume_token(_MORE);
+      break;
+    case _SKIP:
+      jj_consume_token(_SKIP);
+      break;
+    case _TOKEN_MGR_DECLS:
+      jj_consume_token(_TOKEN_MGR_DECLS);
+      break;
+    case _EOF:
+      jj_consume_token(_EOF);
+      break;
+    case TEMPLATE:
+      jj_consume_token(TEMPLATE);
+      break;
+    case 139:
+      jj_consume_token(139);
+      break;
+    case 140:
+      jj_consume_token(140);
+      break;
+    case 141:
+      jj_consume_token(141);
+      break;
+    case 142:
+      jj_consume_token(142);
+      break;
+    case 143:
+      jj_consume_token(143);
+      break;
+    case 144:
+      jj_consume_token(144);
+      break;
+    default:
+      jj_la1[51] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+          Token retval = getToken(0);
+          retval.kind = IDENTIFIER;
+          {if (true) return retval;}
+    throw new Error("Missing return statement in function");
+  }
+
+/*
+ * Program structuring syntax follows.
+ */
+  final public void CompilationUnit() throws ParseException {
+          set_initial_cu_token(getToken(1));
+    if (jj_2_7(2147483647)) {
+      PackageDeclaration();
+    } else {
+      ;
+    }
+    label_15:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case IMPORT:
+        ;
+        break;
+      default:
+        jj_la1[52] = jj_gen;
+        break label_15;
+      }
+      ImportDeclaration();
+    }
+    label_16:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case ABSTRACT:
+      case CLASS:
+      case ENUM:
+      case FINAL:
+      case INTERFACE:
+      case NATIVE:
+      case PRIVATE:
+      case PROTECTED:
+      case PUBLIC:
+      case STATIC:
+      case STRICTFP:
+      case SYNCHRONIZED:
+      case TRANSIENT:
+      case VOLATILE:
+      case SEMICOLON:
+      case 150:
+        ;
+        break;
+      default:
+        jj_la1[53] = jj_gen;
+        break label_16;
+      }
+      TypeDeclaration();
+    }
+          if (Options.isOutputLanguageJava()) {
+            insertionpointerrors(getToken(1));
+          }
+  }
+
+  final public void PackageDeclaration() throws ParseException {
+    Modifiers();
+    jj_consume_token(PACKAGE);
+    Name(null);
+    jj_consume_token(SEMICOLON);
+  }
+
+  final public void ImportDeclaration() throws ParseException {
+    jj_consume_token(IMPORT);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case STATIC:
+      jj_consume_token(STATIC);
+      break;
+    default:
+      jj_la1[54] = jj_gen;
+      ;
+    }
+    Name(null);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case DOT:
+      jj_consume_token(DOT);
+      jj_consume_token(STAR);
+      break;
+    default:
+      jj_la1[55] = jj_gen;
+      ;
+    }
+    jj_consume_token(SEMICOLON);
+  }
+
+/*
+ * Modifiers. We match all modifiers in a single rule to reduce the chances of
+ * syntax errors for simple modifier mistakes. It will also enable us to give
+ * better error messages.
+ */
+  final public int Modifiers() throws ParseException {
+   int modifiers = 0;
+    label_17:
+    while (true) {
+      if (jj_2_8(2)) {
+        ;
+      } else {
+        break label_17;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case PUBLIC:
+        jj_consume_token(PUBLIC);
+              modifiers |= ModifierSet.PUBLIC;
+        break;
+      case STATIC:
+        jj_consume_token(STATIC);
+              modifiers |= ModifierSet.STATIC;
+        break;
+      case PROTECTED:
+        jj_consume_token(PROTECTED);
+                 modifiers |= ModifierSet.PROTECTED;
+        break;
+      case PRIVATE:
+        jj_consume_token(PRIVATE);
+               modifiers |= ModifierSet.PRIVATE;
+        break;
+      case FINAL:
+        jj_consume_token(FINAL);
+             modifiers |= ModifierSet.FINAL;
+        break;
+      case ABSTRACT:
+        jj_consume_token(ABSTRACT);
+                modifiers |= ModifierSet.ABSTRACT;
+        break;
+      case SYNCHRONIZED:
+        jj_consume_token(SYNCHRONIZED);
+                    modifiers |= ModifierSet.SYNCHRONIZED;
+        break;
+      case NATIVE:
+        jj_consume_token(NATIVE);
+              modifiers |= ModifierSet.NATIVE;
+        break;
+      case TRANSIENT:
+        jj_consume_token(TRANSIENT);
+                 modifiers |= ModifierSet.TRANSIENT;
+        break;
+      case VOLATILE:
+        jj_consume_token(VOLATILE);
+                modifiers |= ModifierSet.VOLATILE;
+        break;
+      case STRICTFP:
+        jj_consume_token(STRICTFP);
+                modifiers |= ModifierSet.STRICTFP;
+        break;
+      case 150:
+        Annotation();
+        break;
+      default:
+        jj_la1[56] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+    {if (true) return modifiers;}
+    throw new Error("Missing return statement in function");
+  }
+
+/*
+ * Declaration syntax follows.
+ */
+  final public void TypeDeclaration() throws ParseException {
+   int modifiers;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case SEMICOLON:
+      jj_consume_token(SEMICOLON);
+      break;
+    case ABSTRACT:
+    case CLASS:
+    case ENUM:
+    case FINAL:
+    case INTERFACE:
+    case NATIVE:
+    case PRIVATE:
+    case PROTECTED:
+    case PUBLIC:
+    case STATIC:
+    case STRICTFP:
+    case SYNCHRONIZED:
+    case TRANSIENT:
+    case VOLATILE:
+    case 150:
+      modifiers = Modifiers();
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case CLASS:
+      case INTERFACE:
+        ClassOrInterfaceDeclaration(modifiers, null);
+        break;
+      case ENUM:
+        EnumDeclaration(modifiers);
+        break;
+      case 150:
+        AnnotationTypeDeclaration(modifiers);
+        break;
+      default:
+        jj_la1[57] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      break;
+    default:
+      jj_la1[58] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void ClassOrInterfaceDeclaration(int modifiers, List tokens) throws ParseException {
+   boolean isInterface = false;
+          class_nesting++;
+          Token t;
+          boolean is_parser_class = false;
+  if (tokens == null)
+    tokens = new ArrayList();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case CLASS:
+      jj_consume_token(CLASS);
+      break;
+    case INTERFACE:
+      jj_consume_token(INTERFACE);
+                            isInterface = true;
+      break;
+    default:
+      jj_la1[59] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    t = JavaIdentifier();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case LANGLE:
+      TypeParameters();
+      break;
+    default:
+      jj_la1[60] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case EXTENDS:
+      ExtendsList(isInterface);
+      break;
+    default:
+      jj_la1[61] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case IMPLEMENTS:
+      ImplementsList(isInterface);
+      break;
+    default:
+      jj_la1[62] = jj_gen;
+      ;
+    }
+          if (t.image.equals(parser_class_name) && class_nesting == 1 && processing_cu) {
+            is_parser_class = true;
+            setinsertionpoint(getToken(1), 1);
+          }
+    ClassOrInterfaceBody(isInterface, null);
+          if (is_parser_class) {
+            setinsertionpoint(getToken(0), 2);
+          }
+          class_nesting--;
+  }
+
+  final public void ExtendsList(boolean isInterface) throws ParseException {
+   boolean extendsMoreThanOne = false;
+    jj_consume_token(EXTENDS);
+    ClassOrInterfaceType();
+    label_18:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[63] = jj_gen;
+        break label_18;
+      }
+      jj_consume_token(COMMA);
+      ClassOrInterfaceType();
+                                  extendsMoreThanOne = true;
+    }
+      if (extendsMoreThanOne && !isInterface)
+         {if (true) throw new ParseException("A class cannot extend more than one other class");}
+  }
+
+  final public void ImplementsList(boolean isInterface) throws ParseException {
+    jj_consume_token(IMPLEMENTS);
+    ClassOrInterfaceType();
+    label_19:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[64] = jj_gen;
+        break label_19;
+      }
+      jj_consume_token(COMMA);
+      ClassOrInterfaceType();
+    }
+      if (isInterface)
+         {if (true) throw new ParseException("An interface cannot implement other interfaces");}
+  }
+
+  final public void EnumDeclaration(int modifiers) throws ParseException {
+    jj_consume_token(ENUM);
+    JavaIdentifier();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case IMPLEMENTS:
+      ImplementsList(false);
+      break;
+    default:
+      jj_la1[65] = jj_gen;
+      ;
+    }
+    EnumBody();
+  }
+
+  final public void EnumBody() throws ParseException {
+    jj_consume_token(LBRACE);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _JAVACODE:
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case _TOKEN_MGR_DECLS:
+    case _EOF:
+    case ABSTRACT:
+    case FINAL:
+    case NATIVE:
+    case PRIVATE:
+    case PROTECTED:
+    case PUBLIC:
+    case STATIC:
+    case STRICTFP:
+    case SYNCHRONIZED:
+    case TRANSIENT:
+    case VOLATILE:
+    case TEMPLATE:
+    case 139:
+    case 140:
+    case 141:
+    case 142:
+    case 143:
+    case 144:
+    case 150:
+    case IDENTIFIER:
+      EnumConstant();
+      label_20:
+      while (true) {
+        if (jj_2_9(2)) {
+          ;
+        } else {
+          break label_20;
+        }
+        jj_consume_token(COMMA);
+        EnumConstant();
+      }
+      break;
+    default:
+      jj_la1[66] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case COMMA:
+      jj_consume_token(COMMA);
+      break;
+    default:
+      jj_la1[67] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case SEMICOLON:
+      jj_consume_token(SEMICOLON);
+      label_21:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case _LOOKAHEAD:
+        case _IGNORE_CASE:
+        case _PARSER_BEGIN:
+        case _PARSER_END:
+        case _JAVACODE:
+        case _TOKEN:
+        case _SPECIAL_TOKEN:
+        case _MORE:
+        case _SKIP:
+        case _TOKEN_MGR_DECLS:
+        case _EOF:
+        case ABSTRACT:
+        case BOOLEAN:
+        case BYTE:
+        case CHAR:
+        case CLASS:
+        case CONST:
+        case DOUBLE:
+        case ENUM:
+        case FINAL:
+        case FLOAT:
+        case INT:
+        case INTERFACE:
+        case LONG:
+        case NATIVE:
+        case PRIVATE:
+        case PROTECTED:
+        case PUBLIC:
+        case SHORT:
+        case STATIC:
+        case STRICTFP:
+        case SYNCHRONIZED:
+        case TRANSIENT:
+        case VOID:
+        case VOLATILE:
+        case TEMPLATE:
+        case LBRACE:
+        case SEMICOLON:
+        case LANGLE:
+        case DOUBLECOLON:
+        case 139:
+        case 140:
+        case 141:
+        case 142:
+        case 143:
+        case 144:
+        case 150:
+        case IDENTIFIER:
+          ;
+          break;
+        default:
+          jj_la1[68] = jj_gen;
+          break label_21;
+        }
+        ClassOrInterfaceBodyDeclaration(false);
+      }
+      break;
+    default:
+      jj_la1[69] = jj_gen;
+      ;
+    }
+    jj_consume_token(RBRACE);
+  }
+
+  final public void EnumConstant() throws ParseException {
+    Modifiers();
+    JavaIdentifier();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case LPAREN:
+      Arguments(null);
+      break;
+    default:
+      jj_la1[70] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case LBRACE:
+      ClassOrInterfaceBody(false, null);
+      break;
+    default:
+      jj_la1[71] = jj_gen;
+      ;
+    }
+  }
+
+  final public void TypeParameters() throws ParseException {
+    jj_consume_token(LANGLE);
+    TypeParameter();
+    label_22:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[72] = jj_gen;
+        break label_22;
+      }
+      jj_consume_token(COMMA);
+      TypeParameter();
+    }
+    jj_consume_token(RANGLE);
+  }
+
+  final public void TypeParameter() throws ParseException {
+    JavaIdentifier();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case EXTENDS:
+      TypeBound();
+      break;
+    default:
+      jj_la1[73] = jj_gen;
+      ;
+    }
+  }
+
+  final public void TypeBound() throws ParseException {
+    jj_consume_token(EXTENDS);
+    ClassOrInterfaceType();
+    label_23:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case BIT_AND:
+        ;
+        break;
+      default:
+        jj_la1[74] = jj_gen;
+        break label_23;
+      }
+      jj_consume_token(BIT_AND);
+      ClassOrInterfaceType();
+    }
+  }
+
+  final public void ClassOrInterfaceBody(boolean isInterface, List tokens) throws ParseException {
+          Token first, last;
+          if (tokens == null)
+            tokens = new ArrayList();
+    jj_consume_token(LBRACE);
+          first = getToken(1);
+    label_24:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case _LOOKAHEAD:
+      case _IGNORE_CASE:
+      case _PARSER_BEGIN:
+      case _PARSER_END:
+      case _JAVACODE:
+      case _TOKEN:
+      case _SPECIAL_TOKEN:
+      case _MORE:
+      case _SKIP:
+      case _TOKEN_MGR_DECLS:
+      case _EOF:
+      case ABSTRACT:
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case CLASS:
+      case CONST:
+      case DOUBLE:
+      case ENUM:
+      case FINAL:
+      case FLOAT:
+      case INT:
+      case INTERFACE:
+      case LONG:
+      case NATIVE:
+      case PRIVATE:
+      case PROTECTED:
+      case PUBLIC:
+      case SHORT:
+      case STATIC:
+      case STRICTFP:
+      case SYNCHRONIZED:
+      case TRANSIENT:
+      case VOID:
+      case VOLATILE:
+      case TEMPLATE:
+      case LBRACE:
+      case SEMICOLON:
+      case LANGLE:
+      case DOUBLECOLON:
+      case 139:
+      case 140:
+      case 141:
+      case 142:
+      case 143:
+      case 144:
+      case 150:
+      case IDENTIFIER:
+        ;
+        break;
+      default:
+        jj_la1[75] = jj_gen;
+        break label_24;
+      }
+      ClassOrInterfaceBodyDeclaration(isInterface);
+    }
+          last = getToken(0);
+    jj_consume_token(RBRACE);
+          if (last.next != first) { // i.e., this is not an empty sequence
+            Token t = first;
+            while (true) {
+              tokens.add(t);
+              if (t == last) break;
+              t = t.next;
+            }
+          }
+  }
+
+  final public void ClassOrInterfaceBodyDeclaration(boolean isInterface) throws ParseException {
+   int modifiers;
+    if (jj_2_12(2)) {
+      Initializer();
+     if (isInterface)
+        {if (true) throw new ParseException("An interface cannot have initializers");}
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case _LOOKAHEAD:
+      case _IGNORE_CASE:
+      case _PARSER_BEGIN:
+      case _PARSER_END:
+      case _JAVACODE:
+      case _TOKEN:
+      case _SPECIAL_TOKEN:
+      case _MORE:
+      case _SKIP:
+      case _TOKEN_MGR_DECLS:
+      case _EOF:
+      case ABSTRACT:
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case CLASS:
+      case CONST:
+      case DOUBLE:
+      case ENUM:
+      case FINAL:
+      case FLOAT:
+      case INT:
+      case INTERFACE:
+      case LONG:
+      case NATIVE:
+      case PRIVATE:
+      case PROTECTED:
+      case PUBLIC:
+      case SHORT:
+      case STATIC:
+      case STRICTFP:
+      case SYNCHRONIZED:
+      case TRANSIENT:
+      case VOID:
+      case VOLATILE:
+      case TEMPLATE:
+      case LANGLE:
+      case DOUBLECOLON:
+      case 139:
+      case 140:
+      case 141:
+      case 142:
+      case 143:
+      case 144:
+      case 150:
+      case IDENTIFIER:
+        modifiers = Modifiers();
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case CLASS:
+        case INTERFACE:
+          ClassOrInterfaceDeclaration(modifiers, null);
+          break;
+        case ENUM:
+          EnumDeclaration(modifiers);
+          break;
+        default:
+          jj_la1[76] = jj_gen;
+          if (jj_2_10(2147483647)) {
+            ConstructorDeclaration();
+          } else if (jj_2_11(2147483647)) {
+            FieldDeclaration(modifiers);
+          } else {
+            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+            case BOOLEAN:
+            case BYTE:
+            case CHAR:
+            case CONST:
+            case DOUBLE:
+            case FLOAT:
+            case INT:
+            case LONG:
+            case SHORT:
+            case VOID:
+            case TEMPLATE:
+            case LANGLE:
+            case DOUBLECOLON:
+            case IDENTIFIER:
+              MethodDeclaration(modifiers);
+              break;
+            default:
+              jj_la1[77] = jj_gen;
+              jj_consume_token(-1);
+              throw new ParseException();
+            }
+          }
+        }
+        break;
+      case SEMICOLON:
+        jj_consume_token(SEMICOLON);
+        break;
+      default:
+        jj_la1[78] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void FieldDeclaration(int modifiers) throws ParseException {
+    Type();
+    VariableDeclarator();
+    label_25:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[79] = jj_gen;
+        break label_25;
+      }
+      jj_consume_token(COMMA);
+      VariableDeclarator();
+    }
+    jj_consume_token(SEMICOLON);
+  }
+
+  final public void VariableDeclarator() throws ParseException {
+    VariableDeclaratorId();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case ASSIGN:
+      jj_consume_token(ASSIGN);
+      VariableInitializer();
+      break;
+    default:
+      jj_la1[80] = jj_gen;
+      ;
+    }
+  }
+
+  final public void VariableDeclaratorId() throws ParseException {
+    JavaIdentifier();
+    label_26:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LBRACKET:
+        ;
+        break;
+      default:
+        jj_la1[81] = jj_gen;
+        break label_26;
+      }
+      jj_consume_token(LBRACKET);
+      jj_consume_token(RBRACKET);
+    }
+  }
+
+  final public void VariableInitializer() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case LBRACE:
+      ArrayInitializer();
+      break;
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _JAVACODE:
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case _TOKEN_MGR_DECLS:
+    case _EOF:
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case CONST:
+    case DOUBLE:
+    case FALSE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case NEW:
+    case NULL:
+    case SHORT:
+    case SUPER:
+    case THIS:
+    case TRUE:
+    case VOID:
+    case TEMPLATE:
+    case INTEGER_LITERAL:
+    case FLOATING_POINT_LITERAL:
+    case CHARACTER_LITERAL:
+    case STRING_LITERAL:
+    case LPAREN:
+    case BANG:
+    case TILDE:
+    case DOUBLECOLON:
+    case INCR:
+    case DECR:
+    case PLUS:
+    case MINUS:
+    case 139:
+    case 140:
+    case 141:
+    case 142:
+    case 143:
+    case 144:
+    case IDENTIFIER:
+      Expression(null);
+      break;
+    default:
+      jj_la1[82] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void ArrayInitializer() throws ParseException {
+    jj_consume_token(LBRACE);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _JAVACODE:
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case _TOKEN_MGR_DECLS:
+    case _EOF:
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case CONST:
+    case DOUBLE:
+    case FALSE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case NEW:
+    case NULL:
+    case SHORT:
+    case SUPER:
+    case THIS:
+    case TRUE:
+    case VOID:
+    case TEMPLATE:
+    case INTEGER_LITERAL:
+    case FLOATING_POINT_LITERAL:
+    case CHARACTER_LITERAL:
+    case STRING_LITERAL:
+    case LPAREN:
+    case LBRACE:
+    case BANG:
+    case TILDE:
+    case DOUBLECOLON:
+    case INCR:
+    case DECR:
+    case PLUS:
+    case MINUS:
+    case 139:
+    case 140:
+    case 141:
+    case 142:
+    case 143:
+    case 144:
+    case IDENTIFIER:
+      VariableInitializer();
+      label_27:
+      while (true) {
+        if (jj_2_13(2)) {
+          ;
+        } else {
+          break label_27;
+        }
+        jj_consume_token(COMMA);
+        VariableInitializer();
+      }
+      break;
+    default:
+      jj_la1[83] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case COMMA:
+      jj_consume_token(COMMA);
+      break;
+    default:
+      jj_la1[84] = jj_gen;
+      ;
+    }
+    jj_consume_token(RBRACE);
+  }
+
+  final public void MethodDeclaration(int modifiers) throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case LANGLE:
+      TypeParameters();
+      break;
+    default:
+      jj_la1[85] = jj_gen;
+      ;
+    }
+    ResultType(null);
+    MethodDeclarator();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case THROWS:
+      jj_consume_token(THROWS);
+      NameList();
+      break;
+    default:
+      jj_la1[86] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case LBRACE:
+      Block(null);
+      break;
+    case SEMICOLON:
+      jj_consume_token(SEMICOLON);
+      break;
+    default:
+      jj_la1[87] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void MethodDeclarator() throws ParseException {
+    JavaIdentifier();
+    FormalParameters(null);
+    label_28:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LBRACKET:
+        ;
+        break;
+      default:
+        jj_la1[88] = jj_gen;
+        break label_28;
+      }
+      jj_consume_token(LBRACKET);
+      jj_consume_token(RBRACKET);
+    }
+  }
+
+  final public void FormalParameters(List tokens) throws ParseException {
+          Token first, last;
+          if (tokens == null)
+            tokens = new ArrayList();
+    jj_consume_token(LPAREN);
+          first = getToken(1);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case ABSTRACT:
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case DOUBLE:
+    case FINAL:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case NATIVE:
+    case PRIVATE:
+    case PROTECTED:
+    case PUBLIC:
+    case SHORT:
+    case STATIC:
+    case STRICTFP:
+    case SYNCHRONIZED:
+    case TRANSIENT:
+    case VOLATILE:
+    case TEMPLATE:
+    case DOUBLECOLON:
+    case 150:
+    case IDENTIFIER:
+      FormalParameter();
+      label_29:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case COMMA:
+          ;
+          break;
+        default:
+          jj_la1[89] = jj_gen;
+          break label_29;
+        }
+        jj_consume_token(COMMA);
+        FormalParameter();
+      }
+      break;
+    default:
+      jj_la1[90] = jj_gen;
+      ;
+    }
+          last = getToken(0);
+    jj_consume_token(RPAREN);
+          if (last.next != first) { // i.e., this is not an empty sequence
+            Token t = first;
+            while (true) {
+              tokens.add(t);
+              if (t == last) break;
+              t = t.next;
+            }
+          }
+  }
+
+  final public void FormalParameter() throws ParseException {
+  Token t;
+    Modifiers();
+    Type();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case STAR:
+    case BIT_AND:
+    case 145:
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case STAR:
+      case BIT_AND:
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case BIT_AND:
+          t = jj_consume_token(BIT_AND);
+          break;
+        case STAR:
+          t = jj_consume_token(STAR);
+          break;
+        default:
+          jj_la1[91] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+                           if (!isAllowed(t)) {if (true) throw new ParseException(t.image + " is invalid in this context");}
+        break;
+      case 145:
+        jj_consume_token(145);
+        break;
+      default:
+        jj_la1[92] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      break;
+    default:
+      jj_la1[93] = jj_gen;
+      ;
+    }
+    VariableDeclaratorId();
+  }
+
+  final public void ConstructorDeclaration() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case LANGLE:
+      TypeParameters();
+      break;
+    default:
+      jj_la1[94] = jj_gen;
+      ;
+    }
+    JavaIdentifier();
+    FormalParameters(null);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case THROWS:
+      jj_consume_token(THROWS);
+      NameList();
+      break;
+    default:
+      jj_la1[95] = jj_gen;
+      ;
+    }
+    jj_consume_token(LBRACE);
+    if (jj_2_14(2147483647)) {
+      ExplicitConstructorInvocation();
+    } else {
+      ;
+    }
+    label_30:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case _LOOKAHEAD:
+      case _IGNORE_CASE:
+      case _PARSER_BEGIN:
+      case _PARSER_END:
+      case _JAVACODE:
+      case _TOKEN:
+      case _SPECIAL_TOKEN:
+      case _MORE:
+      case _SKIP:
+      case _TOKEN_MGR_DECLS:
+      case _EOF:
+      case ABSTRACT:
+      case ASSERT:
+      case BOOLEAN:
+      case BREAK:
+      case BYTE:
+      case CHAR:
+      case CLASS:
+      case CONST:
+      case CONTINUE:
+      case DO:
+      case DOUBLE:
+      case FALSE:
+      case FINAL:
+      case FLOAT:
+      case FOR:
+      case IF:
+      case INT:
+      case INTERFACE:
+      case LONG:
+      case NATIVE:
+      case NEW:
+      case NULL:
+      case PRIVATE:
+      case PROTECTED:
+      case PUBLIC:
+      case RETURN:
+      case SHORT:
+      case STATIC:
+      case STRICTFP:
+      case SUPER:
+      case SWITCH:
+      case SYNCHRONIZED:
+      case THIS:
+      case THROW:
+      case TRANSIENT:
+      case TRUE:
+      case TRY:
+      case VOID:
+      case VOLATILE:
+      case WHILE:
+      case TEMPLATE:
+      case INTEGER_LITERAL:
+      case FLOATING_POINT_LITERAL:
+      case CHARACTER_LITERAL:
+      case STRING_LITERAL:
+      case LPAREN:
+      case LBRACE:
+      case SEMICOLON:
+      case DOUBLECOLON:
+      case INCR:
+      case DECR:
+      case 139:
+      case 140:
+      case 141:
+      case 142:
+      case 143:
+      case 144:
+      case 150:
+      case IDENTIFIER:
+        ;
+        break;
+      default:
+        jj_la1[96] = jj_gen;
+        break label_30;
+      }
+      BlockStatement();
+    }
+    jj_consume_token(RBRACE);
+  }
+
+  final public void ExplicitConstructorInvocation() throws ParseException {
+    if (jj_2_16(2147483647)) {
+      jj_consume_token(THIS);
+      Arguments(null);
+      jj_consume_token(SEMICOLON);
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case _LOOKAHEAD:
+      case _IGNORE_CASE:
+      case _PARSER_BEGIN:
+      case _PARSER_END:
+      case _JAVACODE:
+      case _TOKEN:
+      case _SPECIAL_TOKEN:
+      case _MORE:
+      case _SKIP:
+      case _TOKEN_MGR_DECLS:
+      case _EOF:
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case CONST:
+      case DOUBLE:
+      case FALSE:
+      case FLOAT:
+      case INT:
+      case LONG:
+      case NEW:
+      case NULL:
+      case SHORT:
+      case SUPER:
+      case THIS:
+      case TRUE:
+      case VOID:
+      case TEMPLATE:
+      case INTEGER_LITERAL:
+      case FLOATING_POINT_LITERAL:
+      case CHARACTER_LITERAL:
+      case STRING_LITERAL:
+      case LPAREN:
+      case DOUBLECOLON:
+      case 139:
+      case 140:
+      case 141:
+      case 142:
+      case 143:
+      case 144:
+      case IDENTIFIER:
+        if (jj_2_15(2)) {
+          PrimaryExpression();
+          jj_consume_token(DOT);
+        } else {
+          ;
+        }
+        jj_consume_token(SUPER);
+        Arguments(null);
+        jj_consume_token(SEMICOLON);
+        break;
+      default:
+        jj_la1[97] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void Initializer() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case STATIC:
+      jj_consume_token(STATIC);
+      break;
+    default:
+      jj_la1[98] = jj_gen;
+      ;
+    }
+    Block(null);
+  }
+
+/*
+ * Type, name and expression syntax follows.
+ */
+  final public void Type() throws ParseException {
+    if (jj_2_17(2)) {
+      ReferenceType();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case DOUBLE:
+      case FLOAT:
+      case INT:
+      case LONG:
+      case SHORT:
+        PrimitiveType();
+        break;
+      default:
+        jj_la1[99] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void ReferenceType() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case DOUBLE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case SHORT:
+      PrimitiveType();
+      label_31:
+      while (true) {
+        jj_consume_token(LBRACKET);
+        jj_consume_token(RBRACKET);
+        if (jj_2_18(2)) {
+          ;
+        } else {
+          break label_31;
+        }
+      }
+      break;
+    case TEMPLATE:
+    case DOUBLECOLON:
+    case IDENTIFIER:
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case TEMPLATE:
+        Template();
+        break;
+      default:
+        jj_la1[100] = jj_gen;
+        ;
+      }
+      ClassOrInterfaceType();
+      label_32:
+      while (true) {
+        if (jj_2_19(2)) {
+          ;
+        } else {
+          break label_32;
+        }
+        jj_consume_token(LBRACKET);
+        jj_consume_token(RBRACKET);
+      }
+      break;
+    default:
+      jj_la1[101] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void Template() throws ParseException {
+    jj_consume_token(TEMPLATE);
+    jj_consume_token(LANGLE);
+    TemplateBase();
+    label_33:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[102] = jj_gen;
+        break label_33;
+      }
+      jj_consume_token(COMMA);
+      TemplateBase();
+    }
+    jj_consume_token(RANGLE);
+  }
+
+  final public void TemplateBase() throws ParseException {
+    TemplatePack();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case 145:
+      jj_consume_token(145);
+      break;
+    default:
+      jj_la1[103] = jj_gen;
+      ;
+    }
+    jj_consume_token(IDENTIFIER);
+  }
+
+  final public void TemplatePack() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case CLASS:
+      jj_consume_token(CLASS);
+      break;
+    case TYPENAME:
+      jj_consume_token(TYPENAME);
+      break;
+    default:
+      jj_la1[104] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void ClassOrInterfaceType() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case DOUBLECOLON:
+      jj_consume_token(DOUBLECOLON);
+      break;
+    default:
+      jj_la1[105] = jj_gen;
+      ;
+    }
+    jj_consume_token(IDENTIFIER);
+    if (jj_2_20(2)) {
+      TypeArguments(null);
+    } else {
+      ;
+    }
+    label_34:
+    while (true) {
+      if (jj_2_21(2)) {
+        ;
+      } else {
+        break label_34;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case DOT:
+        jj_consume_token(DOT);
+        break;
+      case DOUBLECOLON:
+        jj_consume_token(DOUBLECOLON);
+        break;
+      default:
+        jj_la1[106] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      jj_consume_token(IDENTIFIER);
+      if (jj_2_22(2)) {
+        TypeArguments(null);
+      } else {
+        ;
+      }
+    }
+  }
+
+  final public void TypeArguments(List tokens) throws ParseException {
+  Token first, last;
+  if (tokens == null)
+         tokens = new ArrayList();
+    jj_consume_token(LANGLE);
+           first = getToken(0);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case DOUBLE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case SHORT:
+    case TEMPLATE:
+    case HOOK:
+    case DOUBLECOLON:
+    case IDENTIFIER:
+      TypeArgument();
+      label_35:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case COMMA:
+          ;
+          break;
+        default:
+          jj_la1[107] = jj_gen;
+          break label_35;
+        }
+        jj_consume_token(COMMA);
+        TypeArgument();
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case 145:
+          jj_consume_token(145);
+          break;
+        default:
+          jj_la1[108] = jj_gen;
+          ;
+        }
+      }
+      break;
+    default:
+      jj_la1[109] = jj_gen;
+      ;
+    }
+    jj_consume_token(RANGLE);
+     last = getToken(0);
+          if (last.next != first) { // i.e., this is not an empty sequence
+            Token t = first;
+            while (true) {
+              tokens.add(t);
+              if (t == last) break;
+              t = t.next;
+            }
+          }
+  }
+
+  final public void TypeArgument() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case DOUBLE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case SHORT:
+    case TEMPLATE:
+    case DOUBLECOLON:
+    case IDENTIFIER:
+      ReferenceType();
+      break;
+    case HOOK:
+      jj_consume_token(HOOK);
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case EXTENDS:
+      case SUPER:
+        WildcardBounds();
+        break;
+      default:
+        jj_la1[110] = jj_gen;
+        ;
+      }
+      break;
+    default:
+      jj_la1[111] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void WildcardBounds() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case EXTENDS:
+      jj_consume_token(EXTENDS);
+      ReferenceType();
+      break;
+    case SUPER:
+      jj_consume_token(SUPER);
+      ReferenceType();
+      break;
+    default:
+      jj_la1[112] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void PrimitiveType() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case BOOLEAN:
+      jj_consume_token(BOOLEAN);
+      break;
+    case CHAR:
+      jj_consume_token(CHAR);
+      break;
+    case BYTE:
+      jj_consume_token(BYTE);
+      break;
+    case SHORT:
+      jj_consume_token(SHORT);
+      break;
+    case INT:
+      jj_consume_token(INT);
+      break;
+    case LONG:
+      jj_consume_token(LONG);
+      break;
+    case FLOAT:
+      jj_consume_token(FLOAT);
+      break;
+    case DOUBLE:
+      jj_consume_token(DOUBLE);
+      break;
+    default:
+      jj_la1[113] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void ResultType(List tokens) throws ParseException {
+          Token first = getToken(1);
+          if (tokens == null)
+            tokens = new ArrayList();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case VOID:
+      jj_consume_token(VOID);
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case STAR:
+        jj_consume_token(STAR);
+        break;
+      default:
+        jj_la1[114] = jj_gen;
+        ;
+      }
+      break;
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case CONST:
+    case DOUBLE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case SHORT:
+    case TEMPLATE:
+    case DOUBLECOLON:
+    case IDENTIFIER:
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case CONST:
+        jj_consume_token(CONST);
+        break;
+      default:
+        jj_la1[115] = jj_gen;
+        ;
+      }
+      Type();
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case STAR:
+      case BIT_AND:
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case STAR:
+          jj_consume_token(STAR);
+          break;
+        case BIT_AND:
+          jj_consume_token(BIT_AND);
+          break;
+        default:
+          jj_la1[116] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+        break;
+      default:
+        jj_la1[117] = jj_gen;
+        ;
+      }
+      break;
+    default:
+      jj_la1[118] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+          Token last = getToken(0);
+          Token t = first;
+          while (true) {
+            String i = t.image;
+            if (isAllowed(t))  {
+               tokens.add(t);
+               if (t == last) break;
+               t = t.next;
+            } else {
+           {if (true) throw new ParseException(t.image + " is invalid in this context");}
+            }
+          }
+  }
+
+  final public void Name(List tokens) throws ParseException {
+          if (tokens == null)
+            tokens = new ArrayList();
+          Token first = getToken(1);
+    JavaIdentifier();
+    label_36:
+    while (true) {
+      if (jj_2_23(2)) {
+        ;
+      } else {
+        break label_36;
+      }
+      jj_consume_token(DOT);
+      JavaIdentifier();
+    }
+          Token last = getToken(0);
+          Token t = first;
+          while (true) {
+            tokens.add(t);
+            if (t == last) break;
+            t = t.next;
+          }
+  }
+
+  final public void NameList() throws ParseException {
+    Name(null);
+    label_37:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[119] = jj_gen;
+        break label_37;
+      }
+      jj_consume_token(COMMA);
+      Name(null);
+    }
+  }
+
+/*
+ * Expression syntax follows.
+ */
+  final public void Expression(List tokens) throws ParseException {
+          Token first = getToken(1);
+          if (tokens == null)
+            tokens = new ArrayList();
+    ConditionalExpression();
+    if (jj_2_24(2)) {
+      AssignmentOperator();
+      Expression(null);
+    } else {
+      ;
+    }
+          Token last = getToken(0);
+          Token t = first;
+          while (true) {
+            tokens.add(t);
+            if (t == last) break;
+            t = t.next;
+          }
+  }
+
+  final public void AssignmentOperator() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case ASSIGN:
+      jj_consume_token(ASSIGN);
+      break;
+    case STARASSIGN:
+      jj_consume_token(STARASSIGN);
+      break;
+    case SLASHASSIGN:
+      jj_consume_token(SLASHASSIGN);
+      break;
+    case REMASSIGN:
+      jj_consume_token(REMASSIGN);
+      break;
+    case PLUSASSIGN:
+      jj_consume_token(PLUSASSIGN);
+      break;
+    case MINUSASSIGN:
+      jj_consume_token(MINUSASSIGN);
+      break;
+    case 146:
+      jj_consume_token(146);
+      break;
+    case 147:
+      jj_consume_token(147);
+      break;
+    case 148:
+      jj_consume_token(148);
+      break;
+    case ANDASSIGN:
+      jj_consume_token(ANDASSIGN);
+      break;
+    case XORASSIGN:
+      jj_consume_token(XORASSIGN);
+      break;
+    case ORASSIGN:
+      jj_consume_token(ORASSIGN);
+      break;
+    default:
+      jj_la1[120] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void ConditionalExpression() throws ParseException {
+    ConditionalOrExpression();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case HOOK:
+      jj_consume_token(HOOK);
+      Expression(null);
+      jj_consume_token(COLON);
+      Expression(null);
+      break;
+    default:
+      jj_la1[121] = jj_gen;
+      ;
+    }
+  }
+
+  final public void ConditionalOrExpression() throws ParseException {
+    ConditionalAndExpression();
+    label_38:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case SC_OR:
+        ;
+        break;
+      default:
+        jj_la1[122] = jj_gen;
+        break label_38;
+      }
+      jj_consume_token(SC_OR);
+      ConditionalAndExpression();
+    }
+  }
+
+  final public void ConditionalAndExpression() throws ParseException {
+    InclusiveOrExpression();
+    label_39:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case SC_AND:
+        ;
+        break;
+      default:
+        jj_la1[123] = jj_gen;
+        break label_39;
+      }
+      jj_consume_token(SC_AND);
+      InclusiveOrExpression();
+    }
+  }
+
+  final public void InclusiveOrExpression() throws ParseException {
+    ExclusiveOrExpression();
+    label_40:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case BIT_OR:
+        ;
+        break;
+      default:
+        jj_la1[124] = jj_gen;
+        break label_40;
+      }
+      jj_consume_token(BIT_OR);
+      ExclusiveOrExpression();
+    }
+  }
+
+  final public void ExclusiveOrExpression() throws ParseException {
+    AndExpression();
+    label_41:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case XOR:
+        ;
+        break;
+      default:
+        jj_la1[125] = jj_gen;
+        break label_41;
+      }
+      jj_consume_token(XOR);
+      AndExpression();
+    }
+  }
+
+  final public void AndExpression() throws ParseException {
+    EqualityExpression();
+    label_42:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case BIT_AND:
+        ;
+        break;
+      default:
+        jj_la1[126] = jj_gen;
+        break label_42;
+      }
+      jj_consume_token(BIT_AND);
+      EqualityExpression();
+    }
+  }
+
+  final public void EqualityExpression() throws ParseException {
+    InstanceOfExpression();
+    label_43:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case EQ:
+      case NE:
+        ;
+        break;
+      default:
+        jj_la1[127] = jj_gen;
+        break label_43;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case EQ:
+        jj_consume_token(EQ);
+        break;
+      case NE:
+        jj_consume_token(NE);
+        break;
+      default:
+        jj_la1[128] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      InstanceOfExpression();
+    }
+  }
+
+  final public void InstanceOfExpression() throws ParseException {
+    RelationalExpression();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case INSTANCEOF:
+      jj_consume_token(INSTANCEOF);
+      Type();
+      break;
+    default:
+      jj_la1[129] = jj_gen;
+      ;
+    }
+  }
+
+  final public void RelationalExpression() throws ParseException {
+    ShiftExpression();
+    label_44:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LANGLE:
+      case LE:
+      case GE:
+      case RANGLE:
+        ;
+        break;
+      default:
+        jj_la1[130] = jj_gen;
+        break label_44;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LANGLE:
+        jj_consume_token(LANGLE);
+        break;
+      case RANGLE:
+        jj_consume_token(RANGLE);
+        break;
+      case LE:
+        jj_consume_token(LE);
+        break;
+      case GE:
+        jj_consume_token(GE);
+        break;
+      default:
+        jj_la1[131] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      ShiftExpression();
+    }
+  }
+
+  final public void ShiftExpression() throws ParseException {
+    AdditiveExpression();
+    label_45:
+    while (true) {
+      if (jj_2_25(1)) {
+        ;
+      } else {
+        break label_45;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case 149:
+        jj_consume_token(149);
+        break;
+      default:
+        jj_la1[132] = jj_gen;
+        if (jj_2_26(1)) {
+          RSIGNEDSHIFT();
+        } else if (jj_2_27(1)) {
+          RUNSIGNEDSHIFT();
+        } else {
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+      AdditiveExpression();
+    }
+  }
+
+  final public void AdditiveExpression() throws ParseException {
+    MultiplicativeExpression();
+    label_46:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case PLUS:
+      case MINUS:
+        ;
+        break;
+      default:
+        jj_la1[133] = jj_gen;
+        break label_46;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case PLUS:
+        jj_consume_token(PLUS);
+        break;
+      case MINUS:
+        jj_consume_token(MINUS);
+        break;
+      default:
+        jj_la1[134] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      MultiplicativeExpression();
+    }
+  }
+
+  final public void MultiplicativeExpression() throws ParseException {
+    UnaryExpression();
+    label_47:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case STAR:
+      case SLASH:
+      case REM:
+        ;
+        break;
+      default:
+        jj_la1[135] = jj_gen;
+        break label_47;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case STAR:
+        jj_consume_token(STAR);
+        break;
+      case SLASH:
+        jj_consume_token(SLASH);
+        break;
+      case REM:
+        jj_consume_token(REM);
+        break;
+      default:
+        jj_la1[136] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      UnaryExpression();
+    }
+  }
+
+  final public void UnaryExpression() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case PLUS:
+    case MINUS:
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case PLUS:
+        jj_consume_token(PLUS);
+        break;
+      case MINUS:
+        jj_consume_token(MINUS);
+        break;
+      default:
+        jj_la1[137] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      UnaryExpression();
+      break;
+    case INCR:
+      PreIncrementExpression();
+      break;
+    case DECR:
+      PreDecrementExpression();
+      break;
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _JAVACODE:
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case _TOKEN_MGR_DECLS:
+    case _EOF:
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case CONST:
+    case DOUBLE:
+    case FALSE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case NEW:
+    case NULL:
+    case SHORT:
+    case SUPER:
+    case THIS:
+    case TRUE:
+    case VOID:
+    case TEMPLATE:
+    case INTEGER_LITERAL:
+    case FLOATING_POINT_LITERAL:
+    case CHARACTER_LITERAL:
+    case STRING_LITERAL:
+    case LPAREN:
+    case BANG:
+    case TILDE:
+    case DOUBLECOLON:
+    case 139:
+    case 140:
+    case 141:
+    case 142:
+    case 143:
+    case 144:
+    case IDENTIFIER:
+      UnaryExpressionNotPlusMinus();
+      break;
+    default:
+      jj_la1[138] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void PreIncrementExpression() throws ParseException {
+    jj_consume_token(INCR);
+    PrimaryExpression();
+  }
+
+  final public void PreDecrementExpression() throws ParseException {
+    jj_consume_token(DECR);
+    PrimaryExpression();
+  }
+
+  final public void UnaryExpressionNotPlusMinus() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case BANG:
+    case TILDE:
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case TILDE:
+        jj_consume_token(TILDE);
+        break;
+      case BANG:
+        jj_consume_token(BANG);
+        break;
+      default:
+        jj_la1[139] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      UnaryExpression();
+      break;
+    default:
+      jj_la1[140] = jj_gen;
+      if (jj_2_28(2147483647)) {
+        CastExpression();
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case _LOOKAHEAD:
+        case _IGNORE_CASE:
+        case _PARSER_BEGIN:
+        case _PARSER_END:
+        case _JAVACODE:
+        case _TOKEN:
+        case _SPECIAL_TOKEN:
+        case _MORE:
+        case _SKIP:
+        case _TOKEN_MGR_DECLS:
+        case _EOF:
+        case BOOLEAN:
+        case BYTE:
+        case CHAR:
+        case CONST:
+        case DOUBLE:
+        case FALSE:
+        case FLOAT:
+        case INT:
+        case LONG:
+        case NEW:
+        case NULL:
+        case SHORT:
+        case SUPER:
+        case THIS:
+        case TRUE:
+        case VOID:
+        case TEMPLATE:
+        case INTEGER_LITERAL:
+        case FLOATING_POINT_LITERAL:
+        case CHARACTER_LITERAL:
+        case STRING_LITERAL:
+        case LPAREN:
+        case DOUBLECOLON:
+        case 139:
+        case 140:
+        case 141:
+        case 142:
+        case 143:
+        case 144:
+        case IDENTIFIER:
+          PostfixExpression();
+          break;
+        default:
+          jj_la1[141] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+    }
+  }
+
+// This production is to determine lookahead only.  The LOOKAHEAD specifications
+// below are not used, but they are there just to indicate that we know about
+// this.
+  final public void CastLookahead() throws ParseException {
+    if (jj_2_29(2)) {
+      jj_consume_token(LPAREN);
+      PrimitiveType();
+    } else if (jj_2_30(2147483647)) {
+      jj_consume_token(LPAREN);
+      Type();
+      jj_consume_token(LBRACKET);
+      jj_consume_token(RBRACKET);
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LPAREN:
+        jj_consume_token(LPAREN);
+        Type();
+        jj_consume_token(RPAREN);
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case TILDE:
+          jj_consume_token(TILDE);
+          break;
+        case BANG:
+          jj_consume_token(BANG);
+          break;
+        case LPAREN:
+          jj_consume_token(LPAREN);
+          break;
+        case _LOOKAHEAD:
+        case _IGNORE_CASE:
+        case _PARSER_BEGIN:
+        case _PARSER_END:
+        case _JAVACODE:
+        case _TOKEN:
+        case _SPECIAL_TOKEN:
+        case _MORE:
+        case _SKIP:
+        case _TOKEN_MGR_DECLS:
+        case _EOF:
+        case TEMPLATE:
+        case 139:
+        case 140:
+        case 141:
+        case 142:
+        case 143:
+        case 144:
+        case IDENTIFIER:
+          JavaIdentifier();
+          break;
+        case THIS:
+          jj_consume_token(THIS);
+          break;
+        case SUPER:
+          jj_consume_token(SUPER);
+          break;
+        case NEW:
+          jj_consume_token(NEW);
+          break;
+        case FALSE:
+        case NULL:
+        case TRUE:
+        case INTEGER_LITERAL:
+        case FLOATING_POINT_LITERAL:
+        case CHARACTER_LITERAL:
+        case STRING_LITERAL:
+          Literal();
+          break;
+        default:
+          jj_la1[142] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+        break;
+      default:
+        jj_la1[143] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void PostfixExpression() throws ParseException {
+    PrimaryExpression();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case INCR:
+    case DECR:
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case INCR:
+        jj_consume_token(INCR);
+        break;
+      case DECR:
+        jj_consume_token(DECR);
+        break;
+      default:
+        jj_la1[144] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      break;
+    default:
+      jj_la1[145] = jj_gen;
+      ;
+    }
+  }
+
+  final public void CastExpression() throws ParseException {
+    if (jj_2_31(2147483647)) {
+      jj_consume_token(LPAREN);
+      Type();
+      jj_consume_token(RPAREN);
+      UnaryExpression();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LPAREN:
+        jj_consume_token(LPAREN);
+        Type();
+        jj_consume_token(RPAREN);
+        UnaryExpressionNotPlusMinus();
+        break;
+      default:
+        jj_la1[146] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void PrimaryExpression() throws ParseException {
+    PrimaryPrefix();
+    label_48:
+    while (true) {
+      if (jj_2_32(2)) {
+        ;
+      } else {
+        break label_48;
+      }
+      PrimarySuffix();
+    }
+  }
+
+  final public void MemberSelector() throws ParseException {
+    jj_consume_token(DOT);
+    TypeArguments(null);
+    JavaIdentifier();
+  }
+
+  final public void PrimaryPrefix() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case FALSE:
+    case NULL:
+    case TRUE:
+    case INTEGER_LITERAL:
+    case FLOATING_POINT_LITERAL:
+    case CHARACTER_LITERAL:
+    case STRING_LITERAL:
+      Literal();
+      break;
+    case THIS:
+      jj_consume_token(THIS);
+      break;
+    case SUPER:
+      jj_consume_token(SUPER);
+      jj_consume_token(DOT);
+      JavaIdentifier();
+      break;
+    case LPAREN:
+      jj_consume_token(LPAREN);
+      Expression(null);
+      jj_consume_token(RPAREN);
+      break;
+    case NEW:
+      AllocationExpression();
+      break;
+    default:
+      jj_la1[147] = jj_gen;
+      if (jj_2_33(2147483647)) {
+        ResultType(null);
+        jj_consume_token(DOT);
+        jj_consume_token(CLASS);
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case _LOOKAHEAD:
+        case _IGNORE_CASE:
+        case _PARSER_BEGIN:
+        case _PARSER_END:
+        case _JAVACODE:
+        case _TOKEN:
+        case _SPECIAL_TOKEN:
+        case _MORE:
+        case _SKIP:
+        case _TOKEN_MGR_DECLS:
+        case _EOF:
+        case TEMPLATE:
+        case 139:
+        case 140:
+        case 141:
+        case 142:
+        case 143:
+        case 144:
+        case IDENTIFIER:
+          Name(null);
+          break;
+        default:
+          jj_la1[148] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+    }
+  }
+
+  final public void PrimarySuffix() throws ParseException {
+    if (jj_2_34(2)) {
+      jj_consume_token(DOT);
+      jj_consume_token(THIS);
+    } else if (jj_2_35(2)) {
+      jj_consume_token(DOT);
+      AllocationExpression();
+    } else if (jj_2_36(3)) {
+      MemberSelector();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LBRACKET:
+        jj_consume_token(LBRACKET);
+        Expression(null);
+        jj_consume_token(RBRACKET);
+        break;
+      case DOT:
+        jj_consume_token(DOT);
+        JavaIdentifier();
+        break;
+      case LPAREN:
+        Arguments(null);
+        break;
+      default:
+        jj_la1[149] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void Literal() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case INTEGER_LITERAL:
+      jj_consume_token(INTEGER_LITERAL);
+      break;
+    case FLOATING_POINT_LITERAL:
+      jj_consume_token(FLOATING_POINT_LITERAL);
+      break;
+    case CHARACTER_LITERAL:
+      jj_consume_token(CHARACTER_LITERAL);
+      break;
+    case STRING_LITERAL:
+      jj_consume_token(STRING_LITERAL);
+      break;
+    case FALSE:
+    case TRUE:
+      BooleanLiteral();
+      break;
+    case NULL:
+      NullLiteral();
+      break;
+    default:
+      jj_la1[150] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public int IntegerLiteral() throws ParseException {
+    jj_consume_token(INTEGER_LITERAL);
+          try {
+            {if (true) return Integer.parseInt(token.image);}
+          } catch (NumberFormatException e) {
+            {if (true) throw new Error();}
+          }
+    throw new Error("Missing return statement in function");
+  }
+
+  final public boolean BooleanLiteral() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case TRUE:
+      jj_consume_token(TRUE);
+          {if (true) return true;}
+      break;
+    case FALSE:
+      jj_consume_token(FALSE);
+          {if (true) return false;}
+      break;
+    default:
+      jj_la1[151] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    throw new Error("Missing return statement in function");
+  }
+
+  final public String StringLiteral() throws ParseException {
+          Token t;
+    t = jj_consume_token(STRING_LITERAL);
+          {if (true) return remove_escapes_and_quotes(t, t.image);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public void NullLiteral() throws ParseException {
+    jj_consume_token(NULL);
+  }
+
+  final public void Arguments(List tokens) throws ParseException {
+          Token first, last;
+          if (tokens == null)
+            tokens = new ArrayList();
+    jj_consume_token(LPAREN);
+          first = getToken(1);
+          // Added by Sreenivas Viswanadha for 6.0
+          // TODO :: 2013/07/16 -- cba : Think this condition should be if the language IS C++, not if the language ISN'T Java ...
+          if (!isJavaLanguage()) {
+                eatUptoRParen(null);
+          }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _JAVACODE:
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case _TOKEN_MGR_DECLS:
+    case _EOF:
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case CONST:
+    case DOUBLE:
+    case FALSE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case NEW:
+    case NULL:
+    case SHORT:
+    case SUPER:
+    case THIS:
+    case TRUE:
+    case VOID:
+    case TEMPLATE:
+    case INTEGER_LITERAL:
+    case FLOATING_POINT_LITERAL:
+    case CHARACTER_LITERAL:
+    case STRING_LITERAL:
+    case LPAREN:
+    case BANG:
+    case TILDE:
+    case DOUBLECOLON:
+    case INCR:
+    case DECR:
+    case PLUS:
+    case MINUS:
+    case 139:
+    case 140:
+    case 141:
+    case 142:
+    case 143:
+    case 144:
+    case IDENTIFIER:
+      ArgumentList();
+      break;
+    default:
+      jj_la1[152] = jj_gen;
+      ;
+    }
+          last = getToken(0);
+    jj_consume_token(RPAREN);
+          if (last.next != first) { // i.e., this is not an empty sequence
+            Token t = first;
+            while (true) {
+              tokens.add(t);
+              if (t == last) break;
+              t = t.next;
+            }
+          }
+  }
+
+  final public void ArgumentList() throws ParseException {
+    Expression(null);
+    label_49:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[153] = jj_gen;
+        break label_49;
+      }
+      jj_consume_token(COMMA);
+      Expression(null);
+    }
+  }
+
+  final public void AllocationExpression() throws ParseException {
+    if (jj_2_37(2)) {
+      jj_consume_token(NEW);
+      PrimitiveType();
+      ArrayDimsAndInits();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case NEW:
+        jj_consume_token(NEW);
+        ClassOrInterfaceType();
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case LANGLE:
+          TypeArguments(null);
+          break;
+        default:
+          jj_la1[154] = jj_gen;
+          ;
+        }
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case LBRACKET:
+          ArrayDimsAndInits();
+          break;
+        case LPAREN:
+          Arguments(null);
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case LBRACE:
+            ClassOrInterfaceBody(false, null);
+            break;
+          default:
+            jj_la1[155] = jj_gen;
+            ;
+          }
+          break;
+        default:
+          jj_la1[156] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+        break;
+      default:
+        jj_la1[157] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+/*
+ * The third LOOKAHEAD specification below is to parse to PrimarySuffix
+ * if there is an expression between the "[...]".
+ */
+  final public void ArrayDimsAndInits() throws ParseException {
+    if (jj_2_40(2)) {
+      label_50:
+      while (true) {
+        jj_consume_token(LBRACKET);
+        Expression(null);
+        jj_consume_token(RBRACKET);
+        if (jj_2_38(2)) {
+          ;
+        } else {
+          break label_50;
+        }
+      }
+      label_51:
+      while (true) {
+        if (jj_2_39(2)) {
+          ;
+        } else {
+          break label_51;
+        }
+        jj_consume_token(LBRACKET);
+        jj_consume_token(RBRACKET);
+      }
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LBRACKET:
+        label_52:
+        while (true) {
+          jj_consume_token(LBRACKET);
+          jj_consume_token(RBRACKET);
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case LBRACKET:
+            ;
+            break;
+          default:
+            jj_la1[158] = jj_gen;
+            break label_52;
+          }
+        }
+        ArrayInitializer();
+        break;
+      default:
+        jj_la1[159] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+/*
+ * Statement syntax follows.
+ */
+  final public void Statement() throws ParseException {
+    if (jj_2_41(2)) {
+      LabeledStatement();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case ASSERT:
+        AssertStatement();
+        break;
+      case LBRACE:
+        Block(null);
+        break;
+      case SEMICOLON:
+        EmptyStatement();
+        break;
+      case _LOOKAHEAD:
+      case _IGNORE_CASE:
+      case _PARSER_BEGIN:
+      case _PARSER_END:
+      case _JAVACODE:
+      case _TOKEN:
+      case _SPECIAL_TOKEN:
+      case _MORE:
+      case _SKIP:
+      case _TOKEN_MGR_DECLS:
+      case _EOF:
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case CONST:
+      case DOUBLE:
+      case FALSE:
+      case FLOAT:
+      case INT:
+      case LONG:
+      case NEW:
+      case NULL:
+      case SHORT:
+      case SUPER:
+      case THIS:
+      case TRUE:
+      case VOID:
+      case TEMPLATE:
+      case INTEGER_LITERAL:
+      case FLOATING_POINT_LITERAL:
+      case CHARACTER_LITERAL:
+      case STRING_LITERAL:
+      case LPAREN:
+      case DOUBLECOLON:
+      case INCR:
+      case DECR:
+      case 139:
+      case 140:
+      case 141:
+      case 142:
+      case 143:
+      case 144:
+      case IDENTIFIER:
+        StatementExpression();
+        jj_consume_token(SEMICOLON);
+        break;
+      case SWITCH:
+        SwitchStatement();
+        break;
+      case IF:
+        IfStatement();
+        break;
+      case WHILE:
+        WhileStatement();
+        break;
+      case DO:
+        DoStatement();
+        break;
+      case FOR:
+        ForStatement();
+        break;
+      case BREAK:
+        BreakStatement();
+        break;
+      case CONTINUE:
+        ContinueStatement();
+        break;
+      case RETURN:
+        ReturnStatement();
+        break;
+      case THROW:
+        ThrowStatement();
+        break;
+      case SYNCHRONIZED:
+        SynchronizedStatement();
+        break;
+      case TRY:
+        TryStatement();
+        break;
+      default:
+        jj_la1[160] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void AssertStatement() throws ParseException {
+    jj_consume_token(ASSERT);
+    Expression(null);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case COLON:
+      jj_consume_token(COLON);
+      Expression(null);
+      break;
+    default:
+      jj_la1[161] = jj_gen;
+      ;
+    }
+    jj_consume_token(SEMICOLON);
+  }
+
+  final public void LabeledStatement() throws ParseException {
+    JavaIdentifier();
+    jj_consume_token(COLON);
+    Statement();
+  }
+
+  final public void Block(List tokens) throws ParseException {
+          Token first, last;
+          if (tokens == null)
+            tokens = new ArrayList();
+    jj_consume_token(LBRACE);
+          first = getToken(1);
+          if (!isJavaLanguage()) {
+            eatUptoCloseBrace(null);
+          }
+    label_53:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case _LOOKAHEAD:
+      case _IGNORE_CASE:
+      case _PARSER_BEGIN:
+      case _PARSER_END:
+      case _JAVACODE:
+      case _TOKEN:
+      case _SPECIAL_TOKEN:
+      case _MORE:
+      case _SKIP:
+      case _TOKEN_MGR_DECLS:
+      case _EOF:
+      case ABSTRACT:
+      case ASSERT:
+      case BOOLEAN:
+      case BREAK:
+      case BYTE:
+      case CHAR:
+      case CLASS:
+      case CONST:
+      case CONTINUE:
+      case DO:
+      case DOUBLE:
+      case FALSE:
+      case FINAL:
+      case FLOAT:
+      case FOR:
+      case IF:
+      case INT:
+      case INTERFACE:
+      case LONG:
+      case NATIVE:
+      case NEW:
+      case NULL:
+      case PRIVATE:
+      case PROTECTED:
+      case PUBLIC:
+      case RETURN:
+      case SHORT:
+      case STATIC:
+      case STRICTFP:
+      case SUPER:
+      case SWITCH:
+      case SYNCHRONIZED:
+      case THIS:
+      case THROW:
+      case TRANSIENT:
+      case TRUE:
+      case TRY:
+      case VOID:
+      case VOLATILE:
+      case WHILE:
+      case TEMPLATE:
+      case INTEGER_LITERAL:
+      case FLOATING_POINT_LITERAL:
+      case CHARACTER_LITERAL:
+      case STRING_LITERAL:
+      case LPAREN:
+      case LBRACE:
+      case SEMICOLON:
+      case DOUBLECOLON:
+      case INCR:
+      case DECR:
+      case 139:
+      case 140:
+      case 141:
+      case 142:
+      case 143:
+      case 144:
+      case 150:
+      case IDENTIFIER:
+        ;
+        break;
+      default:
+        jj_la1[162] = jj_gen;
+        break label_53;
+      }
+      BlockStatement();
+    }
+          last = getToken(0);
+    jj_consume_token(RBRACE);
+          if (last.next != first) { // i.e., this is not an empty sequence
+            Token t = first;
+            while (true) {
+              tokens.add(t);
+              if (t == last) break;
+              t = t.next;
+            }
+          }
+  }
+
+  final public void BlockStatement() throws ParseException {
+    if (jj_2_42(2147483647)) {
+      LocalVariableDeclaration();
+      jj_consume_token(SEMICOLON);
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case _LOOKAHEAD:
+      case _IGNORE_CASE:
+      case _PARSER_BEGIN:
+      case _PARSER_END:
+      case _JAVACODE:
+      case _TOKEN:
+      case _SPECIAL_TOKEN:
+      case _MORE:
+      case _SKIP:
+      case _TOKEN_MGR_DECLS:
+      case _EOF:
+      case ASSERT:
+      case BOOLEAN:
+      case BREAK:
+      case BYTE:
+      case CHAR:
+      case CONST:
+      case CONTINUE:
+      case DO:
+      case DOUBLE:
+      case FALSE:
+      case FLOAT:
+      case FOR:
+      case IF:
+      case INT:
+      case LONG:
+      case NEW:
+      case NULL:
+      case RETURN:
+      case SHORT:
+      case SUPER:
+      case SWITCH:
+      case SYNCHRONIZED:
+      case THIS:
+      case THROW:
+      case TRUE:
+      case TRY:
+      case VOID:
+      case WHILE:
+      case TEMPLATE:
+      case INTEGER_LITERAL:
+      case FLOATING_POINT_LITERAL:
+      case CHARACTER_LITERAL:
+      case STRING_LITERAL:
+      case LPAREN:
+      case LBRACE:
+      case SEMICOLON:
+      case DOUBLECOLON:
+      case INCR:
+      case DECR:
+      case 139:
+      case 140:
+      case 141:
+      case 142:
+      case 143:
+      case 144:
+      case IDENTIFIER:
+        Statement();
+        break;
+      case CLASS:
+      case INTERFACE:
+        ClassOrInterfaceDeclaration(0, null);
+        break;
+      default:
+        jj_la1[163] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void LocalVariableDeclaration() throws ParseException {
+    Modifiers();
+    Type();
+    VariableDeclarator();
+    label_54:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[164] = jj_gen;
+        break label_54;
+      }
+      jj_consume_token(COMMA);
+      VariableDeclarator();
+    }
+  }
+
+  final public void EmptyStatement() throws ParseException {
+    jj_consume_token(SEMICOLON);
+  }
+
+  final public void StatementExpression() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case INCR:
+      PreIncrementExpression();
+      break;
+    case DECR:
+      PreDecrementExpression();
+      break;
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _JAVACODE:
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case _TOKEN_MGR_DECLS:
+    case _EOF:
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case CONST:
+    case DOUBLE:
+    case FALSE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case NEW:
+    case NULL:
+    case SHORT:
+    case SUPER:
+    case THIS:
+    case TRUE:
+    case VOID:
+    case TEMPLATE:
+    case INTEGER_LITERAL:
+    case FLOATING_POINT_LITERAL:
+    case CHARACTER_LITERAL:
+    case STRING_LITERAL:
+    case LPAREN:
+    case DOUBLECOLON:
+    case 139:
+    case 140:
+    case 141:
+    case 142:
+    case 143:
+    case 144:
+    case IDENTIFIER:
+      PrimaryExpression();
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case ASSIGN:
+      case INCR:
+      case DECR:
+      case PLUSASSIGN:
+      case MINUSASSIGN:
+      case STARASSIGN:
+      case SLASHASSIGN:
+      case ANDASSIGN:
+      case ORASSIGN:
+      case XORASSIGN:
+      case REMASSIGN:
+      case 146:
+      case 147:
+      case 148:
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case INCR:
+          jj_consume_token(INCR);
+          break;
+        case DECR:
+          jj_consume_token(DECR);
+          break;
+        case ASSIGN:
+        case PLUSASSIGN:
+        case MINUSASSIGN:
+        case STARASSIGN:
+        case SLASHASSIGN:
+        case ANDASSIGN:
+        case ORASSIGN:
+        case XORASSIGN:
+        case REMASSIGN:
+        case 146:
+        case 147:
+        case 148:
+          AssignmentOperator();
+          Expression(null);
+          break;
+        default:
+          jj_la1[165] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+        break;
+      default:
+        jj_la1[166] = jj_gen;
+        ;
+      }
+      break;
+    default:
+      jj_la1[167] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void SwitchStatement() throws ParseException {
+    jj_consume_token(SWITCH);
+    jj_consume_token(LPAREN);
+    Expression(null);
+    jj_consume_token(RPAREN);
+    jj_consume_token(LBRACE);
+    label_55:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case CASE:
+      case _DEFAULT:
+        ;
+        break;
+      default:
+        jj_la1[168] = jj_gen;
+        break label_55;
+      }
+      SwitchLabel();
+      label_56:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case _LOOKAHEAD:
+        case _IGNORE_CASE:
+        case _PARSER_BEGIN:
+        case _PARSER_END:
+        case _JAVACODE:
+        case _TOKEN:
+        case _SPECIAL_TOKEN:
+        case _MORE:
+        case _SKIP:
+        case _TOKEN_MGR_DECLS:
+        case _EOF:
+        case ABSTRACT:
+        case ASSERT:
+        case BOOLEAN:
+        case BREAK:
+        case BYTE:
+        case CHAR:
+        case CLASS:
+        case CONST:
+        case CONTINUE:
+        case DO:
+        case DOUBLE:
+        case FALSE:
+        case FINAL:
+        case FLOAT:
+        case FOR:
+        case IF:
+        case INT:
+        case INTERFACE:
+        case LONG:
+        case NATIVE:
+        case NEW:
+        case NULL:
+        case PRIVATE:
+        case PROTECTED:
+        case PUBLIC:
+        case RETURN:
+        case SHORT:
+        case STATIC:
+        case STRICTFP:
+        case SUPER:
+        case SWITCH:
+        case SYNCHRONIZED:
+        case THIS:
+        case THROW:
+        case TRANSIENT:
+        case TRUE:
+        case TRY:
+        case VOID:
+        case VOLATILE:
+        case WHILE:
+        case TEMPLATE:
+        case INTEGER_LITERAL:
+        case FLOATING_POINT_LITERAL:
+        case CHARACTER_LITERAL:
+        case STRING_LITERAL:
+        case LPAREN:
+        case LBRACE:
+        case SEMICOLON:
+        case DOUBLECOLON:
+        case INCR:
+        case DECR:
+        case 139:
+        case 140:
+        case 141:
+        case 142:
+        case 143:
+        case 144:
+        case 150:
+        case IDENTIFIER:
+          ;
+          break;
+        default:
+          jj_la1[169] = jj_gen;
+          break label_56;
+        }
+        BlockStatement();
+      }
+    }
+    jj_consume_token(RBRACE);
+  }
+
+  final public void SwitchLabel() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case CASE:
+      jj_consume_token(CASE);
+      Expression(null);
+      jj_consume_token(COLON);
+      break;
+    case _DEFAULT:
+      jj_consume_token(_DEFAULT);
+      jj_consume_token(COLON);
+      break;
+    default:
+      jj_la1[170] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void IfStatement() throws ParseException {
+    jj_consume_token(IF);
+    jj_consume_token(LPAREN);
+    Expression(null);
+    jj_consume_token(RPAREN);
+    Statement();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case ELSE:
+      jj_consume_token(ELSE);
+      Statement();
+      break;
+    default:
+      jj_la1[171] = jj_gen;
+      ;
+    }
+  }
+
+  final public void WhileStatement() throws ParseException {
+    jj_consume_token(WHILE);
+    jj_consume_token(LPAREN);
+    Expression(null);
+    jj_consume_token(RPAREN);
+    Statement();
+  }
+
+  final public void DoStatement() throws ParseException {
+    jj_consume_token(DO);
+    Statement();
+    jj_consume_token(WHILE);
+    jj_consume_token(LPAREN);
+    Expression(null);
+    jj_consume_token(RPAREN);
+    jj_consume_token(SEMICOLON);
+  }
+
+  final public void ForStatement() throws ParseException {
+    jj_consume_token(FOR);
+    jj_consume_token(LPAREN);
+    if (jj_2_43(2147483647)) {
+      Modifiers();
+      Type();
+      JavaIdentifier();
+      jj_consume_token(COLON);
+      Expression(null);
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case _LOOKAHEAD:
+      case _IGNORE_CASE:
+      case _PARSER_BEGIN:
+      case _PARSER_END:
+      case _JAVACODE:
+      case _TOKEN:
+      case _SPECIAL_TOKEN:
+      case _MORE:
+      case _SKIP:
+      case _TOKEN_MGR_DECLS:
+      case _EOF:
+      case ABSTRACT:
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case CONST:
+      case DOUBLE:
+      case FALSE:
+      case FINAL:
+      case FLOAT:
+      case INT:
+      case LONG:
+      case NATIVE:
+      case NEW:
+      case NULL:
+      case PRIVATE:
+      case PROTECTED:
+      case PUBLIC:
+      case SHORT:
+      case STATIC:
+      case STRICTFP:
+      case SUPER:
+      case SYNCHRONIZED:
+      case THIS:
+      case TRANSIENT:
+      case TRUE:
+      case VOID:
+      case VOLATILE:
+      case TEMPLATE:
+      case INTEGER_LITERAL:
+      case FLOATING_POINT_LITERAL:
+      case CHARACTER_LITERAL:
+      case STRING_LITERAL:
+      case LPAREN:
+      case SEMICOLON:
+      case DOUBLECOLON:
+      case INCR:
+      case DECR:
+      case 139:
+      case 140:
+      case 141:
+      case 142:
+      case 143:
+      case 144:
+      case 150:
+      case IDENTIFIER:
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case _LOOKAHEAD:
+        case _IGNORE_CASE:
+        case _PARSER_BEGIN:
+        case _PARSER_END:
+        case _JAVACODE:
+        case _TOKEN:
+        case _SPECIAL_TOKEN:
+        case _MORE:
+        case _SKIP:
+        case _TOKEN_MGR_DECLS:
+        case _EOF:
+        case ABSTRACT:
+        case BOOLEAN:
+        case BYTE:
+        case CHAR:
+        case CONST:
+        case DOUBLE:
+        case FALSE:
+        case FINAL:
+        case FLOAT:
+        case INT:
+        case LONG:
+        case NATIVE:
+        case NEW:
+        case NULL:
+        case PRIVATE:
+        case PROTECTED:
+        case PUBLIC:
+        case SHORT:
+        case STATIC:
+        case STRICTFP:
+        case SUPER:
+        case SYNCHRONIZED:
+        case THIS:
+        case TRANSIENT:
+        case TRUE:
+        case VOID:
+        case VOLATILE:
+        case TEMPLATE:
+        case INTEGER_LITERAL:
+        case FLOATING_POINT_LITERAL:
+        case CHARACTER_LITERAL:
+        case STRING_LITERAL:
+        case LPAREN:
+        case DOUBLECOLON:
+        case INCR:
+        case DECR:
+        case 139:
+        case 140:
+        case 141:
+        case 142:
+        case 143:
+        case 144:
+        case 150:
+        case IDENTIFIER:
+          ForInit();
+          break;
+        default:
+          jj_la1[172] = jj_gen;
+          ;
+        }
+        jj_consume_token(SEMICOLON);
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case _LOOKAHEAD:
+        case _IGNORE_CASE:
+        case _PARSER_BEGIN:
+        case _PARSER_END:
+        case _JAVACODE:
+        case _TOKEN:
+        case _SPECIAL_TOKEN:
+        case _MORE:
+        case _SKIP:
+        case _TOKEN_MGR_DECLS:
+        case _EOF:
+        case BOOLEAN:
+        case BYTE:
+        case CHAR:
+        case CONST:
+        case DOUBLE:
+        case FALSE:
+        case FLOAT:
+        case INT:
+        case LONG:
+        case NEW:
+        case NULL:
+        case SHORT:
+        case SUPER:
+        case THIS:
+        case TRUE:
+        case VOID:
+        case TEMPLATE:
+        case INTEGER_LITERAL:
+        case FLOATING_POINT_LITERAL:
+        case CHARACTER_LITERAL:
+        case STRING_LITERAL:
+        case LPAREN:
+        case BANG:
+        case TILDE:
+        case DOUBLECOLON:
+        case INCR:
+        case DECR:
+        case PLUS:
+        case MINUS:
+        case 139:
+        case 140:
+        case 141:
+        case 142:
+        case 143:
+        case 144:
+        case IDENTIFIER:
+          Expression(null);
+          break;
+        default:
+          jj_la1[173] = jj_gen;
+          ;
+        }
+        jj_consume_token(SEMICOLON);
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case _LOOKAHEAD:
+        case _IGNORE_CASE:
+        case _PARSER_BEGIN:
+        case _PARSER_END:
+        case _JAVACODE:
+        case _TOKEN:
+        case _SPECIAL_TOKEN:
+        case _MORE:
+        case _SKIP:
+        case _TOKEN_MGR_DECLS:
+        case _EOF:
+        case BOOLEAN:
+        case BYTE:
+        case CHAR:
+        case CONST:
+        case DOUBLE:
+        case FALSE:
+        case FLOAT:
+        case INT:
+        case LONG:
+        case NEW:
+        case NULL:
+        case SHORT:
+        case SUPER:
+        case THIS:
+        case TRUE:
+        case VOID:
+        case TEMPLATE:
+        case INTEGER_LITERAL:
+        case FLOATING_POINT_LITERAL:
+        case CHARACTER_LITERAL:
+        case STRING_LITERAL:
+        case LPAREN:
+        case DOUBLECOLON:
+        case INCR:
+        case DECR:
+        case 139:
+        case 140:
+        case 141:
+        case 142:
+        case 143:
+        case 144:
+        case IDENTIFIER:
+          ForUpdate();
+          break;
+        default:
+          jj_la1[174] = jj_gen;
+          ;
+        }
+        break;
+      default:
+        jj_la1[175] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+    jj_consume_token(RPAREN);
+    Statement();
+  }
+
+  final public void ForInit() throws ParseException {
+    if (jj_2_44(2147483647)) {
+      LocalVariableDeclaration();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case _LOOKAHEAD:
+      case _IGNORE_CASE:
+      case _PARSER_BEGIN:
+      case _PARSER_END:
+      case _JAVACODE:
+      case _TOKEN:
+      case _SPECIAL_TOKEN:
+      case _MORE:
+      case _SKIP:
+      case _TOKEN_MGR_DECLS:
+      case _EOF:
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case CONST:
+      case DOUBLE:
+      case FALSE:
+      case FLOAT:
+      case INT:
+      case LONG:
+      case NEW:
+      case NULL:
+      case SHORT:
+      case SUPER:
+      case THIS:
+      case TRUE:
+      case VOID:
+      case TEMPLATE:
+      case INTEGER_LITERAL:
+      case FLOATING_POINT_LITERAL:
+      case CHARACTER_LITERAL:
+      case STRING_LITERAL:
+      case LPAREN:
+      case DOUBLECOLON:
+      case INCR:
+      case DECR:
+      case 139:
+      case 140:
+      case 141:
+      case 142:
+      case 143:
+      case 144:
+      case IDENTIFIER:
+        StatementExpressionList();
+        break;
+      default:
+        jj_la1[176] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void StatementExpressionList() throws ParseException {
+    StatementExpression();
+    label_57:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[177] = jj_gen;
+        break label_57;
+      }
+      jj_consume_token(COMMA);
+      StatementExpression();
+    }
+  }
+
+  final public void ForUpdate() throws ParseException {
+    StatementExpressionList();
+  }
+
+  final public void BreakStatement() throws ParseException {
+    jj_consume_token(BREAK);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _JAVACODE:
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case _TOKEN_MGR_DECLS:
+    case _EOF:
+    case TEMPLATE:
+    case 139:
+    case 140:
+    case 141:
+    case 142:
+    case 143:
+    case 144:
+    case IDENTIFIER:
+      JavaIdentifier();
+      break;
+    default:
+      jj_la1[178] = jj_gen;
+      ;
+    }
+    jj_consume_token(SEMICOLON);
+  }
+
+  final public void ContinueStatement() throws ParseException {
+    jj_consume_token(CONTINUE);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _JAVACODE:
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case _TOKEN_MGR_DECLS:
+    case _EOF:
+    case TEMPLATE:
+    case 139:
+    case 140:
+    case 141:
+    case 142:
+    case 143:
+    case 144:
+    case IDENTIFIER:
+      JavaIdentifier();
+      break;
+    default:
+      jj_la1[179] = jj_gen;
+      ;
+    }
+    jj_consume_token(SEMICOLON);
+  }
+
+  final public void ReturnStatement() throws ParseException {
+          Token t;
+    t = jj_consume_token(RETURN);
+          // Add if statement to prevent subsequent code generated
+          // from being dead code.
+          // NB: eclipse now detects 'if (true)' as dead code, so use the more complicated
+          // 'if ("" != null)'
+          if (inAction  && (Options.isLegacyExceptionHandling()) ) {
+            t.image = "{if (\"\" != null) return";
+            jumpPatched = true;
+          }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _JAVACODE:
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case _TOKEN_MGR_DECLS:
+    case _EOF:
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case CONST:
+    case DOUBLE:
+    case FALSE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case NEW:
+    case NULL:
+    case SHORT:
+    case SUPER:
+    case THIS:
+    case TRUE:
+    case VOID:
+    case TEMPLATE:
+    case INTEGER_LITERAL:
+    case FLOATING_POINT_LITERAL:
+    case CHARACTER_LITERAL:
+    case STRING_LITERAL:
+    case LPAREN:
+    case BANG:
+    case TILDE:
+    case DOUBLECOLON:
+    case INCR:
+    case DECR:
+    case PLUS:
+    case MINUS:
+    case 139:
+    case 140:
+    case 141:
+    case 142:
+    case 143:
+    case 144:
+    case IDENTIFIER:
+      Expression(null);
+      break;
+    default:
+      jj_la1[180] = jj_gen;
+      ;
+    }
+    t = jj_consume_token(SEMICOLON);
+          // Add closing brace for above if statement.
+          if (inAction && (Options.isLegacyExceptionHandling())) {
+            t.image = ";}";
+          }
+  }
+
+  final public void ThrowStatement() throws ParseException {
+          Token t;
+    t = jj_consume_token(THROW);
+          // Add if statement to prevent subsequent code generated
+          // from being dead code.
+          if (inAction) {
+            t.image = "{if (true) throw";
+            jumpPatched = true;
+          }
+    Expression(null);
+    t = jj_consume_token(SEMICOLON);
+          // Add closing brace for above if statement.
+          if (inAction) {
+            t.image = ";}";
+          }
+  }
+
+  final public void SynchronizedStatement() throws ParseException {
+    jj_consume_token(SYNCHRONIZED);
+    jj_consume_token(LPAREN);
+    Expression(null);
+    jj_consume_token(RPAREN);
+    Block(null);
+  }
+
+  final public void ResourceDeclaration() throws ParseException {
+    Type();
+    VariableDeclaratorId();
+    jj_consume_token(ASSIGN);
+    Expression(null);
+  }
+
+  final public void CatchParameter() throws ParseException {
+  Token t;
+    Modifiers();
+    Type();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case STAR:
+    case BIT_AND:
+    case 145:
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case STAR:
+      case BIT_AND:
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case BIT_AND:
+          t = jj_consume_token(BIT_AND);
+          break;
+        case STAR:
+          t = jj_consume_token(STAR);
+          break;
+        default:
+          jj_la1[181] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+                           if (!isAllowed(t)) {if (true) throw new ParseException(t.image + " is invalid in this context");}
+        break;
+      case 145:
+        jj_consume_token(145);
+        break;
+      default:
+        jj_la1[182] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      break;
+    default:
+      jj_la1[183] = jj_gen;
+      ;
+    }
+    label_58:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case BIT_OR:
+        ;
+        break;
+      default:
+        jj_la1[184] = jj_gen;
+        break label_58;
+      }
+      jj_consume_token(BIT_OR);
+      Type();
+    }
+    VariableDeclaratorId();
+  }
+
+  final public void TryStatement() throws ParseException {
+  boolean empty = true;
+    jj_consume_token(TRY);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case LPAREN:
+      jj_consume_token(LPAREN);
+      ResourceDeclaration();
+      label_59:
+      while (true) {
+        if (jj_2_45(2)) {
+          ;
+        } else {
+          break label_59;
+        }
+        jj_consume_token(SEMICOLON);
+        ResourceDeclaration();
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case SEMICOLON:
+        jj_consume_token(SEMICOLON);
+        break;
+      default:
+        jj_la1[185] = jj_gen;
+        ;
+      }
+      jj_consume_token(RPAREN);
+                                                                empty = false;
+      break;
+    default:
+      jj_la1[186] = jj_gen;
+      ;
+    }
+    Block(null);
+    label_60:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case CATCH:
+        ;
+        break;
+      default:
+        jj_la1[187] = jj_gen;
+        break label_60;
+      }
+      jj_consume_token(CATCH);
+      jj_consume_token(LPAREN);
+      CatchParameter();
+      jj_consume_token(RPAREN);
+      Block(null);
+                                                   empty = false;
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case FINALLY:
+      jj_consume_token(FINALLY);
+      Block(null);
+                            empty = false;
+      break;
+    default:
+      jj_la1[188] = jj_gen;
+      ;
+    }
+  if (empty)
+      {if (true) throw new ParseException("At least one catch or finally block expected.");}
+  }
+
+/* We use productions to match >>>, >> and > so that we can keep the
+ * type declaration syntax with generics clean
+ */
+  final public void RUNSIGNEDSHIFT() throws ParseException {
+    if (getToken(1).kind == GT &&
+                    ((Token.GTToken)getToken(1)).realKind == RUNSIGNEDSHIFT) {
+
+    } else {
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    jj_consume_token(RANGLE);
+    jj_consume_token(RANGLE);
+    jj_consume_token(RANGLE);
+  }
+
+  final public void RSIGNEDSHIFT() throws ParseException {
+    if (getToken(1).kind == GT &&
+                    ((Token.GTToken)getToken(1)).realKind == RSIGNEDSHIFT) {
+
+    } else {
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    jj_consume_token(RANGLE);
+    jj_consume_token(RANGLE);
+  }
+
+/* Annotation syntax follows. */
+  final public void Annotation() throws ParseException {
+    if (jj_2_46(2147483647)) {
+      NormalAnnotation();
+    } else if (jj_2_47(2147483647)) {
+      SingleMemberAnnotation();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case 150:
+        MarkerAnnotation();
+        break;
+      default:
+        jj_la1[189] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void NormalAnnotation() throws ParseException {
+    jj_consume_token(150);
+    Name(null);
+    jj_consume_token(LPAREN);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _JAVACODE:
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case _TOKEN_MGR_DECLS:
+    case _EOF:
+    case TEMPLATE:
+    case 139:
+    case 140:
+    case 141:
+    case 142:
+    case 143:
+    case 144:
+    case IDENTIFIER:
+      MemberValuePairs();
+      break;
+    default:
+      jj_la1[190] = jj_gen;
+      ;
+    }
+    jj_consume_token(RPAREN);
+  }
+
+  final public void MarkerAnnotation() throws ParseException {
+    jj_consume_token(150);
+    Name(null);
+  }
+
+  final public void SingleMemberAnnotation() throws ParseException {
+    jj_consume_token(150);
+    Name(null);
+    jj_consume_token(LPAREN);
+    MemberValue();
+    jj_consume_token(RPAREN);
+  }
+
+  final public void MemberValuePairs() throws ParseException {
+    MemberValuePair();
+    label_61:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[191] = jj_gen;
+        break label_61;
+      }
+      jj_consume_token(COMMA);
+      MemberValuePair();
+    }
+  }
+
+  final public void MemberValuePair() throws ParseException {
+    JavaIdentifier();
+    jj_consume_token(ASSIGN);
+    MemberValue();
+  }
+
+  final public void MemberValue() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case 150:
+      Annotation();
+      break;
+    case LBRACE:
+      MemberValueArrayInitializer();
+      break;
+    case _LOOKAHEAD:
+    case _IGNORE_CASE:
+    case _PARSER_BEGIN:
+    case _PARSER_END:
+    case _JAVACODE:
+    case _TOKEN:
+    case _SPECIAL_TOKEN:
+    case _MORE:
+    case _SKIP:
+    case _TOKEN_MGR_DECLS:
+    case _EOF:
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case CONST:
+    case DOUBLE:
+    case FALSE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case NEW:
+    case NULL:
+    case SHORT:
+    case SUPER:
+    case THIS:
+    case TRUE:
+    case VOID:
+    case TEMPLATE:
+    case INTEGER_LITERAL:
+    case FLOATING_POINT_LITERAL:
+    case CHARACTER_LITERAL:
+    case STRING_LITERAL:
+    case LPAREN:
+    case BANG:
+    case TILDE:
+    case DOUBLECOLON:
+    case INCR:
+    case DECR:
+    case PLUS:
+    case MINUS:
+    case 139:
+    case 140:
+    case 141:
+    case 142:
+    case 143:
+    case 144:
+    case IDENTIFIER:
+      ConditionalExpression();
+      break;
+    default:
+      jj_la1[192] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void MemberValueArrayInitializer() throws ParseException {
+    jj_consume_token(LBRACE);
+    MemberValue();
+    label_62:
+    while (true) {
+      if (jj_2_48(2)) {
+        ;
+      } else {
+        break label_62;
+      }
+      jj_consume_token(COMMA);
+      MemberValue();
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case COMMA:
+      jj_consume_token(COMMA);
+      break;
+    default:
+      jj_la1[193] = jj_gen;
+      ;
+    }
+    jj_consume_token(RBRACE);
+  }
+
+/* Annotation Types. */
+  final public void AnnotationTypeDeclaration(int modifiers) throws ParseException {
+    jj_consume_token(150);
+    jj_consume_token(INTERFACE);
+    JavaIdentifier();
+    AnnotationTypeBody();
+  }
+
+  final public void AnnotationTypeBody() throws ParseException {
+    jj_consume_token(LBRACE);
+    label_63:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case ABSTRACT:
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case CLASS:
+      case DOUBLE:
+      case ENUM:
+      case FINAL:
+      case FLOAT:
+      case INT:
+      case INTERFACE:
+      case LONG:
+      case NATIVE:
+      case PRIVATE:
+      case PROTECTED:
+      case PUBLIC:
+      case SHORT:
+      case STATIC:
+      case STRICTFP:
+      case SYNCHRONIZED:
+      case TRANSIENT:
+      case VOLATILE:
+      case TEMPLATE:
+      case SEMICOLON:
+      case DOUBLECOLON:
+      case 150:
+      case IDENTIFIER:
+        ;
+        break;
+      default:
+        jj_la1[194] = jj_gen;
+        break label_63;
+      }
+      AnnotationTypeMemberDeclaration();
+    }
+    jj_consume_token(RBRACE);
+  }
+
+  final public void AnnotationTypeMemberDeclaration() throws ParseException {
+   int modifiers;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case ABSTRACT:
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case CLASS:
+    case DOUBLE:
+    case ENUM:
+    case FINAL:
+    case FLOAT:
+    case INT:
+    case INTERFACE:
+    case LONG:
+    case NATIVE:
+    case PRIVATE:
+    case PROTECTED:
+    case PUBLIC:
+    case SHORT:
+    case STATIC:
+    case STRICTFP:
+    case SYNCHRONIZED:
+    case TRANSIENT:
+    case VOLATILE:
+    case TEMPLATE:
+    case DOUBLECOLON:
+    case 150:
+    case IDENTIFIER:
+      modifiers = Modifiers();
+      if (jj_2_49(2147483647)) {
+        Type();
+        JavaIdentifier();
+        jj_consume_token(LPAREN);
+        jj_consume_token(RPAREN);
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case _DEFAULT:
+          DefaultValue();
+          break;
+        default:
+          jj_la1[195] = jj_gen;
+          ;
+        }
+        jj_consume_token(SEMICOLON);
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case CLASS:
+        case INTERFACE:
+          ClassOrInterfaceDeclaration(modifiers, null);
+          break;
+        case ENUM:
+          EnumDeclaration(modifiers);
+          break;
+        case 150:
+          AnnotationTypeDeclaration(modifiers);
+          break;
+        case BOOLEAN:
+        case BYTE:
+        case CHAR:
+        case DOUBLE:
+        case FLOAT:
+        case INT:
+        case LONG:
+        case SHORT:
+        case TEMPLATE:
+        case DOUBLECOLON:
+        case IDENTIFIER:
+          FieldDeclaration(modifiers);
+          break;
+        default:
+          jj_la1[196] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+      break;
+    case SEMICOLON:
+      jj_consume_token(SEMICOLON);
+      break;
+    default:
+      jj_la1[197] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void DefaultValue() throws ParseException {
+    jj_consume_token(_DEFAULT);
+    MemberValue();
+  }
+
+  private boolean jj_2_1(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_1(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(0, xla); }
+  }
+
+  private boolean jj_2_2(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_2(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(1, xla); }
+  }
+
+  private boolean jj_2_3(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_3(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(2, xla); }
+  }
+
+  private boolean jj_2_4(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_4(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(3, xla); }
+  }
+
+  private boolean jj_2_5(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_5(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(4, xla); }
+  }
+
+  private boolean jj_2_6(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_6(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(5, xla); }
+  }
+
+  private boolean jj_2_7(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_7(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(6, xla); }
+  }
+
+  private boolean jj_2_8(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_8(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(7, xla); }
+  }
+
+  private boolean jj_2_9(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_9(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(8, xla); }
+  }
+
+  private boolean jj_2_10(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_10(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(9, xla); }
+  }
+
+  private boolean jj_2_11(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_11(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(10, xla); }
+  }
+
+  private boolean jj_2_12(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_12(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(11, xla); }
+  }
+
+  private boolean jj_2_13(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_13(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(12, xla); }
+  }
+
+  private boolean jj_2_14(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_14(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(13, xla); }
+  }
+
+  private boolean jj_2_15(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_15(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(14, xla); }
+  }
+
+  private boolean jj_2_16(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_16(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(15, xla); }
+  }
+
+  private boolean jj_2_17(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_17(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(16, xla); }
+  }
+
+  private boolean jj_2_18(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_18(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(17, xla); }
+  }
+
+  private boolean jj_2_19(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_19(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(18, xla); }
+  }
+
+  private boolean jj_2_20(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_20(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(19, xla); }
+  }
+
+  private boolean jj_2_21(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_21(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(20, xla); }
+  }
+
+  private boolean jj_2_22(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_22(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(21, xla); }
+  }
+
+  private boolean jj_2_23(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_23(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(22, xla); }
+  }
+
+  private boolean jj_2_24(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_24(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(23, xla); }
+  }
+
+  private boolean jj_2_25(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_25(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(24, xla); }
+  }
+
+  private boolean jj_2_26(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_26(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(25, xla); }
+  }
+
+  private boolean jj_2_27(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_27(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(26, xla); }
+  }
+
+  private boolean jj_2_28(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_28(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(27, xla); }
+  }
+
+  private boolean jj_2_29(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_29(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(28, xla); }
+  }
+
+  private boolean jj_2_30(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_30(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(29, xla); }
+  }
+
+  private boolean jj_2_31(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_31(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(30, xla); }
+  }
+
+  private boolean jj_2_32(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_32(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(31, xla); }
+  }
+
+  private boolean jj_2_33(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_33(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(32, xla); }
+  }
+
+  private boolean jj_2_34(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_34(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(33, xla); }
+  }
+
+  private boolean jj_2_35(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_35(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(34, xla); }
+  }
+
+  private boolean jj_2_36(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_36(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(35, xla); }
+  }
+
+  private boolean jj_2_37(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_37(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(36, xla); }
+  }
+
+  private boolean jj_2_38(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_38(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(37, xla); }
+  }
+
+  private boolean jj_2_39(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_39(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(38, xla); }
+  }
+
+  private boolean jj_2_40(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_40(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(39, xla); }
+  }
+
+  private boolean jj_2_41(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_41(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(40, xla); }
+  }
+
+  private boolean jj_2_42(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_42(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(41, xla); }
+  }
+
+  private boolean jj_2_43(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_43(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(42, xla); }
+  }
+
+  private boolean jj_2_44(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_44(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(43, xla); }
+  }
+
+  private boolean jj_2_45(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_45(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(44, xla); }
+  }
+
+  private boolean jj_2_46(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_46(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(45, xla); }
+  }
+
+  private boolean jj_2_47(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_47(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(46, xla); }
+  }
+
+  private boolean jj_2_48(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_48(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(47, xla); }
+  }
+
+  private boolean jj_2_49(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_49(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(48, xla); }
+  }
+
+  private boolean jj_3R_281() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(105)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(137)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(112)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(113)) return true;
+    }
+    }
+    }
+    if (jj_3R_267()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_275() {
+    if (jj_scan_token(INSTANCEOF)) return true;
+    if (jj_3R_88()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_280() {
+    if (jj_3R_298()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_321()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_211() {
+    if (jj_3R_237()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_268() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(111)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(114)) return true;
+    }
+    if (jj_3R_259()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_274() {
+    if (jj_3R_280()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_312()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_210() {
+    if (jj_scan_token(TILDE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_197() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_210()) jj_scanpos = xsp;
+    if (jj_scan_token(LBRACKET)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_211()) jj_scanpos = xsp;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_267() {
+    if (jj_3R_274()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_25()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_265() {
+    if (jj_scan_token(BIT_AND)) return true;
+    if (jj_3R_252()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_264() {
+    if (jj_3R_267()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_281()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_253() {
+    if (jj_scan_token(BIT_OR)) return true;
+    if (jj_3R_203()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_259() {
+    if (jj_3R_264()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_275()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_260() {
+    if (jj_scan_token(XOR)) return true;
+    if (jj_3R_231()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_232() {
+    if (jj_scan_token(SC_AND)) return true;
+    if (jj_3R_189()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_252() {
+    if (jj_3R_259()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_268()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_206() {
+    if (jj_scan_token(SC_OR)) return true;
+    if (jj_3R_178()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_231() {
+    if (jj_3R_252()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_265()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_191() {
+    if (jj_scan_token(HOOK)) return true;
+    if (jj_3R_97()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_97()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_203() {
+    if (jj_3R_231()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_260()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_189() {
+    if (jj_3R_203()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_253()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_183() {
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_71()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_178() {
+    if (jj_3R_189()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_232()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_182() {
+    if (jj_3R_197()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_181() {
+    if (jj_scan_token(LANGLE)) return true;
+    if (jj_3R_65()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_161() {
+    if (jj_3R_178()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_206()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_168() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_180()) {
+    jj_scanpos = xsp;
+    if (jj_3R_181()) {
+    jj_scanpos = xsp;
+    if (jj_3R_182()) {
+    jj_scanpos = xsp;
+    if (jj_3R_183()) return true;
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_180() {
+    if (jj_3R_113()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_129() {
+    if (jj_3R_161()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_191()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_96() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(104)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(129)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(130)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(134)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(127)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(128)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(146)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(147)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(148)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(131)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(133)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(132)) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3_24() {
+    if (jj_3R_96()) return true;
+    if (jj_3R_97()) return true;
+    return false;
+  }
+
+  private boolean jj_3_49() {
+    if (jj_3R_88()) return true;
+    if (jj_3R_87()) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_97() {
+    if (jj_3R_129()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_24()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_149() {
+    if (jj_3R_168()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_115() {
+    Token xsp;
+    if (jj_3R_149()) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_149()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_318() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_109()) return true;
+    return false;
+  }
+
+  private boolean jj_3_48() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_111()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_304() {
+    if (jj_3R_109()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_318()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_116() {
+    if (jj_scan_token(BIT_OR)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_71() {
+    if (jj_3R_115()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_116()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_165() {
+    if (jj_scan_token(LBRACE)) return true;
+    if (jj_3R_111()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_48()) { jj_scanpos = xsp; break; }
+    }
+    xsp = jj_scanpos;
+    if (jj_scan_token(102)) jj_scanpos = xsp;
+    if (jj_scan_token(RBRACE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_213() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_212()) return true;
+    return false;
+  }
+
+  private boolean jj_3_23() {
+    if (jj_scan_token(DOT)) return true;
+    if (jj_3R_87()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_142() {
+    if (jj_3R_129()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_109() {
+    if (jj_3R_87()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_23()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_141() {
+    if (jj_3R_165()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_140() {
+    if (jj_3R_117()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_111() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_140()) {
+    jj_scanpos = xsp;
+    if (jj_3R_141()) {
+    jj_scanpos = xsp;
+    if (jj_3R_142()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_212() {
+    if (jj_3R_87()) return true;
+    if (jj_scan_token(ASSIGN)) return true;
+    if (jj_3R_111()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_164() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(121)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(123)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_184() {
+    if (jj_3R_198()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_110() {
+    if (jj_3R_87()) return true;
+    if (jj_scan_token(ASSIGN)) return true;
+    return false;
+  }
+
+  private boolean jj_3_6() {
+    if (jj_scan_token(LANGLE)) return true;
+    if (jj_3R_65()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_198() {
+    if (jj_3R_212()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_213()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_170() {
+    if (jj_scan_token(150)) return true;
+    if (jj_3R_109()) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_111()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_171() {
+    if (jj_scan_token(150)) return true;
+    if (jj_3R_109()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_138() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(37)) jj_scanpos = xsp;
+    if (jj_3R_88()) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_164()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3_47() {
+    if (jj_scan_token(150)) return true;
+    if (jj_3R_109()) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_137() {
+    if (jj_scan_token(VOID)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(121)) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_169() {
+    if (jj_scan_token(150)) return true;
+    if (jj_3R_109()) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_184()) jj_scanpos = xsp;
+    if (jj_scan_token(RPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3_46() {
+    if (jj_scan_token(150)) return true;
+    if (jj_3R_109()) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_110()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(96)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_114() {
+    if (jj_scan_token(138)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_103() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_137()) {
+    jj_scanpos = xsp;
+    if (jj_3R_138()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_70() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_114()) jj_scanpos = xsp;
+    if (jj_3R_65()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_152() {
+    if (jj_3R_171()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_151() {
+    if (jj_3R_170()) return true;
+    return false;
+  }
+
+  private boolean jj_3_5() {
+    if (jj_scan_token(LANGLE)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_70()) jj_scanpos = xsp;
+    if (jj_3R_71()) return true;
+    if (jj_scan_token(RANGLE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_130() {
+    return false;
+  }
+
+  private boolean jj_3R_117() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_150()) {
+    jj_scanpos = xsp;
+    if (jj_3R_151()) {
+    jj_scanpos = xsp;
+    if (jj_3R_152()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_150() {
+    if (jj_3R_169()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_131() {
+    return false;
+  }
+
+  private boolean jj_3R_66() {
+    if (jj_3R_95()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_98() {
+    jj_lookingAhead = true;
+    jj_semLA = getToken(1).kind == GT &&
+                ((Token.GTToken)getToken(1)).realKind == RSIGNEDSHIFT;
+    jj_lookingAhead = false;
+    if (!jj_semLA || jj_3R_130()) return true;
+    if (jj_scan_token(RANGLE)) return true;
+    if (jj_scan_token(RANGLE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_101() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(30)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(35)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(32)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(66)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(55)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(57)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(48)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(41)) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3_22() {
+    if (jj_3R_95()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_236() {
+    if (jj_scan_token(SUPER)) return true;
+    if (jj_3R_94()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_196() {
+    if (jj_3R_209()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_209() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_235()) {
+    jj_scanpos = xsp;
+    if (jj_3R_236()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_235() {
+    if (jj_scan_token(EXTENDS)) return true;
+    if (jj_3R_94()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_99() {
+    jj_lookingAhead = true;
+    jj_semLA = getToken(1).kind == GT &&
+                ((Token.GTToken)getToken(1)).realKind == RUNSIGNEDSHIFT;
+    jj_lookingAhead = false;
+    if (!jj_semLA || jj_3R_131()) return true;
+    if (jj_scan_token(RANGLE)) return true;
+    if (jj_scan_token(RANGLE)) return true;
+    if (jj_scan_token(RANGLE)) return true;
+    return false;
+  }
+
+  private boolean jj_3_3() {
+    if (jj_3R_65()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_66()) jj_scanpos = xsp;
+    if (jj_scan_token(LPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_177() {
+    if (jj_scan_token(HOOK)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_196()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_160() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_176()) {
+    jj_scanpos = xsp;
+    if (jj_3R_177()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_167() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_160()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(145)) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_176() {
+    if (jj_3R_94()) return true;
+    return false;
+  }
+
+  private boolean jj_3_45() {
+    if (jj_scan_token(SEMICOLON)) return true;
+    if (jj_3R_108()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_342() {
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_108()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_45()) { jj_scanpos = xsp; break; }
+    }
+    xsp = jj_scanpos;
+    if (jj_scan_token(101)) jj_scanpos = xsp;
+    if (jj_scan_token(RPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_344() {
+    if (jj_scan_token(FINALLY)) return true;
+    if (jj_3R_120()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_343() {
+    if (jj_scan_token(CATCH)) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_351()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_3R_120()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_251() {
+    if (jj_scan_token(TRY)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_342()) jj_scanpos = xsp;
+    if (jj_3R_120()) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_343()) { jj_scanpos = xsp; break; }
+    }
+    xsp = jj_scanpos;
+    if (jj_3R_344()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3_20() {
+    if (jj_3R_95()) return true;
+    return false;
+  }
+
+  private boolean jj_3_19() {
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_215() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_214()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_128() {
+    if (jj_3R_160()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_167()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_359() {
+    if (jj_scan_token(BIT_OR)) return true;
+    if (jj_3R_88()) return true;
+    return false;
+  }
+
+  private boolean jj_3_2() {
+    if (jj_3R_64()) return true;
+    if (jj_scan_token(ASSIGN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_95() {
+    if (jj_scan_token(LANGLE)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_128()) jj_scanpos = xsp;
+    if (jj_scan_token(RANGLE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_363() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(123)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(121)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_358() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_363()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(145)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_351() {
+    if (jj_3R_107()) return true;
+    if (jj_3R_88()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_358()) jj_scanpos = xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_359()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_3R_305()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_108() {
+    if (jj_3R_88()) return true;
+    if (jj_3R_305()) return true;
+    if (jj_scan_token(ASSIGN)) return true;
+    if (jj_3R_97()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_69() {
+    if (jj_3R_64()) return true;
+    if (jj_scan_token(ASSIGN)) return true;
+    return false;
+  }
+
+  private boolean jj_3_21() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(103)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(110)) return true;
+    }
+    if (jj_scan_token(IDENTIFIER)) return true;
+    xsp = jj_scanpos;
+    if (jj_3_22()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_159() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(110)) jj_scanpos = xsp;
+    if (jj_scan_token(IDENTIFIER)) return true;
+    xsp = jj_scanpos;
+    if (jj_3_20()) jj_scanpos = xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_21()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_238() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(36)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(82)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_250() {
+    if (jj_scan_token(SYNCHRONIZED)) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_97()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_3R_120()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_68() {
+    if (jj_3R_113()) return true;
+    return false;
+  }
+
+  private boolean jj_3_4() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_67()) {
+    jj_scanpos = xsp;
+    if (jj_3R_68()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(105)) {
+    jj_scanpos = xsp;
+    if (jj_3R_69()) return true;
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_67() {
+    if (jj_3R_65()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_214() {
+    if (jj_3R_238()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(145)) jj_scanpos = xsp;
+    if (jj_scan_token(IDENTIFIER)) return true;
+    return false;
+  }
+
+  private boolean jj_3_18() {
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_175() {
+    if (jj_scan_token(TEMPLATE)) return true;
+    if (jj_scan_token(LANGLE)) return true;
+    if (jj_3R_214()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_215()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(RANGLE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_158() {
+    if (jj_3R_175()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_289() {
+    if (jj_scan_token(THROWS)) return true;
+    if (jj_3R_304()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_249() {
+    if (jj_scan_token(THROW)) return true;
+    if (jj_3R_97()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_127() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_158()) jj_scanpos = xsp;
+    if (jj_3R_159()) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_19()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_126() {
+    if (jj_3R_101()) return true;
+    Token xsp;
+    if (jj_3_18()) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_18()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_94() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_126()) {
+    jj_scanpos = xsp;
+    if (jj_3R_127()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_119() {
+    if (jj_3R_101()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_88() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_17()) {
+    jj_scanpos = xsp;
+    if (jj_3R_119()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3_17() {
+    if (jj_3R_94()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_341() {
+    if (jj_3R_97()) return true;
+    return false;
+  }
+
+  private boolean jj_3_16() {
+    if (jj_scan_token(THIS)) return true;
+    if (jj_3R_93()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_340() {
+    if (jj_3R_87()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_90() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(67)) jj_scanpos = xsp;
+    if (jj_3R_120()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_350() {
+    if (jj_3R_357()) return true;
+    return false;
+  }
+
+  private boolean jj_3_14() {
+    if (jj_3R_92()) return true;
+    return false;
+  }
+
+  private boolean jj_3_15() {
+    if (jj_3R_64()) return true;
+    if (jj_scan_token(DOT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_248() {
+    if (jj_scan_token(RETURN)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_341()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_124() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_15()) jj_scanpos = xsp;
+    if (jj_scan_token(SUPER)) return true;
+    if (jj_3R_93()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_364() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_240()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_339() {
+    if (jj_3R_87()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_123() {
+    if (jj_scan_token(THIS)) return true;
+    if (jj_3R_93()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_92() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_123()) {
+    jj_scanpos = xsp;
+    if (jj_3R_124()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_291() {
+    if (jj_3R_173()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_290() {
+    if (jj_3R_92()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_247() {
+    if (jj_scan_token(CONTINUE)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_340()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_287() {
+    if (jj_3R_118()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_246() {
+    if (jj_scan_token(BREAK)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_339()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_277() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_287()) jj_scanpos = xsp;
+    if (jj_3R_87()) return true;
+    if (jj_3R_288()) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_289()) jj_scanpos = xsp;
+    if (jj_scan_token(LBRACE)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_290()) jj_scanpos = xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_291()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(RBRACE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_357() {
+    if (jj_3R_362()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_349() {
+    if (jj_3R_97()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_307() {
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_329() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(123)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(121)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_324() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_329()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(145)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_336() {
+    if (jj_scan_token(ELSE)) return true;
+    if (jj_3R_201()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_317() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_316()) return true;
+    return false;
+  }
+
+  private boolean jj_3_44() {
+    if (jj_3R_107()) return true;
+    if (jj_3R_88()) return true;
+    if (jj_3R_87()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_362() {
+    if (jj_3R_240()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_364()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_316() {
+    if (jj_3R_107()) return true;
+    if (jj_3R_88()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_324()) jj_scanpos = xsp;
+    if (jj_3R_305()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_361() {
+    if (jj_3R_362()) return true;
+    return false;
+  }
+
+  private boolean jj_3_43() {
+    if (jj_3R_107()) return true;
+    if (jj_3R_88()) return true;
+    if (jj_3R_87()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_360() {
+    if (jj_3R_200()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_356() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_360()) {
+    jj_scanpos = xsp;
+    if (jj_3R_361()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_348() {
+    if (jj_3R_356()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_338() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_348()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_349()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_350()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_337() {
+    if (jj_3R_107()) return true;
+    if (jj_3R_88()) return true;
+    if (jj_3R_87()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_97()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_303() {
+    if (jj_3R_316()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_317()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_296() {
+    if (jj_scan_token(THROWS)) return true;
+    if (jj_3R_304()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_288() {
+    if (jj_scan_token(LPAREN)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_303()) jj_scanpos = xsp;
+    if (jj_scan_token(RPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3_13() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_91()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_245() {
+    if (jj_scan_token(FOR)) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_337()) {
+    jj_scanpos = xsp;
+    if (jj_3R_338()) return true;
+    }
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_3R_201()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_244() {
+    if (jj_scan_token(DO)) return true;
+    if (jj_3R_201()) return true;
+    if (jj_scan_token(WHILE)) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_97()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_243() {
+    if (jj_scan_token(WHILE)) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_97()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_3R_201()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_295() {
+    if (jj_3R_87()) return true;
+    if (jj_3R_288()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_307()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_347() {
+    if (jj_3R_173()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_297() {
+    if (jj_3R_120()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_242() {
+    if (jj_scan_token(IF)) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_97()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_3R_201()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_336()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_294() {
+    if (jj_3R_118()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_279() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_294()) jj_scanpos = xsp;
+    if (jj_3R_103()) return true;
+    if (jj_3R_295()) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_296()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_297()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(101)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_254() {
+    if (jj_3R_91()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_13()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_319() {
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_306() {
+    if (jj_scan_token(ASSIGN)) return true;
+    if (jj_3R_91()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_293() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_292()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_89() {
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_355() {
+    if (jj_scan_token(_DEFAULT)) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_156() {
+    if (jj_scan_token(LBRACE)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_254()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(102)) jj_scanpos = xsp;
+    if (jj_scan_token(RBRACE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_354() {
+    if (jj_scan_token(CASE)) return true;
+    if (jj_3R_97()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_346() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_354()) {
+    jj_scanpos = xsp;
+    if (jj_3R_355()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_328() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_292()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_335() {
+    if (jj_3R_346()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_347()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_122() {
+    if (jj_3R_97()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_121() {
+    if (jj_3R_156()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_91() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_121()) {
+    jj_scanpos = xsp;
+    if (jj_3R_122()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_241() {
+    if (jj_scan_token(SWITCH)) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_97()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_scan_token(LBRACE)) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_335()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(RBRACE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_353() {
+    if (jj_3R_96()) return true;
+    if (jj_3R_97()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_305() {
+    if (jj_3R_87()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_319()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_345() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(117)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(118)) {
+    jj_scanpos = xsp;
+    if (jj_3R_353()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_292() {
+    if (jj_3R_305()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_306()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_258() {
+    if (jj_3R_64()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_345()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3_11() {
+    if (jj_3R_88()) return true;
+    if (jj_3R_87()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_89()) { jj_scanpos = xsp; break; }
+    }
+    xsp = jj_scanpos;
+    if (jj_scan_token(102)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(104)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(101)) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_257() {
+    if (jj_3R_263()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_86() {
+    if (jj_3R_118()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_278() {
+    if (jj_3R_88()) return true;
+    if (jj_3R_292()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_293()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_240() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_256()) {
+    jj_scanpos = xsp;
+    if (jj_3R_257()) {
+    jj_scanpos = xsp;
+    if (jj_3R_258()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_256() {
+    if (jj_3R_262()) return true;
+    return false;
+  }
+
+  private boolean jj_3_10() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_86()) jj_scanpos = xsp;
+    if (jj_3R_87()) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_273() {
+    if (jj_3R_279()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_272() {
+    if (jj_3R_278()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_271() {
+    if (jj_3R_277()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_270() {
+    if (jj_3R_276()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_269() {
+    if (jj_3R_202()) return true;
+    return false;
+  }
+
+  private boolean jj_3_42() {
+    if (jj_3R_107()) return true;
+    if (jj_3R_88()) return true;
+    if (jj_3R_87()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_200() {
+    if (jj_3R_107()) return true;
+    if (jj_3R_88()) return true;
+    if (jj_3R_292()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_328()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_266() {
+    if (jj_3R_107()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_269()) {
+    jj_scanpos = xsp;
+    if (jj_3R_270()) {
+    jj_scanpos = xsp;
+    if (jj_3R_271()) {
+    jj_scanpos = xsp;
+    if (jj_3R_272()) {
+    jj_scanpos = xsp;
+    if (jj_3R_273()) return true;
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_188() {
+    if (jj_3R_202()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_187() {
+    if (jj_3R_201()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_173() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_186()) {
+    jj_scanpos = xsp;
+    if (jj_3R_187()) {
+    jj_scanpos = xsp;
+    if (jj_3R_188()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_186() {
+    if (jj_3R_200()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3_12() {
+    if (jj_3R_90()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_261() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_12()) {
+    jj_scanpos = xsp;
+    if (jj_3R_266()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(101)) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_199() {
+    if (jj_scan_token(BIT_AND)) return true;
+    if (jj_3R_159()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_323() {
+    if (jj_3R_234()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_155() {
+    if (jj_3R_173()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_334() {
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_97()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_255() {
+    if (jj_3R_261()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_120() {
+    if (jj_scan_token(LBRACE)) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_155()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(RBRACE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_172() {
+    if (jj_3R_185()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_234() {
+    if (jj_scan_token(LBRACE)) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_255()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(RBRACE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_322() {
+    if (jj_3R_93()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_154() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_153()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_185() {
+    if (jj_scan_token(EXTENDS)) return true;
+    if (jj_3R_159()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_199()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_106() {
+    if (jj_3R_87()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_201()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_153() {
+    if (jj_3R_87()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_172()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_239() {
+    if (jj_scan_token(ASSERT)) return true;
+    if (jj_3R_97()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_334()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3_9() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_85()) return true;
+    return false;
+  }
+
+  private boolean jj_3_39() {
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_118() {
+    if (jj_scan_token(LANGLE)) return true;
+    if (jj_3R_153()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_154()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(RANGLE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_229() {
+    if (jj_3R_251()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_228() {
+    if (jj_3R_250()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_227() {
+    if (jj_3R_249()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_315() {
+    if (jj_3R_261()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_226() {
+    if (jj_3R_248()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_85() {
+    if (jj_3R_107()) return true;
+    if (jj_3R_87()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_322()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_323()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_225() {
+    if (jj_3R_247()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_224() {
+    if (jj_3R_246()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_302() {
+    if (jj_scan_token(SEMICOLON)) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_315()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_223() {
+    if (jj_3R_245()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_301() {
+    if (jj_3R_85()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_9()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_222() {
+    if (jj_3R_244()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_286() {
+    if (jj_scan_token(LBRACE)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_301()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(102)) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_302()) jj_scanpos = xsp;
+    if (jj_scan_token(RBRACE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_221() {
+    if (jj_3R_243()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_220() {
+    if (jj_3R_242()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_219() {
+    if (jj_3R_241()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_285() {
+    if (jj_3R_300()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_218() {
+    if (jj_3R_240()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_276() {
+    if (jj_scan_token(ENUM)) return true;
+    if (jj_3R_87()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_285()) jj_scanpos = xsp;
+    if (jj_3R_286()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_217() {
+    if (jj_3R_120()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_216() {
+    if (jj_3R_239()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_193() {
+    if (jj_3R_95()) return true;
+    return false;
+  }
+
+  private boolean jj_3_41() {
+    if (jj_3R_106()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_201() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_41()) {
+    jj_scanpos = xsp;
+    if (jj_3R_216()) {
+    jj_scanpos = xsp;
+    if (jj_3R_217()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(101)) {
+    jj_scanpos = xsp;
+    if (jj_3R_218()) {
+    jj_scanpos = xsp;
+    if (jj_3R_219()) {
+    jj_scanpos = xsp;
+    if (jj_3R_220()) {
+    jj_scanpos = xsp;
+    if (jj_3R_221()) {
+    jj_scanpos = xsp;
+    if (jj_3R_222()) {
+    jj_scanpos = xsp;
+    if (jj_3R_223()) {
+    jj_scanpos = xsp;
+    if (jj_3R_224()) {
+    jj_scanpos = xsp;
+    if (jj_3R_225()) {
+    jj_scanpos = xsp;
+    if (jj_3R_226()) {
+    jj_scanpos = xsp;
+    if (jj_3R_227()) {
+    jj_scanpos = xsp;
+    if (jj_3R_228()) {
+    jj_scanpos = xsp;
+    if (jj_3R_229()) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_314() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_159()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_208() {
+    if (jj_3R_234()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_300() {
+    if (jj_scan_token(IMPLEMENTS)) return true;
+    if (jj_3R_159()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_314()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_233() {
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3_38() {
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_3R_97()) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_207() {
+    Token xsp;
+    if (jj_3R_233()) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_233()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_3R_156()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_313() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_159()) return true;
+    return false;
+  }
+
+  private boolean jj_3_40() {
+    Token xsp;
+    if (jj_3_38()) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_38()) { jj_scanpos = xsp; break; }
+    }
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_39()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_192() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_40()) {
+    jj_scanpos = xsp;
+    if (jj_3R_207()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_299() {
+    if (jj_scan_token(EXTENDS)) return true;
+    if (jj_3R_159()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_313()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_174() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_97()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_195() {
+    if (jj_3R_93()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_208()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_194() {
+    if (jj_3R_192()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_230() {
+    if (jj_scan_token(INTERFACE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_139() {
+    if (jj_scan_token(NEW)) return true;
+    if (jj_3R_159()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_193()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_194()) {
+    jj_scanpos = xsp;
+    if (jj_3R_195()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_104() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_37()) {
+    jj_scanpos = xsp;
+    if (jj_3R_139()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3_37() {
+    if (jj_scan_token(NEW)) return true;
+    if (jj_3R_101()) return true;
+    if (jj_3R_192()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_284() {
+    if (jj_3R_300()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_283() {
+    if (jj_3R_299()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_282() {
+    if (jj_3R_118()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_157() {
+    if (jj_3R_97()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_174()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_202() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(36)) {
+    jj_scanpos = xsp;
+    if (jj_3R_230()) return true;
+    }
+    if (jj_3R_87()) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_282()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_283()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_284()) jj_scanpos = xsp;
+    if (jj_3R_234()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_125() {
+    if (jj_3R_157()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_93() {
+    if (jj_scan_token(LPAREN)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_125()) jj_scanpos = xsp;
+    if (jj_scan_token(RPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_84() {
+    if (jj_3R_117()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_83() {
+    if (jj_scan_token(STRICTFP)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_82() {
+    if (jj_scan_token(VOLATILE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_81() {
+    if (jj_scan_token(TRANSIENT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_80() {
+    if (jj_scan_token(NATIVE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_79() {
+    if (jj_scan_token(SYNCHRONIZED)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_113() {
+    if (jj_scan_token(STRING_LITERAL)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_78() {
+    if (jj_scan_token(ABSTRACT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_77() {
+    if (jj_scan_token(FINAL)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_76() {
+    if (jj_scan_token(PRIVATE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_75() {
+    if (jj_scan_token(PROTECTED)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_74() {
+    if (jj_scan_token(STATIC)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_205() {
+    if (jj_scan_token(FALSE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_73() {
+    if (jj_scan_token(PUBLIC)) return true;
+    return false;
+  }
+
+  private boolean jj_3_8() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_73()) {
+    jj_scanpos = xsp;
+    if (jj_3R_74()) {
+    jj_scanpos = xsp;
+    if (jj_3R_75()) {
+    jj_scanpos = xsp;
+    if (jj_3R_76()) {
+    jj_scanpos = xsp;
+    if (jj_3R_77()) {
+    jj_scanpos = xsp;
+    if (jj_3R_78()) {
+    jj_scanpos = xsp;
+    if (jj_3R_79()) {
+    jj_scanpos = xsp;
+    if (jj_3R_80()) {
+    jj_scanpos = xsp;
+    if (jj_3R_81()) {
+    jj_scanpos = xsp;
+    if (jj_3R_82()) {
+    jj_scanpos = xsp;
+    if (jj_3R_83()) {
+    jj_scanpos = xsp;
+    if (jj_3R_84()) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_190() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_204()) {
+    jj_scanpos = xsp;
+    if (jj_3R_205()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_204() {
+    if (jj_scan_token(TRUE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_107() {
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_8()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_72() {
+    if (jj_3R_117()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_163() {
+    if (jj_3R_166()) return true;
+    return false;
+  }
+
+  private boolean jj_3_7() {
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_72()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(PACKAGE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_179() {
+    if (jj_3R_190()) return true;
+    return false;
+  }
+
+  private boolean jj_3_1() {
+    if (jj_scan_token(LANGLE)) return true;
+    if (jj_scan_token(STAR)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_166() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(83)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(88)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(93)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(94)) {
+    jj_scanpos = xsp;
+    if (jj_3R_179()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(60)) return true;
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_136() {
+    if (jj_3R_93()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_135() {
+    if (jj_scan_token(DOT)) return true;
+    if (jj_3R_87()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_134() {
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_3R_97()) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3_36() {
+    if (jj_3R_105()) return true;
+    return false;
+  }
+
+  private boolean jj_3_35() {
+    if (jj_scan_token(DOT)) return true;
+    if (jj_3R_104()) return true;
+    return false;
+  }
+
+  private boolean jj_3_33() {
+    if (jj_3R_103()) return true;
+    if (jj_scan_token(DOT)) return true;
+    if (jj_scan_token(CLASS)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_102() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_34()) {
+    jj_scanpos = xsp;
+    if (jj_3_35()) {
+    jj_scanpos = xsp;
+    if (jj_3_36()) {
+    jj_scanpos = xsp;
+    if (jj_3R_134()) {
+    jj_scanpos = xsp;
+    if (jj_3R_135()) {
+    jj_scanpos = xsp;
+    if (jj_3R_136()) return true;
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3_34() {
+    if (jj_scan_token(DOT)) return true;
+    if (jj_scan_token(THIS)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_148() {
+    if (jj_3R_109()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_147() {
+    if (jj_3R_103()) return true;
+    if (jj_scan_token(DOT)) return true;
+    if (jj_scan_token(CLASS)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_146() {
+    if (jj_3R_104()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_145() {
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_97()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3_32() {
+    if (jj_3R_102()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_144() {
+    if (jj_scan_token(SUPER)) return true;
+    if (jj_scan_token(DOT)) return true;
+    if (jj_3R_87()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_162() {
+    if (jj_3R_87()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_143() {
+    if (jj_3R_166()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_112() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_143()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(72)) {
+    jj_scanpos = xsp;
+    if (jj_3R_144()) {
+    jj_scanpos = xsp;
+    if (jj_3R_145()) {
+    jj_scanpos = xsp;
+    if (jj_3R_146()) {
+    jj_scanpos = xsp;
+    if (jj_3R_147()) {
+    jj_scanpos = xsp;
+    if (jj_3R_148()) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_352() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(117)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(118)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_105() {
+    if (jj_scan_token(DOT)) return true;
+    if (jj_3R_95()) return true;
+    if (jj_3R_87()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_87() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(151)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(1)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(2)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(3)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(4)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(5)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(7)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(8)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(9)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(10)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(11)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(12)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(81)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(139)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(140)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(141)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(142)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(143)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(144)) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3_31() {
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_101()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_64() {
+    if (jj_3R_112()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_32()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_333() {
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_88()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_3R_320()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_332() {
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_88()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_3R_298()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_330() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_332()) {
+    jj_scanpos = xsp;
+    if (jj_3R_333()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3_30() {
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_88()) return true;
+    if (jj_scan_token(LBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_331() {
+    if (jj_3R_64()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_352()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_65() {
+    if (jj_scan_token(IDENTIFIER)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_133() {
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_88()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(107)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(106)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(95)) {
+    jj_scanpos = xsp;
+    if (jj_3R_162()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(72)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(69)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(59)) {
+    jj_scanpos = xsp;
+    if (jj_3R_163()) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_132() {
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_88()) return true;
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_100() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_29()) {
+    jj_scanpos = xsp;
+    if (jj_3R_132()) {
+    jj_scanpos = xsp;
+    if (jj_3R_133()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3_29() {
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_101()) return true;
+    return false;
+  }
+
+  private boolean jj_3_28() {
+    if (jj_3R_100()) return true;
+    return false;
+  }
+
+  private boolean jj_3_27() {
+    if (jj_3R_99()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_327() {
+    if (jj_3R_331()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_326() {
+    if (jj_3R_330()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_325() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(107)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(106)) return true;
+    }
+    if (jj_3R_298()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_320() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_325()) {
+    jj_scanpos = xsp;
+    if (jj_3R_326()) {
+    jj_scanpos = xsp;
+    if (jj_3R_327()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_263() {
+    if (jj_scan_token(DECR)) return true;
+    if (jj_3R_64()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_312() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(119)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(120)) return true;
+    }
+    if (jj_3R_280()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_321() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(121)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(122)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(126)) return true;
+    }
+    }
+    if (jj_3R_298()) return true;
+    return false;
+  }
+
+  private boolean jj_3_26() {
+    if (jj_3R_98()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_237() {
+    if (jj_3R_113()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_262() {
+    if (jj_scan_token(INCR)) return true;
+    if (jj_3R_64()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_311() {
+    if (jj_3R_320()) return true;
+    return false;
+  }
+
+  private boolean jj_3_25() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(149)) {
+    jj_scanpos = xsp;
+    if (jj_3_26()) {
+    jj_scanpos = xsp;
+    if (jj_3_27()) return true;
+    }
+    }
+    if (jj_3R_274()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_310() {
+    if (jj_3R_263()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_309() {
+    if (jj_3R_262()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_308() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(119)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(120)) return true;
+    }
+    if (jj_3R_298()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_298() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_308()) {
+    jj_scanpos = xsp;
+    if (jj_3R_309()) {
+    jj_scanpos = xsp;
+    if (jj_3R_310()) {
+    jj_scanpos = xsp;
+    if (jj_3R_311()) return true;
+    }
+    }
+    }
+    return false;
+  }
+
+  /** Generated Token Manager. */
+  public JavaCCParserTokenManager token_source;
+  JavaCharStream jj_input_stream;
+  /** Current token. */
+  public Token token;
+  /** Next token. */
+  public Token jj_nt;
+  private int jj_ntk;
+  private Token jj_scanpos, jj_lastpos;
+  private int jj_la;
+  /** Whether we are looking ahead. */
+  private boolean jj_lookingAhead = false;
+  private boolean jj_semLA;
+  private int jj_gen;
+  final private int[] jj_la1 = new int[198];
+  static private int[] jj_la1_0;
+  static private int[] jj_la1_1;
+  static private int[] jj_la1_2;
+  static private int[] jj_la1_3;
+  static private int[] jj_la1_4;
+  static {
+      jj_la1_init_0();
+      jj_la1_init_1();
+      jj_la1_init_2();
+      jj_la1_init_3();
+      jj_la1_init_4();
+   }
+   private static void jj_la1_init_0() {
+      jj_la1_0 = new int[] {0x40000fe0,0xe,0xe,0x0,0x0,0x40000fe0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x780,0x0,0x0,0x0,0x2,0x0,0x40001fbe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1fbe,0x0,0x10000000,0x0,0x0,0x10000000,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10001fbe,0x0,0x50001fbe,0x0,0x0,0x0,0x0,0x0,0x0,0x50001fbe,0x0,0x40000000,0x50001fbe,0x0,0x0,0x0,0x40001fbe,0x40001fbe,0x0,0x0,0x0,0x0,0x0,0x0,0x50000000,0x0,0x0,0x0,0x0,0x0,0xf0001fbe,0x40001fbe,0x0,0x40000000,0x0,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x40000000,0x0,0x40000000,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40001fbe,0x0,0x0,0x40001fbe,0x1fbe,0x0,0x0,0x0,0x0,0x0,0x1fbe,0x0,0x0,0x0,0x40001fbe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe0001fbe,0x0,0xf0001fbe,0xe0001fbe,0x0,0x0,0x0,0x40001fbe,0x0,0xf0001fbe,0x0,0x0,0x50001fbe,0x40001fbe,0x40001fbe,0x50001fbe,0x40001fbe,0x0,0x1fbe,0x1fbe,0x40001fbe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1fbe,0x0,0x40001fbe,0x0,0x50000000,0x0,0x40000000,0x50000000,};
+   }
+   private static void jj_la1_init_1() {
+      jj_la1_1 = new int[] {0xc2810229,0x0,0x0,0x2000,0x0,0xc2810229,0x0,0x0,0x0,0x0,0x0,0x0,0xc0000000,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1a812229,0x4,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0xc5004810,0x0,0x0,0xc4004000,0x1000810,0xc5004810,0x1000010,0x0,0x1000,0x100000,0x0,0x0,0x100000,0xc4004000,0x0,0xc7814a39,0x0,0x0,0x0,0x0,0x1000,0x0,0xc7814a39,0x1000810,0x2810229,0xc7814a39,0x0,0x0,0x0,0x1a812229,0x1a812229,0x0,0x0,0x0,0x0,0x0,0x0,0xc6814209,0x0,0x0,0x0,0x0,0x0,0xdf8b6379,0x1a812229,0x0,0x2810209,0x0,0x2810209,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x2810209,0x1000,0x2810209,0x1000,0x2810209,0x0,0x20,0x0,0x0,0x2810229,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1a812229,0x0,0x0,0x1a812229,0x18002000,0x0,0x0,0x0,0x0,0x18002000,0x0,0x0,0x10002000,0x2000,0x1a812229,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x1a8b2369,0x0,0xdf8b6379,0x1b8b2379,0x0,0x0,0x0,0x1a812229,0x82,0xdf8b6379,0x82,0x400,0xde816229,0x1a812229,0x1a812229,0xde816229,0x1a812229,0x0,0x0,0x0,0x1a812229,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x8000,0x0,0x0,0x0,0x1a812229,0x0,0xc7814a19,0x80,0x3810a19,0xc7814a19,};
+   }
+   private static void jj_la1_init_2() {
+      jj_la1_2 = new int[] {0x24005,0x8,0x8,0xc0081000,0x0,0x24005,0x0,0x400,0x0,0x400,0x0,0x400,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0xe10a5124,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x2000,0x80000000,0x0,0x0,0x40000000,0x0,0x0,0xc0000000,0x80000,0x0,0x0,0x0,0xc0000000,0x0,0x0,0x40000000,0x0,0x20000,0x0,0x8899,0x8,0x0,0x8899,0x0,0x8899,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x28899,0x0,0x2c89d,0x0,0x80000000,0x0,0x0,0x0,0x0,0x2c89d,0x0,0x24004,0x2c89d,0x0,0x0,0x0,0xe10a5124,0xe10a5124,0x0,0x0,0x400,0x0,0x0,0x0,0x2889d,0x0,0x0,0x0,0x0,0x400,0xe10bfbff,0xe10a5124,0x8,0x4,0x20000,0x20004,0x0,0x0,0x40000,0x0,0x0,0x0,0x0,0x20004,0x20,0x20004,0x20,0x4,0x0,0x0,0x0,0x0,0x24004,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe10a5124,0x0,0x0,0xe10a5124,0xe10a1120,0x80000000,0x0,0x0,0x80000000,0xe1081120,0x20000,0x80000000,0x61081000,0x1000,0xe10a5124,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0xe10b73e6,0x0,0xe10bfbff,0xe10b73e6,0x0,0x0,0x0,0xe10a5124,0x0,0xe10bfbff,0x0,0x0,0xe10ad9bd,0xe10a5124,0xe10a5124,0xe10ad9bd,0xe10a5124,0x0,0x20000,0x20000,0xe10a5124,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x20000,0x0,0xe10a5124,0x0,0x2889d,0x0,0x20004,0x2889d,};
+   }
+   private static void jj_la1_init_3() {
+      jj_la1_3 = new int[] {0x4200,0x0,0x0,0x0,0x40,0x4200,0x40,0x0,0x40,0x0,0x40,0x0,0x0,0x0,0x40,0x200,0x200,0x8,0x10000000,0x2,0x0,0x2,0x2000,0x10000000,0x0,0x0,0x1e04c00,0x0,0x0,0x200,0x80,0x200,0x2801000,0x2801000,0xa,0x0,0x0,0x0,0x0,0x200,0x10000000,0xa08,0x0,0x40,0x2801002,0x2801002,0xa08,0x800,0x40,0x0,0x1000000,0x0,0x0,0x20,0x0,0x80,0x0,0x0,0x20,0x0,0x200,0x0,0x0,0x40,0x40,0x0,0x0,0x40,0x4222,0x20,0x0,0x2,0x40,0x0,0x8000000,0x4222,0x0,0x4200,0x4220,0x40,0x100,0x8,0x1e04c02,0x1e04c02,0x40,0x200,0x0,0x22,0x8,0x40,0x4000,0xa000000,0xa000000,0xa000000,0x200,0x0,0x604022,0x4000,0x0,0x0,0x0,0x4000,0x40,0x0,0x0,0x4000,0x4080,0x40,0x0,0x5000,0x0,0x5000,0x0,0x0,0x2000000,0x0,0xa000000,0xa000000,0x4000,0x40,0x80000100,0x1000,0x80000,0x100000,0x10000000,0x20000000,0x8000000,0x48000,0x48000,0x0,0x30200,0x30200,0x0,0x1800000,0x1800000,0x46000000,0x46000000,0x1800000,0x1e04c00,0xc00,0xc00,0x4000,0xc00,0x0,0x600000,0x600000,0x0,0x0,0x0,0x88,0x0,0x0,0x1e04c00,0x40,0x200,0x2,0x8,0x0,0x8,0x8,0x604022,0x2000,0x604022,0x604022,0x40,0x80600100,0x80600100,0x604000,0x0,0x604022,0x0,0x0,0x604000,0x1e04c00,0x604000,0x604020,0x604000,0x40,0x0,0x0,0x1e04c00,0xa000000,0xa000000,0xa000000,0x10000000,0x20,0x0,0x0,0x0,0x0,0x0,0x40,0x1e04c02,0x40,0x4020,0x0,0x4000,0x4020,};
+   }
+   private static void jj_la1_init_4() {
+      jj_la1_4 = new int[] {0x800000,0x800000,0x800000,0x0,0x0,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x81f800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x800400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x81f800,0x0,0x400000,0x0,0x0,0x400000,0x400000,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc1f800,0x0,0xc1f800,0x0,0x0,0x0,0x0,0x0,0x0,0xc1f800,0x0,0x800000,0xc1f800,0x0,0x0,0x0,0x81f800,0x81f800,0x0,0x0,0x0,0x0,0x0,0x0,0xc00000,0x0,0x20000,0x20000,0x0,0x0,0xc1f800,0x81f800,0x0,0x0,0x0,0x800000,0x0,0x20000,0x0,0x0,0x0,0x0,0x20000,0x800000,0x0,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,0x1c007f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x200,0x200000,0x0,0x0,0x0,0x0,0x0,0x81f800,0x0,0x0,0x81f800,0x81f800,0x0,0x0,0x0,0x0,0x0,0x81f800,0x0,0x0,0x0,0x81f800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x81f800,0x0,0xc1f800,0x81f800,0x0,0x1c007f,0x1c007f,0x81f800,0x0,0xc1f800,0x0,0x0,0xc1f800,0x81f800,0x81f800,0xc1f800,0x81f800,0x0,0x81f800,0x81f800,0x81f800,0x0,0x20000,0x20000,0x0,0x0,0x0,0x0,0x0,0x400000,0x81f800,0x0,0xc1f800,0x0,0xc00000,0x0,0xc00000,0xc00000,};
+   }
+  final private JJCalls[] jj_2_rtns = new JJCalls[49];
+  private boolean jj_rescan = false;
+  private int jj_gc = 0;
+
+  /** Constructor with InputStream. */
+  public JavaCCParser(java.io.InputStream stream) {
+     this(stream, null);
+  }
+  /** Constructor with InputStream and supplied encoding */
+  public JavaCCParser(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source = new JavaCCParserTokenManager(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 198; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream stream) {
+     ReInit(stream, null);
+  }
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 198; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Constructor. */
+  public JavaCCParser(java.io.Reader stream) {
+    jj_input_stream = new JavaCharStream(stream, 1, 1);
+    token_source = new JavaCCParserTokenManager(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 198; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.Reader stream) {
+    jj_input_stream.ReInit(stream, 1, 1);
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 198; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Constructor with generated Token Manager. */
+  public JavaCCParser(JavaCCParserTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 198; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Reinitialise. */
+  public void ReInit(JavaCCParserTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 198; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  private Token jj_consume_token(int kind) throws ParseException {
+    Token oldToken;
+    if ((oldToken = token).next != null) token = token.next;
+    else token = token.next = token_source.getNextToken();
+    jj_ntk = -1;
+    if (token.kind == kind) {
+      jj_gen++;
+      if (++jj_gc > 100) {
+        jj_gc = 0;
+        for (int i = 0; i < jj_2_rtns.length; i++) {
+          JJCalls c = jj_2_rtns[i];
+          while (c != null) {
+            if (c.gen < jj_gen) c.first = null;
+            c = c.next;
+          }
+        }
+      }
+      return token;
+    }
+    token = oldToken;
+    jj_kind = kind;
+    throw generateParseException();
+  }
+
+  static private final class LookaheadSuccess extends java.lang.Error { }
+  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
+  private boolean jj_scan_token(int kind) {
+    if (jj_scanpos == jj_lastpos) {
+      jj_la--;
+      if (jj_scanpos.next == null) {
+        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
+      } else {
+        jj_lastpos = jj_scanpos = jj_scanpos.next;
+      }
+    } else {
+      jj_scanpos = jj_scanpos.next;
+    }
+    if (jj_rescan) {
+      int i = 0; Token tok = token;
+      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
+      if (tok != null) jj_add_error_token(kind, i);
+    }
+    if (jj_scanpos.kind != kind) return true;
+    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
+    return false;
+  }
+
+
+/** Get the next Token. */
+  final public Token getNextToken() {
+    if (token.next != null) token = token.next;
+    else token = token.next = token_source.getNextToken();
+    jj_ntk = -1;
+    jj_gen++;
+    return token;
+  }
+
+/** Get the specific Token. */
+  final public Token getToken(int index) {
+    Token t = jj_lookingAhead ? jj_scanpos : token;
+    for (int i = 0; i < index; i++) {
+      if (t.next != null) t = t.next;
+      else t = t.next = token_source.getNextToken();
+    }
+    return t;
+  }
+
+  private int jj_ntk() {
+    if ((jj_nt=token.next) == null)
+      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
+    else
+      return (jj_ntk = jj_nt.kind);
+  }
+
+  private java.util.List jj_expentries = new java.util.ArrayList();
+  private int[] jj_expentry;
+  private int jj_kind = -1;
+  private int[] jj_lasttokens = new int[100];
+  private int jj_endpos;
+
+  private void jj_add_error_token(int kind, int pos) {
+    if (pos >= 100) return;
+    if (pos == jj_endpos + 1) {
+      jj_lasttokens[jj_endpos++] = kind;
+    } else if (jj_endpos != 0) {
+      jj_expentry = new int[jj_endpos];
+      for (int i = 0; i < jj_endpos; i++) {
+        jj_expentry[i] = jj_lasttokens[i];
+      }
+      boolean exists = false;
+      for (java.util.Iterator it = jj_expentries.iterator(); it.hasNext();) {
+        int[] oldentry = (int[])(it.next());
+        if (oldentry.length == jj_expentry.length) {
+          exists = true;
+          for (int i = 0; i < jj_expentry.length; i++) {
+            if (oldentry[i] != jj_expentry[i]) {
+              exists = false;
+              break;
+            }
+          }
+          if (exists) break;
+        }
+      }
+      if (!exists) jj_expentries.add(jj_expentry);
+      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
+    }
+  }
+
+  /** Generate ParseException. */
+  public ParseException generateParseException() {
+    jj_expentries.clear();
+    boolean[] la1tokens = new boolean[155];
+    if (jj_kind >= 0) {
+      la1tokens[jj_kind] = true;
+      jj_kind = -1;
+    }
+    for (int i = 0; i < 198; i++) {
+      if (jj_la1[i] == jj_gen) {
+        for (int j = 0; j < 32; j++) {
+          if ((jj_la1_0[i] & (1<<j)) != 0) {
+            la1tokens[j] = true;
+          }
+          if ((jj_la1_1[i] & (1<<j)) != 0) {
+            la1tokens[32+j] = true;
+          }
+          if ((jj_la1_2[i] & (1<<j)) != 0) {
+            la1tokens[64+j] = true;
+          }
+          if ((jj_la1_3[i] & (1<<j)) != 0) {
+            la1tokens[96+j] = true;
+          }
+          if ((jj_la1_4[i] & (1<<j)) != 0) {
+            la1tokens[128+j] = true;
+          }
+        }
+      }
+    }
+    for (int i = 0; i < 155; i++) {
+      if (la1tokens[i]) {
+        jj_expentry = new int[1];
+        jj_expentry[0] = i;
+        jj_expentries.add(jj_expentry);
+      }
+    }
+    jj_endpos = 0;
+    jj_rescan_token();
+    jj_add_error_token(0, 0);
+    int[][] exptokseq = new int[jj_expentries.size()][];
+    for (int i = 0; i < jj_expentries.size(); i++) {
+      exptokseq[i] = (int[])jj_expentries.get(i);
+    }
+    return new ParseException(token, exptokseq, tokenImage);
+  }
+
+  /** Enable tracing. */
+  final public void enable_tracing() {
+  }
+
+  /** Disable tracing. */
+  final public void disable_tracing() {
+  }
+
+  private void jj_rescan_token() {
+    jj_rescan = true;
+    for (int i = 0; i < 49; i++) {
+    try {
+      JJCalls p = jj_2_rtns[i];
+      do {
+        if (p.gen > jj_gen) {
+          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
+          switch (i) {
+            case 0: jj_3_1(); break;
+            case 1: jj_3_2(); break;
+            case 2: jj_3_3(); break;
+            case 3: jj_3_4(); break;
+            case 4: jj_3_5(); break;
+            case 5: jj_3_6(); break;
+            case 6: jj_3_7(); break;
+            case 7: jj_3_8(); break;
+            case 8: jj_3_9(); break;
+            case 9: jj_3_10(); break;
+            case 10: jj_3_11(); break;
+            case 11: jj_3_12(); break;
+            case 12: jj_3_13(); break;
+            case 13: jj_3_14(); break;
+            case 14: jj_3_15(); break;
+            case 15: jj_3_16(); break;
+            case 16: jj_3_17(); break;
+            case 17: jj_3_18(); break;
+            case 18: jj_3_19(); break;
+            case 19: jj_3_20(); break;
+            case 20: jj_3_21(); break;
+            case 21: jj_3_22(); break;
+            case 22: jj_3_23(); break;
+            case 23: jj_3_24(); break;
+            case 24: jj_3_25(); break;
+            case 25: jj_3_26(); break;
+            case 26: jj_3_27(); break;
+            case 27: jj_3_28(); break;
+            case 28: jj_3_29(); break;
+            case 29: jj_3_30(); break;
+            case 30: jj_3_31(); break;
+            case 31: jj_3_32(); break;
+            case 32: jj_3_33(); break;
+            case 33: jj_3_34(); break;
+            case 34: jj_3_35(); break;
+            case 35: jj_3_36(); break;
+            case 36: jj_3_37(); break;
+            case 37: jj_3_38(); break;
+            case 38: jj_3_39(); break;
+            case 39: jj_3_40(); break;
+            case 40: jj_3_41(); break;
+            case 41: jj_3_42(); break;
+            case 42: jj_3_43(); break;
+            case 43: jj_3_44(); break;
+            case 44: jj_3_45(); break;
+            case 45: jj_3_46(); break;
+            case 46: jj_3_47(); break;
+            case 47: jj_3_48(); break;
+            case 48: jj_3_49(); break;
+          }
+        }
+        p = p.next;
+      } while (p != null);
+      } catch(LookaheadSuccess ls) { }
+    }
+    jj_rescan = false;
+  }
+
+  private void jj_save(int index, int xla) {
+    JJCalls p = jj_2_rtns[index];
+    while (p.gen > jj_gen) {
+      if (p.next == null) { p = p.next = new JJCalls(); break; }
+      p = p.next;
+    }
+    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
+  }
+
+  static final class JJCalls {
+    int gen;
+    Token first;
+    int arg;
+    JJCalls next;
+  }
+
+}
diff --git a/generated/org/javacc/parser/JavaCCParserConstants.java b/generated/org/javacc/parser/JavaCCParserConstants.java
new file mode 100644
index 00000000..098f15fb
--- /dev/null
+++ b/generated/org/javacc/parser/JavaCCParserConstants.java
@@ -0,0 +1,451 @@
+/* Generated By:JavaCC: Do not edit this line. JavaCCParserConstants.java */
+/**
+ * This file contains the code for JavaCCParser generated
+ * by JavaCCParser itself.
+ */
+
+package org.javacc.parser;
+
+
+/** 
+ * Token literal values and constants.
+ * Generated by org.javacc.parser.OtherFilesGen#start()
+ */
+public interface JavaCCParserConstants {
+
+  /** End of File. */
+  int EOF = 0;
+  /** RegularExpression Id. */
+  int _LOOKAHEAD = 1;
+  /** RegularExpression Id. */
+  int _IGNORE_CASE = 2;
+  /** RegularExpression Id. */
+  int _PARSER_BEGIN = 3;
+  /** RegularExpression Id. */
+  int _PARSER_END = 4;
+  /** RegularExpression Id. */
+  int _JAVACODE = 5;
+  /** RegularExpression Id. */
+  int _CPPCODE = 6;
+  /** RegularExpression Id. */
+  int _TOKEN = 7;
+  /** RegularExpression Id. */
+  int _SPECIAL_TOKEN = 8;
+  /** RegularExpression Id. */
+  int _MORE = 9;
+  /** RegularExpression Id. */
+  int _SKIP = 10;
+  /** RegularExpression Id. */
+  int _TOKEN_MGR_DECLS = 11;
+  /** RegularExpression Id. */
+  int _EOF = 12;
+  /** RegularExpression Id. */
+  int SINGLE_LINE_COMMENT = 24;
+  /** RegularExpression Id. */
+  int FORMAL_COMMENT = 25;
+  /** RegularExpression Id. */
+  int MULTI_LINE_COMMENT = 26;
+  /** RegularExpression Id. */
+  int ABSTRACT = 28;
+  /** RegularExpression Id. */
+  int ASSERT = 29;
+  /** RegularExpression Id. */
+  int BOOLEAN = 30;
+  /** RegularExpression Id. */
+  int BREAK = 31;
+  /** RegularExpression Id. */
+  int BYTE = 32;
+  /** RegularExpression Id. */
+  int CASE = 33;
+  /** RegularExpression Id. */
+  int CATCH = 34;
+  /** RegularExpression Id. */
+  int CHAR = 35;
+  /** RegularExpression Id. */
+  int CLASS = 36;
+  /** RegularExpression Id. */
+  int CONST = 37;
+  /** RegularExpression Id. */
+  int CONTINUE = 38;
+  /** RegularExpression Id. */
+  int _DEFAULT = 39;
+  /** RegularExpression Id. */
+  int DO = 40;
+  /** RegularExpression Id. */
+  int DOUBLE = 41;
+  /** RegularExpression Id. */
+  int ELSE = 42;
+  /** RegularExpression Id. */
+  int ENUM = 43;
+  /** RegularExpression Id. */
+  int EXTENDS = 44;
+  /** RegularExpression Id. */
+  int FALSE = 45;
+  /** RegularExpression Id. */
+  int FINAL = 46;
+  /** RegularExpression Id. */
+  int FINALLY = 47;
+  /** RegularExpression Id. */
+  int FLOAT = 48;
+  /** RegularExpression Id. */
+  int FOR = 49;
+  /** RegularExpression Id. */
+  int GOTO = 50;
+  /** RegularExpression Id. */
+  int IF = 51;
+  /** RegularExpression Id. */
+  int IMPLEMENTS = 52;
+  /** RegularExpression Id. */
+  int IMPORT = 53;
+  /** RegularExpression Id. */
+  int INSTANCEOF = 54;
+  /** RegularExpression Id. */
+  int INT = 55;
+  /** RegularExpression Id. */
+  int INTERFACE = 56;
+  /** RegularExpression Id. */
+  int LONG = 57;
+  /** RegularExpression Id. */
+  int NATIVE = 58;
+  /** RegularExpression Id. */
+  int NEW = 59;
+  /** RegularExpression Id. */
+  int NULL = 60;
+  /** RegularExpression Id. */
+  int PACKAGE = 61;
+  /** RegularExpression Id. */
+  int PRIVATE = 62;
+  /** RegularExpression Id. */
+  int PROTECTED = 63;
+  /** RegularExpression Id. */
+  int PUBLIC = 64;
+  /** RegularExpression Id. */
+  int RETURN = 65;
+  /** RegularExpression Id. */
+  int SHORT = 66;
+  /** RegularExpression Id. */
+  int STATIC = 67;
+  /** RegularExpression Id. */
+  int STRICTFP = 68;
+  /** RegularExpression Id. */
+  int SUPER = 69;
+  /** RegularExpression Id. */
+  int SWITCH = 70;
+  /** RegularExpression Id. */
+  int SYNCHRONIZED = 71;
+  /** RegularExpression Id. */
+  int THIS = 72;
+  /** RegularExpression Id. */
+  int THROW = 73;
+  /** RegularExpression Id. */
+  int THROWS = 74;
+  /** RegularExpression Id. */
+  int TRANSIENT = 75;
+  /** RegularExpression Id. */
+  int TRUE = 76;
+  /** RegularExpression Id. */
+  int TRY = 77;
+  /** RegularExpression Id. */
+  int VOID = 78;
+  /** RegularExpression Id. */
+  int VOLATILE = 79;
+  /** RegularExpression Id. */
+  int WHILE = 80;
+  /** RegularExpression Id. */
+  int TEMPLATE = 81;
+  /** RegularExpression Id. */
+  int TYPENAME = 82;
+  /** RegularExpression Id. */
+  int INTEGER_LITERAL = 83;
+  /** RegularExpression Id. */
+  int DECIMAL_LITERAL = 84;
+  /** RegularExpression Id. */
+  int HEX_LITERAL = 85;
+  /** RegularExpression Id. */
+  int OCTAL_LITERAL = 86;
+  /** RegularExpression Id. */
+  int BINARY_LITERAL = 87;
+  /** RegularExpression Id. */
+  int FLOATING_POINT_LITERAL = 88;
+  /** RegularExpression Id. */
+  int DECIMAL_FLOATING_POINT_LITERAL = 89;
+  /** RegularExpression Id. */
+  int DECIMAL_EXPONENT = 90;
+  /** RegularExpression Id. */
+  int HEXADECIMAL_FLOATING_POINT_LITERAL = 91;
+  /** RegularExpression Id. */
+  int HEXADECIMAL_EXPONENT = 92;
+  /** RegularExpression Id. */
+  int CHARACTER_LITERAL = 93;
+  /** RegularExpression Id. */
+  int STRING_LITERAL = 94;
+  /** RegularExpression Id. */
+  int LPAREN = 95;
+  /** RegularExpression Id. */
+  int RPAREN = 96;
+  /** RegularExpression Id. */
+  int LBRACE = 97;
+  /** RegularExpression Id. */
+  int RBRACE = 98;
+  /** RegularExpression Id. */
+  int LBRACKET = 99;
+  /** RegularExpression Id. */
+  int RBRACKET = 100;
+  /** RegularExpression Id. */
+  int SEMICOLON = 101;
+  /** RegularExpression Id. */
+  int COMMA = 102;
+  /** RegularExpression Id. */
+  int DOT = 103;
+  /** RegularExpression Id. */
+  int ASSIGN = 104;
+  /** RegularExpression Id. */
+  int LT = 105;
+  /** RegularExpression Id. */
+  int BANG = 106;
+  /** RegularExpression Id. */
+  int TILDE = 107;
+  /** RegularExpression Id. */
+  int HOOK = 108;
+  /** RegularExpression Id. */
+  int COLON = 109;
+  /** RegularExpression Id. */
+  int DOUBLECOLON = 110;
+  /** RegularExpression Id. */
+  int EQ = 111;
+  /** RegularExpression Id. */
+  int LE = 112;
+  /** RegularExpression Id. */
+  int GE = 113;
+  /** RegularExpression Id. */
+  int NE = 114;
+  /** RegularExpression Id. */
+  int SC_OR = 115;
+  /** RegularExpression Id. */
+  int SC_AND = 116;
+  /** RegularExpression Id. */
+  int INCR = 117;
+  /** RegularExpression Id. */
+  int DECR = 118;
+  /** RegularExpression Id. */
+  int PLUS = 119;
+  /** RegularExpression Id. */
+  int MINUS = 120;
+  /** RegularExpression Id. */
+  int STAR = 121;
+  /** RegularExpression Id. */
+  int SLASH = 122;
+  /** RegularExpression Id. */
+  int BIT_AND = 123;
+  /** RegularExpression Id. */
+  int BIT_OR = 124;
+  /** RegularExpression Id. */
+  int XOR = 125;
+  /** RegularExpression Id. */
+  int REM = 126;
+  /** RegularExpression Id. */
+  int PLUSASSIGN = 127;
+  /** RegularExpression Id. */
+  int MINUSASSIGN = 128;
+  /** RegularExpression Id. */
+  int STARASSIGN = 129;
+  /** RegularExpression Id. */
+  int SLASHASSIGN = 130;
+  /** RegularExpression Id. */
+  int ANDASSIGN = 131;
+  /** RegularExpression Id. */
+  int ORASSIGN = 132;
+  /** RegularExpression Id. */
+  int XORASSIGN = 133;
+  /** RegularExpression Id. */
+  int REMASSIGN = 134;
+  /** RegularExpression Id. */
+  int RUNSIGNEDSHIFT = 135;
+  /** RegularExpression Id. */
+  int RSIGNEDSHIFT = 136;
+  /** RegularExpression Id. */
+  int GT = 137;
+  /** RegularExpression Id. */
+  int LANGLE = 105;
+  /** RegularExpression Id. */
+  int RANGLE = 137;
+  /** RegularExpression Id. */
+  int IDENTIFIER = 151;
+  /** RegularExpression Id. */
+  int LETTER = 152;
+  /** RegularExpression Id. */
+  int PART_LETTER = 153;
+  /** RegularExpression Id. */
+  int ACT_TOK = 154;
+
+  /** Lexical state. */
+  int DEFAULT = 0;
+  /** Lexical state. */
+  int AFTER_EGEN = 1;
+  /** Lexical state. */
+  int IN_SINGLE_LINE_COMMENT = 2;
+  /** Lexical state. */
+  int IN_FORMAL_COMMENT = 3;
+  /** Lexical state. */
+  int IN_MULTI_LINE_COMMENT = 4;
+
+  /** Literal token values. */
+  String[] tokenImage = {
+    "<EOF>",
+    "\"LOOKAHEAD\"",
+    "\"IGNORE_CASE\"",
+    "\"PARSER_BEGIN\"",
+    "\"PARSER_END\"",
+    "\"JAVACODE\"",
+    "\"CPPCODE\"",
+    "\"TOKEN\"",
+    "\"SPECIAL_TOKEN\"",
+    "\"MORE\"",
+    "\"SKIP\"",
+    "\"TOKEN_MGR_DECLS\"",
+    "\"EOF\"",
+    "\" \"",
+    "\"\\t\"",
+    "\"\\n\"",
+    "\"\\r\"",
+    "\"\\f\"",
+    "\"/*@egen*/\"",
+    "<token of kind 19>",
+    "\"//\"",
+    "<token of kind 21>",
+    "\"/*\"",
+    "\"/*@bgen(jjtree\"",
+    "<SINGLE_LINE_COMMENT>",
+    "\"*/\"",
+    "\"*/\"",
+    "<token of kind 27>",
+    "\"abstract\"",
+    "\"assert\"",
+    "\"boolean\"",
+    "\"break\"",
+    "\"byte\"",
+    "\"case\"",
+    "\"catch\"",
+    "\"char\"",
+    "\"class\"",
+    "\"const\"",
+    "\"continue\"",
+    "\"default\"",
+    "\"do\"",
+    "\"double\"",
+    "\"else\"",
+    "\"enum\"",
+    "\"extends\"",
+    "\"false\"",
+    "\"final\"",
+    "\"finally\"",
+    "\"float\"",
+    "\"for\"",
+    "\"goto\"",
+    "\"if\"",
+    "\"implements\"",
+    "\"import\"",
+    "\"instanceof\"",
+    "\"int\"",
+    "\"interface\"",
+    "\"long\"",
+    "\"native\"",
+    "\"new\"",
+    "\"null\"",
+    "\"package\"",
+    "\"private\"",
+    "\"protected\"",
+    "\"public\"",
+    "\"return\"",
+    "\"short\"",
+    "\"static\"",
+    "\"strictfp\"",
+    "\"super\"",
+    "\"switch\"",
+    "\"synchronized\"",
+    "\"this\"",
+    "\"throw\"",
+    "\"throws\"",
+    "\"transient\"",
+    "\"true\"",
+    "\"try\"",
+    "\"void\"",
+    "\"volatile\"",
+    "\"while\"",
+    "\"template\"",
+    "\"typename\"",
+    "<INTEGER_LITERAL>",
+    "<DECIMAL_LITERAL>",
+    "<HEX_LITERAL>",
+    "<OCTAL_LITERAL>",
+    "<BINARY_LITERAL>",
+    "<FLOATING_POINT_LITERAL>",
+    "<DECIMAL_FLOATING_POINT_LITERAL>",
+    "<DECIMAL_EXPONENT>",
+    "<HEXADECIMAL_FLOATING_POINT_LITERAL>",
+    "<HEXADECIMAL_EXPONENT>",
+    "<CHARACTER_LITERAL>",
+    "<STRING_LITERAL>",
+    "\"(\"",
+    "\")\"",
+    "\"{\"",
+    "\"}\"",
+    "\"[\"",
+    "\"]\"",
+    "\";\"",
+    "\",\"",
+    "\".\"",
+    "\"=\"",
+    "\"<\"",
+    "\"!\"",
+    "\"~\"",
+    "\"?\"",
+    "\":\"",
+    "\"::\"",
+    "\"==\"",
+    "\"<=\"",
+    "\">=\"",
+    "\"!=\"",
+    "\"||\"",
+    "\"&&\"",
+    "\"++\"",
+    "\"--\"",
+    "\"+\"",
+    "\"-\"",
+    "\"*\"",
+    "\"/\"",
+    "\"&\"",
+    "\"|\"",
+    "\"^\"",
+    "\"%\"",
+    "\"+=\"",
+    "\"-=\"",
+    "\"*=\"",
+    "\"/=\"",
+    "\"&=\"",
+    "\"|=\"",
+    "\"^=\"",
+    "\"%=\"",
+    "\">>>\"",
+    "\">>\"",
+    "\">\"",
+    "\"#\"",
+    "\"DCL_PARSER_BEGIN\"",
+    "\"DCL_PARSER_END\"",
+    "\"INC_PARSER_BEGIN\"",
+    "\"INC_PARSER_END\"",
+    "\"DEF_PARSER_BEGIN\"",
+    "\"DEF_PARSER_END\"",
+    "\"...\"",
+    "\"<<=\"",
+    "\">>=\"",
+    "\">>>=\"",
+    "\"<<\"",
+    "\"@\"",
+    "<IDENTIFIER>",
+    "<LETTER>",
+    "<PART_LETTER>",
+    "<ACT_TOK>",
+  };
+
+}
diff --git a/generated/org/javacc/parser/JavaCCParserTokenManager.java b/generated/org/javacc/parser/JavaCCParserTokenManager.java
new file mode 100644
index 00000000..5a71e3d1
--- /dev/null
+++ b/generated/org/javacc/parser/JavaCCParserTokenManager.java
@@ -0,0 +1,2723 @@
+/* Generated By:JavaCC: Do not edit this line. JavaCCParserTokenManager.java */
+/**
+ * This file contains the code for JavaCCParser generated
+ * by JavaCCParser itself.
+ */
+
+package org.javacc.parser;
+import static org.javacc.parser.Options.*;
+import java.util.List;
+import java.util.ArrayList;
+
+/** Token Manager. */
+public class JavaCCParserTokenManager implements JavaCCParserConstants
+{
+   int beginLine[] = new int[10];
+   int beginCol[] = new int[10];
+   int depth = 0;
+   int size = 10;
+
+   void saveBeginLineCol(int l, int c)
+   {
+      if (depth == size)
+      {
+         size += 5;
+         int tmpbeginLine[] = new int[size];
+         int tmpbeginCol[] = new int[size];
+
+         System.arraycopy(beginLine, 0, beginLine = tmpbeginLine, 0, depth);
+         System.arraycopy(beginCol, 0, beginCol = tmpbeginCol, 0, depth);
+      }
+
+      beginLine[depth] = l;
+      beginCol[depth] = c;
+      depth++;
+   }
+
+   void restoreBeginLineCol()
+   {
+      depth--;
+      input_stream.adjustBeginLineColumn(beginLine[depth], beginCol[depth]);
+   }
+
+  /** Debug output. */
+  public  java.io.PrintStream debugStream = System.out;
+  /** Set debug output. */
+  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
+private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1, long active2)
+{
+   switch (pos)
+   {
+      case 0:
+         if ((active0 & 0xd40000L) != 0L || (active1 & 0x400000000000000L) != 0L || (active2 & 0x4L) != 0L)
+            return 2;
+         if ((active0 & 0xfffffffff0001ffeL) != 0L || (active1 & 0x7ffffL) != 0L || (active2 & 0x1f800L) != 0L)
+         {
+            jjmatchedKind = 151;
+            return 35;
+         }
+         if ((active1 & 0x8000000000L) != 0L || (active2 & 0x20000L) != 0L)
+            return 9;
+         return -1;
+      case 1:
+         if ((active0 & 0xc40000L) != 0L)
+            return 0;
+         if ((active0 & 0x8030000000000L) != 0L)
+            return 35;
+         if ((active0 & 0xfff7fcfff0001ffeL) != 0L || (active1 & 0x7ffffL) != 0L || (active2 & 0x1f800L) != 0L)
+         {
+            if (jjmatchedPos != 1)
+            {
+               jjmatchedKind = 151;
+               jjmatchedPos = 1;
+            }
+            return 35;
+         }
+         return -1;
+      case 2:
+         if ((active0 & 0xf675fefff0000ffeL) != 0L || (active1 & 0x7dfffL) != 0L || (active2 & 0x1f800L) != 0L)
+         {
+            if (jjmatchedPos != 2)
+            {
+               jjmatchedKind = 151;
+               jjmatchedPos = 2;
+            }
+            return 35;
+         }
+         if ((active0 & 0x982000000001000L) != 0L || (active1 & 0x2000L) != 0L)
+            return 35;
+         return -1;
+      case 3:
+         if ((active0 & 0x12040c0b00000600L) != 0L || (active1 & 0x5100L) != 0L)
+            return 35;
+         if ((active0 & 0xe571f2f4f00009feL) != 0L || (active1 & 0x78effL) != 0L || (active2 & 0x1f800L) != 0L)
+         {
+            jjmatchedKind = 151;
+            jjmatchedPos = 3;
+            return 35;
+         }
+         return -1;
+      case 4:
+         if ((active0 & 0x1e03480000880L) != 0L || (active1 & 0x10624L) != 0L)
+            return 35;
+         if ((active0 & 0xe57012c07000017eL) != 0L || (active1 & 0x688dbL) != 0L || (active2 & 0x1f800L) != 0L)
+         {
+            if (jjmatchedPos != 4)
+            {
+               jjmatchedKind = 151;
+               jjmatchedPos = 4;
+            }
+            return 35;
+         }
+         return -1;
+      case 5:
+         if ((active0 & 0xe15090c05000097eL) != 0L || (active1 & 0x68890L) != 0L || (active2 & 0x1f800L) != 0L)
+         {
+            jjmatchedKind = 151;
+            jjmatchedPos = 5;
+            return 35;
+         }
+         if ((active0 & 0x420020020000000L) != 0L || (active1 & 0x44bL) != 0L)
+            return 35;
+         return -1;
+      case 6:
+         if ((active0 & 0x815000401000093eL) != 0L || (active1 & 0x68890L) != 0L || (active2 & 0x1f800L) != 0L)
+         {
+            jjmatchedKind = 151;
+            jjmatchedPos = 6;
+            return 35;
+         }
+         if ((active0 & 0x6000908040000040L) != 0L)
+            return 35;
+         return -1;
+      case 7:
+         if ((active0 & 0x4010000020L) != 0L || (active1 & 0x68010L) != 0L)
+            return 35;
+         if ((active0 & 0x815000000000091eL) != 0L || (active1 & 0x880L) != 0L || (active2 & 0x1f800L) != 0L)
+         {
+            jjmatchedKind = 151;
+            jjmatchedPos = 7;
+            return 35;
+         }
+         return -1;
+      case 8:
+         if ((active0 & 0x5000000000091cL) != 0L || (active1 & 0x80L) != 0L || (active2 & 0x1f800L) != 0L)
+         {
+            jjmatchedKind = 151;
+            jjmatchedPos = 8;
+            return 35;
+         }
+         if ((active0 & 0x8100000000000002L) != 0L || (active1 & 0x800L) != 0L)
+            return 35;
+         return -1;
+      case 9:
+         if ((active0 & 0x90cL) != 0L || (active1 & 0x80L) != 0L || (active2 & 0x1f800L) != 0L)
+         {
+            jjmatchedKind = 151;
+            jjmatchedPos = 9;
+            return 35;
+         }
+         if ((active0 & 0x50000000000010L) != 0L)
+            return 35;
+         return -1;
+      case 10:
+         if ((active0 & 0x4L) != 0L)
+            return 35;
+         if ((active0 & 0x908L) != 0L || (active1 & 0x80L) != 0L || (active2 & 0x1f800L) != 0L)
+         {
+            jjmatchedKind = 151;
+            jjmatchedPos = 10;
+            return 35;
+         }
+         return -1;
+      case 11:
+         if ((active0 & 0x900L) != 0L || (active2 & 0x1f800L) != 0L)
+         {
+            jjmatchedKind = 151;
+            jjmatchedPos = 11;
+            return 35;
+         }
+         if ((active0 & 0x8L) != 0L || (active1 & 0x80L) != 0L)
+            return 35;
+         return -1;
+      case 12:
+         if ((active0 & 0x800L) != 0L || (active2 & 0x1f800L) != 0L)
+         {
+            jjmatchedKind = 151;
+            jjmatchedPos = 12;
+            return 35;
+         }
+         if ((active0 & 0x100L) != 0L)
+            return 35;
+         return -1;
+      case 13:
+         if ((active2 & 0x15000L) != 0L)
+            return 35;
+         if ((active0 & 0x800L) != 0L || (active2 & 0xa800L) != 0L)
+         {
+            jjmatchedKind = 151;
+            jjmatchedPos = 13;
+            return 35;
+         }
+         return -1;
+      case 14:
+         if ((active2 & 0xa800L) != 0L)
+         {
+            jjmatchedKind = 151;
+            jjmatchedPos = 14;
+            return 35;
+         }
+         if ((active0 & 0x800L) != 0L)
+            return 35;
+         return -1;
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_0(int pos, long active0, long active1, long active2)
+{
+   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0, active1, active2), pos + 1);
+}
+private int jjStopAtPos(int pos, int kind)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   return pos + 1;
+}
+private int jjStartNfaWithStates_0(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_0(state, pos + 1);
+}
+private int jjMoveStringLiteralDfa0_0()
+{
+   switch(curChar)
+   {
+      case 33:
+         jjmatchedKind = 106;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x4000000000000L, 0x0L);
+      case 35:
+         return jjStopAtPos(0, 138);
+      case 37:
+         jjmatchedKind = 126;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x0L, 0x40L);
+      case 38:
+         jjmatchedKind = 123;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x10000000000000L, 0x8L);
+      case 40:
+         return jjStopAtPos(0, 95);
+      case 41:
+         return jjStopAtPos(0, 96);
+      case 42:
+         jjmatchedKind = 121;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x0L, 0x2L);
+      case 43:
+         jjmatchedKind = 119;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x8020000000000000L, 0x0L);
+      case 44:
+         return jjStopAtPos(0, 102);
+      case 45:
+         jjmatchedKind = 120;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x40000000000000L, 0x1L);
+      case 46:
+         jjmatchedKind = 103;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x0L, 0x20000L);
+      case 47:
+         jjmatchedKind = 122;
+         return jjMoveStringLiteralDfa1_0(0xd40000L, 0x0L, 0x4L);
+      case 58:
+         jjmatchedKind = 109;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x400000000000L, 0x0L);
+      case 59:
+         return jjStopAtPos(0, 101);
+      case 60:
+         jjmatchedKind = 105;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x1000000000000L, 0x240000L);
+      case 61:
+         jjmatchedKind = 104;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x800000000000L, 0x0L);
+      case 62:
+         jjmatchedKind = 137;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x2000000000000L, 0x180180L);
+      case 63:
+         return jjStopAtPos(0, 108);
+      case 64:
+         return jjStopAtPos(0, 150);
+      case 67:
+         return jjMoveStringLiteralDfa1_0(0x40L, 0x0L, 0x0L);
+      case 68:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x0L, 0x19800L);
+      case 69:
+         return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L, 0x0L);
+      case 73:
+         return jjMoveStringLiteralDfa1_0(0x4L, 0x0L, 0x6000L);
+      case 74:
+         return jjMoveStringLiteralDfa1_0(0x20L, 0x0L, 0x0L);
+      case 76:
+         return jjMoveStringLiteralDfa1_0(0x2L, 0x0L, 0x0L);
+      case 77:
+         return jjMoveStringLiteralDfa1_0(0x200L, 0x0L, 0x0L);
+      case 80:
+         return jjMoveStringLiteralDfa1_0(0x18L, 0x0L, 0x0L);
+      case 83:
+         return jjMoveStringLiteralDfa1_0(0x500L, 0x0L, 0x0L);
+      case 84:
+         return jjMoveStringLiteralDfa1_0(0x880L, 0x0L, 0x0L);
+      case 91:
+         return jjStopAtPos(0, 99);
+      case 93:
+         return jjStopAtPos(0, 100);
+      case 94:
+         jjmatchedKind = 125;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x0L, 0x20L);
+      case 97:
+         return jjMoveStringLiteralDfa1_0(0x30000000L, 0x0L, 0x0L);
+      case 98:
+         return jjMoveStringLiteralDfa1_0(0x1c0000000L, 0x0L, 0x0L);
+      case 99:
+         return jjMoveStringLiteralDfa1_0(0x7e00000000L, 0x0L, 0x0L);
+      case 100:
+         return jjMoveStringLiteralDfa1_0(0x38000000000L, 0x0L, 0x0L);
+      case 101:
+         return jjMoveStringLiteralDfa1_0(0x1c0000000000L, 0x0L, 0x0L);
+      case 102:
+         return jjMoveStringLiteralDfa1_0(0x3e00000000000L, 0x0L, 0x0L);
+      case 103:
+         return jjMoveStringLiteralDfa1_0(0x4000000000000L, 0x0L, 0x0L);
+      case 105:
+         return jjMoveStringLiteralDfa1_0(0x1f8000000000000L, 0x0L, 0x0L);
+      case 108:
+         return jjMoveStringLiteralDfa1_0(0x200000000000000L, 0x0L, 0x0L);
+      case 110:
+         return jjMoveStringLiteralDfa1_0(0x1c00000000000000L, 0x0L, 0x0L);
+      case 112:
+         return jjMoveStringLiteralDfa1_0(0xe000000000000000L, 0x1L, 0x0L);
+      case 114:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x2L, 0x0L);
+      case 115:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0xfcL, 0x0L);
+      case 116:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x63f00L, 0x0L);
+      case 118:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0xc000L, 0x0L);
+      case 119:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x10000L, 0x0L);
+      case 123:
+         return jjStopAtPos(0, 97);
+      case 124:
+         jjmatchedKind = 124;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x8000000000000L, 0x10L);
+      case 125:
+         return jjStopAtPos(0, 98);
+      case 126:
+         return jjStopAtPos(0, 107);
+      default :
+         return jjMoveNfa_0(3, 0);
+   }
+}
+private int jjMoveStringLiteralDfa1_0(long active0, long active1, long active2)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(0, active0, active1, active2);
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 38:
+         if ((active1 & 0x10000000000000L) != 0L)
+            return jjStopAtPos(1, 116);
+         break;
+      case 42:
+         if ((active0 & 0x400000L) != 0L)
+         {
+            jjmatchedKind = 22;
+            jjmatchedPos = 1;
+         }
+         return jjMoveStringLiteralDfa2_0(active0, 0x840000L, active1, 0L, active2, 0L);
+      case 43:
+         if ((active1 & 0x20000000000000L) != 0L)
+            return jjStopAtPos(1, 117);
+         break;
+      case 45:
+         if ((active1 & 0x40000000000000L) != 0L)
+            return jjStopAtPos(1, 118);
+         break;
+      case 46:
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0L, active2, 0x20000L);
+      case 47:
+         if ((active0 & 0x100000L) != 0L)
+            return jjStopAtPos(1, 20);
+         break;
+      case 58:
+         if ((active1 & 0x400000000000L) != 0L)
+            return jjStopAtPos(1, 110);
+         break;
+      case 60:
+         if ((active2 & 0x200000L) != 0L)
+         {
+            jjmatchedKind = 149;
+            jjmatchedPos = 1;
+         }
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0L, active2, 0x40000L);
+      case 61:
+         if ((active1 & 0x800000000000L) != 0L)
+            return jjStopAtPos(1, 111);
+         else if ((active1 & 0x1000000000000L) != 0L)
+            return jjStopAtPos(1, 112);
+         else if ((active1 & 0x2000000000000L) != 0L)
+            return jjStopAtPos(1, 113);
+         else if ((active1 & 0x4000000000000L) != 0L)
+            return jjStopAtPos(1, 114);
+         else if ((active1 & 0x8000000000000000L) != 0L)
+            return jjStopAtPos(1, 127);
+         else if ((active2 & 0x1L) != 0L)
+            return jjStopAtPos(1, 128);
+         else if ((active2 & 0x2L) != 0L)
+            return jjStopAtPos(1, 129);
+         else if ((active2 & 0x4L) != 0L)
+            return jjStopAtPos(1, 130);
+         else if ((active2 & 0x8L) != 0L)
+            return jjStopAtPos(1, 131);
+         else if ((active2 & 0x10L) != 0L)
+            return jjStopAtPos(1, 132);
+         else if ((active2 & 0x20L) != 0L)
+            return jjStopAtPos(1, 133);
+         else if ((active2 & 0x40L) != 0L)
+            return jjStopAtPos(1, 134);
+         break;
+      case 62:
+         if ((active2 & 0x100L) != 0L)
+         {
+            jjmatchedKind = 136;
+            jjmatchedPos = 1;
+         }
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0L, active2, 0x180080L);
+      case 65:
+         return jjMoveStringLiteralDfa2_0(active0, 0x38L, active1, 0L, active2, 0L);
+      case 67:
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0L, active2, 0x1800L);
+      case 69:
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0L, active2, 0x18000L);
+      case 71:
+         return jjMoveStringLiteralDfa2_0(active0, 0x4L, active1, 0L, active2, 0L);
+      case 75:
+         return jjMoveStringLiteralDfa2_0(active0, 0x400L, active1, 0L, active2, 0L);
+      case 78:
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0L, active2, 0x6000L);
+      case 79:
+         return jjMoveStringLiteralDfa2_0(active0, 0x1a82L, active1, 0L, active2, 0L);
+      case 80:
+         return jjMoveStringLiteralDfa2_0(active0, 0x140L, active1, 0L, active2, 0L);
+      case 97:
+         return jjMoveStringLiteralDfa2_0(active0, 0x2400200600000000L, active1, 0L, active2, 0L);
+      case 98:
+         return jjMoveStringLiteralDfa2_0(active0, 0x10000000L, active1, 0L, active2, 0L);
+      case 101:
+         return jjMoveStringLiteralDfa2_0(active0, 0x800008000000000L, active1, 0x20002L, active2, 0L);
+      case 102:
+         if ((active0 & 0x8000000000000L) != 0L)
+            return jjStartNfaWithStates_0(1, 51, 35);
+         break;
+      case 104:
+         return jjMoveStringLiteralDfa2_0(active0, 0x800000000L, active1, 0x10704L, active2, 0L);
+      case 105:
+         return jjMoveStringLiteralDfa2_0(active0, 0xc00000000000L, active1, 0L, active2, 0L);
+      case 108:
+         return jjMoveStringLiteralDfa2_0(active0, 0x1041000000000L, active1, 0L, active2, 0L);
+      case 109:
+         return jjMoveStringLiteralDfa2_0(active0, 0x30000000000000L, active1, 0L, active2, 0L);
+      case 110:
+         return jjMoveStringLiteralDfa2_0(active0, 0x1c0080000000000L, active1, 0L, active2, 0L);
+      case 111:
+         if ((active0 & 0x10000000000L) != 0L)
+         {
+            jjmatchedKind = 40;
+            jjmatchedPos = 1;
+         }
+         return jjMoveStringLiteralDfa2_0(active0, 0x206026040000000L, active1, 0xc000L, active2, 0L);
+      case 114:
+         return jjMoveStringLiteralDfa2_0(active0, 0xc000000080000000L, active1, 0x3800L, active2, 0L);
+      case 115:
+         return jjMoveStringLiteralDfa2_0(active0, 0x20000000L, active1, 0L, active2, 0L);
+      case 116:
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x18L, active2, 0L);
+      case 117:
+         return jjMoveStringLiteralDfa2_0(active0, 0x1000000000000000L, active1, 0x21L, active2, 0L);
+      case 119:
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x40L, active2, 0L);
+      case 120:
+         return jjMoveStringLiteralDfa2_0(active0, 0x100000000000L, active1, 0L, active2, 0L);
+      case 121:
+         return jjMoveStringLiteralDfa2_0(active0, 0x100000000L, active1, 0x40080L, active2, 0L);
+      case 124:
+         if ((active1 & 0x8000000000000L) != 0L)
+            return jjStopAtPos(1, 115);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(0, active0, active1, active2);
+}
+private int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1, long old2, long active2)
+{
+   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
+      return jjStartNfa_0(0, old0, old1, old2); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(1, active0, active1, active2);
+      return 2;
+   }
+   switch(curChar)
+   {
+      case 46:
+         if ((active2 & 0x20000L) != 0L)
+            return jjStopAtPos(2, 145);
+         break;
+      case 61:
+         if ((active2 & 0x40000L) != 0L)
+            return jjStopAtPos(2, 146);
+         else if ((active2 & 0x80000L) != 0L)
+            return jjStopAtPos(2, 147);
+         break;
+      case 62:
+         if ((active2 & 0x80L) != 0L)
+         {
+            jjmatchedKind = 135;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0L, active2, 0x100000L);
+      case 64:
+         return jjMoveStringLiteralDfa3_0(active0, 0x840000L, active1, 0L, active2, 0L);
+      case 67:
+         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0L, active2, 0x6000L);
+      case 69:
+         return jjMoveStringLiteralDfa3_0(active0, 0x100L, active1, 0L, active2, 0L);
+      case 70:
+         if ((active0 & 0x1000L) != 0L)
+            return jjStartNfaWithStates_0(2, 12, 35);
+         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0L, active2, 0x18000L);
+      case 73:
+         return jjMoveStringLiteralDfa3_0(active0, 0x400L, active1, 0L, active2, 0L);
+      case 75:
+         return jjMoveStringLiteralDfa3_0(active0, 0x880L, active1, 0L, active2, 0L);
+      case 76:
+         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0L, active2, 0x1800L);
+      case 78:
+         return jjMoveStringLiteralDfa3_0(active0, 0x4L, active1, 0L, active2, 0L);
+      case 79:
+         return jjMoveStringLiteralDfa3_0(active0, 0x2L, active1, 0L, active2, 0L);
+      case 80:
+         return jjMoveStringLiteralDfa3_0(active0, 0x40L, active1, 0L, active2, 0L);
+      case 82:
+         return jjMoveStringLiteralDfa3_0(active0, 0x218L, active1, 0L, active2, 0L);
+      case 86:
+         return jjMoveStringLiteralDfa3_0(active0, 0x20L, active1, 0L, active2, 0L);
+      case 97:
+         return jjMoveStringLiteralDfa3_0(active0, 0x1800000000L, active1, 0x808L, active2, 0L);
+      case 98:
+         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x1L, active2, 0L);
+      case 99:
+         return jjMoveStringLiteralDfa3_0(active0, 0x2000000000000000L, active1, 0L, active2, 0L);
+      case 101:
+         return jjMoveStringLiteralDfa3_0(active0, 0x80000000L, active1, 0L, active2, 0L);
+      case 102:
+         return jjMoveStringLiteralDfa3_0(active0, 0x8000000000L, active1, 0L, active2, 0L);
+      case 105:
+         return jjMoveStringLiteralDfa3_0(active0, 0x4000000000000000L, active1, 0x14140L, active2, 0L);
+      case 108:
+         return jjMoveStringLiteralDfa3_0(active0, 0x1000200000000000L, active1, 0x8000L, active2, 0L);
+      case 109:
+         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x20000L, active2, 0L);
+      case 110:
+         return jjMoveStringLiteralDfa3_0(active0, 0x200c06000000000L, active1, 0x80L, active2, 0L);
+      case 111:
+         return jjMoveStringLiteralDfa3_0(active0, 0x8001000040000000L, active1, 0x4L, active2, 0L);
+      case 112:
+         return jjMoveStringLiteralDfa3_0(active0, 0x30000000000000L, active1, 0x40020L, active2, 0L);
+      case 114:
+         if ((active0 & 0x2000000000000L) != 0L)
+            return jjStartNfaWithStates_0(2, 49, 35);
+         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x610L, active2, 0L);
+      case 115:
+         return jjMoveStringLiteralDfa3_0(active0, 0x40040230000000L, active1, 0L, active2, 0L);
+      case 116:
+         if ((active0 & 0x80000000000000L) != 0L)
+         {
+            jjmatchedKind = 55;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0x504100500000000L, active1, 0x2L, active2, 0L);
+      case 117:
+         return jjMoveStringLiteralDfa3_0(active0, 0xa0000000000L, active1, 0x1000L, active2, 0L);
+      case 119:
+         if ((active0 & 0x800000000000000L) != 0L)
+            return jjStartNfaWithStates_0(2, 59, 35);
+         break;
+      case 121:
+         if ((active1 & 0x2000L) != 0L)
+            return jjStartNfaWithStates_0(2, 77, 35);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(1, active0, active1, active2);
+}
+private int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1, long old2, long active2)
+{
+   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
+      return jjStartNfa_0(1, old0, old1, old2); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(2, active0, active1, active2);
+      return 3;
+   }
+   switch(curChar)
+   {
+      case 61:
+         if ((active2 & 0x100000L) != 0L)
+            return jjStopAtPos(3, 148);
+         break;
+      case 65:
+         return jjMoveStringLiteralDfa4_0(active0, 0x20L, active1, 0L, active2, 0L);
+      case 67:
+         return jjMoveStringLiteralDfa4_0(active0, 0x140L, active1, 0L, active2, 0L);
+      case 69:
+         if ((active0 & 0x200L) != 0L)
+            return jjStartNfaWithStates_0(3, 9, 35);
+         return jjMoveStringLiteralDfa4_0(active0, 0x880L, active1, 0L, active2, 0L);
+      case 75:
+         return jjMoveStringLiteralDfa4_0(active0, 0x2L, active1, 0L, active2, 0L);
+      case 79:
+         return jjMoveStringLiteralDfa4_0(active0, 0x4L, active1, 0L, active2, 0L);
+      case 80:
+         if ((active0 & 0x400L) != 0L)
+            return jjStartNfaWithStates_0(3, 10, 35);
+         break;
+      case 83:
+         return jjMoveStringLiteralDfa4_0(active0, 0x18L, active1, 0L, active2, 0L);
+      case 95:
+         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0L, active2, 0x1f800L);
+      case 97:
+         return jjMoveStringLiteralDfa4_0(active0, 0x1c08080000000L, active1, 0x8000L, active2, 0L);
+      case 98:
+         return jjMoveStringLiteralDfa4_0(active0, 0x20000800000L, active1, 0L, active2, 0L);
+      case 99:
+         return jjMoveStringLiteralDfa4_0(active0, 0x400000000L, active1, 0x80L, active2, 0L);
+      case 100:
+         if ((active1 & 0x4000L) != 0L)
+            return jjStartNfaWithStates_0(3, 78, 35);
+         break;
+      case 101:
+         if ((active0 & 0x100000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 32, 35);
+         else if ((active0 & 0x200000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 33, 35);
+         else if ((active0 & 0x40000000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 42, 35);
+         else if ((active1 & 0x1000L) != 0L)
+            return jjStartNfaWithStates_0(3, 76, 35);
+         return jjMoveStringLiteralDfa4_0(active0, 0x100100020040000L, active1, 0x40020L, active2, 0L);
+      case 103:
+         if ((active0 & 0x200000000000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 57, 35);
+         break;
+      case 105:
+         return jjMoveStringLiteralDfa4_0(active0, 0x400000000000000L, active1, 0x10L, active2, 0L);
+      case 107:
+         return jjMoveStringLiteralDfa4_0(active0, 0x2000000000000000L, active1, 0L, active2, 0L);
+      case 108:
+         if ((active0 & 0x1000000000000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 60, 35);
+         return jjMoveStringLiteralDfa4_0(active0, 0x10000040000000L, active1, 0x10001L, active2, 0L);
+      case 109:
+         if ((active0 & 0x80000000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 43, 35);
+         break;
+      case 110:
+         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x800L, active2, 0L);
+      case 111:
+         if ((active0 & 0x4000000000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 50, 35);
+         return jjMoveStringLiteralDfa4_0(active0, 0x20000000000000L, active1, 0x600L, active2, 0L);
+      case 112:
+         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x20000L, active2, 0L);
+      case 114:
+         if ((active0 & 0x800000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 35, 35);
+         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x4L, active2, 0L);
+      case 115:
+         if ((active1 & 0x100L) != 0L)
+            return jjStartNfaWithStates_0(3, 72, 35);
+         return jjMoveStringLiteralDfa4_0(active0, 0x203000000000L, active1, 0L, active2, 0L);
+      case 116:
+         return jjMoveStringLiteralDfa4_0(active0, 0x8040004010000000L, active1, 0x48L, active2, 0L);
+      case 117:
+         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x2L, active2, 0L);
+      case 118:
+         return jjMoveStringLiteralDfa4_0(active0, 0x4000000000000000L, active1, 0L, active2, 0L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(2, active0, active1, active2);
+}
+private int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1, long old2, long active2)
+{
+   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
+      return jjStartNfa_0(2, old0, old1, old2); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(3, active0, active1, active2);
+      return 4;
+   }
+   switch(curChar)
+   {
+      case 65:
+         return jjMoveStringLiteralDfa5_0(active0, 0x2L, active1, 0L, active2, 0L);
+      case 67:
+         return jjMoveStringLiteralDfa5_0(active0, 0x20L, active1, 0L, active2, 0L);
+      case 69:
+         return jjMoveStringLiteralDfa5_0(active0, 0x18L, active1, 0L, active2, 0L);
+      case 73:
+         return jjMoveStringLiteralDfa5_0(active0, 0x100L, active1, 0L, active2, 0L);
+      case 78:
+         if ((active0 & 0x80L) != 0L)
+         {
+            jjmatchedKind = 7;
+            jjmatchedPos = 4;
+         }
+         return jjMoveStringLiteralDfa5_0(active0, 0x800L, active1, 0L, active2, 0L);
+      case 79:
+         return jjMoveStringLiteralDfa5_0(active0, 0x40L, active1, 0L, active2, 0L);
+      case 80:
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0L, active2, 0x1f800L);
+      case 82:
+         return jjMoveStringLiteralDfa5_0(active0, 0x4L, active1, 0L, active2, 0L);
+      case 97:
+         return jjMoveStringLiteralDfa5_0(active0, 0x6040000000000000L, active1, 0L, active2, 0L);
+      case 99:
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x50L, active2, 0L);
+      case 101:
+         if ((active0 & 0x200000000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 45, 35);
+         else if ((active1 & 0x10000L) != 0L)
+            return jjStartNfaWithStates_0(4, 80, 35);
+         return jjMoveStringLiteralDfa5_0(active0, 0x8010000040000000L, active1, 0L, active2, 0L);
+      case 103:
+         return jjMoveStringLiteralDfa5_0(active0, 0x840000L, active1, 0L, active2, 0L);
+      case 104:
+         if ((active0 & 0x400000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 34, 35);
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x80L, active2, 0L);
+      case 105:
+         return jjMoveStringLiteralDfa5_0(active0, 0x4000000000L, active1, 0x9L, active2, 0L);
+      case 107:
+         if ((active0 & 0x80000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 31, 35);
+         break;
+      case 108:
+         if ((active0 & 0x400000000000L) != 0L)
+         {
+            jjmatchedKind = 46;
+            jjmatchedPos = 4;
+         }
+         return jjMoveStringLiteralDfa5_0(active0, 0x820000000000L, active1, 0x20000L, active2, 0L);
+      case 110:
+         return jjMoveStringLiteralDfa5_0(active0, 0x100000000000L, active1, 0x40000L, active2, 0L);
+      case 114:
+         if ((active1 & 0x20L) != 0L)
+            return jjStartNfaWithStates_0(4, 69, 35);
+         return jjMoveStringLiteralDfa5_0(active0, 0x120000030000000L, active1, 0x2L, active2, 0L);
+      case 115:
+         if ((active0 & 0x1000000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 36, 35);
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x800L, active2, 0L);
+      case 116:
+         if ((active0 & 0x2000000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 37, 35);
+         else if ((active0 & 0x1000000000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 48, 35);
+         else if ((active1 & 0x4L) != 0L)
+            return jjStartNfaWithStates_0(4, 66, 35);
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x8000L, active2, 0L);
+      case 117:
+         return jjMoveStringLiteralDfa5_0(active0, 0x8000000000L, active1, 0L, active2, 0L);
+      case 118:
+         return jjMoveStringLiteralDfa5_0(active0, 0x400000000000000L, active1, 0L, active2, 0L);
+      case 119:
+         if ((active1 & 0x200L) != 0L)
+         {
+            jjmatchedKind = 73;
+            jjmatchedPos = 4;
+         }
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x400L, active2, 0L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(3, active0, active1, active2);
+}
+private int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1, long old2, long active2)
+{
+   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
+      return jjStartNfa_0(3, old0, old1, old2); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(4, active0, active1, active2);
+      return 5;
+   }
+   switch(curChar)
+   {
+      case 65:
+         return jjMoveStringLiteralDfa6_0(active0, 0x100L, active1, 0L, active2, 0x1f800L);
+      case 68:
+         return jjMoveStringLiteralDfa6_0(active0, 0x40L, active1, 0L, active2, 0L);
+      case 69:
+         return jjMoveStringLiteralDfa6_0(active0, 0x4L, active1, 0L, active2, 0L);
+      case 72:
+         return jjMoveStringLiteralDfa6_0(active0, 0x2L, active1, 0L, active2, 0L);
+      case 79:
+         return jjMoveStringLiteralDfa6_0(active0, 0x20L, active1, 0L, active2, 0L);
+      case 82:
+         return jjMoveStringLiteralDfa6_0(active0, 0x18L, active1, 0L, active2, 0L);
+      case 95:
+         return jjMoveStringLiteralDfa6_0(active0, 0x800L, active1, 0L, active2, 0L);
+      case 97:
+         return jjMoveStringLiteralDfa6_0(active0, 0x50000000L, active1, 0x60000L, active2, 0L);
+      case 99:
+         if ((active1 & 0x1L) != 0L)
+            return jjStartNfaWithStates_0(5, 64, 35);
+         else if ((active1 & 0x8L) != 0L)
+            return jjStartNfaWithStates_0(5, 67, 35);
+         return jjMoveStringLiteralDfa6_0(active0, 0x8000000000000000L, active1, 0L, active2, 0L);
+      case 100:
+         return jjMoveStringLiteralDfa6_0(active0, 0x100000000000L, active1, 0L, active2, 0L);
+      case 101:
+         if ((active0 & 0x20000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 41, 35);
+         else if ((active0 & 0x400000000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 58, 35);
+         return jjMoveStringLiteralDfa6_0(active0, 0x840000L, active1, 0L, active2, 0L);
+      case 102:
+         return jjMoveStringLiteralDfa6_0(active0, 0x100000000000000L, active1, 0L, active2, 0L);
+      case 103:
+         return jjMoveStringLiteralDfa6_0(active0, 0x2000000000000000L, active1, 0L, active2, 0L);
+      case 104:
+         if ((active1 & 0x40L) != 0L)
+            return jjStartNfaWithStates_0(5, 70, 35);
+         break;
+      case 105:
+         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x8800L, active2, 0L);
+      case 108:
+         return jjMoveStringLiteralDfa6_0(active0, 0x808000000000L, active1, 0L, active2, 0L);
+      case 109:
+         return jjMoveStringLiteralDfa6_0(active0, 0x10000000000000L, active1, 0L, active2, 0L);
+      case 110:
+         if ((active1 & 0x2L) != 0L)
+            return jjStartNfaWithStates_0(5, 65, 35);
+         return jjMoveStringLiteralDfa6_0(active0, 0x40004000000000L, active1, 0L, active2, 0L);
+      case 114:
+         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x80L, active2, 0L);
+      case 115:
+         if ((active1 & 0x400L) != 0L)
+            return jjStartNfaWithStates_0(5, 74, 35);
+         break;
+      case 116:
+         if ((active0 & 0x20000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 29, 35);
+         else if ((active0 & 0x20000000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 53, 35);
+         return jjMoveStringLiteralDfa6_0(active0, 0x4000000000000000L, active1, 0x10L, active2, 0L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(4, active0, active1, active2);
+}
+private int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1, long old2, long active2)
+{
+   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
+      return jjStartNfa_0(4, old0, old1, old2); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(5, active0, active1, active2);
+      return 6;
+   }
+   switch(curChar)
+   {
+      case 68:
+         return jjMoveStringLiteralDfa7_0(active0, 0x20L, active1, 0L, active2, 0L);
+      case 69:
+         if ((active0 & 0x40L) != 0L)
+            return jjStartNfaWithStates_0(6, 6, 35);
+         return jjMoveStringLiteralDfa7_0(active0, 0x2L, active1, 0L, active2, 0L);
+      case 76:
+         return jjMoveStringLiteralDfa7_0(active0, 0x100L, active1, 0L, active2, 0L);
+      case 77:
+         return jjMoveStringLiteralDfa7_0(active0, 0x800L, active1, 0L, active2, 0L);
+      case 82:
+         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0L, active2, 0x1f800L);
+      case 95:
+         return jjMoveStringLiteralDfa7_0(active0, 0x1cL, active1, 0L, active2, 0L);
+      case 97:
+         return jjMoveStringLiteralDfa7_0(active0, 0x100000000000000L, active1, 0L, active2, 0L);
+      case 99:
+         return jjMoveStringLiteralDfa7_0(active0, 0x40000010000000L, active1, 0L, active2, 0L);
+      case 101:
+         if ((active0 & 0x2000000000000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 61, 35);
+         else if ((active0 & 0x4000000000000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 62, 35);
+         return jjMoveStringLiteralDfa7_0(active0, 0x10000000000000L, active1, 0x800L, active2, 0L);
+      case 102:
+         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x10L, active2, 0L);
+      case 108:
+         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x8000L, active2, 0L);
+      case 109:
+         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x40000L, active2, 0L);
+      case 110:
+         if ((active0 & 0x40000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 30, 35);
+         return jjMoveStringLiteralDfa7_0(active0, 0x840000L, active1, 0L, active2, 0L);
+      case 111:
+         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x80L, active2, 0L);
+      case 115:
+         if ((active0 & 0x100000000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 44, 35);
+         break;
+      case 116:
+         if ((active0 & 0x8000000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 39, 35);
+         return jjMoveStringLiteralDfa7_0(active0, 0x8000000000000000L, active1, 0x20000L, active2, 0L);
+      case 117:
+         return jjMoveStringLiteralDfa7_0(active0, 0x4000000000L, active1, 0L, active2, 0L);
+      case 121:
+         if ((active0 & 0x800000000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 47, 35);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(5, active0, active1, active2);
+}
+private int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1, long old2, long active2)
+{
+   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
+      return jjStartNfa_0(5, old0, old1, old2); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(6, active0, active1, active2);
+      return 7;
+   }
+   switch(curChar)
+   {
+      case 40:
+         return jjMoveStringLiteralDfa8_0(active0, 0x800000L, active1, 0L, active2, 0L);
+      case 42:
+         return jjMoveStringLiteralDfa8_0(active0, 0x40000L, active1, 0L, active2, 0L);
+      case 65:
+         return jjMoveStringLiteralDfa8_0(active0, 0x2L, active1, 0L, active2, 0L);
+      case 66:
+         return jjMoveStringLiteralDfa8_0(active0, 0x8L, active1, 0L, active2, 0L);
+      case 67:
+         return jjMoveStringLiteralDfa8_0(active0, 0x4L, active1, 0L, active2, 0L);
+      case 69:
+         if ((active0 & 0x20L) != 0L)
+            return jjStartNfaWithStates_0(7, 5, 35);
+         return jjMoveStringLiteralDfa8_0(active0, 0x10L, active1, 0L, active2, 0L);
+      case 71:
+         return jjMoveStringLiteralDfa8_0(active0, 0x800L, active1, 0L, active2, 0L);
+      case 83:
+         return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0L, active2, 0x1f800L);
+      case 95:
+         return jjMoveStringLiteralDfa8_0(active0, 0x100L, active1, 0L, active2, 0L);
+      case 99:
+         return jjMoveStringLiteralDfa8_0(active0, 0x100000000000000L, active1, 0L, active2, 0L);
+      case 101:
+         if ((active0 & 0x4000000000L) != 0L)
+            return jjStartNfaWithStates_0(7, 38, 35);
+         else if ((active1 & 0x8000L) != 0L)
+            return jjStartNfaWithStates_0(7, 79, 35);
+         else if ((active1 & 0x20000L) != 0L)
+            return jjStartNfaWithStates_0(7, 81, 35);
+         else if ((active1 & 0x40000L) != 0L)
+            return jjStartNfaWithStates_0(7, 82, 35);
+         return jjMoveStringLiteralDfa8_0(active0, 0x8040000000000000L, active1, 0L, active2, 0L);
+      case 110:
+         return jjMoveStringLiteralDfa8_0(active0, 0x10000000000000L, active1, 0x880L, active2, 0L);
+      case 112:
+         if ((active1 & 0x10L) != 0L)
+            return jjStartNfaWithStates_0(7, 68, 35);
+         break;
+      case 116:
+         if ((active0 & 0x10000000L) != 0L)
+            return jjStartNfaWithStates_0(7, 28, 35);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(6, active0, active1, active2);
+}
+private int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1, long old2, long active2)
+{
+   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
+      return jjStartNfa_0(6, old0, old1, old2); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(7, active0, active1, active2);
+      return 8;
+   }
+   switch(curChar)
+   {
+      case 47:
+         if ((active0 & 0x40000L) != 0L)
+            return jjStopAtPos(8, 18);
+         break;
+      case 65:
+         return jjMoveStringLiteralDfa9_0(active0, 0x4L, active1, 0L, active2, 0L);
+      case 68:
+         if ((active0 & 0x2L) != 0L)
+            return jjStartNfaWithStates_0(8, 1, 35);
+         break;
+      case 69:
+         return jjMoveStringLiteralDfa9_0(active0, 0x8L, active1, 0L, active2, 0x1f800L);
+      case 78:
+         return jjMoveStringLiteralDfa9_0(active0, 0x10L, active1, 0L, active2, 0L);
+      case 82:
+         return jjMoveStringLiteralDfa9_0(active0, 0x800L, active1, 0L, active2, 0L);
+      case 84:
+         return jjMoveStringLiteralDfa9_0(active0, 0x100L, active1, 0L, active2, 0L);
+      case 100:
+         if ((active0 & 0x8000000000000000L) != 0L)
+            return jjStartNfaWithStates_0(8, 63, 35);
+         break;
+      case 101:
+         if ((active0 & 0x100000000000000L) != 0L)
+            return jjStartNfaWithStates_0(8, 56, 35);
+         break;
+      case 105:
+         return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x80L, active2, 0L);
+      case 106:
+         return jjMoveStringLiteralDfa9_0(active0, 0x800000L, active1, 0L, active2, 0L);
+      case 111:
+         return jjMoveStringLiteralDfa9_0(active0, 0x40000000000000L, active1, 0L, active2, 0L);
+      case 116:
+         if ((active1 & 0x800L) != 0L)
+            return jjStartNfaWithStates_0(8, 75, 35);
+         return jjMoveStringLiteralDfa9_0(active0, 0x10000000000000L, active1, 0L, active2, 0L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(7, active0, active1, active2);
+}
+private int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1, long old2, long active2)
+{
+   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
+      return jjStartNfa_0(7, old0, old1, old2); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(8, active0, active1, active2);
+      return 9;
+   }
+   switch(curChar)
+   {
+      case 68:
+         if ((active0 & 0x10L) != 0L)
+            return jjStartNfaWithStates_0(9, 4, 35);
+         break;
+      case 71:
+         return jjMoveStringLiteralDfa10_0(active0, 0x8L, active1, 0L, active2, 0L);
+      case 79:
+         return jjMoveStringLiteralDfa10_0(active0, 0x100L, active1, 0L, active2, 0L);
+      case 82:
+         return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0L, active2, 0x1f800L);
+      case 83:
+         return jjMoveStringLiteralDfa10_0(active0, 0x4L, active1, 0L, active2, 0L);
+      case 95:
+         return jjMoveStringLiteralDfa10_0(active0, 0x800L, active1, 0L, active2, 0L);
+      case 102:
+         if ((active0 & 0x40000000000000L) != 0L)
+            return jjStartNfaWithStates_0(9, 54, 35);
+         break;
+      case 106:
+         return jjMoveStringLiteralDfa10_0(active0, 0x800000L, active1, 0L, active2, 0L);
+      case 115:
+         if ((active0 & 0x10000000000000L) != 0L)
+            return jjStartNfaWithStates_0(9, 52, 35);
+         break;
+      case 122:
+         return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x80L, active2, 0L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(8, active0, active1, active2);
+}
+private int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1, long old2, long active2)
+{
+   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
+      return jjStartNfa_0(8, old0, old1, old2); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(9, active0, active1, active2);
+      return 10;
+   }
+   switch(curChar)
+   {
+      case 68:
+         return jjMoveStringLiteralDfa11_0(active0, 0x800L, active1, 0L, active2, 0L);
+      case 69:
+         if ((active0 & 0x4L) != 0L)
+            return jjStartNfaWithStates_0(10, 2, 35);
+         break;
+      case 73:
+         return jjMoveStringLiteralDfa11_0(active0, 0x8L, active1, 0L, active2, 0L);
+      case 75:
+         return jjMoveStringLiteralDfa11_0(active0, 0x100L, active1, 0L, active2, 0L);
+      case 95:
+         return jjMoveStringLiteralDfa11_0(active0, 0L, active1, 0L, active2, 0x1f800L);
+      case 101:
+         return jjMoveStringLiteralDfa11_0(active0, 0L, active1, 0x80L, active2, 0L);
+      case 116:
+         return jjMoveStringLiteralDfa11_0(active0, 0x800000L, active1, 0L, active2, 0L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(9, active0, active1, active2);
+}
+private int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1, long old2, long active2)
+{
+   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
+      return jjStartNfa_0(9, old0, old1, old2); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(10, active0, active1, active2);
+      return 11;
+   }
+   switch(curChar)
+   {
+      case 66:
+         return jjMoveStringLiteralDfa12_0(active0, 0L, active1, 0L, active2, 0xa800L);
+      case 69:
+         return jjMoveStringLiteralDfa12_0(active0, 0x900L, active1, 0L, active2, 0x15000L);
+      case 78:
+         if ((active0 & 0x8L) != 0L)
+            return jjStartNfaWithStates_0(11, 3, 35);
+         break;
+      case 100:
+         if ((active1 & 0x80L) != 0L)
+            return jjStartNfaWithStates_0(11, 71, 35);
+         break;
+      case 114:
+         return jjMoveStringLiteralDfa12_0(active0, 0x800000L, active1, 0L, active2, 0L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(10, active0, active1, active2);
+}
+private int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1, long old2, long active2)
+{
+   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
+      return jjStartNfa_0(10, old0, old1, old2); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(11, active0, 0L, active2);
+      return 12;
+   }
+   switch(curChar)
+   {
+      case 67:
+         return jjMoveStringLiteralDfa13_0(active0, 0x800L, active2, 0L);
+      case 69:
+         return jjMoveStringLiteralDfa13_0(active0, 0L, active2, 0xa800L);
+      case 78:
+         if ((active0 & 0x100L) != 0L)
+            return jjStartNfaWithStates_0(12, 8, 35);
+         return jjMoveStringLiteralDfa13_0(active0, 0L, active2, 0x15000L);
+      case 101:
+         return jjMoveStringLiteralDfa13_0(active0, 0x800000L, active2, 0L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(11, active0, 0L, active2);
+}
+private int jjMoveStringLiteralDfa13_0(long old0, long active0, long old2, long active2)
+{
+   if (((active0 &= old0) | (active2 &= old2)) == 0L)
+      return jjStartNfa_0(11, old0, 0L, old2); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(12, active0, 0L, active2);
+      return 13;
+   }
+   switch(curChar)
+   {
+      case 68:
+         if ((active2 & 0x1000L) != 0L)
+            return jjStartNfaWithStates_0(13, 140, 35);
+         else if ((active2 & 0x4000L) != 0L)
+            return jjStartNfaWithStates_0(13, 142, 35);
+         else if ((active2 & 0x10000L) != 0L)
+            return jjStartNfaWithStates_0(13, 144, 35);
+         break;
+      case 71:
+         return jjMoveStringLiteralDfa14_0(active0, 0L, active2, 0xa800L);
+      case 76:
+         return jjMoveStringLiteralDfa14_0(active0, 0x800L, active2, 0L);
+      case 101:
+         if ((active0 & 0x800000L) != 0L)
+            return jjStopAtPos(13, 23);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(12, active0, 0L, active2);
+}
+private int jjMoveStringLiteralDfa14_0(long old0, long active0, long old2, long active2)
+{
+   if (((active0 &= old0) | (active2 &= old2)) == 0L)
+      return jjStartNfa_0(12, old0, 0L, old2); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(13, active0, 0L, active2);
+      return 14;
+   }
+   switch(curChar)
+   {
+      case 73:
+         return jjMoveStringLiteralDfa15_0(active0, 0L, active2, 0xa800L);
+      case 83:
+         if ((active0 & 0x800L) != 0L)
+            return jjStartNfaWithStates_0(14, 11, 35);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(13, active0, 0L, active2);
+}
+private int jjMoveStringLiteralDfa15_0(long old0, long active0, long old2, long active2)
+{
+   if (((active0 &= old0) | (active2 &= old2)) == 0L)
+      return jjStartNfa_0(13, old0, 0L, old2); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(14, 0L, 0L, active2);
+      return 15;
+   }
+   switch(curChar)
+   {
+      case 78:
+         if ((active2 & 0x800L) != 0L)
+            return jjStartNfaWithStates_0(15, 139, 35);
+         else if ((active2 & 0x2000L) != 0L)
+            return jjStartNfaWithStates_0(15, 141, 35);
+         else if ((active2 & 0x8000L) != 0L)
+            return jjStartNfaWithStates_0(15, 143, 35);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(14, 0L, 0L, active2);
+}
+static final long[] jjbitVec0 = {
+   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+static final long[] jjbitVec2 = {
+   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+static final long[] jjbitVec3 = {
+   0xfff0000000200002L, 0xffffffffffffdfffL, 0xfffff00f7fffffffL, 0x12000000007fffffL
+};
+static final long[] jjbitVec4 = {
+   0x0L, 0x0L, 0x420043c00000000L, 0xff7fffffff7fffffL
+};
+static final long[] jjbitVec5 = {
+   0xffffcffffffffL, 0xffffffffffff0000L, 0xf9ff3fffffffffffL, 0x401f00030003L
+};
+static final long[] jjbitVec6 = {
+   0x0L, 0x400000000000000L, 0xfffffffbffffd740L, 0xffffffcff7fffL
+};
+static final long[] jjbitVec7 = {
+   0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffffff003L, 0x33fffffffff199fL
+};
+static final long[] jjbitVec8 = {
+   0xfffe000000000000L, 0xfffffffe027fffffL, 0xffL, 0x707ffffff0000L
+};
+static final long[] jjbitVec9 = {
+   0x7fffffe00000000L, 0xfffe0000000007ffL, 0xffffffffffffffffL, 0x1c000060002fffffL
+};
+static final long[] jjbitVec10 = {
+   0x1ffffffd0000L, 0x0L, 0x3fffffffffL, 0x0L
+};
+static final long[] jjbitVec11 = {
+   0x23ffffffffffffe0L, 0x3ff010000L, 0x3c5fdfffff99fe0L, 0xf0003b0000000L
+};
+static final long[] jjbitVec12 = {
+   0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100010000L
+};
+static final long[] jjbitVec13 = {
+   0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L
+};
+static final long[] jjbitVec14 = {
+   0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L
+};
+static final long[] jjbitVec15 = {
+   0x3fffdfffffddfe0L, 0x300000000L, 0x2ffbfffffc7fffe0L, 0x7fL
+};
+static final long[] jjbitVec16 = {
+   0x800dfffffffffffeL, 0x7fL, 0x200decaefef02596L, 0x3000005fL
+};
+static final long[] jjbitVec17 = {
+   0x1L, 0x7fffffffeffL, 0xf00L, 0x0L
+};
+static final long[] jjbitVec18 = {
+   0x6fbffffffffL, 0x3f0000L, 0xffffffff00000000L, 0x7fffffffff003fL
+};
+static final long[] jjbitVec19 = {
+   0xffffffffffffffffL, 0xffffffff83ffffffL, 0xffffff07ffffffffL, 0x3ffffffffffffffL
+};
+static final long[] jjbitVec20 = {
+   0xffffffffffffff7fL, 0xffffffff3d7f3d7fL, 0x7f3d7fffffff3d7fL, 0xffff7fffff7f7f3dL
+};
+static final long[] jjbitVec21 = {
+   0xffffffff7f3d7fffL, 0x7ffff7fL, 0xffffffff00000000L, 0x1fffffffffffffL
+};
+static final long[] jjbitVec22 = {
+   0xffffffffffffffffL, 0x7f9fffffffffffL, 0xffffffff07fffffeL, 0x7ffffffffffL
+};
+static final long[] jjbitVec23 = {
+   0x0L, 0x0L, 0xfffffffffffffL, 0x8000000L
+};
+static final long[] jjbitVec24 = {
+   0xffffffff00000000L, 0xffffffffffffffL, 0x1ffffffffffL, 0x0L
+};
+static final long[] jjbitVec25 = {
+   0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL
+};
+static final long[] jjbitVec26 = {
+   0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL
+};
+static final long[] jjbitVec27 = {
+   0x8000000000000000L, 0x8000000000000001L, 0xffff00000000L, 0x0L
+};
+static final long[] jjbitVec28 = {
+   0x3fbbd503e2ffc84L, 0xffffffff00000000L, 0xfL, 0x0L
+};
+static final long[] jjbitVec29 = {
+   0x73e03fe000000e0L, 0xfffffffffffffffeL, 0xfffffffe601fffffL, 0x7fffffffffffffffL
+};
+static final long[] jjbitVec30 = {
+   0xfffe1fffffffffe0L, 0xffffffffffffffffL, 0xffffff00007fffL, 0x0L
+};
+static final long[] jjbitVec31 = {
+   0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffffffL, 0x0L
+};
+static final long[] jjbitVec32 = {
+   0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L
+};
+static final long[] jjbitVec33 = {
+   0xffffffffffffffffL, 0xffffffffffffffffL, 0x1fffL, 0x0L
+};
+static final long[] jjbitVec34 = {
+   0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L
+};
+static final long[] jjbitVec35 = {
+   0x3fffffffffffL, 0x0L, 0x0L, 0x0L
+};
+static final long[] jjbitVec36 = {
+   0x5f7ffdffa0f8007fL, 0xffffffffffffffdbL, 0x3ffffffffffffL, 0xfffffffffff80000L
+};
+static final long[] jjbitVec37 = {
+   0x3fffffffffffffffL, 0xffffffffffff0000L, 0xfffffffffffcffffL, 0xfff0000000000ffL
+};
+static final long[] jjbitVec38 = {
+   0x18000000000000L, 0xffd702000000e000L, 0xffffffffffffffffL, 0x1fffffffffffffffL
+};
+static final long[] jjbitVec39 = {
+   0x87fffffe00000010L, 0xffffffe007fffffeL, 0x7fffffffffffffffL, 0x631cfcfcfcL
+};
+static final long[] jjbitVec40 = {
+   0x0L, 0x0L, 0x420043cffffffffL, 0xff7fffffff7fffffL
+};
+static final long[] jjbitVec41 = {
+   0xffffffffffffffffL, 0x400000700007fffL, 0xfffffffbffffd740L, 0xffffffcff7fffL
+};
+static final long[] jjbitVec42 = {
+   0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffffff07bL, 0x33fffffffff199fL
+};
+static final long[] jjbitVec43 = {
+   0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe00ffL, 0x707ffffff0016L
+};
+static final long[] jjbitVec44 = {
+   0x7fffffe00000000L, 0xffff03ff003fffffL, 0xffffffffffffffffL, 0x1fff3dff9fefffffL
+};
+static final long[] jjbitVec45 = {
+   0xffff1fffffff8000L, 0x7ffL, 0x1ffffffffffffL, 0x0L
+};
+static final long[] jjbitVec46 = {
+   0xf3ffffffffffffeeL, 0xffcfff1f3fffL, 0xd3c5fdfffff99feeL, 0xfffcfb080399fL
+};
+static final long[] jjbitVec47 = {
+   0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100013bbfL
+};
+static final long[] jjbitVec48 = {
+   0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L
+};
+static final long[] jjbitVec49 = {
+   0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL
+};
+static final long[] jjbitVec50 = {
+   0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x2ffbfffffc7fffecL, 0xc0000ff5f847fL
+};
+static final long[] jjbitVec51 = {
+   0x87fffffffffffffeL, 0x3ff7fffL, 0x3bffecaefef02596L, 0x33ff3f5fL
+};
+static final long[] jjbitVec52 = {
+   0xc2a003ff03000001L, 0xfffe07fffffffeffL, 0x1ffffffffeff0fdfL, 0x40L
+};
+static final long[] jjbitVec53 = {
+   0x3c7f6fbffffffffL, 0x3ff03ffL, 0xffffffff00000000L, 0x7fffffffff003fL
+};
+static final long[] jjbitVec54 = {
+   0xffffffff7f3d7fffL, 0x3fe0007ffff7fL, 0xffffffff00000000L, 0x1fffffffffffffL
+};
+static final long[] jjbitVec55 = {
+   0x0L, 0x0L, 0xffffffffffffffffL, 0x3ff080fffffL
+};
+static final long[] jjbitVec56 = {
+   0xffffffff03ff7800L, 0xffffffffffffffL, 0x3ffffffffffL, 0x0L
+};
+static final long[] jjbitVec57 = {
+   0x80007c000000f000L, 0x8000fc0000000001L, 0xffff00000000L, 0x21fff0000L
+};
+static final long[] jjbitVec58 = {
+   0x73efffe000000e0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x7fffffffffffffffL
+};
+static final long[] jjbitVec59 = {
+   0x5f7ffdffe0f8007fL, 0xffffffffffffffdbL, 0x3ffffffffffffL, 0xfffffffffff80000L
+};
+static final long[] jjbitVec60 = {
+   0x18000f00000000L, 0xffd702000000e000L, 0xffffffffffffffffL, 0x9fffffffffffffffL
+};
+static final long[] jjbitVec61 = {
+   0x87fffffe03ff0010L, 0xffffffe007fffffeL, 0x7fffffffffffffffL, 0xe0000631cfcfcfcL
+};
+private int jjMoveNfa_0(int startState, int curPos)
+{
+   //int[] nextStates; // not used
+   int startsAt = 0;
+   jjnewStateCnt = 85;
+   int i = 1;
+   jjstateSet[0] = startState;
+   //int j; // not used
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 3:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddStates(0, 9);
+                  else if (curChar == 36)
+                  {
+                     if (kind > 151)
+                        kind = 151;
+                     jjCheckNAdd(35);
+                  }
+                  else if (curChar == 34)
+                     jjCheckNAddStates(10, 12);
+                  else if (curChar == 39)
+                     jjAddStates(13, 14);
+                  else if (curChar == 46)
+                     jjCheckNAdd(9);
+                  else if (curChar == 47)
+                     jjstateSet[jjnewStateCnt++] = 2;
+                  if ((0x3fe000000000000L & l) != 0L)
+                  {
+                     if (kind > 83)
+                        kind = 83;
+                     jjCheckNAddStates(15, 17);
+                  }
+                  else if (curChar == 48)
+                  {
+                     if (kind > 83)
+                        kind = 83;
+                     jjCheckNAddStates(18, 24);
+                  }
+                  break;
+               case 0:
+                  if (curChar == 42)
+                     jjstateSet[jjnewStateCnt++] = 1;
+                  break;
+               case 1:
+                  if ((0xffff7fffffffffffL & l) != 0L && kind > 21)
+                     kind = 21;
+                  break;
+               case 2:
+                  if (curChar == 42)
+                     jjstateSet[jjnewStateCnt++] = 0;
+                  break;
+               case 4:
+                  if ((0x3fe000000000000L & l) == 0L)
+                     break;
+                  if (kind > 83)
+                     kind = 83;
+                  jjCheckNAddStates(15, 17);
+                  break;
+               case 6:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 83)
+                     kind = 83;
+                  jjCheckNAddStates(15, 17);
+                  break;
+               case 8:
+                  if (curChar == 46)
+                     jjCheckNAdd(9);
+                  break;
+               case 9:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 88)
+                     kind = 88;
+                  jjCheckNAddStates(25, 28);
+                  break;
+               case 12:
+                  if ((0x280000000000L & l) != 0L)
+                     jjCheckNAdd(13);
+                  break;
+               case 13:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 88)
+                     kind = 88;
+                  jjCheckNAddStates(29, 31);
+                  break;
+               case 16:
+                  if (curChar == 39)
+                     jjAddStates(13, 14);
+                  break;
+               case 17:
+                  if ((0xffffff7fffffdbffL & l) != 0L)
+                     jjCheckNAdd(18);
+                  break;
+               case 18:
+                  if (curChar == 39 && kind > 93)
+                     kind = 93;
+                  break;
+               case 20:
+                  if ((0x8400000000L & l) != 0L)
+                     jjCheckNAdd(18);
+                  break;
+               case 21:
+                  if ((0xff000000000000L & l) != 0L)
+                     jjCheckNAddTwoStates(22, 18);
+                  break;
+               case 22:
+                  if ((0xff000000000000L & l) != 0L)
+                     jjCheckNAdd(18);
+                  break;
+               case 23:
+                  if ((0xf000000000000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 24;
+                  break;
+               case 24:
+                  if ((0xff000000000000L & l) != 0L)
+                     jjCheckNAdd(22);
+                  break;
+               case 25:
+                  if (curChar == 34)
+                     jjCheckNAddStates(10, 12);
+                  break;
+               case 26:
+                  if ((0xfffffffbffffdbffL & l) != 0L)
+                     jjCheckNAddStates(10, 12);
+                  break;
+               case 28:
+                  if ((0x8400000000L & l) != 0L)
+                     jjCheckNAddStates(10, 12);
+                  break;
+               case 29:
+                  if (curChar == 34 && kind > 94)
+                     kind = 94;
+                  break;
+               case 30:
+                  if ((0xff000000000000L & l) != 0L)
+                     jjCheckNAddStates(32, 35);
+                  break;
+               case 31:
+                  if ((0xff000000000000L & l) != 0L)
+                     jjCheckNAddStates(10, 12);
+                  break;
+               case 32:
+                  if ((0xf000000000000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 33;
+                  break;
+               case 33:
+                  if ((0xff000000000000L & l) != 0L)
+                     jjCheckNAdd(31);
+                  break;
+               case 34:
+                  if (curChar != 36)
+                     break;
+                  if (kind > 151)
+                     kind = 151;
+                  jjCheckNAdd(35);
+                  break;
+               case 35:
+                  if ((0x3ff00100fffc1ffL & l) == 0L)
+                     break;
+                  if (kind > 151)
+                     kind = 151;
+                  jjCheckNAdd(35);
+                  break;
+               case 36:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddStates(0, 9);
+                  break;
+               case 38:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddStates(36, 39);
+                  break;
+               case 40:
+                  if ((0x280000000000L & l) != 0L)
+                     jjCheckNAdd(41);
+                  break;
+               case 41:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddStates(40, 42);
+                  break;
+               case 44:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddStates(43, 45);
+                  break;
+               case 46:
+                  if ((0x280000000000L & l) != 0L)
+                     jjCheckNAdd(47);
+                  break;
+               case 47:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 88)
+                     kind = 88;
+                  jjCheckNAddStates(46, 48);
+                  break;
+               case 50:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddStates(49, 51);
+                  break;
+               case 51:
+                  if (curChar != 46)
+                     break;
+                  if (kind > 88)
+                     kind = 88;
+                  jjCheckNAddStates(52, 54);
+                  break;
+               case 52:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 88)
+                     kind = 88;
+                  jjCheckNAddStates(55, 58);
+                  break;
+               case 55:
+                  if ((0x280000000000L & l) != 0L)
+                     jjCheckNAdd(56);
+                  break;
+               case 56:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 88)
+                     kind = 88;
+                  jjCheckNAddStates(59, 61);
+                  break;
+               case 58:
+                  if (curChar != 48)
+                     break;
+                  if (kind > 83)
+                     kind = 83;
+                  jjCheckNAddStates(18, 24);
+                  break;
+               case 60:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 83)
+                     kind = 83;
+                  jjCheckNAddStates(62, 64);
+                  break;
+               case 63:
+                  if ((0xff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 83)
+                     kind = 83;
+                  jjCheckNAddStates(65, 67);
+                  break;
+               case 65:
+                  if ((0x3000000000000L & l) == 0L)
+                     break;
+                  if (kind > 83)
+                     kind = 83;
+                  jjCheckNAddStates(68, 70);
+                  break;
+               case 68:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjAddStates(71, 73);
+                  break;
+               case 70:
+                  if (curChar == 46)
+                     jjCheckNAdd(71);
+                  break;
+               case 71:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddStates(74, 76);
+                  break;
+               case 74:
+                  if ((0x280000000000L & l) != 0L)
+                     jjCheckNAdd(75);
+                  break;
+               case 75:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 88)
+                     kind = 88;
+                  jjCheckNAddStates(77, 79);
+                  break;
+               case 78:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddStates(80, 83);
+                  break;
+               case 80:
+                  if (curChar == 46)
+                     jjCheckNAdd(81);
+                  break;
+               case 82:
+                  if ((0x280000000000L & l) != 0L)
+                     jjCheckNAdd(83);
+                  break;
+               case 83:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 88)
+                     kind = 88;
+                  jjCheckNAddStates(84, 86);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 3:
+                  if ((0x7fffffe87fffffeL & l) == 0L)
+                     break;
+                  if (kind > 151)
+                     kind = 151;
+                  jjCheckNAdd(35);
+                  break;
+               case 1:
+                  if (kind > 21)
+                     kind = 21;
+                  break;
+               case 5:
+                  if (curChar == 95)
+                     jjAddStates(87, 88);
+                  break;
+               case 7:
+                  if ((0x100000001000L & l) != 0L && kind > 83)
+                     kind = 83;
+                  break;
+               case 10:
+                  if (curChar == 95)
+                     jjAddStates(89, 90);
+                  break;
+               case 11:
+                  if ((0x2000000020L & l) != 0L)
+                     jjCheckNAddTwoStates(12, 13);
+                  break;
+               case 14:
+                  if (curChar == 95)
+                     jjCheckNAddTwoStates(14, 13);
+                  break;
+               case 15:
+                  if ((0x5000000050L & l) != 0L && kind > 88)
+                     kind = 88;
+                  break;
+               case 17:
+                  if ((0xffffffffefffffffL & l) != 0L)
+                     jjCheckNAdd(18);
+                  break;
+               case 19:
+                  if (curChar == 92)
+                     jjAddStates(91, 93);
+                  break;
+               case 20:
+                  if ((0x14404410000000L & l) != 0L)
+                     jjCheckNAdd(18);
+                  break;
+               case 26:
+                  if ((0xffffffffefffffffL & l) != 0L)
+                     jjCheckNAddStates(10, 12);
+                  break;
+               case 27:
+                  if (curChar == 92)
+                     jjAddStates(94, 96);
+                  break;
+               case 28:
+                  if ((0x14404410000000L & l) != 0L)
+                     jjCheckNAddStates(10, 12);
+                  break;
+               case 35:
+                  if ((0x87fffffe87fffffeL & l) == 0L)
+                     break;
+                  if (kind > 151)
+                     kind = 151;
+                  jjCheckNAdd(35);
+                  break;
+               case 37:
+                  if (curChar == 95)
+                     jjAddStates(97, 98);
+                  break;
+               case 39:
+                  if ((0x2000000020L & l) != 0L)
+                     jjCheckNAddTwoStates(40, 41);
+                  break;
+               case 42:
+                  if (curChar == 95)
+                     jjCheckNAddTwoStates(42, 41);
+                  break;
+               case 43:
+                  if (curChar == 95)
+                     jjAddStates(99, 100);
+                  break;
+               case 45:
+                  if ((0x2000000020L & l) != 0L)
+                     jjCheckNAddTwoStates(46, 47);
+                  break;
+               case 48:
+                  if (curChar == 95)
+                     jjCheckNAddTwoStates(48, 47);
+                  break;
+               case 49:
+                  if (curChar == 95)
+                     jjAddStates(101, 102);
+                  break;
+               case 53:
+                  if (curChar == 95)
+                     jjAddStates(103, 104);
+                  break;
+               case 54:
+                  if ((0x2000000020L & l) != 0L)
+                     jjCheckNAddTwoStates(55, 56);
+                  break;
+               case 57:
+                  if (curChar == 95)
+                     jjCheckNAddTwoStates(57, 56);
+                  break;
+               case 59:
+                  if ((0x100000001000000L & l) != 0L)
+                     jjCheckNAdd(60);
+                  break;
+               case 60:
+                  if ((0x7e0000007eL & l) == 0L)
+                     break;
+                  if (kind > 83)
+                     kind = 83;
+                  jjCheckNAddStates(62, 64);
+                  break;
+               case 61:
+                  if (curChar == 95)
+                     jjCheckNAddTwoStates(61, 60);
+                  break;
+               case 62:
+                  if (curChar == 95)
+                     jjAddStates(105, 106);
+                  break;
+               case 64:
+                  if ((0x400000004L & l) != 0L)
+                     jjCheckNAdd(65);
+                  break;
+               case 66:
+                  if (curChar == 95)
+                     jjCheckNAddTwoStates(66, 65);
+                  break;
+               case 67:
+                  if ((0x100000001000000L & l) != 0L)
+                     jjCheckNAddTwoStates(68, 70);
+                  break;
+               case 68:
+                  if ((0x7e0000007eL & l) != 0L)
+                     jjCheckNAddStates(71, 73);
+                  break;
+               case 69:
+                  if (curChar == 95)
+                     jjCheckNAddTwoStates(69, 68);
+                  break;
+               case 71:
+                  if ((0x7e0000007eL & l) != 0L)
+                     jjCheckNAddStates(74, 76);
+                  break;
+               case 72:
+                  if (curChar == 95)
+                     jjCheckNAddTwoStates(72, 71);
+                  break;
+               case 73:
+                  if ((0x1000000010000L & l) != 0L)
+                     jjCheckNAddTwoStates(74, 75);
+                  break;
+               case 76:
+                  if (curChar == 95)
+                     jjCheckNAddTwoStates(76, 75);
+                  break;
+               case 77:
+                  if ((0x100000001000000L & l) != 0L)
+                     jjCheckNAdd(78);
+                  break;
+               case 78:
+                  if ((0x7e0000007eL & l) != 0L)
+                     jjCheckNAddStates(80, 83);
+                  break;
+               case 79:
+                  if (curChar == 95)
+                     jjCheckNAddTwoStates(79, 78);
+                  break;
+               case 81:
+                  if ((0x1000000010000L & l) != 0L)
+                     jjCheckNAddTwoStates(82, 83);
+                  break;
+               case 84:
+                  if (curChar == 95)
+                     jjCheckNAddTwoStates(84, 83);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 3:
+                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 151)
+                     kind = 151;
+                  jjCheckNAdd(35);
+                  break;
+               case 1:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 21)
+                     kind = 21;
+                  break;
+               case 17:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjstateSet[jjnewStateCnt++] = 18;
+                  break;
+               case 26:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjAddStates(10, 12);
+                  break;
+               case 35:
+                  if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 151)
+                     kind = 151;
+                  jjCheckNAdd(35);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 85 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private int jjMoveStringLiteralDfa0_4()
+{
+   switch(curChar)
+   {
+      case 42:
+         return jjMoveStringLiteralDfa1_4(0x4000000L);
+      default :
+         return 1;
+   }
+}
+private int jjMoveStringLiteralDfa1_4(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 47:
+         if ((active0 & 0x4000000L) != 0L)
+            return jjStopAtPos(1, 26);
+         break;
+      default :
+         return 2;
+   }
+   return 2;
+}
+private int jjMoveStringLiteralDfa0_2()
+{
+   return jjMoveNfa_2(0, 0);
+}
+private int jjMoveNfa_2(int startState, int curPos)
+{
+   //int[] nextStates; // not used
+   int startsAt = 0;
+   jjnewStateCnt = 3;
+   int i = 1;
+   jjstateSet[0] = startState;
+   //int j; // not used
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0x2400L & l) != 0L)
+                  {
+                     if (kind > 24)
+                        kind = 24;
+                  }
+                  if (curChar == 13)
+                     jjstateSet[jjnewStateCnt++] = 1;
+                  break;
+               case 1:
+                  if (curChar == 10 && kind > 24)
+                     kind = 24;
+                  break;
+               case 2:
+                  if (curChar == 13)
+                     jjstateSet[jjnewStateCnt++] = 1;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 3 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private int jjMoveStringLiteralDfa0_1()
+{
+   return 1;
+}
+private int jjMoveStringLiteralDfa0_3()
+{
+   switch(curChar)
+   {
+      case 42:
+         return jjMoveStringLiteralDfa1_3(0x2000000L);
+      default :
+         return 1;
+   }
+}
+private int jjMoveStringLiteralDfa1_3(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 47:
+         if ((active0 & 0x2000000L) != 0L)
+            return jjStopAtPos(1, 25);
+         break;
+      default :
+         return 2;
+   }
+   return 2;
+}
+static final int[] jjnextStates = {
+   37, 38, 39, 15, 43, 44, 45, 49, 50, 51, 26, 27, 29, 17, 19, 5, 
+   6, 7, 59, 62, 63, 7, 64, 67, 77, 10, 9, 11, 15, 14, 13, 15, 
+   26, 27, 31, 29, 37, 38, 39, 15, 42, 41, 15, 43, 44, 45, 48, 47, 
+   15, 49, 50, 51, 52, 54, 15, 53, 52, 54, 15, 57, 56, 15, 61, 60, 
+   7, 62, 63, 7, 66, 65, 7, 69, 68, 70, 72, 71, 73, 76, 75, 15, 
+   79, 78, 80, 81, 84, 83, 15, 5, 6, 10, 9, 20, 21, 23, 28, 30, 
+   32, 37, 38, 43, 44, 49, 50, 53, 52, 62, 63, 
+};
+private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
+{
+   switch(hiByte)
+   {
+      case 0:
+         return ((jjbitVec2[i2] & l2) != 0L);
+      default : 
+         if ((jjbitVec0[i1] & l1) != 0L)
+            return true;
+         return false;
+   }
+}
+private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2)
+{
+   switch(hiByte)
+   {
+      case 0:
+         return ((jjbitVec4[i2] & l2) != 0L);
+      case 2:
+         return ((jjbitVec5[i2] & l2) != 0L);
+      case 3:
+         return ((jjbitVec6[i2] & l2) != 0L);
+      case 4:
+         return ((jjbitVec7[i2] & l2) != 0L);
+      case 5:
+         return ((jjbitVec8[i2] & l2) != 0L);
+      case 6:
+         return ((jjbitVec9[i2] & l2) != 0L);
+      case 7:
+         return ((jjbitVec10[i2] & l2) != 0L);
+      case 9:
+         return ((jjbitVec11[i2] & l2) != 0L);
+      case 10:
+         return ((jjbitVec12[i2] & l2) != 0L);
+      case 11:
+         return ((jjbitVec13[i2] & l2) != 0L);
+      case 12:
+         return ((jjbitVec14[i2] & l2) != 0L);
+      case 13:
+         return ((jjbitVec15[i2] & l2) != 0L);
+      case 14:
+         return ((jjbitVec16[i2] & l2) != 0L);
+      case 15:
+         return ((jjbitVec17[i2] & l2) != 0L);
+      case 16:
+         return ((jjbitVec18[i2] & l2) != 0L);
+      case 17:
+         return ((jjbitVec19[i2] & l2) != 0L);
+      case 18:
+         return ((jjbitVec20[i2] & l2) != 0L);
+      case 19:
+         return ((jjbitVec21[i2] & l2) != 0L);
+      case 20:
+         return ((jjbitVec0[i2] & l2) != 0L);
+      case 22:
+         return ((jjbitVec22[i2] & l2) != 0L);
+      case 23:
+         return ((jjbitVec23[i2] & l2) != 0L);
+      case 24:
+         return ((jjbitVec24[i2] & l2) != 0L);
+      case 30:
+         return ((jjbitVec25[i2] & l2) != 0L);
+      case 31:
+         return ((jjbitVec26[i2] & l2) != 0L);
+      case 32:
+         return ((jjbitVec27[i2] & l2) != 0L);
+      case 33:
+         return ((jjbitVec28[i2] & l2) != 0L);
+      case 48:
+         return ((jjbitVec29[i2] & l2) != 0L);
+      case 49:
+         return ((jjbitVec30[i2] & l2) != 0L);
+      case 77:
+         return ((jjbitVec31[i2] & l2) != 0L);
+      case 159:
+         return ((jjbitVec32[i2] & l2) != 0L);
+      case 164:
+         return ((jjbitVec33[i2] & l2) != 0L);
+      case 215:
+         return ((jjbitVec34[i2] & l2) != 0L);
+      case 250:
+         return ((jjbitVec35[i2] & l2) != 0L);
+      case 251:
+         return ((jjbitVec36[i2] & l2) != 0L);
+      case 253:
+         return ((jjbitVec37[i2] & l2) != 0L);
+      case 254:
+         return ((jjbitVec38[i2] & l2) != 0L);
+      case 255:
+         return ((jjbitVec39[i2] & l2) != 0L);
+      default : 
+         if ((jjbitVec3[i1] & l1) != 0L)
+            return true;
+         return false;
+   }
+}
+private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2)
+{
+   switch(hiByte)
+   {
+      case 0:
+         return ((jjbitVec40[i2] & l2) != 0L);
+      case 2:
+         return ((jjbitVec5[i2] & l2) != 0L);
+      case 3:
+         return ((jjbitVec41[i2] & l2) != 0L);
+      case 4:
+         return ((jjbitVec42[i2] & l2) != 0L);
+      case 5:
+         return ((jjbitVec43[i2] & l2) != 0L);
+      case 6:
+         return ((jjbitVec44[i2] & l2) != 0L);
+      case 7:
+         return ((jjbitVec45[i2] & l2) != 0L);
+      case 9:
+         return ((jjbitVec46[i2] & l2) != 0L);
+      case 10:
+         return ((jjbitVec47[i2] & l2) != 0L);
+      case 11:
+         return ((jjbitVec48[i2] & l2) != 0L);
+      case 12:
+         return ((jjbitVec49[i2] & l2) != 0L);
+      case 13:
+         return ((jjbitVec50[i2] & l2) != 0L);
+      case 14:
+         return ((jjbitVec51[i2] & l2) != 0L);
+      case 15:
+         return ((jjbitVec52[i2] & l2) != 0L);
+      case 16:
+         return ((jjbitVec53[i2] & l2) != 0L);
+      case 17:
+         return ((jjbitVec19[i2] & l2) != 0L);
+      case 18:
+         return ((jjbitVec20[i2] & l2) != 0L);
+      case 19:
+         return ((jjbitVec54[i2] & l2) != 0L);
+      case 20:
+         return ((jjbitVec0[i2] & l2) != 0L);
+      case 22:
+         return ((jjbitVec22[i2] & l2) != 0L);
+      case 23:
+         return ((jjbitVec55[i2] & l2) != 0L);
+      case 24:
+         return ((jjbitVec56[i2] & l2) != 0L);
+      case 30:
+         return ((jjbitVec25[i2] & l2) != 0L);
+      case 31:
+         return ((jjbitVec26[i2] & l2) != 0L);
+      case 32:
+         return ((jjbitVec57[i2] & l2) != 0L);
+      case 33:
+         return ((jjbitVec28[i2] & l2) != 0L);
+      case 48:
+         return ((jjbitVec58[i2] & l2) != 0L);
+      case 49:
+         return ((jjbitVec30[i2] & l2) != 0L);
+      case 77:
+         return ((jjbitVec31[i2] & l2) != 0L);
+      case 159:
+         return ((jjbitVec32[i2] & l2) != 0L);
+      case 164:
+         return ((jjbitVec33[i2] & l2) != 0L);
+      case 215:
+         return ((jjbitVec34[i2] & l2) != 0L);
+      case 250:
+         return ((jjbitVec35[i2] & l2) != 0L);
+      case 251:
+         return ((jjbitVec59[i2] & l2) != 0L);
+      case 253:
+         return ((jjbitVec37[i2] & l2) != 0L);
+      case 254:
+         return ((jjbitVec60[i2] & l2) != 0L);
+      case 255:
+         return ((jjbitVec61[i2] & l2) != 0L);
+      default : 
+         if ((jjbitVec3[i1] & l1) != 0L)
+            return true;
+         return false;
+   }
+}
+
+/** Token literal values. */
+public static final String[] jjstrLiteralImages = {
+"", "\114\117\117\113\101\110\105\101\104", 
+"\111\107\116\117\122\105\137\103\101\123\105", "\120\101\122\123\105\122\137\102\105\107\111\116", 
+"\120\101\122\123\105\122\137\105\116\104", "\112\101\126\101\103\117\104\105", "\103\120\120\103\117\104\105", 
+"\124\117\113\105\116", "\123\120\105\103\111\101\114\137\124\117\113\105\116", "\115\117\122\105", 
+"\123\113\111\120", "\124\117\113\105\116\137\115\107\122\137\104\105\103\114\123", 
+"\105\117\106", null, null, null, null, null, null, null, null, null, null, null, null, null, 
+null, null, "\141\142\163\164\162\141\143\164", "\141\163\163\145\162\164", 
+"\142\157\157\154\145\141\156", "\142\162\145\141\153", "\142\171\164\145", "\143\141\163\145", 
+"\143\141\164\143\150", "\143\150\141\162", "\143\154\141\163\163", "\143\157\156\163\164", 
+"\143\157\156\164\151\156\165\145", "\144\145\146\141\165\154\164", "\144\157", "\144\157\165\142\154\145", 
+"\145\154\163\145", "\145\156\165\155", "\145\170\164\145\156\144\163", "\146\141\154\163\145", 
+"\146\151\156\141\154", "\146\151\156\141\154\154\171", "\146\154\157\141\164", "\146\157\162", 
+"\147\157\164\157", "\151\146", "\151\155\160\154\145\155\145\156\164\163", 
+"\151\155\160\157\162\164", "\151\156\163\164\141\156\143\145\157\146", "\151\156\164", 
+"\151\156\164\145\162\146\141\143\145", "\154\157\156\147", "\156\141\164\151\166\145", "\156\145\167", 
+"\156\165\154\154", "\160\141\143\153\141\147\145", "\160\162\151\166\141\164\145", 
+"\160\162\157\164\145\143\164\145\144", "\160\165\142\154\151\143", "\162\145\164\165\162\156", 
+"\163\150\157\162\164", "\163\164\141\164\151\143", "\163\164\162\151\143\164\146\160", 
+"\163\165\160\145\162", "\163\167\151\164\143\150", 
+"\163\171\156\143\150\162\157\156\151\172\145\144", "\164\150\151\163", "\164\150\162\157\167", "\164\150\162\157\167\163", 
+"\164\162\141\156\163\151\145\156\164", "\164\162\165\145", "\164\162\171", "\166\157\151\144", 
+"\166\157\154\141\164\151\154\145", "\167\150\151\154\145", "\164\145\155\160\154\141\164\145", 
+"\164\171\160\145\156\141\155\145", null, null, null, null, null, null, null, null, null, null, null, null, "\50", 
+"\51", "\173", "\175", "\133", "\135", "\73", "\54", "\56", "\75", "\74", "\41", 
+"\176", "\77", "\72", "\72\72", "\75\75", "\74\75", "\76\75", "\41\75", "\174\174", 
+"\46\46", "\53\53", "\55\55", "\53", "\55", "\52", "\57", "\46", "\174", "\136", "\45", 
+"\53\75", "\55\75", "\52\75", "\57\75", "\46\75", "\174\75", "\136\75", "\45\75", 
+"\76\76\76", "\76\76", "\76", "\43", 
+"\104\103\114\137\120\101\122\123\105\122\137\102\105\107\111\116", "\104\103\114\137\120\101\122\123\105\122\137\105\116\104", 
+"\111\116\103\137\120\101\122\123\105\122\137\102\105\107\111\116", "\111\116\103\137\120\101\122\123\105\122\137\105\116\104", 
+"\104\105\106\137\120\101\122\123\105\122\137\102\105\107\111\116", "\104\105\106\137\120\101\122\123\105\122\137\105\116\104", "\56\56\56", 
+"\74\74\75", "\76\76\75", "\76\76\76\75", "\74\74", "\100", null, null, null, null, };
+
+/** Lexer state names. */
+public static final String[] lexStateNames = {
+   "DEFAULT", 
+   "AFTER_EGEN", 
+   "IN_SINGLE_LINE_COMMENT", 
+   "IN_FORMAL_COMMENT", 
+   "IN_MULTI_LINE_COMMENT", 
+};
+
+/** Lex State array. */
+public static final int[] jjnewLexState = {
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 0, 2, 3, 4, 4, 0, 
+   0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, 
+};
+static final long[] jjtoToken = {
+   0xfffffffff0001fffL, 0xffffffffe10fffffL, 0x4ffffffL, 
+};
+static final long[] jjtoSkip = {
+   0x70fe000L, 0x0L, 0x0L, 
+};
+static final long[] jjtoSpecial = {
+   0x7000000L, 0x0L, 0x0L, 
+};
+static final long[] jjtoMore = {
+   0x8f00000L, 0x0L, 0x0L, 
+};
+protected JavaCharStream input_stream;
+private final int[] jjrounds = new int[85];
+private final int[] jjstateSet = new int[170];
+StringBuffer image;
+int jjimageLen;
+int lengthOfMatch;
+protected char curChar;
+/** Constructor. */
+public JavaCCParserTokenManager(JavaCharStream stream){
+   if (JavaCharStream.staticFlag)
+      throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
+   input_stream = stream;
+}
+
+/** Constructor. */
+public JavaCCParserTokenManager(JavaCharStream stream, int lexState){
+   this(stream);
+   SwitchTo(lexState);
+}
+
+/** Reinitialise parser. */
+public void ReInit(JavaCharStream stream)
+{
+   jjmatchedPos = jjnewStateCnt = 0;
+   curLexState = defaultLexState;
+   input_stream = stream;
+   ReInitRounds();
+}
+private void ReInitRounds()
+{
+   int i;
+   jjround = 0x80000001;
+   for (i = 85; i-- > 0;)
+      jjrounds[i] = 0x80000000;
+}
+
+/** Reinitialise parser. */
+public void ReInit(JavaCharStream stream, int lexState)
+{
+   ReInit(stream);
+   SwitchTo(lexState);
+}
+
+/** Switch to specified lex state. */
+public void SwitchTo(int lexState)
+{
+   if (lexState >= 5 || lexState < 0)
+      throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
+   else
+      curLexState = lexState;
+}
+
+protected Token jjFillToken()
+{
+   final Token t;
+   final String tokenImage;
+   final int beginLine;
+   final int endLine;
+   final int beginColumn;
+   final int endColumn;
+   String im = jjstrLiteralImages[jjmatchedKind];
+   tokenImage = (im == null) ? input_stream.GetImage() : im;
+   beginLine = input_stream.getBeginLine();
+   beginColumn = input_stream.getBeginColumn();
+   endLine = input_stream.getEndLine();
+   endColumn = input_stream.getEndColumn();
+   t = Token.newToken(jjmatchedKind, tokenImage);
+
+   t.beginLine = beginLine;
+   t.endLine = endLine;
+   t.beginColumn = beginColumn;
+   t.endColumn = endColumn;
+
+   return t;
+}
+
+int curLexState = 0;
+int defaultLexState = 0;
+int jjnewStateCnt;
+int jjround;
+int jjmatchedPos;
+int jjmatchedKind;
+
+/** Get the next Token. */
+public Token getNextToken() 
+{
+  //int kind;
+  Token specialToken = null;
+  Token matchedToken;
+  int curPos = 0;
+
+  EOFLoop :
+  for (;;)
+  {   
+   try   
+   {     
+      curChar = input_stream.BeginToken();
+   }     
+   catch(java.io.IOException e)
+   {        
+      jjmatchedKind = 0;
+      matchedToken = jjFillToken();
+      matchedToken.specialToken = specialToken;
+      return matchedToken;
+   }
+   image = null;
+   jjimageLen = 0;
+
+   for (;;)
+   {
+     switch(curLexState)
+     {
+       case 0:
+         try { input_stream.backup(0);
+            while (curChar <= 32 && (0x100003600L & (1L << curChar)) != 0L)
+               curChar = input_stream.BeginToken();
+         }
+         catch (java.io.IOException e1) { continue EOFLoop; }
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_0();
+         if (jjmatchedPos == 0 && jjmatchedKind > 154)
+         {
+            jjmatchedKind = 154;
+         }
+         break;
+       case 1:
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_1();
+         if (jjmatchedPos == 0 && jjmatchedKind > 19)
+         {
+            jjmatchedKind = 19;
+         }
+         break;
+       case 2:
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_2();
+         if (jjmatchedPos == 0 && jjmatchedKind > 27)
+         {
+            jjmatchedKind = 27;
+         }
+         break;
+       case 3:
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_3();
+         if (jjmatchedPos == 0 && jjmatchedKind > 27)
+         {
+            jjmatchedKind = 27;
+         }
+         break;
+       case 4:
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_4();
+         if (jjmatchedPos == 0 && jjmatchedKind > 27)
+         {
+            jjmatchedKind = 27;
+         }
+         break;
+     }
+     if (jjmatchedKind != 0x7fffffff)
+     {
+        if (jjmatchedPos + 1 < curPos)
+           input_stream.backup(curPos - jjmatchedPos - 1);
+        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+        {
+           matchedToken = jjFillToken();
+           matchedToken.specialToken = specialToken;
+           TokenLexicalActions(matchedToken);
+       if (jjnewLexState[jjmatchedKind] != -1)
+         curLexState = jjnewLexState[jjmatchedKind];
+           return matchedToken;
+        }
+        else if ((jjtoSkip[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+        {
+           if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+           {
+              matchedToken = jjFillToken();
+              if (specialToken == null)
+                 specialToken = matchedToken;
+              else
+              {
+                 matchedToken.specialToken = specialToken;
+                 specialToken = (specialToken.next = matchedToken);
+              }
+              SkipLexicalActions(matchedToken);
+           }
+           else 
+              SkipLexicalActions(null);
+         if (jjnewLexState[jjmatchedKind] != -1)
+           curLexState = jjnewLexState[jjmatchedKind];
+           continue EOFLoop;
+        }
+        MoreLexicalActions();
+      if (jjnewLexState[jjmatchedKind] != -1)
+        curLexState = jjnewLexState[jjmatchedKind];
+        curPos = 0;
+        jjmatchedKind = 0x7fffffff;
+        try {
+           curChar = input_stream.readChar();
+           continue;
+        }
+        catch (java.io.IOException e1) { }
+     }
+     int error_line = input_stream.getEndLine();
+     int error_column = input_stream.getEndColumn();
+     String error_after = null;
+     boolean EOFSeen = false;
+     try { input_stream.readChar(); input_stream.backup(1); }
+     catch (java.io.IOException e1) {
+        EOFSeen = true;
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+        if (curChar == '\n' || curChar == '\r') {
+           error_line++;
+           error_column = 0;
+        }
+        else
+           error_column++;
+     }
+     if (!EOFSeen) {
+        input_stream.backup(1);
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+     }
+     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
+   }
+  }
+}
+
+void SkipLexicalActions(Token matchedToken)
+{
+   switch(jjmatchedKind)
+   {
+      case 19 :
+         if (image == null)
+            image = new StringBuffer();
+         image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
+          restoreBeginLineCol(); input_stream.backup(1);
+         break;
+      default :
+         break;
+   }
+}
+void MoreLexicalActions()
+{
+   jjimageLen += (lengthOfMatch = jjmatchedPos + 1);
+   switch(jjmatchedKind)
+   {
+      case 21 :
+         if (image == null)
+            image = new StringBuffer();
+         image.append(input_stream.GetSuffix(jjimageLen));
+         jjimageLen = 0;
+                   input_stream.backup(1);
+         break;
+      case 23 :
+         if (image == null)
+            image = new StringBuffer();
+         image.append(input_stream.GetSuffix(jjimageLen));
+         jjimageLen = 0;
+        saveBeginLineCol(input_stream.getBeginLine(),
+                         input_stream.getBeginColumn());
+         break;
+      default : 
+         break;
+   }
+}
+void TokenLexicalActions(Token matchedToken)
+{
+   switch(jjmatchedKind)
+   {
+      case 135 :
+        if (image == null)
+            image = new StringBuffer();
+        image.append(jjstrLiteralImages[135]);
+        lengthOfMatch = jjstrLiteralImages[135].length();
+     matchedToken.kind = GT;
+     ((Token.GTToken)matchedToken).realKind = RUNSIGNEDSHIFT;
+     input_stream.backup(2);
+     matchedToken.image = ">";
+         break;
+      case 136 :
+        if (image == null)
+            image = new StringBuffer();
+        image.append(jjstrLiteralImages[136]);
+        lengthOfMatch = jjstrLiteralImages[136].length();
+     matchedToken.kind = GT;
+     ((Token.GTToken)matchedToken).realKind = RSIGNEDSHIFT;
+     input_stream.backup(1);
+     matchedToken.image = ">";
+         break;
+      default : 
+         break;
+   }
+}
+private void jjCheckNAdd(int state)
+{
+   if (jjrounds[state] != jjround)
+   {
+      jjstateSet[jjnewStateCnt++] = state;
+      jjrounds[state] = jjround;
+   }
+}
+private void jjAddStates(int start, int end)
+{
+   do {
+      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
+   } while (start++ != end);
+}
+private void jjCheckNAddTwoStates(int state1, int state2)
+{
+   jjCheckNAdd(state1);
+   jjCheckNAdd(state2);
+}
+
+private void jjCheckNAddStates(int start, int end)
+{
+   do {
+      jjCheckNAdd(jjnextStates[start]);
+   } while (start++ != end);
+}
+
+}
diff --git a/generated/org/javacc/parser/JavaCharStream.java b/generated/org/javacc/parser/JavaCharStream.java
new file mode 100644
index 00000000..595589c0
--- /dev/null
+++ b/generated/org/javacc/parser/JavaCharStream.java
@@ -0,0 +1,621 @@
+/* Generated By:JavaCC: Do not edit this line. JavaCharStream.java Version 4.1 */
+/* JavaCCOptions:STATIC=false */
+/**
+ * This file contains the code for JavaCCParser generated
+ * by JavaCCParser itself.
+ */
+
+package org.javacc.parser;
+
+/**
+ * An implementation of interface CharStream, where the stream is assumed to
+ * contain only ASCII characters (with java-like unicode escape processing).
+ */
+
+public class JavaCharStream
+{
+/** Whether parser is static. */
+  public static final boolean staticFlag = false;
+  static final int hexval(char c) throws java.io.IOException {
+    switch(c)
+    {
+       case '0' :
+          return 0;
+       case '1' :
+          return 1;
+       case '2' :
+          return 2;
+       case '3' :
+          return 3;
+       case '4' :
+          return 4;
+       case '5' :
+          return 5;
+       case '6' :
+          return 6;
+       case '7' :
+          return 7;
+       case '8' :
+          return 8;
+       case '9' :
+          return 9;
+
+       case 'a' :
+       case 'A' :
+          return 10;
+       case 'b' :
+       case 'B' :
+          return 11;
+       case 'c' :
+       case 'C' :
+          return 12;
+       case 'd' :
+       case 'D' :
+          return 13;
+       case 'e' :
+       case 'E' :
+          return 14;
+       case 'f' :
+       case 'F' :
+          return 15;
+    }
+
+    throw new java.io.IOException(); // Should never come here
+  }
+
+/** Position in buffer. */
+  public int bufpos = -1;
+  int bufsize;
+  int available;
+  int tokenBegin;
+  protected int bufline[];
+  protected int bufcolumn[];
+
+  protected int column = 0;
+  protected int line = 1;
+
+  protected boolean prevCharIsCR = false;
+  protected boolean prevCharIsLF = false;
+
+  protected java.io.Reader inputStream;
+
+  protected char[] nextCharBuf;
+  protected char[] buffer;
+  protected int maxNextCharInd = 0;
+  protected int nextCharInd = -1;
+  protected int inBuf = 0;
+  protected int tabSize = 8;
+
+  protected void setTabSize(int i) { tabSize = i; }
+  protected int getTabSize(int i) { return tabSize; }
+
+  protected void ExpandBuff(boolean wrapAround)
+  {
+     char[] newbuffer = new char[bufsize + 2048];
+     int newbufline[] = new int[bufsize + 2048];
+     int newbufcolumn[] = new int[bufsize + 2048];
+
+     try
+     {
+        if (wrapAround)
+        {
+           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+           System.arraycopy(buffer, 0, newbuffer,
+                                             bufsize - tokenBegin, bufpos);
+           buffer = newbuffer;
+
+           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+           System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
+           bufline = newbufline;
+
+           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+           System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
+           bufcolumn = newbufcolumn;
+
+           bufpos += (bufsize - tokenBegin);
+        }
+        else
+        {
+           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+           buffer = newbuffer;
+
+           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+           bufline = newbufline;
+
+           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+           bufcolumn = newbufcolumn;
+
+           bufpos -= tokenBegin;
+        }
+     }
+     catch (Throwable t)
+     {
+        throw new Error(t.getMessage());
+     }
+
+     available = (bufsize += 2048);
+     tokenBegin = 0;
+  }
+
+  protected void FillBuff() throws java.io.IOException
+  {
+     int i;
+     if (maxNextCharInd == 4096)
+        maxNextCharInd = nextCharInd = 0;
+
+     try {
+        if ((i = inputStream.read(nextCharBuf, maxNextCharInd,
+                                            4096 - maxNextCharInd)) == -1)
+        {
+           inputStream.close();
+           throw new java.io.IOException();
+        }
+        else
+           maxNextCharInd += i;
+        return;
+     }
+     catch(java.io.IOException e) {
+        if (bufpos != 0)
+        {
+           --bufpos;
+           backup(0);
+        }
+        else
+        {
+           bufline[bufpos] = line;
+           bufcolumn[bufpos] = column;
+        }
+        throw e;
+     }
+  }
+
+  protected char ReadByte() throws java.io.IOException
+  {
+     if (++nextCharInd >= maxNextCharInd)
+        FillBuff();
+
+     return nextCharBuf[nextCharInd];
+  }
+
+/** @return starting character for token. */
+  public char BeginToken() throws java.io.IOException
+  {     
+     if (inBuf > 0)
+     {
+        --inBuf;
+
+        if (++bufpos == bufsize)
+           bufpos = 0;
+
+        tokenBegin = bufpos;
+        return buffer[bufpos];
+     }
+
+     tokenBegin = 0;
+     bufpos = -1;
+
+     return readChar();
+  }     
+
+  protected void AdjustBuffSize()
+  {
+     if (available == bufsize)
+     {
+        if (tokenBegin > 2048)
+        {
+           bufpos = 0;
+           available = tokenBegin;
+        }
+        else
+           ExpandBuff(false);
+     }
+     else if (available > tokenBegin)
+        available = bufsize;
+     else if ((tokenBegin - available) < 2048)
+        ExpandBuff(true);
+     else
+        available = tokenBegin;
+  }
+
+  protected void UpdateLineColumn(char c)
+  {
+     column++;
+
+     if (prevCharIsLF)
+     {
+        prevCharIsLF = false;
+        line += (column = 1);
+     }
+     else if (prevCharIsCR)
+     {
+        prevCharIsCR = false;
+        if (c == '\n')
+        {
+           prevCharIsLF = true;
+        }
+        else
+           line += (column = 1);
+     }
+
+     switch (c)
+     {
+        case '\r' :
+           prevCharIsCR = true;
+           break;
+        case '\n' :
+           prevCharIsLF = true;
+           break;
+        case '\t' :
+           column--;
+           column += (tabSize - (column % tabSize));
+           break;
+        default :
+           break;
+     }
+
+     bufline[bufpos] = line;
+     bufcolumn[bufpos] = column;
+  }
+
+/** Read a character. */
+  public char readChar() throws java.io.IOException
+  {
+     if (inBuf > 0)
+     {
+        --inBuf;
+
+        if (++bufpos == bufsize)
+           bufpos = 0;
+
+        return buffer[bufpos];
+     }
+
+     char c;
+
+     if (++bufpos == available)
+        AdjustBuffSize();
+
+     if ((buffer[bufpos] = c = ReadByte()) == '\\')
+     {
+        UpdateLineColumn(c);
+
+        int backSlashCnt = 1;
+
+        for (;;) // Read all the backslashes
+        {
+           if (++bufpos == available)
+              AdjustBuffSize();
+
+           try
+           {
+              if ((buffer[bufpos] = c = ReadByte()) != '\\')
+              {
+                 UpdateLineColumn(c);
+                 // found a non-backslash char.
+                 if ((c == 'u') && ((backSlashCnt & 1) == 1))
+                 {
+                    if (--bufpos < 0)
+                       bufpos = bufsize - 1;
+
+                    break;
+                 }
+
+                 backup(backSlashCnt);
+                 return '\\';
+              }
+           }
+           catch(java.io.IOException e)
+           {
+              if (backSlashCnt > 1)
+                 backup(backSlashCnt-1);
+
+              return '\\';
+           }
+
+           UpdateLineColumn(c);
+           backSlashCnt++;
+        }
+
+        // Here, we have seen an odd number of backslash's followed by a 'u'
+        try
+        {
+           while ((c = ReadByte()) == 'u')
+              ++column;
+
+           buffer[bufpos] = c = (char)(hexval(c) << 12 |
+                                       hexval(ReadByte()) << 8 |
+                                       hexval(ReadByte()) << 4 |
+                                       hexval(ReadByte()));
+
+           column += 4;
+        }
+        catch(java.io.IOException e)
+        {
+           throw new Error("Invalid escape character at line " + line +
+                                         " column " + column + ".");
+        }
+
+        if (backSlashCnt == 1)
+           return c;
+        else
+        {
+           backup(backSlashCnt - 1);
+           return '\\';
+        }
+     }
+     else
+     {
+        UpdateLineColumn(c);
+        return c;
+     }
+  }
+
+  /**
+   * @deprecated 
+   * @see #getEndColumn
+   */
+
+  public int getColumn() {
+     return bufcolumn[bufpos];
+  }
+
+  /**
+   * @deprecated 
+   * @see #getEndLine
+   */
+
+  public int getLine() {
+     return bufline[bufpos];
+  }
+
+/** Get end column. */
+  public int getEndColumn() {
+     return bufcolumn[bufpos];
+  }
+
+/** Get end line. */
+  public int getEndLine() {
+     return bufline[bufpos];
+  }
+
+/** @return column of token start */
+  public int getBeginColumn() {
+     return bufcolumn[tokenBegin];
+  }
+
+/** @return line number of token start */
+  public int getBeginLine() {
+     return bufline[tokenBegin];
+  }
+
+/** Retreat. */
+  public void backup(int amount) {
+
+    inBuf += amount;
+    if ((bufpos -= amount) < 0)
+       bufpos += bufsize;
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.Reader dstream,
+                 int startline, int startcolumn, int buffersize)
+  {
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    available = bufsize = buffersize;
+    buffer = new char[buffersize];
+    bufline = new int[buffersize];
+    bufcolumn = new int[buffersize];
+    nextCharBuf = new char[4096];
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.Reader dstream,
+                                        int startline, int startcolumn)
+  {
+     this(dstream, startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.Reader dstream)
+  {
+     this(dstream, 1, 1, 4096);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.Reader dstream,
+                 int startline, int startcolumn, int buffersize)
+  {
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    if (buffer == null || buffersize != buffer.length)
+    {
+      available = bufsize = buffersize;
+      buffer = new char[buffersize];
+      bufline = new int[buffersize];
+      bufcolumn = new int[buffersize];
+      nextCharBuf = new char[4096];
+    }
+    prevCharIsLF = prevCharIsCR = false;
+    tokenBegin = inBuf = maxNextCharInd = 0;
+    nextCharInd = bufpos = -1;
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.Reader dstream,
+                                        int startline, int startcolumn)
+  {
+     ReInit(dstream, startline, startcolumn, 4096);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.Reader dstream)
+  {
+     ReInit(dstream, 1, 1, 4096);
+  }
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, String encoding, int startline,
+  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
+  {
+     this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+     this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, String encoding, int startline,
+                        int startcolumn) throws java.io.UnsupportedEncodingException
+  {
+     this(dstream, encoding, startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, int startline,
+                        int startcolumn)
+  {
+     this(dstream, startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
+  {
+     this(dstream, encoding, 1, 1, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream)
+  {
+     this(dstream, 1, 1, 4096);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
+  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
+  {
+     ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
+                     int startcolumn) throws java.io.UnsupportedEncodingException
+  {
+     ReInit(dstream, encoding, startline, startcolumn, 4096);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, int startline,
+                     int startcolumn)
+  {
+     ReInit(dstream, startline, startcolumn, 4096);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
+  {
+     ReInit(dstream, encoding, 1, 1, 4096);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream)
+  {
+     ReInit(dstream, 1, 1, 4096);
+  }
+
+  /** @return token image as String */
+  public String GetImage()
+  {
+     if (bufpos >= tokenBegin)
+        return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
+     else
+        return new String(buffer, tokenBegin, bufsize - tokenBegin) +
+                              new String(buffer, 0, bufpos + 1);
+  }
+
+  /** @return suffix */
+  public char[] GetSuffix(int len)
+  {
+     char[] ret = new char[len];
+
+     if ((bufpos + 1) >= len)
+        System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
+     else
+     {
+        System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
+                                                          len - bufpos - 1);
+        System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
+     }
+
+     return ret;
+  }
+
+  /** Set buffers back to null when finished. */
+  public void Done()
+  {
+     nextCharBuf = null;
+     buffer = null;
+     bufline = null;
+     bufcolumn = null;
+  }
+
+  /**
+   * Method to adjust line and column numbers for the start of a token.
+   */
+  public void adjustBeginLineColumn(int newLine, int newCol)
+  {
+     int start = tokenBegin;
+     int len;
+
+     if (bufpos >= tokenBegin)
+     {
+        len = bufpos - tokenBegin + inBuf + 1;
+     }
+     else
+     {
+        len = bufsize - tokenBegin + bufpos + 1 + inBuf;
+     }
+
+     int i = 0, j = 0, k = 0;
+     int nextColDiff = 0, columnDiff = 0;
+
+     while (i < len &&
+            bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
+     {
+        bufline[j] = newLine;
+        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
+        bufcolumn[j] = newCol + columnDiff;
+        columnDiff = nextColDiff;
+        i++;
+     } 
+
+     if (i < len)
+     {
+        bufline[j] = newLine++;
+        bufcolumn[j] = newCol + columnDiff;
+
+        while (i++ < len)
+        {
+           if (bufline[j = start % bufsize] != bufline[++start % bufsize])
+              bufline[j] = newLine++;
+           else
+              bufline[j] = newLine;
+        }
+     }
+
+     line = bufline[j];
+     column = bufcolumn[j];
+  }
+
+}
+/* JavaCC - OriginalChecksum=22f8b4d773290eeb89ee8218cf5bb44b (do not edit this line) */
diff --git a/generated/org/javacc/parser/ParseException.java b/generated/org/javacc/parser/ParseException.java
new file mode 100644
index 00000000..feef87dd
--- /dev/null
+++ b/generated/org/javacc/parser/ParseException.java
@@ -0,0 +1,203 @@
+/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 4.1 */
+/* JavaCCOptions:KEEP_LINE_COL=null */
+/**
+ * This file contains the code for JavaCCParser generated
+ * by JavaCCParser itself.
+ */
+
+package org.javacc.parser;
+
+/**
+ * This exception is thrown when parse errors are encountered.
+ * You can explicitly create objects of this exception type by
+ * calling the method generateParseException in the generated
+ * parser.
+ *
+ * You can modify this class to customize your error reporting
+ * mechanisms so long as you retain the public fields.
+ */
+public class ParseException extends Exception {
+
+  /**
+   * This constructor is used by the method "generateParseException"
+   * in the generated parser.  Calling this constructor generates
+   * a new object of this type with the fields "currentToken",
+   * "expectedTokenSequences", and "tokenImage" set.  The boolean
+   * flag "specialConstructor" is also set to true to indicate that
+   * this constructor was used to create this object.
+   * This constructor calls its super class with the empty string
+   * to force the "toString" method of parent class "Throwable" to
+   * print the error message in the form:
+   *     ParseException: <result of getMessage>
+   */
+  public ParseException(Token currentTokenVal,
+                        int[][] expectedTokenSequencesVal,
+                        String[] tokenImageVal
+                       )
+  {
+    super("");
+    specialConstructor = true;
+    currentToken = currentTokenVal;
+    expectedTokenSequences = expectedTokenSequencesVal;
+    tokenImage = tokenImageVal;
+  }
+
+  /**
+   * The following constructors are for use by you for whatever
+   * purpose you can think of.  Constructing the exception in this
+   * manner makes the exception behave in the normal way - i.e., as
+   * documented in the class "Throwable".  The fields "errorToken",
+   * "expectedTokenSequences", and "tokenImage" do not contain
+   * relevant information.  The JavaCC generated code does not use
+   * these constructors.
+   */
+
+  public ParseException() {
+    super();
+    specialConstructor = false;
+  }
+
+  /** Constructor with message. */
+  public ParseException(String message) {
+    super(message);
+    specialConstructor = false;
+  }
+
+  /**
+   * This variable determines which constructor was used to create
+   * this object and thereby affects the semantics of the
+   * "getMessage" method (see below).
+   */
+  protected boolean specialConstructor;
+
+  /**
+   * This is the last token that has been consumed successfully.  If
+   * this object has been created due to a parse error, the token
+   * followng this token will (therefore) be the first error token.
+   */
+  public Token currentToken;
+
+  /**
+   * Each entry in this array is an array of integers.  Each array
+   * of integers represents a sequence of tokens (by their ordinal
+   * values) that is expected at this point of the parse.
+   */
+  public int[][] expectedTokenSequences;
+
+  /**
+   * This is a reference to the "tokenImage" array of the generated
+   * parser within which the parse error occurred.  This array is
+   * defined in the generated ...Constants interface.
+   */
+  public String[] tokenImage;
+
+  /**
+   * This method has the standard behavior when this object has been
+   * created using the standard constructors.  Otherwise, it uses
+   * "currentToken" and "expectedTokenSequences" to generate a parse
+   * error message and returns it.  If this object has been created
+   * due to a parse error, and you do not catch it (it gets thrown
+   * from the parser), then this method is called during the printing
+   * of the final stack trace, and hence the correct error message
+   * gets displayed.
+   */
+  public String getMessage() {
+    if (!specialConstructor) {
+      return super.getMessage();
+    }
+    StringBuffer expected = new StringBuffer();
+    int maxSize = 0;
+    for (int i = 0; i < expectedTokenSequences.length; i++) {
+      if (maxSize < expectedTokenSequences[i].length) {
+        maxSize = expectedTokenSequences[i].length;
+      }
+      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
+        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(' ');
+      }
+      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
+        expected.append("...");
+      }
+      expected.append(eol).append("    ");
+    }
+    String retval = "Encountered \"";
+    Token tok = currentToken.next;
+    for (int i = 0; i < maxSize; i++) {
+      if (i != 0) retval += " ";
+      if (tok.kind == 0) {
+        retval += tokenImage[0];
+        break;
+      }
+      retval += " " + tokenImage[tok.kind];
+      retval += " \"";
+      retval += add_escapes(tok.image);
+      retval += " \"";
+      tok = tok.next; 
+    }
+    retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;
+    retval += "." + eol;
+    if (expectedTokenSequences.length == 1) {
+      retval += "Was expecting:" + eol + "    ";
+    } else {
+      retval += "Was expecting one of:" + eol + "    ";
+    }
+    retval += expected.toString();
+    return retval;
+  }
+
+  /**
+   * The end of line string for this machine.
+   */
+  protected String eol = System.getProperty("line.separator", "\n");
+ 
+  /**
+   * Used to convert raw characters to their escaped version
+   * when these raw version cannot be used as part of an ASCII
+   * string literal.
+   */
+  protected String add_escapes(String str) {
+      StringBuffer retval = new StringBuffer();
+      char ch;
+      for (int i = 0; i < str.length(); i++) {
+        switch (str.charAt(i))
+        {
+           case 0 :
+              continue;
+           case '\b':
+              retval.append("\\b");
+              continue;
+           case '\t':
+              retval.append("\\t");
+              continue;
+           case '\n':
+              retval.append("\\n");
+              continue;
+           case '\f':
+              retval.append("\\f");
+              continue;
+           case '\r':
+              retval.append("\\r");
+              continue;
+           case '\"':
+              retval.append("\\\"");
+              continue;
+           case '\'':
+              retval.append("\\\'");
+              continue;
+           case '\\':
+              retval.append("\\\\");
+              continue;
+           default:
+              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
+                 String s = "0000" + Integer.toString(ch, 16);
+                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
+              } else {
+                 retval.append(ch);
+              }
+              continue;
+        }
+      }
+      return retval.toString();
+   }
+
+}
+/* JavaCC - OriginalChecksum=92884b572310b269065e158fe089d94f (do not edit this line) */
diff --git a/generated/org/javacc/parser/TokenMgrError.java b/generated/org/javacc/parser/TokenMgrError.java
new file mode 100644
index 00000000..34e5a03e
--- /dev/null
+++ b/generated/org/javacc/parser/TokenMgrError.java
@@ -0,0 +1,145 @@
+/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 4.1 */
+/* JavaCCOptions: */
+/**
+ * This file contains the code for JavaCCParser generated
+ * by JavaCCParser itself.
+ */
+
+package org.javacc.parser;
+
+/** Token Manager Error. */
+public class TokenMgrError extends Error
+{
+
+   /*
+    * Ordinals for various reasons why an Error of this type can be thrown.
+    */
+
+   /**
+    * Lexical error occurred.
+    */
+   static final int LEXICAL_ERROR = 0;
+
+   /**
+    * An attempt was made to create a second instance of a static token manager.
+    */
+   static final int STATIC_LEXER_ERROR = 1;
+
+   /**
+    * Tried to change to an invalid lexical state.
+    */
+   static final int INVALID_LEXICAL_STATE = 2;
+
+   /**
+    * Detected (and bailed out of) an infinite loop in the token manager.
+    */
+   static final int LOOP_DETECTED = 3;
+
+   /**
+    * Indicates the reason why the exception is thrown. It will have
+    * one of the above 4 values.
+    */
+   int errorCode;
+
+   /**
+    * Replaces unprintable characters by their escaped (or unicode escaped)
+    * equivalents in the given string
+    */
+   protected static final String addEscapes(String str) {
+      StringBuffer retval = new StringBuffer();
+      char ch;
+      for (int i = 0; i < str.length(); i++) {
+        switch (str.charAt(i))
+        {
+           case 0 :
+              continue;
+           case '\b':
+              retval.append("\\b");
+              continue;
+           case '\t':
+              retval.append("\\t");
+              continue;
+           case '\n':
+              retval.append("\\n");
+              continue;
+           case '\f':
+              retval.append("\\f");
+              continue;
+           case '\r':
+              retval.append("\\r");
+              continue;
+           case '\"':
+              retval.append("\\\"");
+              continue;
+           case '\'':
+              retval.append("\\\'");
+              continue;
+           case '\\':
+              retval.append("\\\\");
+              continue;
+           default:
+              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
+                 String s = "0000" + Integer.toString(ch, 16);
+                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
+              } else {
+                 retval.append(ch);
+              }
+              continue;
+        }
+      }
+      return retval.toString();
+   }
+
+   /**
+    * Returns a detailed message for the Error when it is thrown by the
+    * token manager to indicate a lexical error.
+    * Parameters : 
+    *    EOFSeen     : indicates if EOF caused the lexical error
+    *    curLexState : lexical state in which this error occurred
+    *    errorLine   : line number when the error occurred
+    *    errorColumn : column number when the error occurred
+    *    errorAfter  : prefix that was seen before this error occurred
+    *    curchar     : the offending character
+    * Note: You can customize the lexical error message by modifying this method.
+    */
+   protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
+      return("Lexical error at line " +
+           errorLine + ", column " +
+           errorColumn + ".  Encountered: " +
+           (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int)curChar + "), ") +
+           "after : \"" + addEscapes(errorAfter) + "\"");
+   }
+
+   /**
+    * You can also modify the body of this method to customize your error messages.
+    * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
+    * of end-users concern, so you can return something like : 
+    *
+    *     "Internal Error : Please file a bug report .... "
+    *
+    * from this method for such cases in the release version of your parser.
+    */
+   public String getMessage() {
+      return super.getMessage();
+   }
+
+   /*
+    * Constructors of various flavors follow.
+    */
+
+   /** No arg constructor. */
+   public TokenMgrError() {
+   }
+
+   /** Constructor with message and reason. */
+   public TokenMgrError(String message, int reason) {
+      super(message);
+      errorCode = reason;
+   }
+
+   /** Full Constructor. */
+   public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {
+      this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
+   }
+}
+/* JavaCC - OriginalChecksum=95a3de072cdb9c97562030cb1324f3e5 (do not edit this line) */
diff --git a/generated/org/javacc/utils/ConditionParser.java b/generated/org/javacc/utils/ConditionParser.java
new file mode 100644
index 00000000..6915f55e
--- /dev/null
+++ b/generated/org/javacc/utils/ConditionParser.java
@@ -0,0 +1,361 @@
+/* Generated By:JavaCC: Do not edit this line. ConditionParser.java */
+package org.javacc.utils;
+
+import java.io.StringReader;
+import java.util.Map;
+
+public class ConditionParser implements ConditionParserConstants {
+    private Map<String, Object> options;
+
+    public static void main(String... args) throws ParseException
+    {
+      test("F", false);
+      test("T", true);
+      test("F || T", true);
+      test("T || F", true);
+      test("T || will not be compiled )", true);
+      test("F && T", false);
+      test("T && T", true);
+      test("unknown", false);
+    }
+
+    private static void test(String input, boolean expectedValue)  throws ParseException
+    {
+      ConditionParser cp = new ConditionParser(new StringReader(input));
+      Map<String,Object> values = new java.util.HashMap<String,Object>();
+      values.put("F", Boolean.FALSE);
+      values.put("T", Boolean.TRUE);
+      boolean value = cp.CompilationUnit(values);
+      System.out.println(input + " = " + value);
+      if (value != expectedValue)
+        throw new RuntimeException();
+    }
+
+  final public boolean CompilationUnit(Map<String,Object> options) throws ParseException {
+        boolean value;
+    this.options = options;
+    value = ConditionalExpression();
+    {if (true) return value;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public boolean ConditionalExpression() throws ParseException {
+        boolean value;
+    value = ConditionalAndExpression();
+          if (value) {if (true) return true;}
+    label_1:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case SC_OR:
+        ;
+        break;
+      default:
+        jj_la1[0] = jj_gen;
+        break label_1;
+      }
+      jj_consume_token(SC_OR);
+      value = ConditionalAndExpression();
+              if (value) {if (true) return true;}
+    }
+    {if (true) return false;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public boolean ConditionalAndExpression() throws ParseException {
+        boolean value;
+    value = UnaryExpressionNotPlusMinus();
+          if (!value) {if (true) return false;}
+    label_2:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case SC_AND:
+        ;
+        break;
+      default:
+        jj_la1[1] = jj_gen;
+        break label_2;
+      }
+      jj_consume_token(SC_AND);
+      value = UnaryExpressionNotPlusMinus();
+              if (!value) {if (true) return false;}
+    }
+    {if (true) return true;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public boolean UnaryExpressionNotPlusMinus() throws ParseException {
+        boolean value;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case BANG:
+    case 18:
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case 18:
+        jj_consume_token(18);
+        break;
+      case BANG:
+        jj_consume_token(BANG);
+        break;
+      default:
+        jj_la1[2] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      value = UnaryExpressionNotPlusMinus();
+                                                        {if (true) return !value;}
+      break;
+    case LPAREN:
+    case TRUE:
+    case FALSE:
+    case IDENTIFIER:
+      value = UnaryExpression();
+                                   {if (true) return value;}
+      break;
+    default:
+      jj_la1[3] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    throw new Error("Missing return statement in function");
+  }
+
+  final public boolean UnaryExpression() throws ParseException {
+        boolean value;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case TRUE:
+    case FALSE:
+      value = Literal();
+                                  {if (true) return value;}
+      break;
+    case LPAREN:
+      jj_consume_token(LPAREN);
+      value = ConditionalExpression();
+      jj_consume_token(RPAREN);
+                                            {if (true) return value;}
+      break;
+    case IDENTIFIER:
+      value = Name();
+                    {if (true) return value;}
+      break;
+    default:
+      jj_la1[4] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    throw new Error("Missing return statement in function");
+  }
+
+  final public boolean Literal() throws ParseException {
+        boolean value;
+    value = BooleanLiteral();
+                                 {if (true) return value;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public boolean BooleanLiteral() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case TRUE:
+      jj_consume_token(TRUE);
+               {if (true) return true;}
+      break;
+    case FALSE:
+      jj_consume_token(FALSE);
+               {if (true) return false;}
+      break;
+    default:
+      jj_la1[5] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    throw new Error("Missing return statement in function");
+  }
+
+  final public boolean Name() throws ParseException {
+  String name;
+    jj_consume_token(IDENTIFIER);
+            name = getToken(0).image.trim();
+
+            Object obj = options.get(name);
+
+            if (obj instanceof Boolean)
+            {
+              {if (true) return ((Boolean)obj).booleanValue();}
+            }
+            else if (obj instanceof String)
+            {
+              String string = ((String)obj).trim();
+              {if (true) return string.length() > 0 && !string.equalsIgnoreCase("false") && !string.equalsIgnoreCase("no");}
+            }
+
+            {if (true) return false;}
+    throw new Error("Missing return statement in function");
+  }
+
+  /** Generated Token Manager. */
+  public ConditionParserTokenManager token_source;
+  JavaCharStream jj_input_stream;
+  /** Current token. */
+  public Token token;
+  /** Next token. */
+  public Token jj_nt;
+  private int jj_ntk;
+  private int jj_gen;
+  final private int[] jj_la1 = new int[6];
+  static private int[] jj_la1_0;
+  static {
+      jj_la1_init_0();
+   }
+   private static void jj_la1_init_0() {
+      jj_la1_0 = new int[] {0x10000,0x20000,0x48000,0x3ca000,0x382000,0x180000,};
+   }
+
+  /** Constructor with InputStream. */
+  public ConditionParser(java.io.InputStream stream) {
+     this(stream, null);
+  }
+  /** Constructor with InputStream and supplied encoding */
+  public ConditionParser(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source = new ConditionParserTokenManager(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 6; i++) jj_la1[i] = -1;
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream stream) {
+     ReInit(stream, null);
+  }
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 6; i++) jj_la1[i] = -1;
+  }
+
+  /** Constructor. */
+  public ConditionParser(java.io.Reader stream) {
+    jj_input_stream = new JavaCharStream(stream, 1, 1);
+    token_source = new ConditionParserTokenManager(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 6; i++) jj_la1[i] = -1;
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.Reader stream) {
+    jj_input_stream.ReInit(stream, 1, 1);
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 6; i++) jj_la1[i] = -1;
+  }
+
+  /** Constructor with generated Token Manager. */
+  public ConditionParser(ConditionParserTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 6; i++) jj_la1[i] = -1;
+  }
+
+  /** Reinitialise. */
+  public void ReInit(ConditionParserTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 6; i++) jj_la1[i] = -1;
+  }
+
+  private Token jj_consume_token(int kind) throws ParseException {
+    Token oldToken;
+    if ((oldToken = token).next != null) token = token.next;
+    else token = token.next = token_source.getNextToken();
+    jj_ntk = -1;
+    if (token.kind == kind) {
+      jj_gen++;
+      return token;
+    }
+    token = oldToken;
+    jj_kind = kind;
+    throw generateParseException();
+  }
+
+
+/** Get the next Token. */
+  final public Token getNextToken() {
+    if (token.next != null) token = token.next;
+    else token = token.next = token_source.getNextToken();
+    jj_ntk = -1;
+    jj_gen++;
+    return token;
+  }
+
+/** Get the specific Token. */
+  final public Token getToken(int index) {
+    Token t = token;
+    for (int i = 0; i < index; i++) {
+      if (t.next != null) t = t.next;
+      else t = t.next = token_source.getNextToken();
+    }
+    return t;
+  }
+
+  private int jj_ntk() {
+    if ((jj_nt=token.next) == null)
+      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
+    else
+      return (jj_ntk = jj_nt.kind);
+  }
+
+  private java.util.List jj_expentries = new java.util.ArrayList();
+  private int[] jj_expentry;
+  private int jj_kind = -1;
+
+  /** Generate ParseException. */
+  public ParseException generateParseException() {
+    jj_expentries.clear();
+    boolean[] la1tokens = new boolean[24];
+    if (jj_kind >= 0) {
+      la1tokens[jj_kind] = true;
+      jj_kind = -1;
+    }
+    for (int i = 0; i < 6; i++) {
+      if (jj_la1[i] == jj_gen) {
+        for (int j = 0; j < 32; j++) {
+          if ((jj_la1_0[i] & (1<<j)) != 0) {
+            la1tokens[j] = true;
+          }
+        }
+      }
+    }
+    for (int i = 0; i < 24; i++) {
+      if (la1tokens[i]) {
+        jj_expentry = new int[1];
+        jj_expentry[0] = i;
+        jj_expentries.add(jj_expentry);
+      }
+    }
+    int[][] exptokseq = new int[jj_expentries.size()][];
+    for (int i = 0; i < jj_expentries.size(); i++) {
+      exptokseq[i] = (int[])jj_expentries.get(i);
+    }
+    return new ParseException(token, exptokseq, tokenImage);
+  }
+
+  /** Enable tracing. */
+  final public void enable_tracing() {
+  }
+
+  /** Disable tracing. */
+  final public void disable_tracing() {
+  }
+
+}
diff --git a/generated/org/javacc/utils/ConditionParserConstants.java b/generated/org/javacc/utils/ConditionParserConstants.java
new file mode 100644
index 00000000..84898752
--- /dev/null
+++ b/generated/org/javacc/utils/ConditionParserConstants.java
@@ -0,0 +1,77 @@
+/* Generated By:JavaCC: Do not edit this line. ConditionParserConstants.java */
+package org.javacc.utils;
+
+
+/** 
+ * Token literal values and constants.
+ * Generated by org.javacc.parser.OtherFilesGen#start()
+ */
+public interface ConditionParserConstants {
+
+  /** End of File. */
+  int EOF = 0;
+  /** RegularExpression Id. */
+  int SINGLE_LINE_COMMENT = 9;
+  /** RegularExpression Id. */
+  int FORMAL_COMMENT = 10;
+  /** RegularExpression Id. */
+  int MULTI_LINE_COMMENT = 11;
+  /** RegularExpression Id. */
+  int LPAREN = 13;
+  /** RegularExpression Id. */
+  int RPAREN = 14;
+  /** RegularExpression Id. */
+  int BANG = 15;
+  /** RegularExpression Id. */
+  int SC_OR = 16;
+  /** RegularExpression Id. */
+  int SC_AND = 17;
+  /** RegularExpression Id. */
+  int TRUE = 19;
+  /** RegularExpression Id. */
+  int FALSE = 20;
+  /** RegularExpression Id. */
+  int IDENTIFIER = 21;
+  /** RegularExpression Id. */
+  int LETTER = 22;
+  /** RegularExpression Id. */
+  int PART_LETTER = 23;
+
+  /** Lexical state. */
+  int DEFAULT = 0;
+  /** Lexical state. */
+  int IN_SINGLE_LINE_COMMENT = 1;
+  /** Lexical state. */
+  int IN_FORMAL_COMMENT = 2;
+  /** Lexical state. */
+  int IN_MULTI_LINE_COMMENT = 3;
+
+  /** Literal token values. */
+  String[] tokenImage = {
+    "<EOF>",
+    "\" \"",
+    "\"\\t\"",
+    "\"\\n\"",
+    "\"\\r\"",
+    "\"\\f\"",
+    "\"//\"",
+    "<token of kind 7>",
+    "\"/*\"",
+    "<SINGLE_LINE_COMMENT>",
+    "\"*/\"",
+    "\"*/\"",
+    "<token of kind 12>",
+    "\"(\"",
+    "\")\"",
+    "\"!\"",
+    "\"||\"",
+    "\"&&\"",
+    "\"~\"",
+    "\"true\"",
+    "\"false\"",
+    "<IDENTIFIER>",
+    "<LETTER>",
+    "<PART_LETTER>",
+  };
+
+}
diff --git a/generated/org/javacc/utils/ConditionParserTokenManager.java b/generated/org/javacc/utils/ConditionParserTokenManager.java
new file mode 100644
index 00000000..4ea7d4ae
--- /dev/null
+++ b/generated/org/javacc/utils/ConditionParserTokenManager.java
@@ -0,0 +1,771 @@
+/* Generated By:JavaCC: Do not edit this line. ConditionParserTokenManager.java */
+package org.javacc.utils;
+import java.io.StringReader;
+import java.util.Map;
+
+/** Token Manager. */
+public class ConditionParserTokenManager implements ConditionParserConstants
+{
+
+  /** Debug output. */
+  public  java.io.PrintStream debugStream = System.out;
+  /** Set debug output. */
+  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
+private final int jjStopStringLiteralDfa_0(int pos, long active0)
+{
+   switch (pos)
+   {
+      case 0:
+         if ((active0 & 0x180000L) != 0L)
+         {
+            jjmatchedKind = 21;
+            return 5;
+         }
+         if ((active0 & 0x140L) != 0L)
+            return 2;
+         return -1;
+      case 1:
+         if ((active0 & 0x100L) != 0L)
+            return 0;
+         if ((active0 & 0x180000L) != 0L)
+         {
+            jjmatchedKind = 21;
+            jjmatchedPos = 1;
+            return 5;
+         }
+         return -1;
+      case 2:
+         if ((active0 & 0x180000L) != 0L)
+         {
+            jjmatchedKind = 21;
+            jjmatchedPos = 2;
+            return 5;
+         }
+         return -1;
+      case 3:
+         if ((active0 & 0x100000L) != 0L)
+         {
+            jjmatchedKind = 21;
+            jjmatchedPos = 3;
+            return 5;
+         }
+         if ((active0 & 0x80000L) != 0L)
+            return 5;
+         return -1;
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_0(int pos, long active0)
+{
+   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);
+}
+private int jjStopAtPos(int pos, int kind)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   return pos + 1;
+}
+private int jjStartNfaWithStates_0(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_0(state, pos + 1);
+}
+private int jjMoveStringLiteralDfa0_0()
+{
+   switch(curChar)
+   {
+      case 33:
+         return jjStopAtPos(0, 15);
+      case 38:
+         return jjMoveStringLiteralDfa1_0(0x20000L);
+      case 40:
+         return jjStopAtPos(0, 13);
+      case 41:
+         return jjStopAtPos(0, 14);
+      case 47:
+         return jjMoveStringLiteralDfa1_0(0x140L);
+      case 102:
+         return jjMoveStringLiteralDfa1_0(0x100000L);
+      case 116:
+         return jjMoveStringLiteralDfa1_0(0x80000L);
+      case 124:
+         return jjMoveStringLiteralDfa1_0(0x10000L);
+      case 126:
+         return jjStopAtPos(0, 18);
+      default :
+         return jjMoveNfa_0(3, 0);
+   }
+}
+private int jjMoveStringLiteralDfa1_0(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(0, active0);
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 38:
+         if ((active0 & 0x20000L) != 0L)
+            return jjStopAtPos(1, 17);
+         break;
+      case 42:
+         if ((active0 & 0x100L) != 0L)
+            return jjStartNfaWithStates_0(1, 8, 0);
+         break;
+      case 47:
+         if ((active0 & 0x40L) != 0L)
+            return jjStopAtPos(1, 6);
+         break;
+      case 97:
+         return jjMoveStringLiteralDfa2_0(active0, 0x100000L);
+      case 114:
+         return jjMoveStringLiteralDfa2_0(active0, 0x80000L);
+      case 124:
+         if ((active0 & 0x10000L) != 0L)
+            return jjStopAtPos(1, 16);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(0, active0);
+}
+private int jjMoveStringLiteralDfa2_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(0, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(1, active0);
+      return 2;
+   }
+   switch(curChar)
+   {
+      case 108:
+         return jjMoveStringLiteralDfa3_0(active0, 0x100000L);
+      case 117:
+         return jjMoveStringLiteralDfa3_0(active0, 0x80000L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(1, active0);
+}
+private int jjMoveStringLiteralDfa3_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(1, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(2, active0);
+      return 3;
+   }
+   switch(curChar)
+   {
+      case 101:
+         if ((active0 & 0x80000L) != 0L)
+            return jjStartNfaWithStates_0(3, 19, 5);
+         break;
+      case 115:
+         return jjMoveStringLiteralDfa4_0(active0, 0x100000L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(2, active0);
+}
+private int jjMoveStringLiteralDfa4_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(2, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(3, active0);
+      return 4;
+   }
+   switch(curChar)
+   {
+      case 101:
+         if ((active0 & 0x100000L) != 0L)
+            return jjStartNfaWithStates_0(4, 20, 5);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(3, active0);
+}
+static final long[] jjbitVec0 = {
+   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+static final long[] jjbitVec2 = {
+   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+private int jjMoveNfa_0(int startState, int curPos)
+{
+   //int[] nextStates; // not used
+   int startsAt = 0;
+   jjnewStateCnt = 6;
+   int i = 1;
+   jjstateSet[0] = startState;
+   //int j; // not used
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 3:
+                  if (curChar == 36)
+                  {
+                     if (kind > 21)
+                        kind = 21;
+                     jjCheckNAdd(5);
+                  }
+                  else if (curChar == 47)
+                     jjstateSet[jjnewStateCnt++] = 2;
+                  break;
+               case 0:
+                  if (curChar == 42)
+                     jjstateSet[jjnewStateCnt++] = 1;
+                  break;
+               case 1:
+                  if ((0xffff7fffffffffffL & l) != 0L && kind > 7)
+                     kind = 7;
+                  break;
+               case 2:
+                  if (curChar == 42)
+                     jjstateSet[jjnewStateCnt++] = 0;
+                  break;
+               case 4:
+                  if (curChar != 36)
+                     break;
+                  if (kind > 21)
+                     kind = 21;
+                  jjCheckNAdd(5);
+                  break;
+               case 5:
+                  if ((0x3ff001000000000L & l) == 0L)
+                     break;
+                  if (kind > 21)
+                     kind = 21;
+                  jjCheckNAdd(5);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 3:
+               case 5:
+                  if ((0x7fffffe87fffffeL & l) == 0L)
+                     break;
+                  if (kind > 21)
+                     kind = 21;
+                  jjCheckNAdd(5);
+                  break;
+               case 1:
+                  if (kind > 7)
+                     kind = 7;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 1:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 7)
+                     kind = 7;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 6 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private int jjMoveStringLiteralDfa0_3()
+{
+   switch(curChar)
+   {
+      case 42:
+         return jjMoveStringLiteralDfa1_3(0x800L);
+      default :
+         return 1;
+   }
+}
+private int jjMoveStringLiteralDfa1_3(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 47:
+         if ((active0 & 0x800L) != 0L)
+            return jjStopAtPos(1, 11);
+         break;
+      default :
+         return 2;
+   }
+   return 2;
+}
+private int jjMoveStringLiteralDfa0_1()
+{
+   return jjMoveNfa_1(0, 0);
+}
+private int jjMoveNfa_1(int startState, int curPos)
+{
+   //int[] nextStates; // not used
+   int startsAt = 0;
+   jjnewStateCnt = 3;
+   int i = 1;
+   jjstateSet[0] = startState;
+   //int j; // not used
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0x2400L & l) != 0L)
+                  {
+                     if (kind > 9)
+                        kind = 9;
+                  }
+                  if (curChar == 13)
+                     jjstateSet[jjnewStateCnt++] = 1;
+                  break;
+               case 1:
+                  if (curChar == 10 && kind > 9)
+                     kind = 9;
+                  break;
+               case 2:
+                  if (curChar == 13)
+                     jjstateSet[jjnewStateCnt++] = 1;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 3 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private int jjMoveStringLiteralDfa0_2()
+{
+   switch(curChar)
+   {
+      case 42:
+         return jjMoveStringLiteralDfa1_2(0x400L);
+      default :
+         return 1;
+   }
+}
+private int jjMoveStringLiteralDfa1_2(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 47:
+         if ((active0 & 0x400L) != 0L)
+            return jjStopAtPos(1, 10);
+         break;
+      default :
+         return 2;
+   }
+   return 2;
+}
+static final int[] jjnextStates = {
+};
+private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
+{
+   switch(hiByte)
+   {
+      case 0:
+         return ((jjbitVec2[i2] & l2) != 0L);
+      default : 
+         if ((jjbitVec0[i1] & l1) != 0L)
+            return true;
+         return false;
+   }
+}
+
+/** Token literal values. */
+public static final String[] jjstrLiteralImages = {
+"", null, null, null, null, null, null, null, null, null, null, null, null, 
+"\50", "\51", "\41", "\174\174", "\46\46", "\176", "\164\162\165\145", 
+"\146\141\154\163\145", null, null, null, };
+
+/** Lexer state names. */
+public static final String[] lexStateNames = {
+   "DEFAULT", 
+   "IN_SINGLE_LINE_COMMENT", 
+   "IN_FORMAL_COMMENT", 
+   "IN_MULTI_LINE_COMMENT", 
+};
+
+/** Lex State array. */
+public static final int[] jjnewLexState = {
+   -1, -1, -1, -1, -1, -1, 1, 2, 3, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+};
+static final long[] jjtoToken = {
+   0x3fe001L, 
+};
+static final long[] jjtoSkip = {
+   0xe3eL, 
+};
+static final long[] jjtoSpecial = {
+   0xe00L, 
+};
+static final long[] jjtoMore = {
+   0x11c0L, 
+};
+protected JavaCharStream input_stream;
+private final int[] jjrounds = new int[6];
+private final int[] jjstateSet = new int[12];
+StringBuffer image;
+int jjimageLen;
+int lengthOfMatch;
+protected char curChar;
+/** Constructor. */
+public ConditionParserTokenManager(JavaCharStream stream){
+   if (JavaCharStream.staticFlag)
+      throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
+   input_stream = stream;
+}
+
+/** Constructor. */
+public ConditionParserTokenManager(JavaCharStream stream, int lexState){
+   this(stream);
+   SwitchTo(lexState);
+}
+
+/** Reinitialise parser. */
+public void ReInit(JavaCharStream stream)
+{
+   jjmatchedPos = jjnewStateCnt = 0;
+   curLexState = defaultLexState;
+   input_stream = stream;
+   ReInitRounds();
+}
+private void ReInitRounds()
+{
+   int i;
+   jjround = 0x80000001;
+   for (i = 6; i-- > 0;)
+      jjrounds[i] = 0x80000000;
+}
+
+/** Reinitialise parser. */
+public void ReInit(JavaCharStream stream, int lexState)
+{
+   ReInit(stream);
+   SwitchTo(lexState);
+}
+
+/** Switch to specified lex state. */
+public void SwitchTo(int lexState)
+{
+   if (lexState >= 4 || lexState < 0)
+      throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
+   else
+      curLexState = lexState;
+}
+
+protected Token jjFillToken()
+{
+   final Token t;
+   final String tokenImage;
+   final int beginLine;
+   final int endLine;
+   final int beginColumn;
+   final int endColumn;
+   String im = jjstrLiteralImages[jjmatchedKind];
+   tokenImage = (im == null) ? input_stream.GetImage() : im;
+   beginLine = input_stream.getBeginLine();
+   beginColumn = input_stream.getBeginColumn();
+   endLine = input_stream.getEndLine();
+   endColumn = input_stream.getEndColumn();
+   t = Token.newToken(jjmatchedKind, tokenImage);
+
+   t.beginLine = beginLine;
+   t.endLine = endLine;
+   t.beginColumn = beginColumn;
+   t.endColumn = endColumn;
+
+   return t;
+}
+
+int curLexState = 0;
+int defaultLexState = 0;
+int jjnewStateCnt;
+int jjround;
+int jjmatchedPos;
+int jjmatchedKind;
+
+/** Get the next Token. */
+public Token getNextToken() 
+{
+  //int kind;
+  Token specialToken = null;
+  Token matchedToken;
+  int curPos = 0;
+
+  EOFLoop :
+  for (;;)
+  {   
+   try   
+   {     
+      curChar = input_stream.BeginToken();
+   }     
+   catch(java.io.IOException e)
+   {        
+      jjmatchedKind = 0;
+      matchedToken = jjFillToken();
+      matchedToken.specialToken = specialToken;
+      return matchedToken;
+   }
+   image = null;
+   jjimageLen = 0;
+
+   for (;;)
+   {
+     switch(curLexState)
+     {
+       case 0:
+         try { input_stream.backup(0);
+            while (curChar <= 32 && (0x100003600L & (1L << curChar)) != 0L)
+               curChar = input_stream.BeginToken();
+         }
+         catch (java.io.IOException e1) { continue EOFLoop; }
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_0();
+         break;
+       case 1:
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_1();
+         if (jjmatchedPos == 0 && jjmatchedKind > 12)
+         {
+            jjmatchedKind = 12;
+         }
+         break;
+       case 2:
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_2();
+         if (jjmatchedPos == 0 && jjmatchedKind > 12)
+         {
+            jjmatchedKind = 12;
+         }
+         break;
+       case 3:
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_3();
+         if (jjmatchedPos == 0 && jjmatchedKind > 12)
+         {
+            jjmatchedKind = 12;
+         }
+         break;
+     }
+     if (jjmatchedKind != 0x7fffffff)
+     {
+        if (jjmatchedPos + 1 < curPos)
+           input_stream.backup(curPos - jjmatchedPos - 1);
+        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+        {
+           matchedToken = jjFillToken();
+           matchedToken.specialToken = specialToken;
+       if (jjnewLexState[jjmatchedKind] != -1)
+         curLexState = jjnewLexState[jjmatchedKind];
+           return matchedToken;
+        }
+        else if ((jjtoSkip[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+        {
+           if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+           {
+              matchedToken = jjFillToken();
+              if (specialToken == null)
+                 specialToken = matchedToken;
+              else
+              {
+                 matchedToken.specialToken = specialToken;
+                 specialToken = (specialToken.next = matchedToken);
+              }
+              SkipLexicalActions(matchedToken);
+           }
+           else 
+              SkipLexicalActions(null);
+         if (jjnewLexState[jjmatchedKind] != -1)
+           curLexState = jjnewLexState[jjmatchedKind];
+           continue EOFLoop;
+        }
+        MoreLexicalActions();
+      if (jjnewLexState[jjmatchedKind] != -1)
+        curLexState = jjnewLexState[jjmatchedKind];
+        curPos = 0;
+        jjmatchedKind = 0x7fffffff;
+        try {
+           curChar = input_stream.readChar();
+           continue;
+        }
+        catch (java.io.IOException e1) { }
+     }
+     int error_line = input_stream.getEndLine();
+     int error_column = input_stream.getEndColumn();
+     String error_after = null;
+     boolean EOFSeen = false;
+     try { input_stream.readChar(); input_stream.backup(1); }
+     catch (java.io.IOException e1) {
+        EOFSeen = true;
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+        if (curChar == '\n' || curChar == '\r') {
+           error_line++;
+           error_column = 0;
+        }
+        else
+           error_column++;
+     }
+     if (!EOFSeen) {
+        input_stream.backup(1);
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+     }
+     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
+   }
+  }
+}
+
+void SkipLexicalActions(Token matchedToken)
+{
+   switch(jjmatchedKind)
+   {
+      default :
+         break;
+   }
+}
+void MoreLexicalActions()
+{
+   jjimageLen += (lengthOfMatch = jjmatchedPos + 1);
+   switch(jjmatchedKind)
+   {
+      case 7 :
+         if (image == null)
+            image = new StringBuffer();
+         image.append(input_stream.GetSuffix(jjimageLen));
+         jjimageLen = 0;
+                   input_stream.backup(1);
+         break;
+      default : 
+         break;
+   }
+}
+private void jjCheckNAdd(int state)
+{
+   if (jjrounds[state] != jjround)
+   {
+      jjstateSet[jjnewStateCnt++] = state;
+      jjrounds[state] = jjround;
+   }
+}
+private void jjAddStates(int start, int end)
+{
+   do {
+      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
+   } while (start++ != end);
+}
+private void jjCheckNAddTwoStates(int state1, int state2)
+{
+   jjCheckNAdd(state1);
+   jjCheckNAdd(state2);
+}
+
+private void jjCheckNAddStates(int start, int end)
+{
+   do {
+      jjCheckNAdd(jjnextStates[start]);
+   } while (start++ != end);
+}
+
+}
diff --git a/generated/org/javacc/utils/JavaCharStream.java b/generated/org/javacc/utils/JavaCharStream.java
new file mode 100644
index 00000000..68bcc0b7
--- /dev/null
+++ b/generated/org/javacc/utils/JavaCharStream.java
@@ -0,0 +1,616 @@
+/* Generated By:JavaCC: Do not edit this line. JavaCharStream.java Version 4.1 */
+/* JavaCCOptions:STATIC=false */
+package org.javacc.utils;
+
+/**
+ * An implementation of interface CharStream, where the stream is assumed to
+ * contain only ASCII characters (with java-like unicode escape processing).
+ */
+
+public class JavaCharStream
+{
+/** Whether parser is static. */
+  public static final boolean staticFlag = false;
+  static final int hexval(char c) throws java.io.IOException {
+    switch(c)
+    {
+       case '0' :
+          return 0;
+       case '1' :
+          return 1;
+       case '2' :
+          return 2;
+       case '3' :
+          return 3;
+       case '4' :
+          return 4;
+       case '5' :
+          return 5;
+       case '6' :
+          return 6;
+       case '7' :
+          return 7;
+       case '8' :
+          return 8;
+       case '9' :
+          return 9;
+
+       case 'a' :
+       case 'A' :
+          return 10;
+       case 'b' :
+       case 'B' :
+          return 11;
+       case 'c' :
+       case 'C' :
+          return 12;
+       case 'd' :
+       case 'D' :
+          return 13;
+       case 'e' :
+       case 'E' :
+          return 14;
+       case 'f' :
+       case 'F' :
+          return 15;
+    }
+
+    throw new java.io.IOException(); // Should never come here
+  }
+
+/** Position in buffer. */
+  public int bufpos = -1;
+  int bufsize;
+  int available;
+  int tokenBegin;
+  protected int bufline[];
+  protected int bufcolumn[];
+
+  protected int column = 0;
+  protected int line = 1;
+
+  protected boolean prevCharIsCR = false;
+  protected boolean prevCharIsLF = false;
+
+  protected java.io.Reader inputStream;
+
+  protected char[] nextCharBuf;
+  protected char[] buffer;
+  protected int maxNextCharInd = 0;
+  protected int nextCharInd = -1;
+  protected int inBuf = 0;
+  protected int tabSize = 8;
+
+  protected void setTabSize(int i) { tabSize = i; }
+  protected int getTabSize(int i) { return tabSize; }
+
+  protected void ExpandBuff(boolean wrapAround)
+  {
+     char[] newbuffer = new char[bufsize + 2048];
+     int newbufline[] = new int[bufsize + 2048];
+     int newbufcolumn[] = new int[bufsize + 2048];
+
+     try
+     {
+        if (wrapAround)
+        {
+           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+           System.arraycopy(buffer, 0, newbuffer,
+                                             bufsize - tokenBegin, bufpos);
+           buffer = newbuffer;
+
+           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+           System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
+           bufline = newbufline;
+
+           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+           System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
+           bufcolumn = newbufcolumn;
+
+           bufpos += (bufsize - tokenBegin);
+        }
+        else
+        {
+           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+           buffer = newbuffer;
+
+           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+           bufline = newbufline;
+
+           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+           bufcolumn = newbufcolumn;
+
+           bufpos -= tokenBegin;
+        }
+     }
+     catch (Throwable t)
+     {
+        throw new Error(t.getMessage());
+     }
+
+     available = (bufsize += 2048);
+     tokenBegin = 0;
+  }
+
+  protected void FillBuff() throws java.io.IOException
+  {
+     int i;
+     if (maxNextCharInd == 4096)
+        maxNextCharInd = nextCharInd = 0;
+
+     try {
+        if ((i = inputStream.read(nextCharBuf, maxNextCharInd,
+                                            4096 - maxNextCharInd)) == -1)
+        {
+           inputStream.close();
+           throw new java.io.IOException();
+        }
+        else
+           maxNextCharInd += i;
+        return;
+     }
+     catch(java.io.IOException e) {
+        if (bufpos != 0)
+        {
+           --bufpos;
+           backup(0);
+        }
+        else
+        {
+           bufline[bufpos] = line;
+           bufcolumn[bufpos] = column;
+        }
+        throw e;
+     }
+  }
+
+  protected char ReadByte() throws java.io.IOException
+  {
+     if (++nextCharInd >= maxNextCharInd)
+        FillBuff();
+
+     return nextCharBuf[nextCharInd];
+  }
+
+/** @return starting character for token. */
+  public char BeginToken() throws java.io.IOException
+  {     
+     if (inBuf > 0)
+     {
+        --inBuf;
+
+        if (++bufpos == bufsize)
+           bufpos = 0;
+
+        tokenBegin = bufpos;
+        return buffer[bufpos];
+     }
+
+     tokenBegin = 0;
+     bufpos = -1;
+
+     return readChar();
+  }     
+
+  protected void AdjustBuffSize()
+  {
+     if (available == bufsize)
+     {
+        if (tokenBegin > 2048)
+        {
+           bufpos = 0;
+           available = tokenBegin;
+        }
+        else
+           ExpandBuff(false);
+     }
+     else if (available > tokenBegin)
+        available = bufsize;
+     else if ((tokenBegin - available) < 2048)
+        ExpandBuff(true);
+     else
+        available = tokenBegin;
+  }
+
+  protected void UpdateLineColumn(char c)
+  {
+     column++;
+
+     if (prevCharIsLF)
+     {
+        prevCharIsLF = false;
+        line += (column = 1);
+     }
+     else if (prevCharIsCR)
+     {
+        prevCharIsCR = false;
+        if (c == '\n')
+        {
+           prevCharIsLF = true;
+        }
+        else
+           line += (column = 1);
+     }
+
+     switch (c)
+     {
+        case '\r' :
+           prevCharIsCR = true;
+           break;
+        case '\n' :
+           prevCharIsLF = true;
+           break;
+        case '\t' :
+           column--;
+           column += (tabSize - (column % tabSize));
+           break;
+        default :
+           break;
+     }
+
+     bufline[bufpos] = line;
+     bufcolumn[bufpos] = column;
+  }
+
+/** Read a character. */
+  public char readChar() throws java.io.IOException
+  {
+     if (inBuf > 0)
+     {
+        --inBuf;
+
+        if (++bufpos == bufsize)
+           bufpos = 0;
+
+        return buffer[bufpos];
+     }
+
+     char c;
+
+     if (++bufpos == available)
+        AdjustBuffSize();
+
+     if ((buffer[bufpos] = c = ReadByte()) == '\\')
+     {
+        UpdateLineColumn(c);
+
+        int backSlashCnt = 1;
+
+        for (;;) // Read all the backslashes
+        {
+           if (++bufpos == available)
+              AdjustBuffSize();
+
+           try
+           {
+              if ((buffer[bufpos] = c = ReadByte()) != '\\')
+              {
+                 UpdateLineColumn(c);
+                 // found a non-backslash char.
+                 if ((c == 'u') && ((backSlashCnt & 1) == 1))
+                 {
+                    if (--bufpos < 0)
+                       bufpos = bufsize - 1;
+
+                    break;
+                 }
+
+                 backup(backSlashCnt);
+                 return '\\';
+              }
+           }
+           catch(java.io.IOException e)
+           {
+              if (backSlashCnt > 1)
+                 backup(backSlashCnt-1);
+
+              return '\\';
+           }
+
+           UpdateLineColumn(c);
+           backSlashCnt++;
+        }
+
+        // Here, we have seen an odd number of backslash's followed by a 'u'
+        try
+        {
+           while ((c = ReadByte()) == 'u')
+              ++column;
+
+           buffer[bufpos] = c = (char)(hexval(c) << 12 |
+                                       hexval(ReadByte()) << 8 |
+                                       hexval(ReadByte()) << 4 |
+                                       hexval(ReadByte()));
+
+           column += 4;
+        }
+        catch(java.io.IOException e)
+        {
+           throw new Error("Invalid escape character at line " + line +
+                                         " column " + column + ".");
+        }
+
+        if (backSlashCnt == 1)
+           return c;
+        else
+        {
+           backup(backSlashCnt - 1);
+           return '\\';
+        }
+     }
+     else
+     {
+        UpdateLineColumn(c);
+        return c;
+     }
+  }
+
+  /**
+   * @deprecated 
+   * @see #getEndColumn
+   */
+
+  public int getColumn() {
+     return bufcolumn[bufpos];
+  }
+
+  /**
+   * @deprecated 
+   * @see #getEndLine
+   */
+
+  public int getLine() {
+     return bufline[bufpos];
+  }
+
+/** Get end column. */
+  public int getEndColumn() {
+     return bufcolumn[bufpos];
+  }
+
+/** Get end line. */
+  public int getEndLine() {
+     return bufline[bufpos];
+  }
+
+/** @return column of token start */
+  public int getBeginColumn() {
+     return bufcolumn[tokenBegin];
+  }
+
+/** @return line number of token start */
+  public int getBeginLine() {
+     return bufline[tokenBegin];
+  }
+
+/** Retreat. */
+  public void backup(int amount) {
+
+    inBuf += amount;
+    if ((bufpos -= amount) < 0)
+       bufpos += bufsize;
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.Reader dstream,
+                 int startline, int startcolumn, int buffersize)
+  {
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    available = bufsize = buffersize;
+    buffer = new char[buffersize];
+    bufline = new int[buffersize];
+    bufcolumn = new int[buffersize];
+    nextCharBuf = new char[4096];
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.Reader dstream,
+                                        int startline, int startcolumn)
+  {
+     this(dstream, startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.Reader dstream)
+  {
+     this(dstream, 1, 1, 4096);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.Reader dstream,
+                 int startline, int startcolumn, int buffersize)
+  {
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    if (buffer == null || buffersize != buffer.length)
+    {
+      available = bufsize = buffersize;
+      buffer = new char[buffersize];
+      bufline = new int[buffersize];
+      bufcolumn = new int[buffersize];
+      nextCharBuf = new char[4096];
+    }
+    prevCharIsLF = prevCharIsCR = false;
+    tokenBegin = inBuf = maxNextCharInd = 0;
+    nextCharInd = bufpos = -1;
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.Reader dstream,
+                                        int startline, int startcolumn)
+  {
+     ReInit(dstream, startline, startcolumn, 4096);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.Reader dstream)
+  {
+     ReInit(dstream, 1, 1, 4096);
+  }
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, String encoding, int startline,
+  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
+  {
+     this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+     this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, String encoding, int startline,
+                        int startcolumn) throws java.io.UnsupportedEncodingException
+  {
+     this(dstream, encoding, startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, int startline,
+                        int startcolumn)
+  {
+     this(dstream, startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
+  {
+     this(dstream, encoding, 1, 1, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream)
+  {
+     this(dstream, 1, 1, 4096);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
+  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
+  {
+     ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
+                     int startcolumn) throws java.io.UnsupportedEncodingException
+  {
+     ReInit(dstream, encoding, startline, startcolumn, 4096);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, int startline,
+                     int startcolumn)
+  {
+     ReInit(dstream, startline, startcolumn, 4096);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
+  {
+     ReInit(dstream, encoding, 1, 1, 4096);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream)
+  {
+     ReInit(dstream, 1, 1, 4096);
+  }
+
+  /** @return token image as String */
+  public String GetImage()
+  {
+     if (bufpos >= tokenBegin)
+        return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
+     else
+        return new String(buffer, tokenBegin, bufsize - tokenBegin) +
+                              new String(buffer, 0, bufpos + 1);
+  }
+
+  /** @return suffix */
+  public char[] GetSuffix(int len)
+  {
+     char[] ret = new char[len];
+
+     if ((bufpos + 1) >= len)
+        System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
+     else
+     {
+        System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
+                                                          len - bufpos - 1);
+        System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
+     }
+
+     return ret;
+  }
+
+  /** Set buffers back to null when finished. */
+  public void Done()
+  {
+     nextCharBuf = null;
+     buffer = null;
+     bufline = null;
+     bufcolumn = null;
+  }
+
+  /**
+   * Method to adjust line and column numbers for the start of a token.
+   */
+  public void adjustBeginLineColumn(int newLine, int newCol)
+  {
+     int start = tokenBegin;
+     int len;
+
+     if (bufpos >= tokenBegin)
+     {
+        len = bufpos - tokenBegin + inBuf + 1;
+     }
+     else
+     {
+        len = bufsize - tokenBegin + bufpos + 1 + inBuf;
+     }
+
+     int i = 0, j = 0, k = 0;
+     int nextColDiff = 0, columnDiff = 0;
+
+     while (i < len &&
+            bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
+     {
+        bufline[j] = newLine;
+        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
+        bufcolumn[j] = newCol + columnDiff;
+        columnDiff = nextColDiff;
+        i++;
+     } 
+
+     if (i < len)
+     {
+        bufline[j] = newLine++;
+        bufcolumn[j] = newCol + columnDiff;
+
+        while (i++ < len)
+        {
+           if (bufline[j = start % bufsize] != bufline[++start % bufsize])
+              bufline[j] = newLine++;
+           else
+              bufline[j] = newLine;
+        }
+     }
+
+     line = bufline[j];
+     column = bufcolumn[j];
+  }
+
+}
+/* JavaCC - OriginalChecksum=f1662a28227bdfa34fc26cfa1db91b87 (do not edit this line) */
diff --git a/generated/org/javacc/utils/ParseException.java b/generated/org/javacc/utils/ParseException.java
new file mode 100644
index 00000000..53ba735c
--- /dev/null
+++ b/generated/org/javacc/utils/ParseException.java
@@ -0,0 +1,198 @@
+/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 4.1 */
+/* JavaCCOptions:KEEP_LINE_COL=null */
+package org.javacc.utils;
+
+/**
+ * This exception is thrown when parse errors are encountered.
+ * You can explicitly create objects of this exception type by
+ * calling the method generateParseException in the generated
+ * parser.
+ *
+ * You can modify this class to customize your error reporting
+ * mechanisms so long as you retain the public fields.
+ */
+public class ParseException extends Exception {
+
+  /**
+   * This constructor is used by the method "generateParseException"
+   * in the generated parser.  Calling this constructor generates
+   * a new object of this type with the fields "currentToken",
+   * "expectedTokenSequences", and "tokenImage" set.  The boolean
+   * flag "specialConstructor" is also set to true to indicate that
+   * this constructor was used to create this object.
+   * This constructor calls its super class with the empty string
+   * to force the "toString" method of parent class "Throwable" to
+   * print the error message in the form:
+   *     ParseException: <result of getMessage>
+   */
+  public ParseException(Token currentTokenVal,
+                        int[][] expectedTokenSequencesVal,
+                        String[] tokenImageVal
+                       )
+  {
+    super("");
+    specialConstructor = true;
+    currentToken = currentTokenVal;
+    expectedTokenSequences = expectedTokenSequencesVal;
+    tokenImage = tokenImageVal;
+  }
+
+  /**
+   * The following constructors are for use by you for whatever
+   * purpose you can think of.  Constructing the exception in this
+   * manner makes the exception behave in the normal way - i.e., as
+   * documented in the class "Throwable".  The fields "errorToken",
+   * "expectedTokenSequences", and "tokenImage" do not contain
+   * relevant information.  The JavaCC generated code does not use
+   * these constructors.
+   */
+
+  public ParseException() {
+    super();
+    specialConstructor = false;
+  }
+
+  /** Constructor with message. */
+  public ParseException(String message) {
+    super(message);
+    specialConstructor = false;
+  }
+
+  /**
+   * This variable determines which constructor was used to create
+   * this object and thereby affects the semantics of the
+   * "getMessage" method (see below).
+   */
+  protected boolean specialConstructor;
+
+  /**
+   * This is the last token that has been consumed successfully.  If
+   * this object has been created due to a parse error, the token
+   * followng this token will (therefore) be the first error token.
+   */
+  public Token currentToken;
+
+  /**
+   * Each entry in this array is an array of integers.  Each array
+   * of integers represents a sequence of tokens (by their ordinal
+   * values) that is expected at this point of the parse.
+   */
+  public int[][] expectedTokenSequences;
+
+  /**
+   * This is a reference to the "tokenImage" array of the generated
+   * parser within which the parse error occurred.  This array is
+   * defined in the generated ...Constants interface.
+   */
+  public String[] tokenImage;
+
+  /**
+   * This method has the standard behavior when this object has been
+   * created using the standard constructors.  Otherwise, it uses
+   * "currentToken" and "expectedTokenSequences" to generate a parse
+   * error message and returns it.  If this object has been created
+   * due to a parse error, and you do not catch it (it gets thrown
+   * from the parser), then this method is called during the printing
+   * of the final stack trace, and hence the correct error message
+   * gets displayed.
+   */
+  public String getMessage() {
+    if (!specialConstructor) {
+      return super.getMessage();
+    }
+    StringBuffer expected = new StringBuffer();
+    int maxSize = 0;
+    for (int i = 0; i < expectedTokenSequences.length; i++) {
+      if (maxSize < expectedTokenSequences[i].length) {
+        maxSize = expectedTokenSequences[i].length;
+      }
+      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
+        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(' ');
+      }
+      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
+        expected.append("...");
+      }
+      expected.append(eol).append("    ");
+    }
+    String retval = "Encountered \"";
+    Token tok = currentToken.next;
+    for (int i = 0; i < maxSize; i++) {
+      if (i != 0) retval += " ";
+      if (tok.kind == 0) {
+        retval += tokenImage[0];
+        break;
+      }
+      retval += " " + tokenImage[tok.kind];
+      retval += " \"";
+      retval += add_escapes(tok.image);
+      retval += " \"";
+      tok = tok.next; 
+    }
+    retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;
+    retval += "." + eol;
+    if (expectedTokenSequences.length == 1) {
+      retval += "Was expecting:" + eol + "    ";
+    } else {
+      retval += "Was expecting one of:" + eol + "    ";
+    }
+    retval += expected.toString();
+    return retval;
+  }
+
+  /**
+   * The end of line string for this machine.
+   */
+  protected String eol = System.getProperty("line.separator", "\n");
+ 
+  /**
+   * Used to convert raw characters to their escaped version
+   * when these raw version cannot be used as part of an ASCII
+   * string literal.
+   */
+  protected String add_escapes(String str) {
+      StringBuffer retval = new StringBuffer();
+      char ch;
+      for (int i = 0; i < str.length(); i++) {
+        switch (str.charAt(i))
+        {
+           case 0 :
+              continue;
+           case '\b':
+              retval.append("\\b");
+              continue;
+           case '\t':
+              retval.append("\\t");
+              continue;
+           case '\n':
+              retval.append("\\n");
+              continue;
+           case '\f':
+              retval.append("\\f");
+              continue;
+           case '\r':
+              retval.append("\\r");
+              continue;
+           case '\"':
+              retval.append("\\\"");
+              continue;
+           case '\'':
+              retval.append("\\\'");
+              continue;
+           case '\\':
+              retval.append("\\\\");
+              continue;
+           default:
+              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
+                 String s = "0000" + Integer.toString(ch, 16);
+                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
+              } else {
+                 retval.append(ch);
+              }
+              continue;
+        }
+      }
+      return retval.toString();
+   }
+
+}
+/* JavaCC - OriginalChecksum=21a7d6479066ef183115f5a5acdc9cfd (do not edit this line) */
diff --git a/generated/org/javacc/utils/Token.java b/generated/org/javacc/utils/Token.java
new file mode 100644
index 00000000..f7c2e6b1
--- /dev/null
+++ b/generated/org/javacc/utils/Token.java
@@ -0,0 +1,124 @@
+/* Generated By:JavaCC: Do not edit this line. Token.java Version 4.1 */
+/* JavaCCOptions:TOKEN_EXTENDS=,KEEP_LINE_COL=null */
+package org.javacc.utils;
+
+/**
+ * Describes the input token stream.
+ */
+
+public class Token {
+
+  /**
+   * An integer that describes the kind of this token.  This numbering
+   * system is determined by JavaCCParser, and a table of these numbers is
+   * stored in the file ...Constants.java.
+   */
+  public int kind;
+
+  /** The line number of the first character of this Token. */
+  public int beginLine;
+  /** The column number of the first character of this Token. */
+  public int beginColumn;
+  /** The line number of the last character of this Token. */
+  public int endLine;
+  /** The column number of the last character of this Token. */
+  public int endColumn;
+
+  /**
+   * The string image of the token.
+   */
+  public String image;
+
+  /**
+   * A reference to the next regular (non-special) token from the input
+   * stream.  If this is the last token from the input stream, or if the
+   * token manager has not read tokens beyond this one, this field is
+   * set to null.  This is true only if this token is also a regular
+   * token.  Otherwise, see below for a description of the contents of
+   * this field.
+   */
+  public Token next;
+
+  /**
+   * This field is used to access special tokens that occur prior to this
+   * token, but after the immediately preceding regular (non-special) token.
+   * If there are no such special tokens, this field is set to null.
+   * When there are more than one such special token, this field refers
+   * to the last of these special tokens, which in turn refers to the next
+   * previous special token through its specialToken field, and so on
+   * until the first special token (whose specialToken field is null).
+   * The next fields of special tokens refer to other special tokens that
+   * immediately follow it (without an intervening regular token).  If there
+   * is no such token, this field is null.
+   */
+  public Token specialToken;
+
+  /**
+   * An optional attribute value of the Token.
+   * Tokens which are not used as syntactic sugar will often contain
+   * meaningful values that will be used later on by the compiler or
+   * interpreter. This attribute value is often different from the image.
+   * Any subclass of Token that actually wants to return a non-null value can
+   * override this method as appropriate.
+   */
+  public Object getValue() {
+    return null;
+  }
+
+  /**
+   * No-argument contructor
+   */
+  public Token() {}
+
+  /**
+   * Constructs a new token for the specified Image.
+   */
+  public Token(int kind)
+  {
+     this(kind, null);
+  }
+
+  /**
+   * Constructs a new token for the specified Image and Kind.
+   */
+  public Token(int kind, String image)
+  {
+     this.kind = kind;
+     this.image = image;
+  }
+
+  /**
+   * Returns the image.
+   */
+  public String toString()
+  {
+     return image;
+  }
+
+  /**
+   * Returns a new Token object, by default. However, if you want, you
+   * can create and return subclass objects based on the value of ofKind.
+   * Simply add the cases to the switch for all those special cases.
+   * For example, if you have a subclass of Token called IDToken that
+   * you want to create if ofKind is ID, simply add something like :
+   *
+   *    case MyParserConstants.ID : return new IDToken(ofKind, image);
+   *
+   * to the following switch statement. Then you can cast matchedToken
+   * variable to the appropriate type and use sit in your lexical actions.
+   */
+  public static Token newToken(int ofKind, String image)
+  {
+     switch(ofKind)
+     {
+       default : return new Token(ofKind, image);
+     }
+  }
+
+  public static Token newToken(int ofKind)
+  {
+     return newToken(ofKind, null);
+  }
+
+}
+/* JavaCC - OriginalChecksum=6015b462df1ebe503d6a81460988137d (do not edit this line) */
diff --git a/generated/org/javacc/utils/TokenMgrError.java b/generated/org/javacc/utils/TokenMgrError.java
new file mode 100644
index 00000000..410e48bd
--- /dev/null
+++ b/generated/org/javacc/utils/TokenMgrError.java
@@ -0,0 +1,140 @@
+/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 4.1 */
+/* JavaCCOptions: */
+package org.javacc.utils;
+
+/** Token Manager Error. */
+public class TokenMgrError extends Error
+{
+
+   /*
+    * Ordinals for various reasons why an Error of this type can be thrown.
+    */
+
+   /**
+    * Lexical error occurred.
+    */
+   static final int LEXICAL_ERROR = 0;
+
+   /**
+    * An attempt was made to create a second instance of a static token manager.
+    */
+   static final int STATIC_LEXER_ERROR = 1;
+
+   /**
+    * Tried to change to an invalid lexical state.
+    */
+   static final int INVALID_LEXICAL_STATE = 2;
+
+   /**
+    * Detected (and bailed out of) an infinite loop in the token manager.
+    */
+   static final int LOOP_DETECTED = 3;
+
+   /**
+    * Indicates the reason why the exception is thrown. It will have
+    * one of the above 4 values.
+    */
+   int errorCode;
+
+   /**
+    * Replaces unprintable characters by their escaped (or unicode escaped)
+    * equivalents in the given string
+    */
+   protected static final String addEscapes(String str) {
+      StringBuffer retval = new StringBuffer();
+      char ch;
+      for (int i = 0; i < str.length(); i++) {
+        switch (str.charAt(i))
+        {
+           case 0 :
+              continue;
+           case '\b':
+              retval.append("\\b");
+              continue;
+           case '\t':
+              retval.append("\\t");
+              continue;
+           case '\n':
+              retval.append("\\n");
+              continue;
+           case '\f':
+              retval.append("\\f");
+              continue;
+           case '\r':
+              retval.append("\\r");
+              continue;
+           case '\"':
+              retval.append("\\\"");
+              continue;
+           case '\'':
+              retval.append("\\\'");
+              continue;
+           case '\\':
+              retval.append("\\\\");
+              continue;
+           default:
+              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
+                 String s = "0000" + Integer.toString(ch, 16);
+                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
+              } else {
+                 retval.append(ch);
+              }
+              continue;
+        }
+      }
+      return retval.toString();
+   }
+
+   /**
+    * Returns a detailed message for the Error when it is thrown by the
+    * token manager to indicate a lexical error.
+    * Parameters : 
+    *    EOFSeen     : indicates if EOF caused the lexical error
+    *    curLexState : lexical state in which this error occurred
+    *    errorLine   : line number when the error occurred
+    *    errorColumn : column number when the error occurred
+    *    errorAfter  : prefix that was seen before this error occurred
+    *    curchar     : the offending character
+    * Note: You can customize the lexical error message by modifying this method.
+    */
+   protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
+      return("Lexical error at line " +
+           errorLine + ", column " +
+           errorColumn + ".  Encountered: " +
+           (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int)curChar + "), ") +
+           "after : \"" + addEscapes(errorAfter) + "\"");
+   }
+
+   /**
+    * You can also modify the body of this method to customize your error messages.
+    * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
+    * of end-users concern, so you can return something like : 
+    *
+    *     "Internal Error : Please file a bug report .... "
+    *
+    * from this method for such cases in the release version of your parser.
+    */
+   public String getMessage() {
+      return super.getMessage();
+   }
+
+   /*
+    * Constructors of various flavors follow.
+    */
+
+   /** No arg constructor. */
+   public TokenMgrError() {
+   }
+
+   /** Constructor with message and reason. */
+   public TokenMgrError(String message, int reason) {
+      super(message);
+      errorCode = reason;
+   }
+
+   /** Full Constructor. */
+   public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {
+      this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
+   }
+}
+/* JavaCC - OriginalChecksum=13cab53dac748d0c83a2702a822081af (do not edit this line) */
-- 
2.46.0

